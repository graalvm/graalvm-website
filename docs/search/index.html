<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:image" content='/resources/img/og-image.jpg' />
  <meta name="twitter:widgets:border-color" content="#55acee">

  <title>
    
      Search
    
  </title>
  <meta name="description" content="GraalVM is an advanced JDK with ahead-of-time Native Image compilation."/>

  
  <link rel="canonical" href="https://www.graalvm.org/docs/search/">
  

  <link rel="icon" id="favicon" href='/resources/img/favicon/favicon-light/favicon-light.ico'>

  <link rel="manifest" href='/resources/img/favicon/site.webmanifest'>
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <script src='/resources/lib/jquery/jquery-3.6.1.min.js'></script>
  <link rel="stylesheet" href='/assets/main.css'>
  <script src='/resources/lib/bootstrap/js/bootstrap.min.js'></script>
  <script src='/resources/lib/sticky-sidebar/resizeSensor.js'></script>
  <script src='/resources/lib/sticky-sidebar/sticky-sidebar.min.js'></script>
  <script src='/resources/lib/highlight/highlight.pack.js'></script>
  <script src='/resources/lib/purl/purl.js'></script>
  <script src='/resources/lib/fiddle/fiddle.js' defer></script>
  <link rel="stylesheet" href='/resources/styles/fiddle.css'>
  <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>




  <body class="preload">
    <div class="wrapper wrapper--nofooter">
      <header  class="header header--content" 
  role="banner">

  
  




  <div class="d-flex">
    <nav class="menu">
      <div class="menu__logo">
        <a class="menu__logojs" href="/">
          <img src='/resources/img/home/logo_mobile_openmenu.svg' alt="GraalVM logo">
        </a>
      </div>
      <ul class="menu__list">
        <li class="menu__item">
          <a href='/latest/docs/' class="menu__link">Docs</a>
        </li>
        <li class="menu__item">
          <a href='/guides/' class="menu__link">Guides</a>
        </li>
        <li class="menu__item">
          <a href="https://medium.com/graalvm" class="menu__link" target="_blank">Blog</a>
        </li>
        <li class="menu__item">
          <a href="https://www.youtube.com/graalvm" class="menu__link" target="_blank">Videos</a>
        </li>
        <li class="menu__item">
          <a href='/community/' class="menu__link">Community</a>
        </li>
        <li class="menu__item">
          <div class="stack-container">
            <a href="#" class="menu__link stack__header">Graal Projects</a>
            <div class="stack-menu">
              <div class="stack-row">
                <div class="stack-column">
                  <div class="stack__item">
                    <img src="/resources/img/header-navigation/graalstack.svg">
                    <a href="https://graal.cloud/" class="item-line">Graal Stack</a>
                  </div>
                  <div class="stack__item">
                    <img src="/resources/img/header-navigation/gdk.svg">
                    <a href="https://graal.cloud/gdk/" class="item-line">Graal Dev Kit for Micronaut</a>
                  </div>
                  <div class="stack__item">
                    <img src="/resources/img/header-navigation/graalos.svg">
                    <a href="https://graal.cloud/graalos/" class="item-line">GraalOS</a>
                  </div>
                </div>
                <div class="stack-column">
                  <div class="stack__item">
                    <img src="/resources/img/header-navigation/js-navi.svg">
                    <a href="/javascript/" class="item-line">GraalJS</a>
                  </div>
                  <div class="stack__item">
                    <img src="/resources/img/header-navigation/python-navi.svg">
                    <a href="/python/" class="item-line">GraalPy</a>
                  </div>
                  <div class="stack__item">
                    <img src="/resources/img/header-navigation/wasm-navi.svg">
                    <a href="/webassembly/" class="item-line">GraalWasm</a>
                  </div>
                  <div class="stack__item">
                    <img src="/resources/img/header-navigation/java-navi.svg">
                    <a href='/reference-manual/java-on-truffle/' class="item-line">Espresso</a>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </li>
        <div class="menu__item icons githubstar" tabindex="0">
          <span class="github-widget">
            <a tabindex="-1" class="github-button" href="https://github.com/oracle/graal" data-icon="octicon-star"
              data-show-count="true" aria-label="Star oracle/graal on GitHub">Star</a>
          </span>
        </div>
        <div class="menu__downloads">
          <a href='/downloads/' class="btn btn-try btn-primary">Download</a>
        </div>
      </ul>
      <div role="button" class="menu-btn menu-btn--menu js-show-menu" tabindex="-1" title="sweet hamburger">
        <div class="hamburger">
          <div class="inner"></div>
        </div>
      </div>
    </nav>
  </div>
  
</header>
      <main class="content" aria-label="Content">
        <div class="wrapper wrapper-content">
  <article>
  <div class="row d-flex flex-wrap">
    <div class="col-sm-3 docsimpro col-bg">
      <div class="sidebar-wrap">
        <div class="sidebar">
          <div class="menuabout">
            <img id="sidebarClose" src='/resources/img/docs-sidebar/arrow-sidebar(close)' alt="Expand or collapse sidebar" class="btn-color no-display">
            <img id="sidebarOpen" src='/resources/img/docs-sidebar/arrow-sidebar.svg' alt="Expand or collapse sidebar">
          </div>
          
<div class="toc-floating">


<script>
var sidebar = document.currentScript.parentElement;


$(document).ready(function(){
  var header = $('.header').height();
  var invisibleBlock;

  $("#content-wrapper h1, #content-wrapper h2").each(function() {
    invisibleBlock = $(this).before("<div class='anchor' id="+ $(this).attr("id") +"></div>");
  });

  $(window).scroll(function() {
    var lastitem = null;
    $("#content-wrapper h1, #content-wrapper h2").each(function() {
      var heading = $(this);
      var position = (heading.position().top - heading.height()) - $(window).scrollTop();
      var listitem = $(sidebar).find("li").filter(function() {
        return $(this).find("a").attr("href") == "#" + heading.attr("id");
      });
      listitem.removeClass("toc-bullets-focused");
      if (position <= 0) {
        lastitem = listitem;
      }
    });
    if (lastitem != null) lastitem.addClass("toc-bullets-focused");
  });
});

</script>

<!-- Docs version dropdown -->
<section class="versions">
  <div class="dropdown">
    <div class="d-flex align-items-center version-dropdown">
      <input name="select_value" type="hidden" id="selectedValue">
      <div class="display-value display-version" id="displayValue" onclick="toggleOptions(event)">
        <span class="value-text" id="valueText">Version</span>
      </div>
      <ul tabindex="0" class="select-container" id="selectContainer" onblur="toggleOptions(event)">
        <li class="select-option" onclick="selected('GraalVM 25 (Latest)', 'latest');">GraalVM 25 (Latest)</li>
        <li class="select-option" onclick="selected('GraalVM for JDK 21', 'jdk21');">GraalVM for JDK 21</li>
        <li class="select-option" onclick="selected('GraalVM for JDK 17', 'jdk17');">GraalVM for JDK 17</li>
        <li class="select-option" onclick="selected('Archives'); location='/docs/archives/'">Archives</li>
        <li class="select-option" onclick="window.open('https://github.com/oracle/graal/tree/master/docs', '_blank').focus()">Dev Build</li>
      </ul>
    </div>
  </div>
</section>

<ul class="toc-bullets">

  

  
    

    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/latest/getting-started/">
            Getting Started
          </a>
        </li>

        
        

        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/latest/reference-manual/native-image/">
            Getting Started with Native Image
          </a>
        </li>

        
        

        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/latest/reference-manual/">
            Reference Manuals
          </a>
        </li>

        
        

        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/latest/graalvm-as-a-platform/">
            GraalVM as a Platform
          </a>
        </li>

        
        

        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/latest/security-guide/">
            Security Guide
          </a>
        </li>

        
        

        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/pages/javadocs/jdk25.html">
            SDK Javadoc for JDK 25
          </a>
        </li>

        
        

        
        
      
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

</div>
        </div>
      </div>
    </div>

    <div class="col-sm-9 docsmod">
      <div id="content-wrapper" class="docs-content docs-content--with-sidebar">
        <h2 class="additional-item__title">Search Results</h2>
        <!-- Placeholder for displaying results -->
        <!-- Search field -->
        <div class="search search-results">
          <form class="form-inline" action="/docs/search" autocomplete="on" method="get">
            <input class="input-search" type="text" id="search-box" name="query" placeholder="Search Documentation">
            <button type="submit" class="search-button"></button>
          </form>
        </div>
        <div class="search-results">
          <ul id="search-results"></ul>
        </div>
      </div>
              <!-- JSON output of all the content we want to search on  -->
        <script>
          window.store = {
          
          "release-notes-19-0":  {
          "title": "19.0.2",
          "content": "19.0.2(2019-06-13)This is a bug fix release for 19.0 and we recommend upgrading for all 19.0.x users.Java  Improved compilation performance of scheduler phase.  Support retrieving annotations from class initializers (see 1320).  Fixed problems related to the freetype library: 1269, 1270, 1305.  Fixed Version string reporting (it was missing 64-Bit in the string).Native image  Fixed IllegalArgumentException: Cannot create Method for class initializer (see 1320).  Fixed an issue when the build would loop forever if META-INF/native-image/native-image.properties contains --force-fallback.  Fixed the issue where fallback image generation would not respect the --no-server argument.  Fix native-image-agent=restrict configuration detection.  Added -agentlib:native-image-agent=build configuration option.LLVM interpreterAllow LLVM interpreter Context to run without allowIO(true).19.0.0(2019-05-09)Early Adopter Windows SupportThe early adopter builds for Windows are available for GraalVM. These includethe JDK with the GraalVM compiler enabled, the Native Image capabilities,GraalVM’s JavaScript engine and the developer tools: Chrome inspector baseddebugger, Profiler etc.. Currently there is no gu utility or the ability toadd support for the other GraalVM languages.Java  We updated the base JDK to 8u212. You can find the JDK release notes at the Oracle Technology Network website.Native ImageNative Image was extracted from the base GraalVM distribution. Currently it isavailable as an early adopter plugin. To install it, run: gu installnative-image. After this additional step, the native-image executable will bein the bin directory, as for the previous releases.There was a change in how classes are initialized in a native-image. Now, we initialize application classes at run time by default. The policy for initialization is as follows:  All JDK classes are initialized at build time.  We prove the safety of application static initializers after the analysis and initialize the safe classes.  We provide the following flags to control class initialization in a fine-grained way: --initialize-at-build-time and --initialize-at-run-time.The performance and startup impact of this change is negligible on all benchmarks that we have.This change was made to improve user experience: there is no need to writesubstitutions and to deal with instances of unsupported classes ending up in theimage heap. Their applications, given the right configuration for reflection,proxies, etc., should work without performance degradation.To allow framework authors and end users to keep the startup time at minimum weimproved functionality of --initialize-at-build-time and--initialize-at-run-time. These flags allow to specify a policy for wholepackages or individual classes. For example, if we have classes p.C1, p.C2,… , p.Cn, we can eagerly initialize this package with--initalize-at-build-time=p. If we want to delay one of the classes in packagep we can simply add --initialize-at-run-time=p.C1.The whole class hierarchy can be initialized at build time by simply passing --initalize-at-build-time on the command line.We also introduced the flag -H:+PrintClassInitialization which allows you to track what class initialization does during the image build. This flag will help you configure the build to work as intended.What should I do if I am a library author?  To get your tests back in check you can use --intialize-at-build-time which will revert to the previous behaviour.  Then use the flag -H:+PrintClassInitialization to see when classes get initialized. Based on this output you can make the proper configuration.  Configure your native-image.properties by passing --intialize-at-build-time=&amp;lt;csv-of-classes-or-packages&amp;gt; to it.  Submit a pull request to the downstream libraries with the configuration you believe works well. That way your native-image.properties will be concerned only with the classes from your framework.  There is a known issue with lambdas being initialized at build time. If your lambda inherits an interface with a default method and static fields, those fields will get pulled into the image. We will provide a fix to this bug in the next two weeks.JavaScript  Fixed various bugs that address compilation problems.R  Fixed a fatal error on Linux platforms when sending SIGINT during long computations.  Fixed issues with the installation to protected locations: the default Renviron file sets the R_LIBS_USER to a directory inside the current user’s home. Users still have to create this directory manually. Alternatively, the configure_fastr script creates the directory, but for the current user only.  Implemented missing C API: S_realloc.Ruby  Various bug fixes. Most notably fixes around OpenSSL C extension compilation.  Renamed methods in the TruffleRuby object.Ideal Graph Visualizer (IGV)  Fixed the issue with the ASTs and call trees not showing up.",
          "url": " /release-notes/19_0/"
          },
          
          "release-notes-19-1":  {
          "title": "19.1.1",
          "content": "19.1.1(2019-07-16)This is a Critical Patch Update (CPU) release for the 19.1.0 GraalVM releaseinduced by the update to OracleJDK 8u221 and OpenJDK 8u222 as the base JDKs.More details can be foundhereand here. We recommend upgradingto it from the 19.1.x and older releases.This CPU release includes fixes for the following CVEs:  CVE-2019-2813  CVE-2019-2862For more information please see the Oracle July 2019 Security Advisory.Critical fixes to GraalVM Native Image listed below went also into this version:      Fixed Reflection.getCallerClass methods sometimes failing to acquire the correct frame in the native images (#1479).        Fixed an issue that could cause header files not being generated in the working directory when compiling shared libraries ahead-of-time.  19.1.0(2019-07-02)This is a feature release, we recommend upgrading to it from the 19.0.x releases.Java  Improved speed of just-in-time (JIT) compilation in GraalVM, which significantlyimproves the performance on medium length workloads.  Applied profile-guided optimization (PGO) when building the ahead-of-time (AOT) image of the compiler. This enables more aggressive optimization of the compiler itself providing better compilation throughput.Native imageWe fixed many issues that were reported on GitHub. You can browse the full list here.JavaScript  Added an experimental option js.locale to set the default locale for locale-sensitive operations.  Allow making evaluated sources internal using the sourceURL directive by prefixing the URL with internal:, e.g., //# sourceURL=internal:myname.js.  Improved code sharing across threads. Prior to this one context had to be closed before the code in it could be reused in another context , now for JavaScript contexts one can share code using ContextPolicy.SHARED without closing the context.In the following example the source code is shared between context1 and context2:public static void main(String[] args) {        try (Engine engine = Engine.create()) {            Source source = Source.create(&quot;js&quot;, &quot;21 + 21&quot;);            try (              Context context1 = Context.newBuilder().engine(engine).build();              Context context2 = Context.newBuilder().engine(engine).build()) {                context1.eval(source).asInt();                context2.eval(source).asInt();            }        }    }LLVM interpreter  Calling exit(...) in an embedded context is now a catchable PolyglotException.  Skip source path entries that we are not allowed to access. Previously, whenrunning in an embedded context with restricted access to the file system, theLLVM engine threw an exception when it could not read the source files, even ifno debugger was attached. Now it will still run. Only when a debugger isattached, an error is reported when the source file can’t be accessed.RubyThe GraalVM Ruby implementation in this version targets performance and compatibility improvements, new features implementations and multiple bug fixes. The most notable include:  Interactive sources (like the GraalVM polyglot shell) now all share the same binding (#1695).  Hash code calculation has been improved to reduce hash collisions for Hash and other cases.  eval(code, binding) for a fixed code containing blocks is now much faster. This improves the performance of rendering ERB templates containing loops.  rb_str_cat is faster due to the C string now being concatenated without first being converted to a Ruby string or having its encoding checked.A complete changelog for the Ruby component is available on GitHub.R  Strings -Inf, +NaN, and -NaN are correctly parsed to doubles including ignoring leading and trailing whitespaces.  For loop creates and initializes the control variable even if there are no iterations (#77).  Updated the output of the capabilities builtin (#78).  is.function returns true for foreign executables.The complete project changelog is available on GitHub.Python  Updated Python standard library files from 3.7.0 to 3.7.3.  Improved performance of exceptions that do not escape.  Fixed caching of core sources in a native image with a preinitialized contextfor pre-built images and libpolyglot fast startup.  Implemented support for pwd.getpwuid, os.exec, os.execv, and os.execl modules.To see a complete list of changes, please refer to the project changelog.",
          "url": " /release-notes/19_1/"
          },
          
          "release-notes-19-2":  {
          "title": "19.2.1",
          "content": "19.2.1(2019-10-15)This is a Critical Patch Update (CPU) for GraalVM Enterprise and CommunityEditions following a regular Oracle CPUs cycle. The updateis to address security vulnerabilities announced in the October 2019 Oracle Critical Patch Update Advisory. The 19.2.1 version is a full distribution and and it is recommended to upgrade to it from older GraalVM versions.Oracle GraalVM Enterprise Edition 19.2.1 includes all the Java security fixes released as part of that CPU and mentioned in the Java SE 8 Release notes.  It also includes the following:  Update GraalVM Enterprise base Java to the 8u231 Oracle JDK version  Update GraalVM Community base Java to the 8u232 OpenJDK version  Update Node.js to 10.16.3Listed below are critical fixes that also went into this version:  Fixed a problem that prevented creating a native image including the GraalVM JavaScript engine combined with java.lang.CharSequence implementations that have non-trivial implementations of the length and charAt methods (see #1625).  Fixed a problem that could allow an exception to propagate past a catch clause that should handle it.Oracle Cloud Infrastructure customers can use GraalVM Enterprise environment in their cloud instances by simply installing it with yum. For more details, please seeGraalVM on OCI. Note: We currently do not recommend macOS users to upgrade to Catalina – a next majorrelease of macOS desktop operating system. We can not guarantee completecompatibility with GraalVM 19.2.1 or older versions yet.19.2.0.1(2019-09-13)We prepared a high severity update for GraalVM to address the following issues:  Fixed a critical compiler bug that caused String.indexOf to be executed incorrectly on older machines that do not support the TZCNT instruction. The problem causes incorrect string operations and typically shows up as truncated string values.  Fixed a bug causing the bounds check in Native Image’s implementation of System.arraycopy to overflow with large indices which typically causes process termination.  Fixed a bounds check for System.arraycopy in cases where the array is “virtualized” (i.e., can be in registers and stack slots instead of on the heap).  Removed declaration of otherwise unused SIOCGSTAMP symbol in Native Image. This allows use of Native Image on any Linux distro using a 5.2.x kernel such as the latest versions of Fedora, Ubuntu (except LTS release users), Arch, openSUSE (tumbleweed).19.2.0(2019-08-20)This is a GraalVM feature release, we recommend upgrading to it from the 19.1.x or older releases.Native ImageWe simplified the process of collecting data for profile-guided optimizations (PGO) for GraalVM Enterprise native images. PGO allows to optimize performance of native images by analyzing collected profiles during the image generation process. Since 19.2.0 you can collect data for PGO while running your application in a just-in-time (JIT) compiled mode:$ /graal-ee-19.2.0/bin/java -Dgraal.PGOInstrument=myclass.iprof MyClass$ /graal-ee-19.2.0/bin/native-image --pgo=myclass.iprof MyClass$ ./myclassPerformanceWe improved throughput for native image in GraalVM Enterprise when no profiles are available. Running the Micronaut GraalVM example shows spending ~10% less CPU time and achieving a ~10% higher throughput of requests per CPU second in 19.2.We also solved a common usability problem when a class marked forinitialization at runtime gets inadvertently initialized at build time. The flag -H:+TraceClassInitialization was introduced to help tracing what classes got initialized at runtime.JavaScript  We added support for date, time, timezone, instant and duration interoperabilitytypes to distinguish date-like objects from multiplelanguages in polyglot contexts (see changes to GraalVM SDK and Truffle APIs).  Added Context.Builder.timeZone to set the time zone.  We implemented the Numeric separators TC39 proposal. It isavailable in ECMAScript 2020 mode (--js.ecmascript-version=2020).  We moved ICU data for internationalization APIs, e.g., date and time formatting, number formatting, collation for each individual supported language, previously distributed as separate files in &amp;lt;JAVA_HOME&amp;gt;/jre/languages/js/icu4j/icudt to the executable of JavaScript (js).More changes are listed in the JavaScript component changelog.LLVM InterpreterWe added preliminary support for compiling native programs to bitcode usingthe LLVM toolchain. The LLVM toolchain is a set of tools and APIs for compilingnative projects, such as C and C++, to bitcode that can be executed with theGraalVM LLVM runtime. It is aimed to simplify ahead-of-time compilation forusers and language implementers who want to use the GraalVM LLVM runtime. To doso, we provide launchers that invoke the C/C++ compiler with special flags toproduce results that can be executed by the GraalVM LLVM runtime. For moredetails, please consult the LLVM reference documentation.The toolchain is an experimental feature in this release.A complete list of changes to GraalVM LLVM runtime can be found in thechangelog.RubyA comprehensive list of changes to Ruby language component is available on GitHub. Major changes include:  Implemented support for Fiddle – an extension to translate a foreign function interface (FFI) and libffi wrapper for Ruby.  In terms of compatibility, Thread.report_on_exception is now true by defaultlike MRI 2.5+; BigDecimal compatibility has been generally improved in severalways.  Improved the performance by optimizing String methods to use the vectorinstructions when searching for a single-byte character in a String.  Fixed several bugs reported by community:          Set RbConfig::CONFIG[&#39;ruby_version&#39;] to the same value as the TruffleRuby version. This fixes reusing C extensions between different versions of TruffleRuby with Bundler (#1715).      Improved errors when interacting with single-threaded languages (#1709).      R  Added a new fastRCluster package that allows to run FastR inside GNU-R:          install in GNU-R or RStudio with: devtools::install_github(&#39;oracle/fastr/com.oracle.truffle.r.pkgs/fastRCluster&#39;);      use ?fastRCluster to learn more.        The problem that SET_ATTRIB does not validate the attributes as expected was resolved.The changelog is available on GitHub.PythonThe GraalVM Python implementation is still experimental and we are working towards improving completeness.  Implemented PyStructSequence_* C API – standard structured prediction functions.  Added support for more C API functions as PyEval_InitThreads and PyEval_ThreadsInitialized, type attributes i.e. nb_remainder, nb_subtract, overflowed and recursion_depth thread state fields.  Fixed printing of errors in the REPL and full paths in tracebacks.More details are available in the project changelog on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)We implemented the ability to configure custom polyglot access configuration withPolyglotAccess.newBuilder(). It allows to configure fine-grained accesscontrol for polyglot bindings and between polyglot languages. For example, givena TruffleObject as a value, there is a need to determine language and type ofthat object. This feature is significant for GraalVM execution inside OracleRDBMS.GraalVM 19.2.0 release also added support for date, time, timezone, durationvalues in polyglot APIs, and introduced the Context.Builder.timeZone(ZoneId)class to configure the default timezone of polyglot contexts.The major GraalVM SDK and Truffle APIs changes between the versions are summarized in:  GraalVM SDK changelog  GraalVM Truffle changelogToolsA preview version of Java Flight Recorder (JFR) support has been released as a plugin for the VisualVM tool bundled with GraalVM 19.2.0. The plugin reads all JFR snapshots created from Java 7 and newer and presents the data in typical VisualVM views familiar for its users.To install the JFR support, download GraalVM 19.2.0 from graalvm.org/downloads, unzip it and run /bin/jvisualvm to start VisualVM.Use `Tools | Plugins | Available Plugins` to list all available plugins and install the VisualVM-JFR and VisualVM-JFR-Generic modules.The JFR snapshots can be opened using either the File | Load… action or by double-clicking the JFR Snapshots node and adding the snapshot into the JFR repository permanently.Please follow the documentation of your Java installation how to create JFR snapshots.JFR support is currently anexperimentalfeature. Some advanced features like analyzing JVM internals, showing eventstack traces or support for creating JFR snapshots from live processes are notavailable in the preview version and will be addressed incrementally in thefollowing releases.GraalVM Updater UtilityWe fixed an issue where GraalVM Enterprise would by default download the GraalVM Community components from GitHub. If you are using GraalVM Community – nothing changes, you can still install the components as before, and the gu will locate the necessary jar files on GitHub and correctly install them:gu install native-image ruby R pythonIf you are using GraalVM Enterprise, you can install R and llvm-toolchain components from GitHub, for example:gu install RThe other components are available from the OTN page, and can be installed from a manually downloaded file, for example to install native-image support run:gu -L install native-image-installable-svm-svmee-darwin-amd64-19.2.0.jarVersion CalendarYou can now refer to GraalVM version calendar to learn more about the GraalVM release model and prepare for upcoming releases.",
          "url": " /release-notes/19_2/"
          },
          
          "release-notes-19-3":  {
          "title": "19.3.6",
          "content": "19.3.6(2021-04-20)GraalVM Community Edition 19.3.6 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 19.3.x.Please note that this is the last release of GraalVM Community Edition 19.3.x.It also includes:  update to 8u292 for Java 8-based GraalVM Community, please see OpenJDK 8u292 Updates  update to 11.0.11 for Java 11-based GraalVM Community, please see OpenJDK 11.0.11 Updates  Node.js runtime update to 12.22.1 which contains all security fixes mentioned in April 2021 Security Releases19.3.5(2021-01-19)GraalVM Community Edition 19.3.5 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous releases of GraalVM 19.3.x.It also includes the following:  Update to OpenJDK version 8u282 for Java 8-based GraalVM Community, please see please see OpenJDK 8u282 Updates  Update to OpenJDK version 11.0.10 for Java 11-based GraalVM Community, please see OpenJDK 11.0.10 Updates19.3.4(2020-11-03)GraalVM Community Edition 19.3.4 is a Critical Patch Update (CPU) and contains fixes to security vulnerabilities and critical bugs.GraalVM Community Edition 19.3.4 is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU. It is a full distribution and supersedes all previous releases of GraalVM 19.3.containsOther changes that went into the release:  Update Java to 8u272 for Java 8-based GraalVM, please see OpenJDK 8u272 Release notes  Update Java to 11.0.9 for Java 11-based GraalVM, please see OpenJDK 11.0.9 Release notes19.3.3(2020-08-04)GraalVM Community Edition 19.3.3 is a Critical Patch Update (CPU) and contains fixes to security vulnerabilities and critical bugs.GraalVM Community Edition 19.3.3 is based on OpenJDK CPU and will include all the OpenJDK security fixes released as part of that CPU. It is a full distribution and supersedes all previous releases of GraalVM 19.3.Other changes that went into the release:  Update Java to 8u262 for Java 8-based GraalVM, please see OpenJDK 8u262 Release notes  Update Java to 11.0.8 for Java 11-based GraalVM, please see OpenJDK 11.0.7 Release notes19.3.2(2020-05-12)GraalVM Community Edition 19.3.2 is a Critical Patch Update (CPU) that only contains security and bug fixes, and supersedes all previous releases of GraalVM 19.3.The release includes:  Java update to 8u252 for Java 8-based GraalVM, please see [OpenJDK 8u252 Release notes]https://adoptopenjdk.net/release_notes.html#jdk8u252).  Java update to 11.0.7 for Java 11-based GraalVM, please see OpenJDK 11.0.7 Release notes.Other critical bug fixes that went into this version:  Made Chrome debugger call getter functions several times to test for side-effects.  Fixed a problem when LLVM context could send user directory information into the image heap by not caching System.getenv() for a single usage.  Substitute missing native methods in DynamicHub with @Delete (see #2054).  Added tests for JNI getFieldID and getMethodID method to ensure the class is initialized.19.3.1(2020-01-14)This is a Critical Patch Update (CPU) for GraalVM Enterprise and CommunityEditions. The 19.3.1 release contains fixes to security vulnerabilities,critical bugs, and other fixes as identified in the January 2020 Oracle Critical Patch Update Advisory. OracleGraalVM Enterprise Edition 19.3.1 includes all the Java security fixes releasedas part of that CPU.The 19.3.1 version also includes the following:  Update Java to 8u241 for Java 8-based GraalVM, please see Java SE 8 Release notes.  Update Java to 11.0.6 for Java 11-based GraalVM, please see Java SE 11 Release notes.  Update Ruby to 2.6.5, please see Ruby 2.6.5 release notes.  Update Node.js to 12.14.0, please see Node.js 12.14.0 release notes.For more information about Oracle Critical Patch Updates and Security Alerts, please visit the announcements list.Please note that for GraalVM Enterprise Edition on Java 11, java -version incorrectly reports aversion based on 11.0.6+1 where as it is actually 11.0.6+8. This issue inthe GraalVM build process will be remedied in future releases.Listed below are issues addressed in this release:  Resolved the issue of NullPointerException being thrown with SecurityServicesFeature when the application uses non-JDK related services (#1893).  Made efforts to turn Code coverage command line tool more reliable (#1800).  Prevented linking errors in Unsafe and ClassLoader by substituting all native methods (#1920).  Made dynamically generate On_Load_* function call for static libraries so all libraries are known before the image generation to prevent -Djava.net.preferIPv6Addresses=true returning an incorrect value (#1937).  Fixed ProcessHandle properties not providing useful values when running a native image (#2001).  Fixed an unsynchronized java.util.WeakHashMap.get access when single engine isshared between several thread local polyglot contexts (#1916).  Fixed an issue of JDK 11  GraalVM build not being recognized by macOS /usr/libexec/java_home -V (#801).  Implemented a new C APIs used by JSON 2.3.0 (#1857).  Ensured that GraalVM Native Image does  not have references to native methods from java.lang.reflect.Proxy (#1971).  Ensured that all native methods of core classes would be substituted to prevent reflection configuration issues (#1848).  Fixed an issue leading to JavaFX applications misbehave with GraalArithmeticStubs (#1867).  Ensured that DynamicProxySupport classes being called from multiple threads are thread safe (#1927).  Prevent static field values changing during a native image generation (#1945).  Fixed the issue with the native linking step at image writing phase when the image uses functions from unsupported static JDK libraries (#1875).19.3.0.2(2019-12-24)This is a bugfix update including fixes to the JVM Compiler Interface (JVMCI) and necessary updates to the JDK 11 support.The following issues were addressed:  Approached the issue of DynamicProxySupport being not thread safe when DynamicProxySupport.addProxyClass is called from multiple threads (see #1927).  Resolved a problem leading to a wrong execution of the code produced with the GraalVM native-image builder at optimization level 2 -H:Optimize=2 (see #1995).  Fixed a problem when JavaFX applications misbehave with GraalArithmeticStubs (see #1867).  Resolved an issue of VM crashing when run with Serial GC (see #1892).  ReduceInitialCardMarks is unsafe with OptBulkAllocation in JDK 11 (see #1915).  Fixed a transient crash while building native images with GraalVM based on JDK11 (see #1906).19.3.0(2019-11-19)GraalVM 19.3 is the first planned Medium-Term Support (MTS) release built fromthe main line of the project. This is also a major feature release and it is arecommended upgrade to it. The MTS status assures that stability, security, andperformance fixes will be backported from the current branch for the next 18months.GraalVM JDK 11 Based BuildsWith the major update to the 19.3 version, we announce the first release ofGraalVM based on JDK 11! This represents a substantial milestone given thedifferences between JDK 8 and JDK 11. In particular, the Java Platform ModuleSystem (JPMS) introduced in JDK 9 means GraalVM now uses module encapsulation to isolate code such as JVMCI, the GraalVM compiler and the Truffle API from application code. In addition, it means GraalVM on JDK 11 includes all theJDK changes since JDK 8. These are detailed in the release notes for JDK 9,JDK 10and JDK 11.In terms of languages, GraalVM on JDK11 supports all JVM languages (Java, Scala etc.) aswell as all guest languages currently supported in GraalVM on JDK8.Due to the modular structure of the base JDK, there is no more $JAVA_HOME/jre/ directoryin the GraalVM package based on JDK 11. This has an impact on the path to the languages location,e.g., $JAVA_HOME/jre/languages/js now becomes $JAVA_HOME/languages/js):GraalVM Native Imageon JDK 11 allows usage of all JDK 8 command line options. Currently the nativeimage builder ($JAVA_HOME/bin/native-image) does not support the JavaPlatform Module System (JPMS) and has no module introspection at image run time.Pease note, at present GraalVM Updater cannot rebuild images ($JAVA_HOME/bin/gu rebuild-images) with GraalVM Enterprise and Community editions on JDK 11. Even if GraalVM Native Image is installed, a user will encounter the following error while rebuilding:$ $JAVA_HOME/bin/gu rebuild-images rubyError: rebuild-images utility is not available. You may need to install &quot;native-image&quot; component.Please refer to documentation for the details.A possible workaround is to rebuild images invoking rebuild-images command directly, e.g.:$JAVA_HOME/bin/rebuild-images rubyPlease be informed, to have GraalVM JDK 11 based build on macOS listed by /usr/libexec/java_home -V you need to:  extract the GraalVM archive to /Library/Java/JavaVirtualMachines/ location  mkdir /Library/Java/JavaVirtualMachines/graalvm-ce-java11-19.3.0/Contents/MacOS  cd /Library/Java/JavaVirtualMachines/graalvm-ce-java11-19.3.0/Contents/MacOS  ln -s ../Home/lib/jli/libjli.dylibThis issue will be fixed in the next release.GraalVM JDK 11 on ARM64We provide a preview of GraalVM Community Edition on JDK 11 for ARM64architecture. It includes the support for all JVM languages. The support for theother languages should follow soon after. This distribution includes GraalVMNative Image off the shelf to build instantly starting applications whichconsume less memory in ARM64 environments.There are some known limitations with this distribution at the moment:  npm and node do not support runtime code installation (Trufflecompilations). To avoid failing with java.lang.NullPointerException, disableTruffle compilations with npm --vm.Dgraal.TruffleCompilation=false or node--vm.Dgraal.TruffleCompilation=false.  npm and node crash with  a free(): invalid pointer error.Native ImageGraalVM 19.3 switched to using the JDK native code instead of manualsubstitutions. For GraalVM Native Image this switch to Java Native Interface(JNI) platform enabled the possibility to provide support for JDK 11 andextended support for Windows OS. It has no impact on startup time or memoryfootprint, and eliminates the need for shipping JDK libraries such aslibsunec.so along with native images that use Java crypto services. GraalVMnow ships with statically linkable version of the JDK libraries.Note that the sunec native library of SunEC provider gets statically linkedinto an image if required (see#951). Thus native images do notdepend on the sunec shared library anymore at runtime. However, if SunECprovider gets statically linked into an image on Linux and macOS the image willdepend on libstdc++.Native Image Maven PluginSupport for using GraalVM Native Image with Maven was introduced with theNative Image Maven Plugin. It means auser can build a project and its native image directly with Maven using the mvnpackage command. As of the GraalVM version 19.3, the Maven &amp;lt;groupId&amp;gt; for theGraalVM Native Image related artifacts, including the plugin, changed fromcom.oracle.substratevm to org.graalvm.nativeimage:&amp;lt;plugin&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.nativeimage&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;native-image-maven-plugin&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;19.3.0&amp;lt;/version&amp;gt;    &amp;lt;executions&amp;gt;        &amp;lt;execution&amp;gt;            &amp;lt;goals&amp;gt;                &amp;lt;goal&amp;gt;native-image&amp;lt;/goal&amp;gt;            &amp;lt;/goals&amp;gt;            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;        &amp;lt;/execution&amp;gt;    &amp;lt;/executions&amp;gt;    &amp;lt;configuration&amp;gt;        &amp;lt;skip&amp;gt;false&amp;lt;/skip&amp;gt;        &amp;lt;buildArgs&amp;gt;            --no-fallback        &amp;lt;/buildArgs&amp;gt;    &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;To use the plugin make sure GraalVM home is set as your JAVA_HOME environment and Native Image is installed. Using the plugin without GraalVM is not recommend.GraalVM Compiler  We have improved System.arraycopy to eliminate store checks when copying toObject[]. That improvement fixes slowdowns (versus C2) on some EclipseCollections benchmarks.  A performance regression when creating List values in Scala has been fixed bymore optimized inlining.  Fixed an issue that could prevent a method from being compiled that contains the JSR bytecode produced by older javac versions (see #1699).JavaScriptThe Node.js runtime available with GraalVM was updated to the 12.10.0 version, which brought some breaking changes.Additional proposals for ECMAScript 2020 have been implemented (Promise.allSettled and Nullish coalescing) and are available in ECMAScript 2020 mode (--js.ecmascript-version=2020).To provide better compatibility with the ECMAScript specification, some extensions are now disabled by default, some depending on the launcher (js, node, or via GraalVM Polyglot Context). This includes the print and printErr functions (the js.print flag), the global built-in (superseded by globalThis, use the js.global-property flag to reenable), or the performance global property (the js.performance flag).More details can be found in the project changelog on GitHub.LLVM InterpreterIn GraalVM 19.3 clang and other LLVM tools are no longer required to beinstalled for building the GraalVM LLVM runtime. The LLVM toolchain bundled with GraalVM is used.Also the LLVM toolchain is not an “experimental” feature any more and is used by other languages.For example, save this native code demonstrating the interoperability with Java as a polyglot.c file:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 42);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}Now you can compile it using GraalVM drop-in replacement of traditional clang:$JAVA_HOME/jre/languages/llvm/native/bin/clang polyglot.c -o polyglotThen run the executable (polyglot) with its dependencies encoded in GraalVM LLVM runtime:lli polyglotList of features that have also been added:  Preliminary support for parsing bitcode produced by LLVM 9  Added intrinsics for pthread thread management functions  Support for pthreads LLVM bitcodeRefer to the component changelog on GitHub.Python  Updated Python standard library to 3.7.4.  Implemented support for NumPy 1.16.4 and Pandas 0.25.0, that can be installed with:$ graalpython -m ginstall install numpy$ graalpython -m ginstall install pandas  With the help of Weblogic Scripting Team in conversion of Jython into GraalVM Python,added Jython compatibility (enabled with --python.EmulateJython) that allows importing ofJava classes and catching of Java exceptions in Python the same way Jython allows it.$ graalpython --jvm --experimental-option --python.EmulateJython&amp;gt;&amp;gt;&amp;gt; import sun.misc.Signal&amp;gt;&amp;gt;&amp;gt; from java.lang import Integer, NumberFormatException&amp;gt;&amp;gt;&amp;gt; try:...   Integer.parseInt(&quot;99&quot;, 8)... except NumberFormatException as e:...   pass  Added support for basic sockets. Note that SSL is not implemented, thus there is no https yet:import urllib.requestprint(urllib.request.urlopen(&quot;http://google.com&quot;).read())  Implemented missing functions and fixed bugs to run various modules (timeit, socket, pytest).  Improved performance of Java interoperability, exceptions that do not escape,various C API functions, and the parser. The parser is ~20% faster now, sometimes upto ~40%, the performance in micro benchmarks is 5x faster, micro benchmarks forC API are 5x faster, but there is no change to NumPy performance numbers.To see a complete list of changes, please refer to the project changelog.R  FastR has been updated to R version 3.6.1.  In this release, FastR does not ship with GCC runtime libraries. Use the following commands to install the necessary dependencies:          Ubuntu 18.04 and 19.04: apt-get install libgfortran3 libgomp1      Oracle Linux 7: yum install libgfortran libgomp      Oracle Linux 8: yum install compat-libgfortran-48      MacOS: brew install gcc@4.9        Preview of support for LLVM based execution of R native extensions.          FastR is configured to use the GraalVM LLVM toolchain to compile the C/C++ and Fortran code of R packages. The resulting binarieswill contain both the native code and the LLVM bitcode. The R packages that are shipped with FastR were also compiledusing the GraalVM LLVM toolchain and their binaries contain the LLVM bitcode.      FastR loads and runs the R extensions native code by default, but when run with the option --R.BackEnd=llvm,it will load and run the LLVM bitcode if available. You can use the LLVM backend selectively for specific R packages via --R.BackEndLLVM=pkg1,pkg2.      If you encounter any issues when installing R packages, you can switch back from the GraalVM LLVM toolchainto the native toolchain by running fastr.setToolchain(&quot;native&quot;) or by manually editing the $FASTR_HOME/etc/Makeconf file.        Fixed memory leaks reported on GitHub.  Fixed failures when working with large vectors (&amp;gt;1GB).  Implemented grepRaw, but only for fixed=T.We encourage the users to experiment with the new LLVM support and report anyissues to GitHub. To see thecomplete list of changes, please refer to the projectchangelog.RubyA comprehensive list of changes to the Ruby language component is available on GitHub.The focus has been on improving compatibility with Ruby on Rails applications.Major changes include:  Compilation of C extensions is now done with an internal LLVM toolchain producing both native code and bitcode. This means more C extensions should compile out of the box and this should resolve most linker-related issues.  It is no longer necessary to install LLVM for installing C extensions on TruffleRuby.  It is no longer necessary to install libc++ and libc++abi for installing C++ extensions on TruffleRuby.  On macOS, it is no longer necessary to install the system headers package (#1417).  License updated to EPL 2.0/GPL 2.0/LGPL 2.1 like recent JRuby.  Installing sassc now works due to using the LLVM toolchain (#1753).  Include executables of default gems, needed for rails new in Rails 6.ToolsCode Coverage Command Line ToolAs of version 19.3 GraalVM provides a code coverage command line tool to recordand analyze the source code coverage of a particular execution of code forlanguages implemented with the Truffle framework. Enable it with --codecoverageoption, for example js --codecoverage. Visit the tool reference documentation for moreinformation.GraalVM VisualVM  Previously, to view the JFR files you had to install a plugin. Now GraalVM VisualVM contains the viewer in the tool core. Other JFR viewer improvements include new views for Exceptions and GC, improved performance and accuracy.  The tool is now able to monitor and profile AArch64 Java and Java 13 processes.Debugger  Enabled support for functional breakpoints and memory tools in Chrome Inspector.Visual Studio Code ExtensionsVSCode extensions are provided as VSIX packages. GraalVM team created the firstVSIX extension based on Python implementation. The extension installs with npmpackage manager and upon the extension installation, the user is requested topoint the PATH environment variable to GraalVM home directory.Changes for GraalVM Embedders (SDK)  Added new APIs for statement count resource limits:ResourceLimits.newBuilder()ResourceLimits.newBuilder()    .statementLimit(1000, null)    .build();              Duration.ofMillis(10))    .statementLimit(1000, null).build();try (Context context = Context.newBuilder()                .resourceLimits(limits).build()) {    context.eval(&quot;js&quot;, &quot;while(true);&quot;);    assert false;} catch (PolyglotException e) {    assert e.isCancelled();}  The default temporary directory can now be configured by FileSystem. A getTempDirectory()method of the FileSystem interface will return the default temporary directory.  Added the org.graalvm.home.Version version utility that allows to create, validate and compare GraalVM versions.  Added support for detecting and mapping polyglot exception values. Exceptions can be detected using Value.isException().  Added default target type mapping from guest language exceptions to PolyglotException.Proceed to the GraalVM SDK changelog for the complete list of changes.Changes for GraalVM Language or Tool Implementers (Truffle)  Added standard block node for language implementations. The block node usage allows the optimizingruntime to group elements of a block into multiple block compilation units. This optimization may beenabled using --engine.PartialBlockCompilation (on by default) and configuredusing --engine.PartialBlockCompilationSize (default 3000).  Merged new experimental inlining heuristic. Inlining budgets are now based on Graal IR nodecounts and no longer Truffle Node counts.  Support boolean literals in Truffle DSL expressions. Use true or false in expressions,e.g., isFunction(value) == false.  Added support for temporary files and directories.  Threads created by the embedder may now be collected by the GC before they canbe disposed. If languages hold onto thread objects exposed viainitializeThread they now need to do so with WeakReference. This avoidsleaking thread instances.  Added the new execute method to LoopNode, which allows loops to return values.To see the full list of changes to the APIs, proceed to theGraalVM Truffle changelog.",
          "url": " /release-notes/19_3/"
          },
          
          "2022-openjdk-announcement":  {
          "title": "OpenJDK Announcement",
          "content": "                                                        Oracle contributing GraalVM Community Edition Java Code to OpenJDK                              October 25, 2022                                                                                                                                    Oracle is contributing GraalVM Community Edition Java code to OpenJDK to more closely align the development of the GraalVM technologies with that of Java. This will benefit GraalVM and OpenJDK contributors, our partners, customers, and the broader Java ecosystem. It will pave a path towards the elimination of obstacles to wider ecosystem adoption and participation in the development of GraalVM technologies. Some of these obstacles include differences in release schedules, features, and development processes.                    By moving GraalVM to the OpenJDK Community, these technologies will be developed using the same successful methods and processes that a large community of companies, organizations, individual developers, and academics have used to move Java forward transparently and predictably for more than a decade.                          What parts of GraalVM Community Edition does Oracle plan to contribute to the OpenJDK Community?                      Oracle plans to contribute the most applicable portions of the GraalVM just-in-time (JIT) compiler and Native Image. Oracle does not currently intend to contribute the polyglot technologies supporting other languages such as Python, Ruby, R, and JavaScript. Additional details will follow in the coming months as we move forward through this process.                  How does Oracle plan to contribute the code?                      Oracle plans to contribute the suitable GraalVM technologies into one or more OpenJDK projects, in accordance with the OpenJDK Community processes. Additional details will follow in the coming months.                  Which versions of the GraalVM Community Edition code does Oracle plan to migrate?                      Oracle plans to contribute the GraalVM technologies currently in development. Previous versions of these technologies will remain in the GraalVM GitHub organization.                  How will GraalVM Community Edition technologies be developed in the OpenJDK Community?                              GraalVM technologies will be developed in accordance with the methods and processes used in the OpenJDK Community. That means that there will be at least one Project with Committers and Reviewers. If and when a GraalVM technology is ready to become part of a main-line JDK release, a JDK Enhancement Proposal (JEP) will be submitted.            GraalVM technologies will be developed with the same kind of transparency and predictability that Java developers have come to expect from other Oracle-led Projects in the OpenJDK Community.                  Will there be a GraalVM JEP?                      The JEP planning process provides transparency into JDK development for the entire Java ecosystem. Any sufficiently large feature destined for the JDK main line goes through the JEP Process, since that is how JDK releases are planned in the OpenJDK Community. When suitable portions of the GraalVM technologies are ready to be proposed for inclusion into the main-line JDK source code, they will be accompanied by one or more JEPs.                   Will the GraalVM license change?                      The plan is to align all the GraalVM technologies with Java both from a release perspective and from a licensing perspective. Additional details will follow in the coming months as we move forward through this process.                  Where can I learn more about it?                      You will be able to learn more about the details of the migration of GraalVM technologies to the OpenJDK Community through the inside.java news aggregation site (which may point to content from multiple sources), as we continue to move forward through this process — just as you would learn about any other interesting bits of Java platform development news.                  Will GraalVM Community dev builds be published from the OpenJDK Projects?                      Oracle-led OpenJDK Projects such as Loom, Panama, and Valhalla all publish Early Access releases on jdk.java.net. Early Access releases of the contributed GraalVM Community Edition technologies may be made available in a similar fashion, as we move forward through this process.                  What does the alignment with the Java release model mean in practice?                      Oracle plans to align future GraalVM releases with the JDK release model:                                          Support for one Java SE Platform Specification per release                Two feature releases per year                Four predictable, quarterly Critical Patch Updates annually                A Long-Term Support Release every two years                                      The alignment of the release model is planned for CY 2023, pending the migration to OpenJDK development and contribution processes.                  What are the plans for Native Image?                      Oracle plans to contribute the most applicable parts of the GraalVM Native Image implementation to the OpenJDK Community. Once contributed, the Native Image technology would continue to be developed within the scope of an OpenJDK Project, using the same processes and methods as other OpenJDK development. Oracle plans to evolve the Native Image technology in the OpenJDK Community to track the Project Leyden specification as it progresses to pave a path to fully-static images in a future release of the Java SE Platform specification.                  I’m a GraalVM CE or GraalVM EE user. Will this change affect me?                      Ongoing updates for previous GraalVM releases will continue as anticipated with the release schedule getting aligned with Java releases in CY23. This change only affects future development of select open-source GraalVM technologies. Java users will benefit from the alignment of release schedules and cadence as well as easier access to innovation.                      ",
          "url": " /2022/openjdk-announcement/"
          },
          
          "release-notes-20-0":  {
          "title": "20.0.0",
          "content": "20.0.0(2020-02-18)GraalVM Platform UpdatesGraalVM 20.0 improves significantly on the previously available GraalVM buildsfor Windows platforms. Windows is no longer an experimental platform in the GraalVM ecosystem.Windows builds now contain the functional gu utility to install thecomponents. GraalVM Native Image component needs to be installedwith gu as on other platforms. JavaScript engine is now included in the GraalVM Windows distribution. Node.js support on the Windows platform is scheduled to be included in the next GraalVM release (20.1).GraalWasm, the WebAssembly component, is distributed through the usual component distribution channels.The GraalVM distribution for AArch64 now includes a functional node.js runtime (both in --jvm and native modes).Java  GraalVM Community Editions are based on OpenJDK version 1.8.0_242 and OpenJDK version 11.0.6.  GraalVM Enterprise Editions are based on Oracle JDK version 1.8.0_241 and Oracle JDK version 11.0.6. You can find the JDK release notes at the Oracle Technology Network website.  Added mitigation of Jump Conditional Code (JCC) Erratum (see #1829).  GraalVM has a default setting of ThreadPriorityPolicy=1, which means thread priorities set in Java are reflected by native operating sytstem thread priorities. This may affect Java application performance.Native Image  Native Image support on Windows has significantly advanced. Please report issues if you find any problems.  Native images built with GraalVM Enterprise can now include a G1-based low-latency garbage collector that reduces stop-the-world pauses and improves latency. It is an experimental feature that can be enabled at image build time with -H:+UseLowLatencyGC. For more details, please refer to the documentation.  Fixed several Java Native Interface (JNI) and JDK11 related issues, please refer to GitHub for more information.JavaScript  Updated Node.js to 12.15.0, please see Node.js 12.15.0 release notes.  Added the js.commonjs-require option to load npm-compatible CommonJS modules from plain JavaScript. This is an experimental feature. See NodeJSVSJavaScriptContext.md for details.  Added the js.load-from-classpath option to allow loading files from the classpath via the classpath: pseudo URLs (disabled by default). Its usage is not recommended with untrusted code.  Added the implementation of the String.prototype.replaceAll proposal. It is available in ECMAScript 2020 mode (--js.ecmascript-version=2020).  Updated String.prototype.matchAll to be available only in ECMAScript 2020 mode (--js.ecmascript-version=2020).  Added the js.bind-member-functions option for the implicit binding of unbound functions returned by Value.getMember to the receiver. The preferred way of calling members is using Value.invokeMember.  Made the support for Nashorn pseudo URLs available only in the Nashorn compatibility mode (--js.nashorn-compat).  Implemented support for public and private class fields, including static fields. This feature can be enabled using the experimental option js.class-fields and is available by default in Node.js.  Added the js.global-arguments option with true as a default value for the non-standard arguments global property.More details can be found in the project changelog on GitHub.LLVM Runtime  The toolchain is now based on LLVM 9.0.0.  Support accessing llvm-ar, llvm-nm, llvm-objcopy, llvm-objdump, llvm-ranlib, llvm-readelf, llvm-readobj and llvm-strip via the toolchain.For more details refer to the component changelog on GitHub.Python  Improved Jython Compatibility by implementing syntax from JavaType import * to import all static members of a Java class, and by enabling import of Python code from inside JAR files by adding path/to/jarfile.jar!path/inside/jar to sys.path.  Added support for date and time interop.  Added support for setting the time zone via Context.Builder.timeZone.  Implemented PEP 570 - Python Positional-Only Parameters.To see a complete list of changes, please refer to the project changelog.R  On Linux, the required version of libgfortran changed from 3 to 5. See the requirements section for details.  Implemented subsetting an array by numeric and/or string matrix.  Fixed an issue where polyglot value is not an object (see #123).  Fixed an issue with the incorrect formatting for sprintf %g and %G (trailing zeroes, see #126).  Added  R builtins and C APIs:          Ported all external C functions used by nlm (see #100) and fisher.test from the stats base package.      Added Rf_asS4 C API function (see #118).      More details can be found in the project changelog on GitHub.RubyA detailed changelog for the Ruby component is available on GitHub.  Updated to Ruby 2.6.5 (see #1749).  Updated the internal LLVM toolchain to LLVM 9 and reduce its download size.  Automatically set PKG_CONFIG_PATH as needed for compiling OpenSSL on macOS (see #1830).  Performance improvements related to sockets and RSTRING_PTR.  100+ compatibility and bug fixes, please refer to the changelog.Changes for GraalVM Embedders (SDK)  The deprecated graalvm.home and graalvm.version system properties have been removed, use the HomeFinder instead.  Added EventContext.createError which allows to introduce guest application errors in execution listeners/nodes.  Added Context.Builder.currentWorkingDirectory to set the current working directory used by the guest application to resolve relative paths.  The algorithm used to generate a unique URI for a Source built without an URI was changed to SHA-256.  All Truffle Graal runtime options (-Dgraal.) will be deprecated with 20.1. The Truffle runtime options are no longer specified as Graal options (-Dgraal.). The Graal options must be replaced by corresponding engine options specified using the polyglot API. The TRUFFLE_STRICT_OPTION_DEPRECATION environment variable can be used to detect usages of deprecated GraalVM options. When the TRUFFLE_STRICT_OPTION_DEPRECATION is set to true and the deprecated Graal option is used, the Truffle runtime throws an exception listing the used deprecated options and corresponding replacements.More details are in the SDK and Truffle changelogs.Tooling  Added an option for gu to install all available components from a local directory, for example: gu install -C /path/to/downloaded/20.0-components/ native-image llvm-toolchain ruby r python wasm.  Added a JDK Flight Recorder Data Viewer to VisualVM.  Added an integration of T-trace instrumentation framework with OpenTracing.  Added LLVM languages support to T-trace instrumentation framework  Added a Technology Preview of the Language Server Protocol implementation for GraalVM languages and its support to GraalVM VSCode Extensions.",
          "url": " /release-notes/20_0/"
          },
          
          "release-notes-20-1":  {
          "title": "20.1.0",
          "content": "20.1.0(2020-05-19)Java  GraalVM Community Edition is based on OpenJDK version 1.8.0_252 and OpenJDK version 11.0.7.  Oracle GraalVM Enterprise Edition is based on Oracle JDK version 1.8.0_251 andOracle JDK version 11.0.7. You can find Oracle JDK release notes for theseversions at the Oracle Technology Network website.  Added support for compiling classes with irreducible loops in the bytecode. Theseoften occur in Kotlin applications using coroutines with loops. The supportboth improves performance of such applications and enables their ahead-of-time compilation.  Added new TuneInlinerExploration option to increase or decrease the time spentexploring inlining opportunities. Tuning this option helps to achieve betterpeak performance or limit time to reach (potentially lower) peak performancewhich might improve overall speed of the program. This option is only aheuristic and should be tuned for a specific application. (Only available in GraalVM Enterprise.)  Added support to optimize away some redundant clone operations. For example, incode patterns similar to the one below, the GraalVM compiler will avoid creatingthe array clone:new int[length].clone().length      Added support for visualizing libgraal memory usage in VisualVM:    The mitigation of the Intel JumpConditional Code (JCC) Erratum is now only enabled for CPUs that need it.  Significantly improved performance for some benchmarks on JDK 11 due to fixes inthe area of synchronization. The most notable improvement isRenaissance:reactorswhich shows approximately 50% better results.Native Image  Improved scalability of the static analysis. The static analysis time wasinfeasible for some large applications. We added a new mechanism, called“saturated type flows”, to make the analysis faster. The new analysis isdisabled by default for GraalVM 20.1, but we plan to enable it by default in afuture release. We encourage all users to try it out using the image builderoption -H:+RemoveSaturatedTypeFlows. According to our measurements theprecision of the static analysis is comparable, but if you have an applicationwhere many more classes or methods are reachable with this option please create an issue on GitHub.  Added new option for the image generator to exit handlers on terminationsignals: --install-exit-handlers. This improves the user experience whenrunning a native image in a Docker container as the init process, since Linuxdoes not install a default signal handler for the process with id “1” and thenative image is therefore not reacting to a shutdown request from Docker.  Improved support for soft references. Before 20.1, soft references (the JavaSoftReference class) were cleared immediately at every GC like weakreferences. Now they are cleared based on a policy that takes the last accessand the memory pressure into account.  Added survivor spaces to the GC. Disabled by default until a proper policy isimplemented, see this GitHub issue for ideas and tasks aroundGC in native images.  Added generation of Dwarf debug information.  Improved support for timezones: information about all timezones is now includedin every image, and the default timezone is correctly initialized at imagestartup and no longer fixed at image generation time.  Improved checking that the native compiler toolchain is correct, for example,whether the compiler version on Windows is correct. This avoids strange errors dueto known incompatible compiler versions.Many more compatibility improvements and bug fixes can be found on GitHub. Forexample, here is a list of fixed issues relevant for Spring framework support.JavaScript  Enabled ECMAScript 2020 mode features by default.  Implemented several ECMAScript proposals, including Optional Chaining, HashbangGrammar, FinalizationRegistry, private class methods, RegExp Match Indices,export * as ns from &quot;mod&quot;, Intl.Locale, Intl.DisplayNames, Intl.DateTimeFormatdateStyle and timeStyle.  Added npx (npm package runner) utility into GraalVM distributions.  Removed the JOni RegExp-engine and the use-tregex option. TRegex engine is now the default regex engine.  Removed our SIMD.js implementation.LLVM Runtime  Added a preliminary support for running C++ code in managed mode. (Only available in GraalVM Enterprise.)  Updated musl libc to version 1.1.24. (Only available in GraalVM Enterprise.)  Both libc++ and libc++abi are now shipped as bitcode libraries.  Improved C++ support, libsulong++ is loaded only if libc++ is loaded. Theexecutables (ELF, Mach-O) compiled with the toolchain usually have a dependencyon this library and will continue to work. Plain bitcode files, which do notallow specification of dependencies, may fail with an error similar to thefollowing:    Global variable ZNSt3_15ctypeIcE2idE is declared but not defined.    This can be solved, for example, by specifying the dependency on the commandline lli --lib libc++.so.1 ... on Linux or lli --lib libc++.1.dylib onmacOS.    Changed module initialization order to be only based on the dependenciesrecorded in the ELF/Mach-O file (instead of looking at imported symbols). Thismight change the order in which plain bitcode files are initialized since theydo not allow recording dependencies. If the initialization order is important,the suggested approach is to use ELF/Mach-O files. See theToolchaindocumentation for more details.  Added support for on-stack-replacement of loops during bitcode execution, now itcan compile long-running loops before the surrounding function is compiled.Python  Updated to Python 3.8.2.  Improved tuples with primitive elements performance.  Improved performance of sequences, sets, dicts, and list expressions.  Added support of cProfile and trace modules through the GraalVM CPU sampler and coverage, respectively.  Added support of NumPy on macOS.  Added support of setuptools-scm and pytz.timezone.  Added support of a new syntax for iterable unpacking from yield and return statements.  Fixed issues with inspection and printing of non-Python numbers in the Chrome debugger.  Fixed issues with AST sharing across different contexts when these contexts run concurrently on multiple threads.  Fixed passing non-ASCII strings to gethostbyname.  Improved Jython compatibility mode: treat Java null as identical to Python None when comparing with the is operator.  Improved Jython compatibility mode: isinstance now works with Java classes and objects.  Moved all GraalPython specific functions on sys or builtins to the _graalpython_ module.To see a complete list of changes, please refer to the project changelog.R  Preview of improved graphical support based on the graphics, grDevices, and JavaGD packages          Use --R.UseInternalGridGraphics=false to activate this feature.      Our custom grid package re-implementation, which is currently the default, will be first deprecated and then removed in future releases.        Included GCC runtime libraries for supported systems (Linux and macOS)  Removed GFortran as a requirement to run FastR.  The GFortran runtime libraries versions are 4.8.5 on Linux and 8.3.0 on macOS. When compiling additional R packages with Fortran code, one must use GFortran of the same or higher version.          There’s a known issue: the libgomp.1.dylib library is not distributed with FastR on MacOS. To workaround this issue: install GCC with the package manager of your choice, e.g., brew install gcclocate file libgomp.1.dylib. Variable $GOMPLIB will denote full path to this library and $R_HOMEthe path to R installation:$JAVA_HOME/jre/languages/R on JDK8 based builds$JAVA_HOME/languages/R on JDK11 based buildsexecute these two commands:install_name_tool -change /cm/shared/apps/gcc/8.3.0/lib/libgomp.1.dylib $GOMPLIB $R_HOME/lib/libRblas.dylibinstall_name_tool -change /cm/shared/apps/gcc/8.3.0/lib/libgomp.1.dylib $GOMPLIB $R_HOME/lib/libRlapack.dylib        GFortran is now the default Fortran compiler even in the LLVM toolchain configuration.  Added support for traceback() to show frames from other GraalVM languages and C/C++ when run in the LLVM mode (--R.BackEnd=llvm).  Improved interoperability with other languages: “@” and “$” can be used to access members of foreign polyglot objects.A detailed list of the changes and bug fixes is available in the project changelog.Ruby  Added nightly builds, see the README for details.  ||= will not compile the right-hand-side if it is only executed once, to match the idiomatic lazy-initialization use-case (see the blog post).  Optimized performance of bundle install.  Added the --metrics-profile-require option to profile searching, parsing, translating and loading files.  Changed the C API type VALUE to be defined as unsigned long as on MRI. This enables using switch (VALUE) and other expressions which rely on VALUE being an integer type.  Removed deprecated Truffle::System.full_memory_barrier, Truffle::Primitive.logical_processors, and Truffle::AtomicReference.  Improved interoperability with other languages: hash keys are no longer reported as polyglot members.  Added Truffle::Interop.hash_keys_as_members to treat a Ruby Hash as a polyglot object with the Hash keys as members.Other 56 bug fixes and 52 compatibility improvements, see a detailed changelog.ToolingChrome Inspector  Implemented the display of asynchronous stack traces in debugger, in Chrome Inspector and in exception traces.Language Server Protocol  Improved stability of GraalVM Language Server and GraalVM VSCode Extensions.  Changed to start GraalVM Language Server in the native mode for better startup performance.  Stabilized support for LSP in R and Ruby.VisualVM  Enabled VisualVM to monitor libgraal memory usage.  Implemented showing compiled and interpreter time in the GraalVM sampler.  Improved JFR viewer to display stack traces for JFR events.Ideal Graph Visualizer      Added grouping of graph dumps by session:    Added an action to go to compiler classes.  Improved stability of IGV to no longer hang on some graph layout.GraalVM Updater gu  Added support for wildcards when GraalVM Updater installs from a directory (-C).Updates for Polyglot Embedders  Added Value.isMetaObject(), Value.getMetaQualifiedName(), Value.getMetaSimpleName() and Value.isMetaInstance(Object) to allow language agnostic access to meta-objects like classes or types.  The result of Value.getMetaObject() will always return meta-objects. It is recommended but not required to change uses of meta-objects to use Value.getMetaQualifiedName() instead of Value.toString() to return a type name.  Added OptionDescriptor.getDeprecationMessage returning the option deprecation reason. Added OptionDescriptor.Builder.deprecationMessage() to set the option deprecation reason.  Added Context.Builder.hostClassLoader to allow an embedder to specify a context ClassLoader for code execution.More changes can be found in the GraalVM SDK changelog.Updates for Language and Tool Implementers  engine.Mode is now a supported option and no longer experimental.  Added new meta-data APIs to InteropLibrary:          has/getLanguage(Object receiver) to access the original language of an object      has/getSourceLocation(Object receiver) to access the source location of an object (e.g., a function or classes)      has/toDisplayString(Object receiver, boolean allowsSideEffect) to produce a human-readable string      has/getMetaObject(Object receiver) to access the meta-object of an object      isMetaObject(Object receiver) to find out whether an object is a meta-object (e.g., Java class)      getMetaQualifiedName(Object receiver) to get the qualified name of a meta-object      getMetaSimpleName(Object receiver) to get the simple name of a the meta-object      isMetaInstance(Object receiver, Object instance) to check whether an object is an instance of a meta-object        Added TruffleLanguage.getLanguageView that allows to wrap values to add language specific information for primitive and foreign values.  Added TruffleLanguage.getScopedView that allows to wrap values to add scoping and visibility to language values.  Added TruffleInstrument.Env.getScopedView and TruffleInstrument.Env.getLanguageView to access language and scoped views from instruments.  Added TruffleInstrument.Env.getLanguageInfo to convert language classes to LanguageInfo.  Added @GenerateLibrary(dynamicDispatchEnabled = false) that allows to disable dynamic dispatch semantics for a library. The default is true.  Added ability to load external default exports for libraries using a service provider. See GenerateLibrary(defaultExportLookupEnabled = true).  Added @ExportLibrary(transitionLimit=&quot;3&quot;) that allows the accepts condition of exported libraries to transition from true to false for a library created for a receiver instance. This is, for example, useful to export messages for array strategies.  Added support for asynchronous stack traces for languages and tools to allow debuggers to show them.To see a full list of changes to APIs, proceed to theGraalVM Truffle changelog.",
          "url": " /release-notes/20_1/"
          },
          
          "release-notes-20-2":  {
          "title": "20.2.0",
          "content": "20.2.0(2020-08-18)Java  GraalVM Community Edition is based on OpenJDK version 1.8.0_262 and OpenJDK version 11.0.8.  Oracle GraalVM Enterprise Edition is based on Oracle JDK version 1.8.0_261 and Oracle JDK version 11.0.8.0.2. You can find Oracle JDK release notes for these versions at the Oracle Technology Network website. (Only available in GraalVM Enterprise.)  Added the ability to release the memory used by libgraal to the OS when an application enters a stable phase and compilation goes idle. This is achieved by attaching each compiler thread to a libgraal isolate. The number of compiler threads that can be attached to an isolate is controlled by the jvmci.ThreadsPerNativeLibraryRuntime system property. The default is all threads attached to a single isolate. Isolates are initialized on demand to handle extra compiler threads. When a compiler thread becomes idle (idleness delay is configurable by jvmci.CompilerIdleDelay), it detaches itself from its isolate. As the last thread detaches from an isolate, it is shutdown and its memory (i.e., the libgraal heap) is released to the OS. This feature has the following of advantages:          It can reduce the RSS memory footprint of a GraalVM process. If the compiler is not being used, it uses no resources.      If multiple isolates are used, it mitigates interference between complier threads. For example, there is less contention on shared objects and a garbage collection in one isolate will not pause threads in other isolates. (Only available in GraalVM Enterprise.)        Improved the optimization responsible for removing redundant read/write, array clone() and accesses to the cloned arrays operations. Workloads that heavily use array read/write operations, especially inside loops, in combination with allocations may benefit from this optimization. As a result of the enhanced read/write optimization, the speedups of up to 2.5x on the JetStream benchmarks were seen with GraalVM JavaScript engine. (Only available in GraalVM Enterprise.)  Added an experimental partial loop unrolling optimization. Partial loop unrolling is an extended form of traditional loop unrolling optimization that works for arbitrary counted loops with an unknown upper bound of loop iterations i. The optimization is not enabled by default, you can experiment with the optimization by enabling it with -Dgraal.EnterprisePartialUnroll=true. Note, the optimization is still experimental and thus may lead to unknown errors. (Only available in GraalVM Enterprise.)  Fixed an error in code generation which was leading to incorrect behaviour of programs using the Apache commons-compress BZip2 implementation (see #2534).  Improved excessive compile time of certain programs (see #2548).  Improved error reporting with libgraal. Fatal errors in libgraal now produce a hs-err crash log that can substantially improve triaging and debugging such errors. Likewise, low level libgraal output, such as libgraal GC messages produced by -Dlibgraal.PrintGC=true are routed to HotSpot’s log stream. That is, libgraal error handling and logging is unified with HotSpot support for these features and thus configurable by options such as -XX:LogFile and -XX:OnError.  Renamed the MitigateSpeculativeExecutionAttacks compiler option to SpectrePHTBarriers (e.g., use -Dgraal.SpectrePHTBarriers=AllTargets for java or --vm.Dgraal.SpectrePHTBarriers=AllTargets for js).Native Image  Improved the G1GC-like garbage collection for workloads where Native Image requires smaller GC pauses. More details are in the documentation on how to enable and configure it documentation on how to enable and configure it. (Only available in GraalVM Enterprise.)  Added an option to create “mostly static” native images which link statically everything except libc. Native images built this way are convenient to use in small docker images, for example, based on distroless/static. Enable nearly static native image generation with the following option: -H:+StaticExecutableWithDynamicLibC.  Improved generation of native images statically linked against muslc. If you have musl-gcc on the path, you can now generate a native image statically linked against muslc with the following options: --static --libc=musl. More information about this is available in the documentation.  Enabled -H:+RemoveSaturatedTypeFlows by default, which should result in faster native image generation and use less memory for the generation.  Changed the class initialization strategy to initialize at build time only a small part of the JDK library. To get the previous behaviour back, use --initialize-at-build-time option for necessary packages.  Many other improvements and bug fixes can be found in the repository.JavaScript  Updated Node.js to version 12.18.0. Notable changes in this release are available from the Node.JS project website.  Updated ICU4J library to version 67.1.  Implemented the Intl.NumberFormat Unified API proposal.  Implemented the Logical Assignment Operators proposal.  Implemented the Top-level Await proposal.  Implemented the Promise.any proposal. It is available in ECMAScript 2021 mode (--js.ecmascript-version=2021).  Implemented support for async stack traces.  Fixed Date.toLocaleString and Intl.DateTimeFormat to use the context’s default time zone rather than the system default if no explicit time zone is requested.  Improved js.timezone option to validate the time zone ID and support zone offsets like “-07:00”.Updates for Language and Tool Implementers  Enabled by default the new inlining heuristic in which inlining budgets are based on Graal IR node counts and not on Truffle Node counts. More information can be found in the Inlining guide.  Added support for subclassing DynamicObject so that guest languages can directly base their object class hierarchy on it, add fields and use @ExportLibrary on subclasses.  Added new DynamicObjectLibrary API for accessing and mutating properties and the shape of DynamicObject instances. More information can be found in the Dynamic Object Model guide.  Added new identity APIs to InteropLibrary:          hasIdentity(Object receiver) to find out whether an object specifies identity      isIdentical(Object receiver, Object other, InteropLibrary otherLib) to compare the identity of two object      isIdenticalOrUndefined(Object receiver, Object other) to specify the identity of an object      identityHashCode(Object receiver) to implement maps that depend on identity        Added Truffle DSL @Bind annotation to common out expression for use in guards and specialization methods.  Added the ability to disable adoption for DSL cached expressions with type node using @Cached(value =&quot;...&quot;, weak = true).  Added an option not to adopt the parameter annotated by @Cached, using @Cached(value =&quot;...&quot;, adopt = false).  Added CompilerDirectives.shouldNotReachHere() as a short-cut for languages to indicate that a path should not be reachable neither in compiled nor interpreted code paths.More details are available from the changelog.Updates for Polyglot Embedders  Added Context.parse(Source) to parse but not evaluate a source. Parsing the source allows to trigger e.g., syntax validation prior to executing the code.  Added PolyglotException.isResourceExhausted() to determine if an error was caused by a resource limit (e.g., OutOfMemoryError) that was exceeded.  Added a factory method creating a FileSystem based on the host Java NIO. The obtained instance can be used as a delegate in a decorating filesystem.  Added optional FileSystem.isSameFile method testing if the given paths refer to the same physical file. The method can be overridden by the FileSystem implementer with a more efficient test.More details are available from the changelog.ToolingVS Code  Updated Language Server Protocol (LSP) implementation to support the latest protocol version 3.15.VisualVM  Updated VisualVM to use NetBeans platform 11.3.  Added GoToSource from VisualVM to your preferred IDE.Ideal Graph Visualizer  Implemented usability improvements for graphs identification in IGV (IGV graph now displays a dump ID and a user label with Graph name). (Only available in GraalVM Enterprise.)  Added Go To Type and Attach Debugger actions.  IGV updated to NetBeans platform to 11.3.LLVM Runtime  Added support for InteropLibrary.isIdentical and related messages.  Added the --print-toolchain-api-identifier, --print-toolchain-api-tool &amp;lt;tool-name&amp;gt; and --print-toolchain-api-paths &amp;lt;path-name&amp;gt; arguments to the lli launcher. These can be used to query the Toolchain API from the command line.  Added support for requesting locations via the #getPaths() method to the Java API of the Toolchain. For example, the location of the toolchain executables or libraries.  Added llvm/api/toolchain.h header for accessing the Toolchain from C code.  Added ability to read and write bigger values to a polyglot i8 array. For example, when reading an i64 from a foreign value that is typed as i8 array, the LLVM runtime will read 8 i8 values and combine them to an i64 result.  Removed the --llvm.sourcePath option (deprecated since 19.0). Use --inspect.SourcePath instead.  Removed support for the application/x-llvm-ir-bitcode-base64 mime-type (deprecated since 19.0).Python  Improved reference counting for native extensions to prevent memory leaks.  Added code serialization to .pyc files (.pyc files persistently store the Python bytecode compiled from the source .py files).  Fixed warning in pandas about size of the datetime objects.  Improved compatibility (more CPython unittests pass for core types).  Added support for parsing requests with arguments for embedding Python.  Added support for the basic usage of tox – a Python testing wrapper.  Removed support for iterables as arrays in polyglot applications.  Added a faster implementation of _struct. (Only available in GraalVM Enterprise.)R  Improved SVG support activated with the --R.UseInternalGridGraphics=false flag.  Improved FastR user experience: FastR should have no requirements on both Linux and macOS i.e., installing GCC or GFortran should not be necessary to run FastR, but it may be necessary to install some third party R packages.RubyNew features:  Updated to Ruby 2.6.6.  Configured Ruby to always show core library files in backtraces.  The Java stacktrace is now shown when sending SIGQUIT to the process, also on TruffleRuby Native.  Use InteropLibrary#toDisplayString() to better display objects from other languages.  foreign_object.to_s now uses InteropLibrary#toDisplayString() (and still asString() if isString()).  foreign_object.inspect has been improved to be more useful (include the language and meta object).  foreign_object.name = value will now call Interoplibrary#writeMember(&quot;name&quot;, value) instead of invokeMember(&quot;name=&quot;, value).  Calls to foreign objects with a block argument will now pass the block as the last argument.  foreign.name will now use invokeMember if invocable and if not use readMember. See doc/contrib/interop_implicit_api.md for details.Bug fixes:  Fix #class_exec, #module_exec, #instance_eval, and instance_exec to use activated refinements (@ssnickolay).  Use upgraded default gems when installed.  The output for --engine.TraceCompilation is now significantly easier to read, by having shorter method names and source names.  Fixed indentation for squiggly heredoc syntax with single quotes.  Fixed missing flushing when printing an exception at top-level with a custom backtrace, which caused no output to be shown.Compatibility:  Implemented Ripper by using the C extension.  Implemented ObjectSpace::WeakMap.  Supported #refine for Module (@ssnickolay).  Fixed refine + super compatibility (@ssnickolay)  Implemented UnboundMethod#bind_call.  RUBY_REVISION is now the full commit hash used to build TruffleRuby, similar to MRI 2.7+.  Changed the lookup methods to achieve Refinements specification (@ssnickolay)Performance:  Enabled lazy translation from the parser AST to the Truffle AST for user code by default. This should improve application startup time.  instance variable ... not initialized and similar warnings are now optimized to have no peak performance impact if they are not printed (depends on $VERBOSE).  Implemented integer modular exponentiation using BigInteger#mod_pow ( @skateman).  Fixed a performance issue when computing many substrings of a given non-leaf String with non-US-ASCII characters.  Speedup native handle to Ruby object lookup for C extensions.Changes:  RubyGems gem commands updated to use the --no-document option by default.",
          "url": " /release-notes/20_2/"
          },
          
          "release-notes-20-3":  {
          "title": "20.3.6",
          "content": "20.3.6(2022-04-26)This is April 2022 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 20.3.5.The OpenJDK release that GraalVM Community Edition is built on was updated to 11.0.15 for Java 11-based GraalVM Community. See OpenJDK 11.0.15 Updates.20.3.5(2022-01-18)This is January 2022 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 20.3.4.The OpenJDK release that GraalVM Community Edition is built on was updated to 11.0.14 for Java 11-based GraalVM Community. See OpenJDK 11.0.14 Updates.20.3.4(2021-10-19)This is October 2021 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 20.3.x.GraalVM Community Edition 20.3.4 was updated to 11.0.13 for Java 11-based GraalVM Community. See OpenJDK 11.0.13 Updates.20.3.3(2021-07-20)GraalVM Community Edition 20.3.3 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 20.3.x.It also includes:  update to 8u302 for Java 8 based GraalVM Community, please see OpenJDK 8u302 Updates.  update to 11.0.12 for Java 11-based GraalVM Community, please see OpenJDK 11.0.12 Updates.20.3.2(2021-04-20)GraalVM Community Edition 20.3.2 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 20.3.x.It also includes:  update to 8u292 for Java 8-based GraalVM Community, please see OpenJDK 8u292 Updates  update to 11.0.11 for Java 11-based GraalVM Community, please see OpenJDK 11.0.11 Updates  Node.js runtime update to 12.22.1 which contains all security fixes mentioned in April 2021 Security Releases20.3.1.2(2021-02-11)This is a bug fix release for the GraalVM 20.3.x branch.It contains operational changes to GraalVM Updater - a tool for installing optional GraalVM language runtimes and utilities, and for updating your local GraalVM installation.  Enhanced the upgrading policies to prevent components not being upgraded when migrating from GraalVM Community to GraalVM Enterprise Edition (gu upgrade --edition ee).  Improved handling the license acceptance by gu when a user is prompted to accept “Oracle GraalVM Enterprise Edition Native Image License”.20.3.1(2021-01-19)GraalVM Community Edition 20.3.1 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community 20.3.0.It also includes the following:  Update to OpenJDK version 8u282 for Java 8-based GraalVM Community, please see please see OpenJDK 8u282 Updates.  Update to OpenJDK version 11.0.10 for Java 11-based GraalVM Community, please see OpenJDK 11.0.10 Updates.20.3.0(2020-11-17)Java  GraalVM Community Edition is based on OpenJDK version 1.8.0_272 and OpenJDK version 11.0.9.  Oracle GraalVM Enterprise Edition is based on Oracle JDK version 1.8.0_271 and Oracle JDK version 11.0.9. You canfind Oracle JDK release notes for these versions at the Oracle Technology Network website.  Improved eliminating or delaying class loading from libgraal until after itsinitialization. This improves performance on workloads with very shortiterations (in milliseconds). It also fixes problems related to VM assumptionsabout the JIT compiler not loading classes, which could lead to races andsometimes deadlocks.  Improved conditional move optimization: GraalVM Enterprise contains an optimization that uses the CPU’sconditional move (CMOV) instruction to implement certain conditionalstatements. In this release we have improved this optimization to give higherand more predictable performance for workloads sensitive to conditional moveinstructions. (Only available in GraalVM Enterprise.)  Improved heuristics in GraalVM Enterprise for loop peeling optimization for workloads where the first iterationinitializes array objects lazily. This is a common pattern in GraalVM’s Pythonruntime of Python iterators. It results in performance improvements for microPython benchmarks of up to 40%. (Only available in GraalVM Enterprise.)  Improved code generated by GraalVM Enterprise for initializing newly allocated arrays, fixing a performance issuewhere large array allocations were initialized twice. (Only available in GraalVM Enterprise.)  Improved the heuristics for the code duplication optimization in GraalVM Enterprise which gives a peak performanceimprovement of up to 17% on some LLVM workloads and a 5% increase on some Javaworkloads. (Only available in GraalVM Enterprise.)Native image  Improved container awareness: on Linux, the resource limits - processor count,memory size -  are read from cgroup V1 and V2 configurations. The processorcount can also be overridden on the command line using the option-XX:ActiveProcessorCount=.  Improved the “isolated compilation” that separates applications and theruntime compiler from each other, which improves performance by reducinginterference between them, for example, due to garbage collection.  The G1 garbage collector now also supportsnative images that use runtime-compiled code. It can be enabled at image buildtime using the option --gc=G1. G1 support is currently limited to Linux onAMD64. Windows and macOS support will be available in future releases. G1 nowalso supports performance counters (when the image is built with-H:+AllowVMInspection). (Only available in GraalVM Enterprise.)  Improved the options to enable and disable assertions which now support the fullsyntax to specify package and class names. Assertions need to be configured atimage build time, using the options -ea / -da / -esa / -dsa. Thedefinition of “system assertions” is expanded to not only include assertions inthe JDK, but also in the Native Image runtime system, for example, in the garbagecollector implementation.  Added basic debug information generation on Windows (developed in collaboration with Red Hat).  Added many small performance and memory footprint optimizations. In particular,a new implementation of type checks improves the performance ofClass.isInstance and Class.isAssignableFrom with less type data in the imageheap.  Added support for method handles that represent a call to a single methodaccessible by the Reflection API, with no transformations applied through theMethod Handles API, such as calls to MethodHandle.bindTo() orMethodHandle.asType(). To enable this feature use--report-unsupported-elements-at-runtime.  Many other bug fixes and improvements which can be found in the GitHub repository.Updates for Language and Tool Implementers  Enabled by default the elastic allocation of the compiler threads dependingon the number of available processors, in both JVM and native modes. The oldbehaviour, 1 or 2 compiler threads, can be explicitly enabled with--engine.CompilerThreads=0.  Added ThreadsActivationListener to listen to the thread enter and leave events in instruments.  Added new flags to inspect the expansion during partial evaluation:--engine.TraceMethodExpansion=truffleTier,--engine.TraceNodeExpansion=truffleTier,--engine.MethodExpansionStatistics=truffleTier and--engine.NodeExpansionStatistics=truffleTier. Language implementations areencouraged to run with these flags enabled and investigate their output forunexpected results. See Optimizing.md for details.  Added TruffleInstrument.Env.getOptions(TruffleContext) to retrieve contextspecific options for an instrument and TruffleInstrument.getContextOptions()to describe them. This is useful if an instrument wants to be configured percontext.  Added the ability to create context and context thread locals in languages and instruments. See ContextLocal and ContextThreadLocal classes for details.  Added NodeLibrary, which provides guest language information associated with aparticular Node location, the local scope mainly and TruffleLanguage.getScopeand TruffleInstrument.Env.getScope, which provides a top scope object of a guestlanguage.  Added ByteArraySupport: a helper class providing safe multi-byte primitive type accesses from byte arrays.  Added a new base class for the exceptions, see AbstractTruffleException. The original TruffleException has been deprecated. Added new interop messages for exception handling replacing the deprecated TruffleException methods.  Added new specialization utility to print detailed statistics about specialization instances and execution count. See Specialization Statistics for details on how to use it.  More details are available from the changelog.Updates for Polyglot Embedders  Added Context.interrupt(Duration) to interrupt a polyglot Context execution. The interrupt is non-destructive meaning that the polyglot Context can still be used for further execution.  Added the ability to specify a TargetMappingPrecedence of target type mappings for HostAccess configurations that influence conversion order and precedence in relation to default mappings and other target type mappings.  Added a log.file option that allows redirection of all languages, instrument or engine logging to a file. The handler configured with the Context.Builder.logHandler method has precedence over the new option.  Added experimental sandbox resource limits for languages implemented on top of the Truffle language implementation framework. (Only available in GraalVM Enterprise.)  More details are available from the changelog.JavaScript  Updated Node.js to version 12.18.4.  Fixed field/getter/setter access order in a Nashorn compatibility mode, see #343.  Fixed “Multiple applicable overloads found” error in a Nashorn compatibility mode, see #286.  Enabled low precedence lossy number, string-to-boolean, and number-to-boolean conversions in a Nashorn compatibility mode.  Fixed Java.extend to respect HostAccess.Builder.allowImplementations, see #294.  Added Java host interoperability support for mapping JavaScript objects to abstract classes (if HostAccess allows it).  Added js.foreign-object-prototype as a supported option to set JavaScript prototypes for foreign objects mimicing JavaScript types. It was renamed from js.experimental-foreign-object-prototype.  Changed ToPrimitive abstract operation to follow the specification for foreign objects. InteropLibrary.toDisplayString is not used by ToPrimitive/ToString conversions anymore.Ruby  Added handling foreign null object as falsy value (#1902).  Improve reliability of the post install hook by disabling RubyGems (#2075).  Fixed the top level exception handler to print exception cause (#2013).  Fixed handling of post arguments for super() (#2111).  Fixed constant/identifier detection in lexer for non-ASCII encodings (#2079, #2102).  Fixed parsing of --jvm as an application argument (#2108).  Added checking bounds for FFI::Pointer accesses when the size of the memory behind is known.  Implemented negative line numbers for eval (#1482).  Migrated from JLine 2 to JLine 3 for the readline standard library.  Added various warmup improvements, notably much less splitting and more operations are done inline, without a call.  Improved setting and access to the special variables $~ and $_ which has been refactored to require less splitting.  More details are available from the changelog.R  Improved compatibility with a preliminary implementation of the ALTREP framework: http://homepage.stat.uiowa.edu/~luke/talks/uiowa-2018.pdf  Exposed native function match5, which is necessary for R package fastmatch.  Added a few more smaller compatibility fixes and implemented missing APIs.  More details are available from the changelog.Python  Updated Python to version 3.8.5.  Added the experimental new HPy native API, so it is possible run piconumpy through HPy now.  The standalone graalpython version can now be installed through pyenv.  Many fixes to pass the unittests of standard library types and modules:complex, bytes, bytearray, subclassing of special descriptors, type layouts, float, generators, modules, argument passing corner cases, string literals and encodings, import and importlib, decimal, glob, the builtin module, json, math, operator, numeric tower, sys, warnings, random, f-strings, struct, itertools, super.LLVM runtime  Added support for code sharing in the GraalVM LLVM runtime. This allows the AST and compiled code of common bitcode libraries to be shared between multiple contexts within a single engine improving performance.  Updated LLVM toolchain to version 10.0.0.  Improved for va_list / varargs handling across language boundaries. Using va_start in an LLVM function that was called from a foreign language no longer forces all arguments into native memory. The resulting va_list object can be passed to code written in other languages, and accessed there using standard interop APIs.  Introduced the Handles API for storing managed pointers in native memory.  Moved polyglot.h to graalvm/llvm/polyglot.h and llvm/api/toolchain.h to graalvm/llvm/toolchain-api.h. The old header locations are deprecated, and will be removed in a future release.  Renamed libpolyglot-mock.so to libgraalvm-llvm.so. The old name is deprecated and will be removed in a future release.ToolingVisual Studio Code Extensions  Enhanced a VSCode GraalVM Extension with:          Java syntax highlighting      Java code completion      Installation wizard to download and install GraalVM Community or GraalVM Enterprise from the UI      Integrated Java debugger with all the features you would expect from a full featured IDE debugger like the Netbeans IDE      Integrated Polyglot debugger allowing to debug Javascript, Python, R, Ruby and other GraalVM languages        Implemented a VS Code Micronaut extension which:          Leverages all the great features of the Graal VS Code Extension for Java      Includes a Micronaut project wizard for creating new Micronaut applications      Includes Gradle and Maven support      Includes support to easily create a native executable from a Micronaut Gradle application using GraalVM Native Image      GraalVM Dashboard  Re-implemented GraalVM Dashboard with OracleJET.  Updated GraalVM Dashboard to accept new in Native Image dump format in BGV.",
          "url": " /release-notes/20_3/"
          },
          
          "release-notes-21-0":  {
          "title": "21.0.0.2",
          "content": "21.0.0.2(2021-02-11)This is a bug fix release for the GraalVM 21.0.x branch.It contains operational changes to GraalVM Updater - a tool for installing optional GraalVM language runtimes and utilities, and for updating your local GraalVM installation.  Enhanced the upgrading policies to prevent components not being upgraded when migrating from GraalVM Community to GraalVM Enterprise Edition (gu upgrade --edition ee).  Improved handling the license acceptance by gu when a user is prompted to accept “Oracle GraalVM Enterprise Edition Native Image License”.21.0.0(2021-01-19)JavaUpdated the underlying JDK GraalVM is built on:  GraalVM Community Edition is based on OpenJDK version 1.8.0_282 and OpenJDK version 11.0.10.  Oracle GraalVM Enterprise Edition is based on Oracle JDK version 1.8.0_281 and Oracle JDK version 11.0.10. You can find Oracle JDK release notes for these versions at Oracle Java SE Downloads.Java on Truffle  Added an experimental Java Virtual Machine implementation based on a Truffle interpreter. Read more here.Container ImagesGraalVM Community images for Docker containers changed the location and now are available from GitHub Container Registry. See the guide.Platforms SupportAs of this version, we provide GraalVM distributions for Linux on AArch64 system.All components including the GraalVM core are experimental.GraalVM Enterprise Edition is based on Oracle JDK11 for AArch64, and GraalVM Community Edition on OpenJDK 11 for AArch64 architecture accordingly.Native Image  Added serialization support for Native Image. The serialization support ensures constructors for classes are contained in a native image, so that they can be deserialized in the first place. These classes should be whitelisted in an additional specific configuration file, similar to the Reflection continuation, as some classes cannot be deserialized, including classes that might be part of the native image, but not listed in the configuration file. You can either create a configuration file manually or apply a Tracing Agent, provided with GraalVM, to help writing the configuration files.  Added method handle invocation support for Native Image (see #2761). Methods and fields accessed through method handles have to be registered in the Reflection configuration file. Also added method handles support to the Tracing agent to automatically generate the configuration for the native image build. Most use cases of method handles are supported. VarHandles that are not stored in static fields are still not supported.  Added AWT and Swing support for the Linux platform (configuration collection with the Tracing agent is necessary).  Added the experimental -H:+InlineBeforeAnalysis option to reduce the number of required configuration entries and lessen the image size.  Improved the Tracing agent: it now captures instances of Class.getClasses and Class.getDeclaredClasses.  Improved the ServiceLoaderFeature class to scan for services declared using modules.  Disallowed the instances of Random in the native image heap.  Improved GC performance (less time spent in GC).Updates for Language and Tool Implementers Using Truffle API  Fixed many issues related to multi-tier compilation. Multi-tier compilation (--engine.MultiTier) will be enabled by default in 21.1.  Added HostCompilerDirectives for directives that guide the host compilations of the Truffle interpreters:  HostCompilerDirectives.BytecodeInterpreterSwitchto denote methods that contain the instruction-dispatch switch in bytecode interpreters  HostCompilerDirectives.BytecodeInterpreterSwitchBoundary to denote methods that do not need to be inlined into the bytecode interpreter switch  Truffle DSL generated nodes are no longer limited to 64 state bits. Use these state bits responsibly.  More changes are listed in the changelog.Updates for Polyglot Embedders  Added support for explicitly selecting a host method overload using the signature in the form of comma-separated fully qualified parameter type names enclosed by parentheses (e.g., methodName(f.q.TypeName,java.lang.String,int,int[])).  Deprecated the host method selection by JNI mangled signature, replaced by the aforementioned new form. Scheduled for removal in 21.2.JavaScript  Updated Node.js to version 12.20.1.  Enabled the following ECMAScript 2021 mode/features by default:          Class fields      Promise.any      String.prototype.replaceAll      Logical Assignment Operators        Adopted a new interop exception handling and made JS exceptions extend the AbstractTruffleException class.  Exposed Graal.versionECMAScript instead of Graal.versionJS.  Implemented the relative indexing method proposal. It is available in ECMAScript 2022 mode (--js.ecmascript-version=2022).Python  Added the jarray module for compatiblity with Jython.  Improved the support for Pandas and added the initial support for the Matplotlib visualization library.  Provided fixes to avoid possible memory leaks and crashes when running NumPy in a shared engine.  Fixed an infinite continuation prompt in REPL when pasting snippets.More details can be found in the changelog.Ruby  The new IRB is quite slow when copy/paste code into it. This is due to an inefficient io/console implementation which will be addressed in the next release. A workaround is to use irb --readline, which disables some IRB features but is much faster for copy/pasting code.New features:  Updated to Ruby 2.7.2. Most Ruby 2.7 features and changes are implemented (see #2004).Bug fixes:  Fixed setting of special variables in enumerators and enumerables (issue #1484).  Fixed issue with Method#to_proc and special variable storage (issue #2156).Compatibility:  **kwargs now accept non-Symbol keys like Ruby 2.7.Performance:  Refactor and implement more performant MatchData#length (see #2147).  Refactor and implement more performant Array#sample (see #2148).  String#inspect is now more efficient.Changes:  All InteropLibrary messages are now exposed consistently as methods on Truffle::Interop (see #2139). Some methods were renamed to match the scheme described in the documentation.  More details are available from the changelog.R  Fixed AssertionError when trying to install the R validate package (issue #169).LLVM runtime  Improved the AST sharing, and support for the auxiliary engine caching. On top of the regular AST sharing that allows sharing code between multiple contexts in a single engine, this allows persisting of shared code across process boundaries.  Added support for the current major release of macOS (macOS Big Sur).Deprecations:  Added a deprecation warning for the old header files locations polyglot.h and llvm/api/toolchain.h. These header files have been already deprecated in 20.3.0, but without a warning.GraalWasm  This release included a large number of bugfixes in semantics, linking and in-module validation. GraalVM’s WebAssembly interpreter now passes almost all tests from the official specification test suite.  Exposed Polyglot bindings that are needed for the JS-to-WebAssembly Interface API.  Optimized the GraalWasm interpreter, leading to warmup and an overall 20x peak performance improvement of the interpreted execution mode.  Improved the security by using the byte-buffer-based memory instead of the off-heap memory.ToolingGraalVM UpdaterStarting from version 21.0, GraalVM Updater has become more powerful and can be used to update your GraalVM local installation to a newer version or upgrade from a Community to Enterprise Edition. Read more in Upgrade GraalVM.Visual Studio Code Extensions  Added refactoring and other productivity features.  Published GraalVM 21.0 Extension Pack for Visual Studio Code on VS Code Marketplace. Read more on the advancements and modifications here.GraalVM Dashboard  Improved the BGV format to support large amount of integer properties.VisualVM  Enabled a seamless import of settings from the previous installations of VisualVM.",
          "url": " /release-notes/21_0/"
          },
          
          "release-notes-21-1":  {
          "title": "21.1.0",
          "content": "21.1.0(2021-04-20)Java UpdatesThe OpenJDK release that GraalVM Community Edition is built on was updated to:  8u292 for Java 8 based GraalVM Community  11.0.11 for Java 11-based GraalVM Community  16.0.1 for Java 16-based GraalVM CommunityThe Oracle JDK release that GraalVM Enterprise Edition is built on was updated to:  8u291 for Java 8-based GraalVM Enterprise, please see Java SE 8 release notes  11.0.11 for Java 11-based GraalVM Enterprise, please see Java SE 11 release notes  16.0.1 for Java 16-based GraalVM Enterprise, please see Java SE 16 release notesPlatform Updates  Java 16 (experimental) support: The GraalVM distributions based on Oracle Java 16 and OpenJDK 16 are available for download.  MacOS platform support: Builds of GraalVM Community Edition for macOS based on OpenJDK 8 are no longer being produced. GraalVM Enterprise Edition for macOS  based on Oracle JDK 8 continue to be available.  Linux AArch64 platform compatibility: The GraalVM distributions for Linux AArch64 architecture remain experimental in this release. Supported features include the GraalVM compiler, the gu tool, the Node.js JavaScript runtime, Native Image, some developer tools.  Windows platform compatibility: To run GraalVM Community Edition based on OpenJDK 8u292 on a Windows platform, the MSVCR100.dll redistributable package needs to be installed (for more details, see the issue #3187).Compiler  Added support to detect inverted (tail counted) loops as counted loops. GraalVM Enterprise now detects such loops as counted, enabling them to be analyzed and optimized like all other counted loops. These loops are subject to full unrolling, partial unrolling, guard optimization and vectorization. This new capability can be disabled with -Dgraal.DetectInvertedLoopsAsCounted=false. (Only available in GraalVM Enterprise.)  Added a novel loop inversion optimization in GraalVM Enterprise. This adds compiler support to generate inverted loops from regular ones. Inverted loops have superior characteristics for instruction level parallelism and optimization capabilities compared to regular, head counted loops. We have seem performance improvements of up to 30% for micro benchmarks exercising the inverted loop shape. Loop inversion is on by default and can be disabled with -Dgraal.LoopInversion=false. (Only available in GraalVM Enterprise.)  Added a new optimization that analyzes code guarded by a conditional of the form x == y and replace all uses of x with y (or vice versa) if the replacement results in potential for further optimization. (Only available in GraalVM Enterprise.)  Enhanced SIMD vectorization, to support vector byte reversal (e.g., Integer.reverseBytes). SIMD vectorization is still experimental and not enabled by default. Enable it with -Dgraal.VectorizeSIMD=true. (Only available in GraalVM Enterprise.)  Added support for vectorizing hashCode-like loops using the hash = c * hash + array[i]. Disable with -Dgraal.VectorizeHashes=false. (Only available in GraalVM Enterprise.)  Eliminated the cast of the loaded array element to Node, to prevent the situation when volatile fields are loading from arrays, losing type information about the element, and resulting in unneeded casts. This method in ConcurrentHashMap can be an example:     static final &amp;lt;K,V&amp;gt; Node&amp;lt;K,V&amp;gt; tabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i) {      return (Node&amp;lt;K,V&amp;gt;)U.getObjectVolatile(tab, ((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE);  }    Eliminate unneeded memory barriers on sequential volatile writes on x86. There are patterns in classes such as ConcurrentHashMap where numerous volatile writes can occur in a sequence (after inlining). The GraalVM compiler now omits the memory barrier for all but the last write in the sequence, speeding up methods such as ConcurrentHashMap.transfer.Native Image  Improved support for localization. Now you can specify which locales should be included in the native executable, and which should be the default. Forexample, to switch the default locale to German and also include French and English, use -H:DefaultLocale=de -H:IncludeLocales=fr,en. All locales can be included via -H:+IncludeAllLocales.  Deprecated the --enable-all-security-services option as it is no longer necessary. Security services are now registered automatically when found in use by static analysis.  Improved support on Windows: applications now do file globbing on parameters.  Added reporting on the native image build to produce multiple artifacts. Results of the build are written to the imagename.build_artifacts.txt file.  Fixed a bug on Linux and macOS that resulted in local symbols about all methods being included in the native image, when -g is passed for debug information generation. Method symbols are not necessary for debugging because the Dwarf debugging information also contains this information. When local symbols are desired, e.g., for certain profilers, they can be included in the image using -H:-DeleteLocalSymbols (independently of the -g option).  Allowed multiple different native images in the same process, e.g., an application and a shared library. This was required for Linux platforms.  Automatically mark more classes for build-time initializaiton. This reduces the overhead of class initialization at run time.Polyglot Runtime  Enabled multi-tier compilation by default. This feature was first introduced in 20.3 as an experimental option. Truffle now uses two tiers of compilation. The first tier is optimized for compilation speed and reuses the GraalVM compiler economy configuration to perform speedy compilations with method inlining of trivial methods only. The second tier compiles with all GraalVM’s compiler optimizations enabled and is performed after the first tier compilation is completed. Our benchmark results show that this improves warmup for most languages significantly.  Added new capabilities for language implementations that require an optional dependency to the newest JVMCI version 21.1-b02 (issue JDK-8263776). In the next release, 21.2 we plan to use some of these capabilities for core runtime functionality, and therefore JVMCI 21.1-b02 will become a required dependency. This will make runtime compilation for JDK releases that do not support JVMCI 21.1-b02 unsupported. Note that all Truffle languages can still be executed on any JDK but without support for runtime compilation.   Introduced new experimental flags to set the compilation thresholds for multi-tier compilation: --engine.FirstTierCompilationThreshold sets the threshold for the first, and --engine.LastTierCompilationThreshold for the second tier. If multi-tier compilation is disabled, --engine.SingleTierCompilationThreshold=x may be used. The original option, --engine.CompilationThreshold, is now deprecated and will be removed in a future release.  Added a new experimental compilation queue implementation inspired by HotSpot. The implementation is not yet enabled by default, but can be tried out using the --engine.TraversingCompilationQueue option. The flag is expected to reduce warmup time. More changes and enhancements are planned for the next release, where it is expected to become the default implementation.  Deprecated the --engine.CompilationThreshold option. Use --engine.FirstTierCompilationThreshold and --engine.LastTierCompilationThreshold instead.Java on Truffle  Introduced many fixes and improvements to the Java Debug Wire Protocol (JDWP) support. Many edge cases have been fixed which increased the performance of Java on Truffle while debugging is enabled (up to 200x!).  Provided fixes for method redefinition: reflective access and MethodHandles now follow method changes.  Added support for signal handlers (sun.misc.Signal / jdk.internal.misc.Signal). This means shutdown hooks are now run when closing a program with Ctrl-C.  Removed the dependency on deprecated Scope API and implement newly introduced NodeLibrary instead.  Fixed guest stack traces as reported by the GraalVM embedder API (PolyglotException).  Improved support for restricting thread creation.JavaScript  Updated Node.js to version 14.16.1.  Node.js support is not enabled by default and must be installed explicitly with GraalVM Updater if needed: gu install nodejs. The JavaScript runtime continue to be included in the base GraalVM installation.  Added Iterator interoperability support. It allows JavaScript iterators to be used via the Value API (hasIterator(), getIterator(), hasIteratorNextElement(), getIteratorNextElement()), as well as iterable objects from other languages to be iterated in GraalVM’s JavaScript runtime (e.g., via for-of loops), and vice versa.  Enabled buffer interoperability support. It allows host ByteBuffers and buffers from other languages to be used with JavaScript typed arrays (e.g., new Uint8Array(foreignBuffer)) and DataView, without copying. It also enables access to ArrayBuffers via the Value API (readBuffer*, writeBuffer*).  Implemented the experimental version of the WebAssembly JavaScript Interface, which allows invoking WebAssembly programs from within JavaScript programs (available behind the --js.webassembly option).The changelog is available in the project repository.LLVM Runtime (Sulong)  The ability to build GraalVM or a native image with “native mode” completely removed (so only --llvm.managed mode works). (Only available in GraalVM Enterprise.)  Made pointers to foreign “buffer-like” objects (e.g., JS ArrayBuffer) be transparently accessed like native buffers.  Added support for loading bitcode modules with regular dlopen in addition to the Polyglot API.   Added experimental support for the Linux AArch64 platform.  Implemented a sanity check to verify that loaded bitcode files are compiled correctly for the GraalVM LLVM Runtime. In particular, this will fail when loading bitcode that is built for managed mode and used in native mode, or vice versa. This can be turned into a non-fatal warning with the --llvm.verifyBitcode=false option.The project changelog is available on GitHub.Ruby  Implemented more complete support of Ruby 2.7 (see #2004 for more details).  Multi-tier compilation is now enabled by default, which improves warmup significantly.  C extensions which link to a static library now generally work by prepending the GraalVM LLVM toolchain to PATH when installing gems.  Improved the performance of checks for recursion (#2189).  Improved random number generation performance by avoiding synchronization (#2190).  Implemented the ability to create a single call target per block by default instead of two.  Optimized some uses of class variables (#2259).  Speeded up the interpreter and reduced footprint by making several methods that need the caller frame  always inlined in their caller.  Added support for accessing local variables of the interactive Binding via language bindings: context.getBindings(&quot;ruby&quot;).putMember(&quot;my_var&quot;, 42);. See #2030.  Made signal handlers run without triggering multi-threading.  Implemented the Debug Inspector C API.  Switched to the io-console C extension for better performance and compatibility in irb.  Updated to irb 1.3.3 and reline 0.2.3 which allow pasting code in IRB reasonably fast (#2233).  Standalone builds of TruffleRuby are now based on JDK11 (they used JDK8 previously).More details are available from the TruffleRuby changelog.Python  Improved support for Java subclassing and  new Interoperability APIs for better Jython migration path. The features often requested and available with Jython, like convenient iteration over Python types from Java, implementing Java abstract classes and interfaces from Python, catching and re-throwing Java exceptions in Python code, are now provided with GraalVM’s Python runtime as well, making the migration easier.  Added the SSL support. This allows out-of-the-box installation of Python packages. Now users can run the Python pip installer to download Python packages, and their dependencies, just as they would on CPython.  Added a completely native backend for posix API. This provides better performance and more compatibility for filesystem access.  Added support for multi-threading with GIL. Multi-threading is supported in GraalVM’s Python runtime to the same extent as CPython. That is, there is only concurrency, not parallelism for most workloads.  Added support for the current HPy Python C API to run C extensions at better performance. This is an ongoing research project together with members of the PyPy project and the University of Cape Town to provide a faster API for NumPy and other popular Python C extensions.More details are available in the project changelog.R  Upgraded GraalVM’s R runtime to R 4.0.3:          Made the GraalVM R runtime mostly compatible with R 4.0.3;      Migrated to new versions of the base and recommended packages;      Implemented some of the new features of R 4.0.3 (see the changelog for a complete list).        Upgraded the CRAN snapshot, used by default by install.packages, to 2021-02-01:          Support of the new versions of some of the most popular packages on GraalVM’s R runtime is a work in progress;      Packages with known issues remain: dplyr 1.0.3, ggplot 3.3.3, knitr 1.31.      More details are available in the project changelog.WebAssembly (GraalWasm)  Substantially improved the speedup and the overall peak performance of the GraalWasm interpreter by over 10x.  Provided the basic WASI functions that allow manipulating the files and accessing the file system through the Truffle filesystem layer.   GraalWasm is now passing most of the tests in the official WebAssembly test suite.  Improved the speed of the standalone GraalWasm launcher, and the peak performance overall.  Implemented the WebAssembly-JavaScript Interface specification, which allows invoking WebAssembly programs from within JavaScript programs running on GraalVM’s JavaScript runtime.  Implemented parsing custom name sections in the .wasm files to make stack-traces more user-friendly.  Made the GraalWasm interpreter  respect the binary-validation rules.  Introduced checks for memory/table/function count limits when parsing and linking binaries, as defined in the specification.  Added checks to not get exponential compilation slowdown on some pathological code examples.ToolsVisual Studio Code Extensions  Added results visualization for unit tests.  Improved Micronaut support by adding YAML &amp;lt;&amp;gt; Java code editing features:  Added a number of refactorings.  Included Micronaut projects Docker build commands.  Improved support for Maven and Gradle multi-project builds.VisualVM  Added support for upcoming JDK 16 (#260).  Added support for the new Apple M1 processor (aarch64) (#262).  Added support for the importation of plugins from the previous release (#270).  Added a display list of enabled modules in heap dumps feature, taken from JDK 9+ created by jlink (#275).Polyglot Embedding  Added a new experimental sandbox option --sandbox.MaxHeapMemory=&amp;lt;size&amp;gt; that specifies the maximum heap memory that a guest application can retain during its run. This feature is currently only supported on HotSpot. Note that this feature is still experimental. (Only available in GraalVM Enterprise.)  Added support for byte buffer-like data structures. This release adds new methods to access buffer values like Value.hasBufferElements(). Java host interoperability was improved to handle java.nio.ByteBuffer implementations to make them work like native guest language buffers. This feature can be enabled and disabled using HostAccess.Builder.allowBufferAccess(boolean). Support for polyglot buffers in languages may vary. See the individual language changelog for more details.  Added support for iterable and iterator-like data structures. This includes new methods to detect if a polyglot value is an iterator or iterable with Value.isIterator() and Value.hasIterator(). New proxy interfaces ProxyIterator and ProxyIterable were added to mimic iterators and iterables. Java host interoperability was improved to handle java.util.Iterator and java.util.Iterable implementations to make them work like guest language values. This feature can be enabled and disabled with HostAccess.Builder.allowIteratorAccess(boolean) and HostAccess.Builder.allowIterableAccess(boolean). Guest language iterators can now also be mapped to Java iterators using Value.as(Iterator.class). The support for this feature in individual languages may vary. See the language changelog for more details.  Added support for map-like data structures (issue #143). This includes new methods for polyglot values like Value.hasHashEntries() to query if a polyglot value represents a hash map like data structure. A new interface ProxyHashMap was added to mimic such values. Java host interoperability was improved to handle java.util.Map implementations to make them look like guest language hash maps. This feature can be enabled and disabled with HostAccess.Builder.allowMapAccess(boolean). Guest language maps can now also be mapped to Java Maps using Value.as(Map.class). The support for this feature in individual languages may vary. See the language changelog for more details.  Added Context.safepoint() to cooperatively poll thread local actions of a polyglot context while a host method is executed. For example, this allows the context to check for interruption or cancellation.A detailed list of all the changes can be found in the changelog.Truffle Language and Tool Implementations  Added support for submitting thread local actions to run at guest language safepoints for language implementations (issue JDK-8263776). Please see the tutorial on how to adapt and use this feature in a language or tool implementation.  Added a new interoperability trait for buffer elements in InteropLibrary that allows better integration with native buffers.  Added a new interoperability type iterator and a new trait for iterable in InteropLibrary to improve traversal of collections between languages.  Added a new interoperability trait for hash entries in InteropLibrary to improve interoperability between guest language hash maps (issue #143).  Added TruffleInstrument.Env.calculateContextHeapSize(TruffleContext, long, AtomicBoolean) to calculate the heap size retained by a context.  Added @GenerateAOT to support preparation for AOT specializing nodes. Read the AOT tutorial to get started with Truffle and AOT compilation. We also added the --engine.CompileAOTOnCreate option to trigger AOT compilation on call target create. More changes and enhancements are planned for the next release.  Added ExactMath.truncate(float) and ExactMath.truncate(double) methods to remove the decimal part (round toward zero) of a float or of a double respectively. These methods are intrinsified.  Added several new events to ContextsListener when language context initialization was completed or failed.  Added CompilerDirectives.isExact(Object, Class) to check whether a value is of an exact type. This method should be used instead of the value != null &amp;amp;&amp;amp; value.getClass() == exactClass pattern.  Added Frame.clear(FrameSlot). This allows the compiler to reason about the liveness of local variables. Languages are recommended to use this method when applicable.  Added TruffleLanguage.Env.getLogger(String) and TruffleLanguage.Env.getLogger(Class&amp;lt;?&amp;gt;) creating a context-bound logger. The returned TruffleLogger always uses a logging handler and options from Env’s context and does not depend on being entered on any thread.  Added TruffleContext.leaveAndEnter(Node, Supplier) to wait for another thread without triggering multithreading.  The native image build now fails for the Truffle languages if a method that is known to be not suitable for partial evaluation is reachable for runtime compilation. The check can be disabled by the -H:-TruffleCheckBlackListedMethods option for the native-image builder.Removed the deprecated TruffleLanguage.Env.getTruffleFile(String), TruffleLanguage.Env.getTruffleFile(URI) methods.  Added TruffleContext.isCancelling() to check whether a Truffle context is being cancelled.  Added new features to the specializing DSL @NodeChild annotation: Added implicit and implicitCreate attributes to allow implicit creation of child nodes by the parent factory method.  Added allowUncached and uncached attributes to allow using @NodeChild with @GenerateUncached.  Profiles now can be disabled using Profile.disable() and reset using Profile.reset().  Added support for two-phase attach in the Truffle instrumentation with the new EventBinding.attach() method.A detailed list of all the changes can be found in the Truffle framework changelog.",
          "url": " /release-notes/21_1/"
          },
          
          "release-notes-21-2":  {
          "title": "21.2.0.1",
          "content": "21.2.0.1(2021-08-04)This is a hotfix release for the GraalVM 21.2.x branch.It contains some operational fixes as:  Fixed a StringBuilder optimization issue in Java 11-based GraalVM to improve special characters parsing (see #3627). (Only available in GraalVM Enterprise.)  Fixed issue with strspn used in the date C extension compiled as a macro on older glibc and then missing the __strspn_c1 symbol on newer glibc (see #2406).21.2.0(2021-07-20)  Java and Compiler Updates  Platform Updates  Native Image  Polyglot Runtime  Java on Truffle  JavaScript  WebAssembly  LLVM Runtime  Ruby  Python  R  Tools  Polyglot Embedding  Truffle Language and Tool ImplementationsJava and Compiler Updates  The OpenJDK release that GraalVM Community Edition is built on was updated to:          8u302 for Java 8 based GraalVM Community. See OpenJDK 8u302 Updates      11.0.12 for Java 11-based GraalVM Community. See OpenJDK 11.0.12 Updates      16.0.2 for Java 16-based GraalVM Community. See OpenJDK 16.0.2 Updates        The Oracle JDK release that GraalVM Enterprise Edition is built on was updated to:          8u301 for Java 8-based GraalVM Enterprise. See Java SE 8 release notes      11.0.12 for Java 11-based GraalVM Enterprise. See Java SE 11 release notes      16.0.2 for Java 16-based GraalVM Enterprise. See Java SE 16 release notes        Improved loop limit analysis for counted loops. The compiler will now detect and refine the range of an induction variable by taking the preceding conditions into account. When the loop is counted, it becomes amendable for advanced optimizations like partial unrolling, inversion, and vectorization. Read more here. (Only available in GraalVM Enterprise.)  Added a novel SIMD (Single Instruction Multiple Data) vectorization optimization for sequential code. This optimization is disabled by default until the 21.3 release. Enable it with -Dgraal.VectorizeSIMD=true. (Only available in GraalVM Enterprise.)  Added a novel Strip Mining optimization for non-counted loops. Strip mining is disabled per default. Enable it with the -Dgraal.StripMineNonCountedLoops=true option. (Only available in GraalVM Enterprise.)  The existing StringBuilderOptimizationPhase performs high level transformations on StringBuilder patterns to directly construct the final String and eliminate unnecessary intermediate Strings and StringBuilders. This release adds support for this optimization in JDK11 by adding support for the compact String representation used in the JDK. The core optimizations were improved to handle more code shapes and to constant fold more operations. (Only available in GraalVM Enterprise.)  Improved safepoint elimination in long counted loops. The compiler can now eliminate safepoints in loops that have a long induction variable (as opposed to an int) where it can statically prove that the range of the induction variable (i.e., the maximum number of iterations) is Integer.MAX_VALUE - Integer.MIN_VALUE while previously it would only consider int-typed induction variables. Read more here. (Only available in GraalVM Enterprise.)  Added an optimization that tries to move writes out of loops, called “Write Sinking.” Write Sinking is an experimental feature disabled by default. Enable it with -Dgraal.OptWriteMotion=true. (Only available in GraalVM Enterprise.)  Implemented a Speculative Guard Movement optimization that tries to move a loop invariant guard (e.g., an array bounds check) inside a loop to outside the loop. This change improves the geomean throughput score of GraalVM Community on SpecJVM2008 by 4.2%. The scores on the Renaissance, DaCapo, and ScalaDacapo benchmarks also increased by about 0.5%. Disable it with -Dgraal.SpeculativeGuardMovement=false.  Added intrinsic for Reference.refersTo and PhantomReference.refersTo just like it was done for C2.  Added support for applying counted loop optimizations to do/while loops whose first iteration is not guarded by the loop condition.  Added guard hoisting loop duplication phase which should contribute to ahead-of-time compilation flow (GraalVM Native Image). It splits certain loops into “fast” and “slow” versions. The fast loop is chosen if we know at run time that no exceptions can happen. The fast loop allows more loop optimizations and loop vectorization. Loop duplication needs the profile-guided optimizations data. Disable it with -H:-GuardHoistingLoopDuplication.  Improved the Graal compiler to allow compiling ahead-of-time methods with more than 64 loops. This resolves a problem that was preventing Native Image from compiling programs with more than 64 loops in a method body. This is a pattern often seen in generated Java code, such as that output by tools such as ANTLR.Platform Updates  Linux AArch64: GraalVM distributions for AArch64 CPU architecture are released as supported in 21.2 with more features enabled, like Ruby runtime, and Java on Truffle (Espresso).  Java 16 support: GraalVM builds based on Oracle JDK 16 or OpenJDK 16 remain experimental in this release, but have become more “mature” by overcoming some known limitations and adding support for Ruby, Python, and WebAssembly runtimes.Native Image  Released new official Gradle and Maven plugins for Native Image with initial JUnit 5 testing support. These plugins will make building, testing, and running Java applications as native executables much easier, and the native JUnit support allows JVM libraries to run their test suites via GraalVM Native Image. For more details, read the announcement blog post.  Added basic Java Flight Recorder (JFR) support on JDK 11. This feature was developed in a cooperation between Oracle and Red Hat. Native images that are built with -H:+AllowVMInspection support JFR events that are written in Java (see jdk.jfr.Event). To record JFR events at run time, JFR support and JFR recording must be enabled. Check the documentation or see the help message for -XX:+FlightRecorder and -XX:StartFlightRecording options. At the moment, JFR support is still significantly limited, i.e., most VM-internal events and also most advanced features such as stack traces or memory leak detection are still missing.  Improved resource handling: resources stored in the image can be accessed through a virtual file system.  Implemented the class pre-definition: to support ClassLoader.loadClass at run time, classes that need to be loaded at run time can be made available to the static analysis so that they are included in the closed-world analysis. This improves compatibility with libraries that rely on dynamic class loading, as long as the classes loaded or generated at run time are stable. This feature was developed in cooperation with Oracle and Alibaba.  Removed unnecessary security providers from the image: the reachable security providers are automatically detected by the static analysis. We fixed some bugs that made too many providers reachable in some cases, leading to large and non-deterministic image sizes. It is now also possible to disable the automatic detection completely using -H:-EnableSecurityServicesFeature.  Added an “epsilon” GC to build an image without any garbage collector, which is applicable for very short running applications that only allocate a small amount of memory.  The application fails when more than the maximum heap size is allocated. Enable it at image build time with --gc=epsilon.  Changed the --initialize-at-build-time option behaviour to be used only with arguments. This prevents users to write non-composable code and to avoid accidental semantic errors.Polyglot Runtime  Added a new compilation queuing heuristic enabled by default. The new heuristic improves the warmup time of the polyglot runtime on many workloads. It detects code being currently executed and prioritizes the compilation of such code. The new queue implementation also uses dynamic compilation thresholds that increase and decrease compilation thresholds depending on the load of the compilation queue. The new heuristic can be enabled or disabled using --engine.TraversingCompilationQueue=true|false. A more detailed description of the new heuristic can be found here.  VM inspection is now enabled in all launchers by default. It is no longer necessary to rebuild the language launcher image to enable inspection. The SIGQUIT signal can now be used to print thread dumps at any point during their execution. By additionally enabling the performance counters with the --vm.XX:+UsePerfData option in GraalVM Enterprise, VisualVM is able to attach and monitor language launchers that run with native-image.Java on Truffle  Introduced Truffle on Java HotSwap Plugin API which allows to reload the code without the need for restarting a running application. It is meant for framework developers to reflect changes to, e.g., annotations, framework-specific updates such as implemented services or beans. For more details, check the documentation.  Improved bytecode dispatch, yielding a 15-30% interpreter speed-up.  Added a new static object model implementation that dynamically generates host classes at run time. It is experimental at the moment.  Added fixes to prevent crashes when external threads enter Espresso and call native code.  Fixed crashes when running with older versions of GNU libc (&amp;lt;= 2.17).  Added support for additional interoperability messages for guest objects implementing Map, Map.Entry, List, Iterator, or Iterable.JavaScript  GraalVM JavaScript now prints a warning when runtime compilation is not supported. This warning can be disabled using the -engine.WarnInterpreterOnly=false option or the -Dpolyglot.engine.WarnInterpreterOnly=false system property.  Added the js.unhandled-rejections option to track unhandled promise rejections in a polyglot Context. By default, the option is set to none, and unhandled promise rejections are not tracked.  Implemented the New Set Methods proposal. It is available behind an experimental flag (--js.new-set-methods).  Implemented experimental operator overloading support. Use the experimental option --js.operator-overloading to enable it and consult the documentation.  Updated the RegExp Match Indices proposal with opt-in using the d flag. Available in ECMAScript 2022 (-js.ecmascript-version=2022). Deprecated the -js.regexp-match-indices option.The changelog is available in the project repository.WebAssembly  GraalVM’s WebAssembly now correctly detects memory-allocation failures, and throws WebAssembly errors as per specification (RangeError exception), instead of returning internal engine errors.  Fixed edge-cases in calls to functions from imported tables. In indirect calls (call_indirect instruction) GraalWasm will now correctly type-check the function type when the function is exported from a different module and set as an entry in an imported table.  Improved detection of some arithmetic errors, printing out a more specific type of the arithmetic exception. In the earlier version, handling of certain arithmetic errors caused a NullPointerException.  Performed general maintenance work and fixed bugs to pass tests for as many NPM modules that use WebAssembly as possible.LLVM Runtime  Added support for pthreads and pthread synchronization primitives in managed mode such aspthread_create, pthread_exit, pthread_join, pthread_mutex, pthread_rwlock, pthread_cond, and more. This enables a user to run multi-threaded programs. Previously, it would just fail when a user tried to run a multi-threaded software. (Only available in GraalVM Enterprise.)  Updated musl libc to version 1.2.2. (Only available in GraalVM Enterprise.)  Added support for C++ virtual calls via cross-language interoperability.  Added support for atomic versions of already existing assembly instructions. This means that the LLVM runtime now has wider support for inline assembly, especially for multi-threaded software.  Fixed GraalVM’s LLVM toolchain not working correctly for C++ on MacOS 11.3 (see #3383.The project changelog is available on GitHub.Ruby  Implemented the precise invalidation for Ruby methods and constants, by using per-name and per-class assumptions.  Updated to Ruby 2.7.3 (fixes CVE-2021-28965 and CVE-2021-28966). The resolv stdlib was not updated (resolv in 2.7.3 has bugs).  Fixed the LLVM toolchain issue on macOS 10.13 (see  #3383).  Improved the #dig method to make iteration through arrays and hashes faster and compile better for calls with 3+ arguments (see #2301).  Improved fiber-local variables by using less synchronization which made them faster.  TruffleSafepoint is now used instead of custom logic, which no longer invalidates JIT-ed code for guest safepoints (e.g., Thread#{backtrace,raise,kill}, ObjectSpace, etc.).A full list of changes is available in the changelog.Python  Implemented _pickle as a faster version than the pure Python version. Users will see better performance when serializing objects across the network. (Only available in GraalVM Enterprise.)  Improved Python performance especially during warmup and in shared engine configurations by adding fast paths, intrinsifying functions, and adding optimized representations for common data structures.  Applied the new Truffle safepoint mechanism for more efficient GIL releases, signal handlers, and weak reference callbacks.  Updated the supported HPy version to 0.0.2.  Added support for the dict type properly using the new hash interoperability messages. Now Python dictionaries can be cast to java.util.Map and behave as expected when using Python from Java.  GraalVM Python runtime now passes more compatibility tests for io, crypt, and more functions in socket, OrderedDict, and time. The code written for Python 3.8 that uses these can be expected to work better now.  Added initial support for the psutil package which enables system access and processes monitoring, and for the PyGame modules designed for writing video games.  GraalVM’s Python no longer unconditionally creates _pycache_ if the file name “sitecustomize.py” exists in the current working directory.More details can be found in the changelog.R  Continued improving the compatibility with R 4.0.3. For example, the support for rlang 0.4.10, vctrs 3.6, tibble 3.0.6, and testthat 3.0.1  packages was significantly improved.  Packages with known issues, dplyr 1.0.3, ggplot 3.3.3, and knitr 1.31, still remain.More details are available in the project changelog.ToolsVisual Studio Code  Renamed extensions for VS Code as following:          GraalVM Tools for Java      GraalVM Extension Pack for Java      GraalVM Tools for Micronaut      GraalVM Tools for Java Extension  Implemented full support of JDK16 and its language features.  Added support for developing, running, and debugging single Java class, supported from JDK8 and beyond.      Introduced a wizard to easily create a new Java project:        Introduced a new class wizard “Java: New From Template” that allows to add various Java and related files to a project:        Implemented the possibility to attach a debugger to a running process. Available via Run and Debug “Java 8+…” configuration.    Improved Java code navigation with “GoTo Type”, “Find Usages” options.  Enabled the Native Image agent to gather the configuration data in the “Run without Debugger” mode. This makes it easier to build native images from VS Code. Use a special launch configuration Launch Java 8+ Application With Native Image Agent.GraalVM Tools for Micronaut Extension  Added  “Launch Java: Continuous Mode” launch configuration also known as “Run Dev Mode” for Gradle and Maven projects:  Developed and ran Spock tests in the Groovy language. Included code completion and other editing support for Groovy.VisualVM and VS Code Integration  Added a special section to the VS Code Gr activity to control the VisualVM tool included in the active GraalVM installation. The major updates are:          Enabled to start VisualVM along with the VS Code project      Provided actions to take a thread or heap dump, and to configure and control CPU/Memory sampling and JFR recording      Enabled the Go to Source action in VisualVM views which opens the sources back in VS Code      VisualVM  Added a feature that allows to save JFR recording from live process (see #297).  Implemented a lock contentions profiling feature, by adding a Lock Contention view in the Profiler tab (see #298).  Added support for JDK 17.  Enabled controlling VisualVM instance from the command line or an external tool: start sampling (#321), control flight recording (#322), taking a thread (#319) or a heap dump (#320) of a Java process from the terminal.  Published Maven artifacts for VisualVM.Polyglot Embedding As announced in the 21.1 release notes, we have updated the required JVMCI version for Polyglot Embeddings in this release. All GraalVM JDK versions (8, 11, 16) already contain the updated JVMCI version and there is no further action required. If you are using a different JDK than GraalVM and you have configured the Graal compiler on the upgrade module path you will need one of the following JDK versions that includes JDK-8264016 for full compatibility:  Other JDK 11: Oracle JDK 11.0.13 (2021-10-19), OpenJDK is still to be determined.  Other JDK 16: No current plans to update JVMCI.  Other JDK 17: The new JVMCI version is already integrated into early access builds.If your JVMCI version is outdated, you will be able to use GraalVM embeddings, but forced context cancellation (Context.close(true)) and interrupt (Context.interrupt(Duration)) will throw an error. We recommend the following workarounds:  Do not use forced context cancellation or interrupt. All other features are still supported.  Switch to the fallback runtime by removing graal.jar from the upgrade-module-path. Note that this will significantly worsen performance and should only be a last resort.  Wait with upgrading to 21.2 until the JDK version has support for the new JVMCI version.Other changes:  Changed the behaviour of Value.as(TypeLiteral&amp;lt;Function&amp;lt;Object, Object&amp;gt;&amp;gt;).apply(): when the function is called with an Object[] argument, it is passed through as a single argument rather than an array of arguments (see #456).A full list of changes can be found here.Truffle Language and Tool Implementations  Added support for Truffle libraries to be prepared for ahead-of-time compilation without prior execution. See ExportLibrary.useForAOT or the AOT Tutorial for more details.  Implemented DebugValue methods hashCode() and equals() to provide results of the interoperability identityHashCode and isIdentical calls on the corresponding guest objects, respectively.  Added support for iterators and hash maps to DebugValue. The added methods delegate to the respective methods of InteropLibrary.  Methods annotated with @Fallback of the Truffle specialization DSL now support @Cached, @CachedContext, @CachedLanguage, @Bind and dispatched @CachedLibrary parameters.  Added TruffleContext.pause() and TruffleContext.resume(Future&amp;lt;Void&amp;gt;) to pause and resume execution for a Truffle context, respectively.  Added CompilerDirectives.blackhole(value) which can be helpful for benchmarking.  Added TruffleLanguage#Env.registerOnDispose(Closeable) registering a Closeable for automatic close on context dispose.  Added RootNode#countsTowardsStackTraceLimit(), replacing RootNode#isInternal() as the criterion that determines whether a frame with the given root node counts towards the stack trace limit.  Added MemoryFence which provides methods for fine-grained control of memory ordering (see #2031).  Deprecated ValueProfile.createEqualityProfile() without replacement. Object.equals(Object) cannot safely be used on compiled code paths. Use the Truffle Specialization DSL instead to implement caches with equality semantics. Making Object.equals(Object) reachable as runtime compiled method will mark too many equals implementations reachable for runtime compilation in a native image.  Deprecated and added methods to support expected arity ranges in ArityException instances. Note that the replacement methods now include more strict validations.  The Specialization DSL now generates code to throw an AssertionError if a @Shared and @Cached parameter returns a non-null value and is used in a guard. The null state is reserved for the uninitialized state.  Added LoopConditionProfile#create() as an alias of createCountingProfile() so it can be used like @Cached LoopConditionProfile loopProfile.A full list of changes can be found here.",
          "url": " /release-notes/21_2/"
          },
          
          "release-notes-21-3":  {
          "title": "21.3.3.1",
          "content": "21.3.3.1(2022-09-20)This is a patch release for the GraalVM 21.3.3 branch which includes the following:  Platform updates:          11.0.16.1 for Java 11-based GraalVM      17.0.4.1 for Java 17-based GraalVM        Prevent the Truffle file system sandbox from checking host files while parsing paths using alternative file system providers.  The hashCode() and equals() methods of InsightFilter are corrected and context management is fixed.  Corrected the depth in insight heap dumps: it does not apply to primitives and is applied to variables, not the frame.  Fixed the PolyglotFunction to not treat null argument as zero arguments.21.3.3(2022-07-26)This is July 2022 Critical Patch Update (CPU) for GraalVM Community Edition.It is a full distribution and supersedes the previous release of GraalVM Community Edition 21.3.x.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, and platform updates.  Updated the OpenJDK release on which GraalVM Community Edition is built to:          11.0.16 for Java 11-based GraalVM Community. See OpenJDK 11.0.16 Updates      17.0.4 for Java 17-based GraalVM Community. See OpenJDK 17 Updates      21.3.2(2022-04-26)This is April 2022 Critical Patch Update (CPU) for GraalVM Community Edition.It is a full distribution and supersedes the previous release of GraalVM Community Edition 21.3.x.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, and platform updates.  Updated the OpenJDK release on which GraalVM Community Edition is built to:          11.0.15 for Java 11-based GraalVM Community. See OpenJDK 11.0.15 Updates      17.0.3 for Java 17-based GraalVM Community. See OpenJDK 17 Updates      21.3.1(2022-01-18)This is January 2022 Critical Patch Update (CPU) for GraalVM Community Edition.It is a full distribution and supersedes the previous release of GraalVM Community Edition 21.3.x.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, and platform updates.  The OpenJDK release that GraalVM Community Edition is built on was updated to:          11.0.14 for Java 11-based GraalVM Community. See OpenJDK 11.0.14 Updates      17.0.2 for Java 17-based GraalVM Community. See OpenJDK 17 Updates        Removed support for JDK versions 12, 13, 14, 15, and 16.  Updated Node.js to version 14.18.1.21.3.0(2021-10-19)  Java and Compiler Updates  Platform Updates  Native Image  Polyglot Runtime  Java on Truffle  JavaScript  Ruby  Python  R  LLVM Runtime  WebAssembly  Tools  Polyglot Embedding  Truffle Language and Tool ImplementationsPlatform Updates  Java 17 support: The GraalVM distributions based on Oracle Java 17 and OpenJDK 17 are available for download.  As of this release and further, there will be GraalVM Community distributions based on OpenJDK 11 and 17 only (no distributions based on OpenJDK 8).      The 21.3 release line will be the last one to contain GraalVM Enterprise based on Oracle JDK 8. 22.x and further will only contain distributions based on Oracle Java 11 and 17.    The OpenJDK release that GraalVM Community Edition is built on was updated to:          11.0.13 for Java 11-based GraalVM Community. See OpenJDK 11.0.13 Updates      17.0.1 for Java 17-based GraalVM Community. See OpenJDK 17 Updates        The Oracle JDK release that GraalVM Enterprise Edition is built on was updated to:          8u311 for Java 8-based GraalVM Enterprise. See Java SE 8 release notes      11.0.13 for Java 11-based GraalVM Enterprise. See Java SE 11 release notes      17.0.1 for Java 17-based GraalVM Enterprise. See Java SE 17 release notes      Java and Compiler Updates  Improved the Strip Mining optimization for non-counted loops (only available in GraalVM Enterprise), which includes:          Enabled Strip Mining for non-counted loops by default.      Improved counted loop detection for inequality checked loops. Now more uncounted loops are converted to counted loops, becoming subject to further optimization such as vectorization and partial unrolling. This extra optimization adds to better performance. Take this loop as an example:        for (int i = start; i != end; i++){ // body}        The compiler cannot statically prove that start &amp;lt; end and so this loop may have to overflow i before it terminates.The compiler now inserts a start &amp;lt; end check before the loop.If this check fails, the compiled code will deoptimize and the next time it is compiled,the check will be omitted and the loop will be treated as uncounted.              Added a new Infeasible Path Correlation optimization to eliminate infeasible paths (only available in GraalVM Enterprise). Have a look at this snippet:    class A { ... }class B extends A { ... }if (x &amp;gt; 5) {    if (y instanceof A) {        throw Error();    }}loop {    int foo = &amp;lt;expensive computation&amp;gt;;    if (x &amp;gt; 10) {        if (y instanceof B) {            bar(foo);        }    }}    The bar(foo) call will only be executed if x &amp;gt; 10 &amp;amp;&amp;amp; y instanceof B.However, that condition implies x &amp;gt; 5 &amp;amp;&amp;amp; y instanceof A which means throw Error() will be executed.That is, the call to bar can never actually be executed.The Graal compiler now recognizes this and eliminates both the call to bar as well as the computation of foo if it is only used as an argument to bar.This optimization is enabled by default and can be disabled with -Dgraal.InfeasiblePathCorrelation=false.    Implemented support for Constant Blinding to defend against JIT spraying attacks. In a JIT spraying attack, an attacker uses the JIT compiler to inject machine instructions in executable memory by using operations with immediate values. Given an existing memory corruption vulnerability, the attacker can then redirect control flow to the injected code. (Only available in GraalVM Enterprise.)The constant blinding phase encrypts user supplied constants in the code with a randomly generated key, so that the attacker cannot rely on the immediate value being present in executable memory:    mov reg, $0xF5952Cxor reg, $0xABCDEF // reg = 0x5E58C3    Constant Blinding is an experimental feature disabled by default. Enable it with -Dgraal.BlindConstants=true.Configure with -Dgraal.MinimumBlindedConstantSize the size of constants (in bytes) above which constant blinding will be applied.    Improved the SIMD (Single Instruction Multiple Data) vectorization optimization for sequential code (only available in GraalVM Enterprise):          SIMD Vectorization and Partial Loop Unrolling can now be enabled at the same time. It is no longer necessary to specify -Dgraal.PartialUnroll=false to maximize the benefit achieved from SIMD Vectorization. This optimization is now enabled by default.      SIMD Vectorization can now create groups of operations which do not completely fill a vector register. This increases the number of acceleration opportunities SIMD Vectorization is able to realize and so improves overall throughput performance.      Improved grouping and pattern matching in SIMD Vectorization to increase the number of SIMD opportunities the optimization can find and successfully exploit.            Added a new optimization that prevents inlining from negatively impacting register allocation and code size for certain caller/callee combinations. This can improve performance because fewer values may be existing concurrently in a program. (Only available in GraalVM Enterprise.)    Added compiler intrinsics for following methods in both JVM and Native Image mode: Math.signum, Math.copySign, Reference.refersTo and PhantomReference.refersTo.The way intrinsics operate is to replace a native method with direct machine code. Thus intrinsification of the above Java methods removes the overhead of native calls, which is considerable and improves the overall performance. For example, intrinsifying Reference.refersTo and PhantomReference.refersTo fixed the performance regression reported in this GitHub issue.A full list of compiler changes in GraalVM Community Edition can be found in the compiler changelog.Native Image  Improved the Native Image configuration: configuration file entries that are necessary at image build time for Reflection, JNI, class path resources, and Dynamic Proxy objects, can now be conditional based on the reachability of a class. This allows a more precise configuration, which can reduce the size of a native image. See the documentation and find there an example for a conditional reflection configuration.  Improved gathering the reflection metadata by the native-image builder: Native Image now distinguishes between queried and invoked reflection methods. Calling Class.getDeclaredMethods (and all the other variants to look up methods and constructors) now returns all reachable methods for all classes. Previously, only methods that were explicitly registered for reflective invocation were returned. This new feature allows significant reduction of the manual reflection configuration: only methods that need to be invoked via Method.invoke, or methods that would not be seen as reachable based on reachability, need to be registered manually. This distinction between queried and invoked reflection methods reduces the filesize of a native image.      Added several new optimizations to reduce the image size as well as the image build time for large applications. This has been an ongoing effort for several releases. The following table shows the image size and image build time for Spring petclinic-jdbc, a well-known large application. The numbers are measured on a developer laptop with Linux, AMD64, JDK 11, GraalVM Enterprise, spring-native 0.10.3:                            GraalVM Version          Image Build Time          Image Size                                      GraalVM 21.1          170 sec.          138 MByte                          GraalVM 21.2          163 sec.          133 MByte                          GraalVM 21.3          133 sec.          119 MByte                      Added initial support for the Java Platform Module System: The native-image builder now accepts the module-related arguments known from the java launcher like -m, -p, and --add-opens. When such a module-related argument is used, the image generator itself is used as a module too. This is a major change in how the image generator works, and development is still ongoing to support more aspects of the module system. Please provide feedback and bug reports when you try out this new feature.  Changed the way the compiler is looked up when creating static, musl-based native images to use the musl toolchain from musl.cc. The musl toolchain greatly simplifies the creation of static native images. Using a toolchain also ensures minimum changes will be needed on users’ side to create a dynamically linked musl based image. See the documentation.  Added a new policy for the Serial GC reducing the memory footprint of applications at run time. The new policy enables survivor spaces for the young generation, a feature that has been present in the codebase for a while but was not enabled by default. In addition, a full GC no longer scans the whole image heap for root pointers, but only parts of the image heap that have been written to. The new policy is not enabled by default (this is planned for the next release) but can be enabled using -H:InitialCollectionPolicy=Adaptive. Please test the new policy and report any regressions so that they can be addressed before the next release.  Improved the precision of the static analysis: small methods are now inlined before the static analysis. This improves constant folding and reduces surprises. For example, previously code that accessed a static final field directly was optimized differently from code that accessed a static final field via an accessor method:    void foo() {   if (MyConfiguration.WINDOWS) {     // The static analysis does not see this code as reachable on non-Windows platforms.  }}static boolean isWindows() {  return MyConfiguration.WINDOWS;}void bar() {  if (isWindows()) {    // The static analysis marked this code as reachable because the method invocation prevented constant folding before the static analysis. With method inlining before static analysis enabled now, this code is no longer seen as reachable on non-Windows platforms.  }}    Arguments to the native image generator can now be passed in a separate file that is provided with the @argument option. This is a necessary workaround for platforms like Windows where the length of the command line is limited.  Root certificates can now be configured at image run time. Previously, the root certificates present at image build time were the only root certificates available at run time. See the documentation for details, and to find a list of system properties that are now read at run time to configure the root certificates.  Crash dumps, which are printed when segfault or fatal VM errors happen, now include more details to aid diagnostics. Also, the beginning of the image heap is now protected memory so that null pointer accesses produce a segfault instead of accessing random memory. Internal VM errors, where an illegal virtual method table entry is accessed, produce a better crash dump.  On Linux, the processor count reported at run time now takes limitations set via cpuset into account.  Improved Dwarf debug info generation now includes information about inlined methods (contributed by Red Hat).  JDK Flight Recorder (JFR) support is now also available for JDK 17 based GraalVM (contributed by Red Hat).Polyglot Runtime  Improved stability and performance of the experimental engine caching feature. See the documentation for more details. (Only available in GraalVM Enterprise.)  Improved builtin CPU sampler tool usability with all polyglot languages (see --cpusampler option).          Increased precision of the sampling output by using the new guest language safepoint mechanism. The sampling output now shows inlined methods in addition to compilation units by default.      Simplified the default sampling histogram output and added the --cpusampler.ShowTiers option to show time spent in each optimization tier.              Added the SVG flamegraph output format to the CPUSampler. To enable it, use option --cpusampler.OutputFormat=flamegraph.                    Java on Truffle  Added Java 17 guest and host support.  Enabled support using interop buffer-like object as byte[] in Java on Truffle. See “buffer elements” in the Interop API javadoc.  Added support for buffer interop messages to the explicit Interop API.  The Polyglot API is not enabled by default anymore. When needed, contexts should be created with the java.Polyglot option set to true.  The HotSwap API is not auto-enabled by debugging anymore. When needed, contexts should be created with the java.HotSwapAPI option set to true.  Added optimization to avoid illegal reflective access warnings with the host Java 11 or higher.The project changelog is available on GitHub.JavaScript  Updated Node.js to version 14.17.6.  Implemented the Error Cause proposal. It is available behind the experimental option --js.error-cause.  Implemented the Import Assertions proposal. It is available behind the experimental option --js.import-assertions.  Implemented Object.hasOwn (Accessible Object.hasOwnProperty proposal). It is available in ECMAScript 2022 (--js.ecmascript-version=2022).  Implemented support for class static initialization blocks and private fields in in. Available in ECMAScript 2022 (--js.ecmascript-version=2022).  Added an experimental polyglot Context option --js.esm-eval-returns-exports (disabled by default). When enabled, eval() of an ES module will return a polyglot Value containing the exports.  Added several WebAssembly completeness and performance fixes, including the JavaScript BigInt to WebAssembly i64 integration proposal.The changelog is available in the project repository.Ruby  TRegex is now used by default, which provides large speedups for matching regular expressions.  Fully integrated support for foreign objects traits (arrays, hashes, iterables, etc.) in polyglot mode, which now behave like their Ruby counterpart.  Added support for transparent inner contexts as used in the ExecJS gem.  Updated to Ruby 2.7.4 to fix CVE-2021-31810, CVE-2021-32066 and CVE-2021-31799.A full list of changes is available in the changelog.Python  Removed PYPY_VERSION from our C extension emulation layer. This means we no longer pretend to be PyPy for C extensions and can avoid PyPy specific hacks, which enables the PyGame package to work out of the box.  Intrinsified and optimized more of the core language for better startup and reduced footprint.  Implemented a binary compatible backend for HPy 0.0.3, which allows HPy packages to run unmodified on CPython and GraalVM Python. This is part of an ongoing effort to make more packages available to users without them having to compile them for GraalPython specifically.  Added support for the multiprocessing module via in-process nested contexts. This allows execution on multiple cores within the same process using the common Python facilities for multiprocessing.  Added support for the ctypes module, enabling more native extensions to run that use the ctypes API.  Fixed multiple REPL issues reported on Github. Users can now properly paste blocks of code and use the numpad in the REPL.  Made our marshal format compatible with CPython, so objects can now be exchanged between CPython and GraalVM Python processes.  Made most socket module tests pass in native mode, allowing usage of all POSIX socket APIs where before only those supported with Java facilities could be used. This includes, for example, Unix domain sockets and the message APIs for sockets.  Added various compatibility fixes to make the psutil package work.The project changelog is available on GitHub.R  Upgraded from PCRE to PCRE2 version 10.37. Some Unicode patterns and texts are still not supported. See GNU-R changelog (section MIGRATION TO PCRE2) for more details on potentially user visible differences between PCRE and PCRE2.  Added some usability improvements and bug fixes:          Fixed implicit make rule parameters used when building R extensions.      Fixed unexpected garbage collection of CHARSXP objects in R extensions. FastR did not materialize its internal representation of character vectors to GNU-R compatible CHARSXP objects, which caused unexpected collection of CHARSXP objects returned by STRING_ELT.      The option to ignore the user’s profile at startup, --no-init-file, works as expected now.      Fixed functions approx and approxfun from the stats package to prevent them failing with error message “Incorrect number of arguments”.      The project changelog is available on GitHub.LLVM Runtime  Updated the LLVM toolchain for compiling C/C++ to version 12.0.1.  Improved modularization of the codebase around “managed mode” and “native mode” code. This reduces static build dependencies between these two modes, at the same time making the managed mode codebase more robust by removing all unmanaged memory accesses.The project changelog is available on GitHub.WebAssembly  Improved internal implementation of GraalVM WebAssembly to make JS-WebAssembly Interface API more compliant.  Added support for importing and exporting mutable globals to GraalVM WebAssembly, as defined by the Import/Export mutable globals proposal.  Moved the module-validation checks to the earlier stage, so that a module is completely validated during parsing, instead of being validated during linking and instantiation. All validation errors are now properly reported when Context#eval from the Polyglot API is invoked, and similarly when invoking WebAssembly.validate from the JS-WebAssembly Interface API.  Added notifications to JavaScript when the memory grows (i.e., when mem_grow instruction executes). This improves the compliance of the JS-WebAssembly Interface API.  Changed the Interop objects in GraalVM WebAssembly to allow object-caching in the JS-WebAssembly Interface.  Added support for BigInt-to-i64 conversion in the JS-WebAssembly Interface API.A full list of changes can be found in the changelog.ToolsVisual Studio CodeAdded a number of refractorings to the GraalVM Extension Pack for Java. These are:  Convert to static import  Extract interface or method  Extract local variable  Assign to variable  Generate hashCode and equals  Generate toString()  Change method signature  Rename  Pull member up  Move class  for cycle, while() cycle, try-catch, switch()statement refactoringsGraalVM Tools for Java Extension      Native Image debugging in VS Code, enabled with GraalVM Tools for Java extension, was significantly improved. Now you can attach the debugger to Native Image processes and step over the image “real” code:    Implemented the ability to add GraalVM installed by a host OS utility like yum. Then components must be managed from a terminal by the same utility.      Enabled utilizing VS Code Native Test Explorer API and UI extensions.        Enabled setting conditional breakpoints:    Groovy language features are now available for Java projects which contain some Groovy files or Spock tests. For example, CodeCompletion is working, Spock tests can be debugged and run. The execution of standalone Groovy scripts is not supported.GraalVM Tools for Micronaut ExtensionAdded support for Kubernetes: now you can deploy, run and debug Micronaut applications in a Kubernetes cluster directly from VS Code.      Enabled “Create Kubernetes Deployment Resource”, “Run in Kubernetes” and “Deploy in Kubernetes” quick actions for Micronaut support:        Enabled selecting what Docker image will be used when creating a Kubernetes deployment:        Enabled selecting a secret for a Docker registry:  When you invoke the “Micronaut: Deploy to Kubernetes” action, your Java project is packaged, Docker image is built and pushed to the container registry. Deployment is created in the Kubernetes Cluster and local port is forwarded to an application running in a Pod.Polyglot Embedding  Added the ability to share values between contexts. Please see Context.Builder.allowValueSharing(boolean) for further details. The update addressed this GitHub issue.  Improved the Polyglot API by adding support for scoped values in guest-to-host callbacks. Scoped values are automatically released when the callback returns. They can be configured in HostAccess.A full list of changes can be found in the changelog.Truffle Language and Tool Implementations  Added new Static Object Model APIs to represent the layout of objects that, once defined, do not change the number and the type of their properties. It is particularly well suited for, but not limited to, the implementation of the object model of static programming languages. For more information, read the Javadoc and the tutorial.  Added BytecodeOSRNode interface to support on-stack replacement (OSR) for bytecode interpreters. OSR can improve start-up performance by switching from interpreted code to compiled code in the middle of execution. It is especially effective for targets with long-running loops, which can get “stuck” running in the interpreter without OSR. Refer to the Javadoc and the OSR guide for more details.  Language and context references can now be stored in static final fields. See the javadoc for the new intended usage. All thread local lookups have an efficient implementation on HotSpot and SubstrateVM, interpreted and compiled, eliminating the need to ever cache the value in the AST.  Added FrameInstance#getCompilationTier and FrameInstancel#isCompilationRoot  Added TruffleContext.evalPublic(Node, Source) and TruffleContext.evalInternal(Node, Source) that allow the evaluation of sources in an inner context and access values of the inner context safely.  Added --engine.TraceDeoptimizeFrame to trace frame deoptimizations due to FrameInstance#getFrame(READ_WRITE|MATERIALIZE).  Added TruffleContext.evalPublic(Node, Source) and TruffleContext.evalInternal(Node, Source) that allow to evaluate sources in an inner context and access values of the inner context safely.  Added TruffleContext.Builder.initializeCreatorContext(boolean) that allows users to disable initialization of the language that created the inner context.  Added ExecuteTracingSupport interface that allows tracing the calls to execute methods of a Node.A full list of changes can be found in the changelog.",
          "url": " /release-notes/21_3/"
          },
          
          "release-notes-22-0":  {
          "title": "22.0.0",
          "content": "22.0.0(2021-01-18)  Platform Updates  Java and Compiler Updates  Native Image  JavaScript  Ruby  Python  R  LLVM Runtime  WebAssembly  Java on Truffle  Polyglot Embedding  Truffle Language and Tool Implementations  ToolsPlatform Updates  Dropped support for Java 8. As of this release and later, GraalVM Enterprise distributions will be based on JDK 11 and 17 only.      Removed support for JDK versions 12, 13, 14, 15, and 16.    The OpenJDK release that GraalVM Community Edition is built on was updated to:          11.0.14 for Java 11-based GraalVM Community. See OpenJDK 11.0.14 Updates      17.0.2 for Java 17-based GraalVM Community. See OpenJDK 17 Updates        The Oracle JDK release that GraalVM Enterprise Edition is built on was updated to:          11.0.14 for Java 11-based GraalVM Enterprise. See Java SE 11 release notes      17.0.2 for Java 17 based GraalVM Enterprise. See Java SE 17 release notes      Java and Compiler Updates  Added a new loop rotation optimization that converts more non-counted loops to counted loops (only available in GraalVM Enterprise). A counted loop is an abstraction the compiler uses to ensure a loop’s iteration limit is a bound integer. When the loop is counted, it becomes amenable for partial unrolling, vectorization, and other optimizations to improve performance. For example, the following code for LinkedList.toArray() in JDK 17:    public Object[] toArray() {  Object[] result = new Object[size];  int i = 0;  for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next)    result[i++] = x.item;  return result;}    will be optimized by the compiler to:    public Object[] toArray() {  Object[] result = new Object[size];  int i = 0;  Node&amp;lt;E&amp;gt; x = first;  if (x == null) return result;             // Loop condition 1  while (true) {    if (i |&amp;gt;=| result.length) deoptimize(); // Loop condition 2    result[i++] = x.item;    x = x.next;    if (x == null) break;                   // Loop condition 1  }  return result;}    For a microbenchmark centered on LinkedList.toArray(), loop rotation brings a gain in performance of just over 10%.For workloads containing a lot of non-counted loops with a similar shape, performance improvements of up to 30% have been measured.Loop rotation is disabled by default in 22.0 and can be enabled with -Dgraal.LoopRotation=true.    Improved the Graal compiler treatment of execution profiles. (Only available in GraalVM Enterprise.)Graal was designed as an aggressive JIT compiler that heavily relies on profiles (see here and here) collected by the underlying runtime (HotSpot VM or Native Image).The profiles are used by the compiler to determine which branches are important, how often loops are executed, and which types are used in polymorphic code.That is, the compiler relies on profiles to determine where to focus optimization effort.As such, the quality of the profiles is critical to optimizations such as inlining, duplication, and vectorization.The compiler now automatically switches to an “AOT” (ahead-of-time) mode where major optimizations can still do a reasonable job in the absence of profiles.This helps in the following situations:          Truffle languages that do not profile uncommon patterns that still can become hot.      Native Image without PGO.        We observe performance improvements for GraalVM Enterprise of up to 25% for loop and type-check heavy benchmarks that lacked good profiles.This optimization is always enabled and cannot be disabled as it is at the core of the compiler.It is transparent to the user and should provide general better code in absence of precise branch and loop profiles.        Added a new optimization to improve the performance in Native Image of a type switch (i.e., a series of cascading instanceof branches). For example:      void foo(Object o) {    if (o instanceof A) {      // ...    } else if (o instanceof B) {      // ...    } else if (o instanceof C) {      // ...    }  }    With the new optimization, the null check and load of o’s class are factored out:      void foo(Object o) {    if (o != null) {      Object nonNullO = o;      Class oClass = nonNullO.getClass();      if (A.class.isAssignableFrom(oClass)) {        // ...      } else if (B.class.isAssignableFrom(oClass) {        // ...      } else if (C.class.isAssignableFrom(oClass)) {        // ...      }    }  }    This optimization only pays off if there are subclasses of A, B, and C that Native Image sees as allocated. Otherwise, the instanceof tests are reduced to == comparisons on the class of o.  A full list of compiler changes in GraalVM Community Edition can be found in the compiler changelog.Native Image  Added updates to reduce image size: a more compressed encoding for stack frame metadata reduces image size for all images. In addition, an optimized implementation of String.format() makes localization classes unreachable for small images such as “Hello World” and reduces their size significantly. Note: The String.format optimization is available with GraalVM Enterprise only.  GraalVM 22.0 will be the final release in which the native-image builder can be executed with JDK 8. There is no need to explicitly check for and allow JDK versions 12, 13, 14, 15, 16 because they are no longer supported. It is recommended to use Native Image with GraalVM JDK 11 or JDK 17.  Introduced a new user-friendly build output for native-image with progress bars and more summary information about a native image build process. The previous output can be restored with -H:-BuildOutputUseNewStyle.  Enabled a new garbage collection policy for the Serial Garbage Collector (Serial GC) by default. This reduces the time spent in GC and/or the RSS size of the application up to 30%. The Serial GC algorithm is a good choice for small heaps.  Improved support for the Java Platform Module System: the options --add-reads and --add-modules are now supported by native-image. Also, all module-related options such as --add-reads, --add-exports, and --add-opens are now applied before scanning the classpath/module-path. This ensures the modules are properly configured before class loading to prevent class loading errors. More information about modules is added to the image heap, which allows more module introspection at run time.  Added support for reflective introspection of sealed classes on JDK 17: Class.isSealed() and Class.getPermittedSubclasses().  Removed support for JLine 2. Substitutions for JLine 2 were historically included in Native Image. Since JLine 2 is no longer maintained, the support was removed without replacement.  Removed the option -H:SubstitutionFiles=... to register substitutions via a JSON file.  Updated the C to Java interoperability: custom prolog, epilogue, and exception handling methods for @CEntryPoint entry points from C to Java must be annotated with @Uninterruptible. They were always treated as uninterruptible, but now they must be marked explicitly.  Improved the Native Image API: added CEntryPoint#include attribute which can be used to control if the entry point should be automatically added to a shared library. The Native Image API is now also supported on the Windows AARCH64 platform.JavaScript  Enabled ECMAScript 2022 mode/features by default.  Updated Node.js to version 14.18.1.  Implemented several proposals: Intl.DisplayNames v2, Intl Locale Info, Intl.DateTimeFormat.prototype.formatRange, Extend TimeZoneName Option, Intl Enumeration API.  Added a new option js.esm-bare-specifier-relative-lookup, defaulting to false, to customize how bare specifiers for ES Modules are resolved. When disabled, bare specifiers are resolved with an absolute path lookup. When enabled, bare specifiers are resolved relative to the importing module’s path.A full list of changes is available in the changelog.Ruby  Updated to Ruby 3.0.2, see #2453. Most of Ruby 3 changes are implemented in this release, with the exception of Ractor, parser changes, and keyword arguments changes.  TruffleRuby now requires Java 11 or later and no longer supports Java 8.  Updated Regexp objects to be interned in a similar way to symbols. As a consequence, all Regexp instances are frozen.  Added various optimizations to make the interpreter faster (before the code is JIT-compiled).A full list of changes is available in the changelog.Python  Added support for pyexpat module, which is a Python module for fast non-validating XML parsing, also known as expat.  Implemented the _csv accelerator module to read and write tabular data in CSV format.  Improved compatibility with PyPI packages such as wheel, click, and ujson.The project changelog is available on GitHub.R  Improved the internal infrastructure, compatibility with the Truffle framework, and popular R packages.  Adopted the new NodeLibrary, as a replacement for the old API that was removed in this release. It provides access to guest language information associated with a particular Node location. This helps GraalVM tool developers to better support the R language.The project changelog is available on GitHub.LLVM Runtime  Switched to the new Truffle Frame API.  Optimized the loop count to report profiles also in first-tier compiled code. This improves the warmup by transitioning from first-tier to second-tier compilation sooner for loop-heavy methods.  Added a fix to properly reuse library dependencies if some library with the same “soname” is already loaded. This allows users to depend on libraries that can not be found automatically on the library search path by manually loading them first.The project changelog is available on GitHub.WebAssembly  Improved the compatibility of GraalVM’s WebAssembly runtime with the Truffle framework by adopting the new Frame API.  Implemented the Sign-Extension-Ops proposal. It is available by using the experimental option --wasm.SignExtensionOps.Java on Truffle  Improved compatibility with the Truffle framework by adopting the new Frame API.  Added support for more class changes during a class redefinition, namely changes to fields and class access modifiers. Enable with the --java.ArbitraryChangesSupport=true flag.Polyglot Embedding  Introduced the first version of Polyglot Isolates. You can spawn a native image isolate for each Engine or Context by calling Context.Builder.option(&quot;engine.SpawnIsolate&quot;, &quot;true&quot;). This enables heap isolation between the host and guest applications. Using isolates improves security, startup and warmup time of Truffle languages, and provides strong memory isolation for guest applications. In this mode, calls between host and guest are more costly as they need to cross a native boundary. It is recommended to use the HostAccess.SCOPED policy with this mode to avoid strong cyclic references between host and guest. This mode is experimental in this release and only supported for JavaScript. (Only available in GraalVM Enterprise.)The project changelog is available on GitHub.Truffle Language and Tool Implementations  Added new APIs to com.oracle.truffle.api.frame.Frame and com.oracle.truffle.api.frame.FrameDescriptor:          Added a new “namespace” of index-based slots in Frame that is defined during construction of the frame descriptor and cannot be changed afterward.      Added a second new “namespace” of slots (called auxiliary slots) in Frame that can be added to the frame descriptor dynamically (and which only supports “object” slots).      In addition to get.../set... methods, the new API also supports copy and swap of frame slots.      FrameSlotTypeException is now an unchecked exception, which simplifies many APIs and removes the need for the FrameUtil class.        Introduced sharing layers. A sharing layer is a set of language instances that share code within one or more polyglot contexts. In previous releases language instances were shared individually whenever a new language context was created. Instead, language instances are now reused for a new context if and only if the entire layer can be shared. A layer can be shared if all of its initialized languages support the same context policy and their options are compatible. Note some changes in observable language behavior:          For any executed Truffle node it can now be assumed that the current language instance will remain constant.      TruffleLanguage.initializeMultipleContexts() is now guaranteed to be called before all created contexts of the same language instance.      Language initialization will now fail if a new language context is initialized and the language is incompatible to the sharing layer of the current context.      A complete list of behavioral changes can be found in the changelog. Read more on code sharing in the javadoc.        Introduced a Truffle Exit API to support exit across multiple languages. It provides a unified way for languages to trigger the exit. When triggered, all initialized guest languages are first notified using TruffleLanguage.exitContext(C,ExitMode,int), then all context threads are stopped, and finally, the context is closed. See the documentation for more details.  Imposed a new requirement in TruffleLanguage.finalizeContext(Object) for leaving all remaining unclosed inner contexts created by the language on all threads where the contexts are still active. No active inner context is allowed after TruffleLanguage.finalizeContext(Object) returns. Not complying with this requirement will result in an internal error. Note that inactive inner contexts are still closed implicitly by the parent context.  Improved the output format for engine.TraceCompilation and engine.TraceCompilationDetails. See the documentation for details.  Added the --engine.TraceCodeSharing option that allows logging debug information on code sharing.  Added the --engine.ForceCodeSharing and --engine.DisableCodeSharing options to force enable and force disable code sharing. These options are useful for testing to enable or disable sharing across all contexts of a process.A full list of updates can be found in the changelog.ToolsVS Code Extensions      Added the Project Explorer which provides an overview of logical project structure, groups sources together and greatly simplifies Java package structure exploration. Project Explorer is an addition to the classical workspace explorer. Use it to build, test, execute and operate your Maven and Gradle Java projects:            Introduced a number of refactorings and improvements to GraalVM extensions for VS Code, which include:                  Provided a graphical UI for the change method signature refactoring:                            Ability to organize Imports for the source file accompanied with several other settings:                            Ability to generate equals() and hashCode() methods              Added the Outline View that provides all details about the opened Java file      Added the ability to run separate NetBeans Language Server for each VS Code instance using its own classpath and JDK. Use a new option userdir = global | local:        Added the ability to manage GraalVM installation(s) with SDKMan  Improved the Groovy language support by performance and reliability improvements, and ability to run a standalone Groovy script file (without Spock tests)  Updated the Micronaut Gradle plugin to use the official GraalVM Native Image build plugin. As a consequence, the Micronaut: Build Native Image… action calles the nativeCompile job instead of nativeImage.VisualVM      Added exact thread state monitoring using JFR events. See #363.            Added preliminary support for JDK 18.  ",
          "url": " /release-notes/22_0/"
          },
          
          "release-notes-22-1":  {
          "title": "22.1.0",
          "content": "22.1.0(2022-04-26)  Platform Updates  Java and Compiler Updates  Native Image  JavaScript  Ruby  Python  R  LLVM Runtime  Java on Truffle  Polyglot Embedding  Truffle Language and Tool Implementations  ToolsPlatform Updates      Added support for Apple Silicon, an ARM-based system on a chip by Apple Inc. You can download the GraalVM Community distribution for this platform from GitHub. Look for darwin-aarch64. Currently, you can use the JVM with libgraal, Native Image, the JavaScript runtime, and Java on Truffle features with this distribution. The support is experimental.        Updated the OpenJDK release on which GraalVM Community Edition is built to:          11.0.15 for Java 11-based GraalVM Community. See OpenJDK 11.0.15 Updates      17.0.3 for Java 17-based GraalVM Community. See OpenJDK 17 Updates      Java and Compiler Updates  A counted loop is an abstraction the compiler uses to ensure a loop’s iteration limit is a bound integer.Such loops are subject to major optimizations such as vectorization and partial unrolling.The Truffle API provides the ability to profile and speculate on a loop counter value having a max value that can be treated as constant by the compiler. The Graal compiler now respects this speculation and will unroll such loops if the max value is small enough. For example, this Ruby loop will now be unrolled:      [1, 2].each { |e| print e }    Implemented all the intrinsics annotated by @IntrinsicCandidate as of JDK 17.  Removed the DuplicateIrreducibleLoops option. To disable irreducible loop handling, set -Dgraal.MaxDuplicationFactor to a value less than or equal to 1. For ahead-of-time (AOT) compilations, the effort spent to handle irreducible loops is boosted to let Native Image support more programs with irreducible loops. In particular, this mitigates this issue.Native Image  The option --allow-incomplete-classpath is now enabled by default and deprecated as it is no longer needed. This means that, by default, linking errors are now thrown at executable run time instead of at build time. The new option --link-at-build-time enables linking at build time for a specified list of packages and classes. You can provide as many --link-at-build-time options with specific arguments on command line as you want, for example, native-image --link-at-build-time=foo.bar,foobar.core.MyClass --link-at-build-time=my.other.RandomClass ....  See #4305.  Added a new “quick build” mode to reduce the time taken to generate a native executable during development. Enable it using the existing option to select the optimization level: -Ob, where b means optimize for build time. Note that this mode can have a negative impact on peak performance and the size of the resulting executable, thus recommended for development purposes only.  Added a new experimental mode to generate conditional configuration using the Tracing agent. The agent can now generate conditional reflection configuration using a heuristic that operates on the call graph, that is, those reflection elements that are only registered when a predicate class is reachable. Two modes are supported:          By passing experimental-conditional-config-filter-file=&amp;lt;path&amp;gt; to the agent. In this mode, the agent directly generates the configuration. The filter tells the agent which code belongs to the user’s application. Conditions are only generated on the classes belonging to the user’s application.      By passing experimental-conditional-config-part to the agent and using native-image-configure generate-conditional --user-code-filter=&amp;lt;path&amp;gt; --input-dir=&amp;lt;agent-ouput&amp;gt; --output-dir=&amp;lt;config-output&amp;gt; to generate the configuration. Check the Native Image documentation for more information.            Introduced code size improvements that help reduce the size of native executables. Performance improvements and memory footprint reductions for the native-image generator lead to faster build times (independent of the new “quick build” mode). The following table shows the image size and time taken to build an executable for Spring petclinic-jdbc, a well-known large application. The numbers are measured on a developer machine with Linux, AMD64, JDK 11, GraalVM Enterprise, spring-native 0.10.3.                            GraalVM Version          Build Time          Executable Size          Build Time with -Ob                                      GraalVM 21.1          2 min 50 sec          138 MB                                     GraalVM 21.2          2 min 43 sec          133 MB                                     GraalVM 21.3          2 min 13 sec          121 MB                                     GraalVM 22.0          2 min 20 sec          119 MB                                     GraalVM 22.1          2 min 5 sec          103 MB          1 min 17 sec                      Added support for Apple Silicon, an ARM-based system on a chip. One of the missing features was, for example, support for Truffle just-in-time compilation.  Improved the ahead-of-time compilation of Record classes. For example, annotations of Record classes can now be accessed at executable runtime.  Added support for the following JFR events: SafepointBegin, SafepointEnd, GarbageCollection, GCPhasePause, and GCPhasePauseLevel (all contributed by Red Hat). All GC-related JFR events are currently limited to the Serial GC.  JFR can now be used to profile the native-image tool itself, for example, by adding -J-XX:StartFlightRecording=dumponexit=true on the command line to native-image.  Improved handling of static synchronized methods: the lock is no longer stored in the secondary monitor map, but instead in the mutable DynamicHubCompanion object. With this change, the synchronization of static methods is as fast as the synchronization of instance methods.  Added support for AccessControlContext that helps to control the context that can be modified using privileged operations.  References handling is now performed in a separate thread by default. It helps prevent occasional deadlocks when handling references and running garbage collection in the same thread.  Added the possibility to include helper methods in the native executable that can be invoked from gdb and therefore help debugging native executables. Provide the option -H:+IncludeDebugHelperMethods to native-image to enable this feature.  Deprecated the JDK8OrEarlier and JDK11OrLater classes because JDK 8 is no longer supported. They will be removed in a future release.  Every annotated element (classes, methods, fields, etc.) will be included in the image regardless of reachability. It may require some configuration changes, especially for dynamically-generated proxies. For example, using the following code:      @AccessedAnnotation  @NonAccessedAnnotation  class Example {  boolean func(Object obj) {      Proxy.getProxyClass(classLoader, Example.class.getDeclaredAnnotations());      obj.isAnnotationPresent(AccessedAnnotation.class);      }  }    Previously, you would only specify the [AccessedAnnotation] configuration. Now the proxy configuration would look like [AccessedAnnotation], [NonAccessedAnnotation].    Prevented class path entries in META-INF/MANIFEST.MF being processed in the wrong order. See #4374  Now using -H:CompilerBackend=llvm also works if the native-image builder runs on the module-path (when building with the --module-path flag). See #4336.  Improved building native executables inside a container if a resource path contains a forward slash, /, as a working directory. See #4002.JavaScript  Updated Node.js to version 16.14.2.  Implemented a number of proposals:          The Intl.NumberFormat v3 proposal.      The Array Grouping proposal. It is available in the ECMAScript staging mode using the --js.ecmascript-version=staging option.      The Temporal proposal. It is available behind the experimental option --js.temporal.      The Array Find from Last proposal. It is available in ECMAScript staging mode using the --js.ecmascript-version=staging option.        Added a new option --js.string-lazy-substrings, defaulting to true, to toggle the copying behavior of String slices. When enabled, String slices internally create String views instead of copying the given String region, which increases performance but may also increase memory utilization.A full list of changes is in the changelog.Ruby  Implemented full Ruby 3 keyword arguments semantics (see #2453).  Foreign exceptions are now fully integrated, have most methods of Exception, and can be rescued with rescue Polyglot::ForeignException or rescue foreign_meta_object (see #2544).  Foreign exceptions are no longer translated to RuntimeError but instead remain as foreign exceptions.  Added various fixes for the digest default gem, RubyGems, and Bundler (#2577, #2605, #2586).  Fixed Module#const_get to raise a NameError when nested modules do not exist, needed for Rails 7 scaffolding.  Removed extra array allocations for method calls in the interpreter to improve warmup performance.  Reduced memory footprint for C extensions (separate Init_ allocations from the rest, fewer handles, and others).  Optimized Dir[], String#&amp;lt;=&amp;gt;, Regexp#match? and File.read (see #2536).A full list of changes is available in the changelog.Python  Added support for module freezing which makes the Python REPL start 30% faster and with 40% less memory usage.  Added support for more private key formats (PKCS#1, password protected) in the ssl module.  Improved compatibility with the following PyPI packages: lxml, pytz, Pillow, urllib3, setuptools, pytest, twine, jinja2, and six.A full list of changes is in the changelog on GitHub.R  JavaGD is now the default graphical subsystem. The --R.UseInternalGridGraphics option is deprecated. Most functions from graphics grid, and grDevices base packages are supported. Supported devices are SVG, PNG, JPEG, BMP, AWT. Display lists are fully implemented. See the documentation for more information.  GraalVM’s R runtime now uses system zlib instead of its own copy of this library. This makes zlib a requirement for GraalVM’s R runtime, however, most Linux distributions and all supported macOS versions have zlib preinstalled. One conceivable situation, where this may not be the case, could be some optimized stripped-down Docker images.The project changelog is available on GitHub.LLVM Runtime  Added support for C/C++ thread-local storage.  Added support for new interop APIs:          Date, Time, TimeZone and Instant (see graalvm/llvm/polyglot-time.h)      Buffers (see graalvm/llvm/polyglot-buffer.h)        Replaced custom logging options in the --llvm.* namespace (e.g., --llvm.traceIR) with Truffle Logger options (--log.llvm.*, for example, --log.llvm.TraceIR.level=FINER).See a full list of changes and option replacements in the project changelog on GitHub.Java on Truffle  Enabled explicit reference processing in single-threaded mode. This means the single-threaded mode is usable in many more situations to prevent leaking resources. It is available as a command called &amp;lt;ProcessReferences&amp;gt;, which can be run with context.eval(&quot;java&quot;, &quot;&amp;lt;ProcessReferences&amp;gt;&quot;).  Introduced new hotswap capabilities:          Added support for changing the super class and implemented interfaces.      Added support for ‘Move Field in Hierarchy’ refactoring where the state is preserved.      Turned on by default changing fields and class access modifiers.        Enabled responding to Truffle safepoints more promptly in many situations (including when using monitors).  Adopted the AbstractTruffleException API to improve exception handling thrown during the execution of a guest language program.  Added a new implementation for reading jimages (libs/modules), which is enabled by default. This improves context startup time when using the LLVM backend. Use --java.JImage=native to revert to the old implementation.  The Java on Truffle LLVM Java libraries are now provided for macOS (previously they were available for Linux distributions only) and can be installed using GraalVM Updater: gu install espresso-llvm.Polyglot Embedding  Changed the default Object target type mapping (Value.as(Object.class)) for values that have both array elements and members from Map to List. Note that this is an incompatible change. Embedders relying on the dynamic type Map after an Object target type coercion will have to migrate their code. The previous behavior can be restored using a custom target type mapping, for example:      HostAccess access = HostAccess.newBuilder(HostAccess.EXPLICIT)          .targetTypeMapping(Value.class, Object.class, v -&amp;gt; v.hasMembers() &amp;amp;&amp;amp; v.hasArrayElements(), v -&amp;gt; v.as(Map.class))          .build();  try (Context c = Context.newBuilder().hostAccess(access).build()) {      // run application  }  The changelog is available on GitHub.Truffle Language and Tool Implementations  Added an API for Truffle languages, namely Language#getWebsite(), and Instrument#getWebsite() for instruments to provide information for a website. Developers can specify a URL for a website with further information about their language/tool.  Added the TruffleStrings implementation, a primitive String type that can be shared between Truffle languages (languages implemented with the Truffle framework). Check Truffle Strings guide for more information.  Added a @GeneratePackagePrivate annotation to change the visibility of generated nodes to package-private even if the template node is public.  Added TruffleLanguage.Env#createHostAdapter accepting host symbols and host classes as the types to extend, replacing and deprecating the java.lang.Class-based version.  Added the usageSyntax property to Option enabling developers to specify the syntax that their option expects. See the Javadoc for more information.  Removed the deprecated TruffleException (deprecated since GraalVM 20.3.0). The AbstractTruffleException no longer implements TruffleException. The AbstractTruffleException methods inherited from the TruffleException have been removed. As part of this removal, the recommendation for languages on how to handle exceptions has been updated.  Added methods to TruffleContext.Builder that allow throwing custom guest exceptions when the newly built context is canceled, hard-exited, or closed, and the corresponding exception is about to reach the outer context. In case the customization is not used and the new context is canceled, hard-exited, or closed, Truffle newly throws an internal error.  Deprecated TruffleRuntime.getCurrentFrame() and TruffleRuntime.getCallerFrame(). They were encouraging unsafe use of the FrameInstance  class.Other deprecations and updates in the release are listed in the project changelog.ToolsGraalVM for Java VS Code Extension      Updated the workflow to download and install GraalVM Enterprise Edition and its accompanying components using the GraalVM built-in installation wizard in VS Code. As before, to install a GraalVM Enterprise core or additional components, a user has to provide a valid email address and accept the license agreement. The installation wizard will now use a download token that is bound to the user’s email address and defines the set of accepted licenses. Email verification and license acceptance take place via the user’s email client.        Added the NATIVE IMAGE pane to automate the process of tracking and registering dynamic feature calls, making it even easier to build a native executable in VS Code. The pane becomes available when you install GraalVM and with Native Image:            Improved the VS Code integration in VisualVM with the extension. Now you do not have to create a special launch configuration to open VisualVM and start monitoring a Java process. Click the play button in the VISUALVM pane:            Improved Groovy support including the ability to Run and Debug Groovy.  GraalVM Updater  Enhanced the workflow to install components to GraalVM Enterprise Edition from the command line using GraalVM Updater, gu. GraalVM Updater will create and use a download token, which is bound to the user’s email address and defines the set of accepted licenses. As before, to install a component, the user has to provide a valid email address and accept the license agreement, but now the email verification and the license acceptance will happen in the user’s email client. For more information, see the documentation.",
          "url": " /release-notes/22_1/"
          },
          
          "release-notes-22-2":  {
          "title": "22.2.0",
          "content": "22.2.0(2022-07-26)  Platform Updates  Java and Compiler Updates  Native Image  Polyglot Runtime  JavaScript  Ruby  Python  R  LLVM Runtime  Java on Truffle  WebAssembly  Polyglot Embedding  Truffle Language and Tool Implementations  ToolsPlatform Updates  Improved GraalVM packaging experience by reducing the size of the base binary almost ~2x. JavaScript, LLVM runtimes, and VisualVM are now decoupled from the main package and released as separate installable components. The package size of, for example, the GraalVM Community Linux distribution dropped from ~430 MB to ~250 MB. This makes GraalVM more modular offering the same RPM-like experience when you add support for only what you need.  The Native Image component size has increased because necessary runtime components (Substrate VM) and static libraries (used by Substrate VM) are now part of the Native Image installable.  Improved Apple Silicon support:          Released GraalVM Enterprise distribution for Apple Silicon (AArch64 architecture). The support is experimental.      Extended the supported GraalVM functionalities in the existing GraalVM Community distribution for Apple Silicon. You can now optionally install Native Image, the LLVM toolchain, Java on Truffle, and language runtimes for JavaScript, Ruby, WebAssembly.            GraalVM will no longer run on some older Linux AMD64 distributions. It is now built against glibc 2.17 (instead of 2.12), and as a result it may not run on Oracle Linux 6 or other RHEL 6 derivatives.    Updated the OpenJDK release on which GraalVM Community Edition is built to:          11.0.16 for Java 11-based GraalVM Community. See OpenJDK 11.0.16 Updates      17.0.4 for Java 17-based GraalVM Community. See OpenJDK 17 Updates        Updated the Oracle JDK release on which GraalVM Enterprise Edition is built to:          11.0.16 for Java 11-based GraalVM Enterprise. See Java SE 11 release notes      17.0.4 for Java 17-based GraalVM Enterprise. See Java SE 17 release notes      Java and Compiler Updates      Improved the RSS memory usage by the JIT compiler (Graal) in GraalVM Community Edition. The memory used by libgraal is now reclaimed when compilation goes idle. It reduces RSS usage of JIT in a stable state (few or no compilations happening). To measure RSS memory usage of a Java process, you can run ps aux --sort -rss. See JDK-8242440.        Enhanced the Novel Strip Mining optimization for counted loops. The optimization can be enabled with this option: -Dgraal.StripMineCountedLoops=true. Strip Mining optimization converts a single long running loop into a nested loop where the inner body runs for a bounded time. It allows you to put a safepoint in the outer loop to reduce the overhead of safepoint polling. By choosing the right value for the outer loop stride, you still ensure reasonable time-to-safepoint latency. The latter is particularly important for low pause time collectors such as ZGC and Shenandoah. For example, this loop:      int checksum = 0;          for (int i = Integer.MIN_VALUE; i &amp;lt; Integer.MAX_VALUE; i++) {              checksum += i;              // safepoint_poll          }    would become:      int checksum = 0;  for (int i = Integer.MIN_VALUE; i &amp;lt; Integer.MAX_VALUE - 1000; i += 1000) {      for (int j = i; j &amp;lt; i + 1000; j++) {          checksum += j;      }      // safepoint_poll  }  for (int i = Integer.MAX_VALUE - 1000; i &amp;lt; Integer.MAX_VALUE; i++) {      checksum += i;      // safepoint_poll  }    This optimization adds to Truffle guest language safepoints latency. For example, Novel Strip Mining optimization eliminates HotSpot safepoints from a counted loop that does allocation (the HotSpot allocation slow path has a safepoint). However, this allocation related safepoint will not trigger a Truffle safepoint. As such, the Truffle safepoint latency can be very long. In this case, Novel Strip Mining optimization can decompose such a loop into strips and issue a Truffle safepoint poll once per strip.        Enabled floating and global value numbering of division nodes early on in the compilation pipeline if it is known they will not trap. This means division-by-constant operations can be commoned and moved out of loops if the constant divisor proves that they cannot throw div-by-zero exceptions. See #3866.        Introduced a global value numbering optimization for fixed nodes early in the compilation pipeline. Disabled by default, but can be enabled with  -Dgraal.EarlyGVN=true. This optimization improve workloads that require complex partial escape analysis and unrolling optimizations in order to optimize away constant loops with complex object allocations. This optimization can also speed up Native Image build time (by reducing graph sizes earlier in the compilation pipeline) as well as speeding up the generated native executables themselves by folding more memory operations.  Native Image  Enhanced the compatibility of GraalVM Native Image with the 3rd party libraries. The Oracle GraalVM team in conjunction with the Spring, Micronaut, and Quarkus teams have created a GitHub repository, GraalVM Reachability Metadata Repository, a centralized place that provides configuration (reachability metadata) for libraries which do not support GraalVM Native Image by default. The support needs to be enabled explicitly. For example, in Gradle you can enable this repository with:      graalvmNative {      metadataRepository {          enabled = true      }  }    The GraalVM Reachability Metadata Repository enables users to share and reuse reachability metadata for the most popular libraries in the Java ecosystem. Check the documentation for more information.        The native-image generator now runs on the module path by default. This is part of a longer-term effort to support module-based applications using a clean module-based generator. The module system prevents direct access to internals of the native-image generator by default. Applications and frameworks can still provide command-line arguments to open up the internals again using the usual module system command line options. For now, the old mode of running the native-image generator can be enabled by setting the environment variable USE_NATIVE_IMAGE_JAVA_PLATFORM_MODULE_SYSTEM=false (but note that this mode will be deleted without replacement in a future release).        Improved many internal data structures of the native-image generator to reduce the memory footprint. This makes Native Image builds more robust when running on memory-constraint environments like cloud-based build services, GitHub Actions, or in Docker containers. Many larger application now build successfully with 2 GByte of Java heap size available for the native-image generator.        Added support for Software Bill of Materials (SBOM). The native-image generator can optionally include a SBOM into a native executable to aid vulnerability scanners. Currently, the CycloneDX format is supported. Users may embed a CycloneDX SBOM into a native executable by using the -H:IncludeSBOM=cyclonedx option during compilation. After embedding the compressed SBOM into the executable, you can use the Native Image Inspect tool to extract the compressed SBOM with this command: $JAVA_HOME/bin/native-image-inspect --sbom &amp;lt;path_to_binary&amp;gt;. Check the documentation for more details. GraalVM Enterprise only        Added a new optimization for String concatenation operations (including StringBuilder operations): it eliminates temporary memory buffers during concatenation. GraalVM Enterprise only        Heap dumps at image run time are now supported in GraalVM Community Edition. Also, a new runtime option, -XX:+DumpHeapAndExit, has been introduced to dump the initial image heap of a native executable. Check the documentation how to dump the initial heap of a native executable.        Improved debugging support on Linux: The Dwarf information now contains information about parameters and local variables (contributed by Red Hat).        Certain Native Image options can now only be provided on the command-line and no longer in native-image.properties files. These options also get processed before other options so that they properly pre-configure all other options coming from both the command line and native-image.properties files. The affected options are --exclude-config, --configurations-path, --debug-attach, --diagnostics-mode, as well as all the options to print help messages.        Added a new runtime option -XX:+ExitOnOutOfMemoryError that  aborts the execution of a native executable on the first out-of-memory error.        Added support for most methods of OperatingSystemMXBean at image run time.    Annotation classes are no longer force-initialized at image build time. Like any other class, annotation classes can now be initialized either at build time or at run time using the according command-line options (--initialize-at-build-time or --initialize-at-run-time) or the Feature API. This fixes problems with transitive dependencies of annotations, including non-annotation classes that are used by annotations. See Class Initialization in Native Image.Polyglot Runtime  Introduced updates that improve interpreter-only performance for 20-30% and warmup for GraalVM supported languages.  Added support in libgraal for caching encoded graphs across Truffle compilations to speedup partial evaluation. The cache is enabled by default and can be enabled/disabled with the --engine.EncodedGraphCache option. This update contribute to faster compilation time improvements on HotSpot.  Implemented a new domain specific inlining phase for the Truffle interpreter host compilation, which improves the interpreter performance for GraalVM Native Image. See the Host Compilation for Interpreter Java code reference manual for details.A full list of updates can be found in the changelog.JavaScript  JavaScript support is now decoupled from the base GraalVM installation and can be easily added with this command: gu install js.  Improved JavaScript interoperability with Java: now foreign objects get a JavaScript prototype assigned by default, unless explicitly turned off. This feature was available behind the experimental option js.foreign-object-prototype before and now made default. Previously, if you use any foreign object like a Java array in JavaScript code, you could access it by using the index operator []. The array did however lack the Array.prototype, and thus methods like indexOf or sort could not be easily called on it. With this change, foreign objects get a fitting JavaScript prototype assigned and can be “manipulated” with regular JavaScript functions. This adds more flexibility for regular Java or GraalVM Polyglot API users.  Extended the implementation of the Temporal specification in GraalVM JavaScript, which provides standard objects and functions for working with dates and times. Changes from the specification are adopted continuously. Temporal objects can now be converted to compatible Java objects when appropriate, using the Value API’s methods like asDate(). The opposite direction, providing Java Temporal objects and using them with JavaScript Temporal methods is planned for a future release.See the project changelog.Ruby  Added support for AArch64 distribution for macOS (Apple Silicon).  Added support for OpenSSL 3.0.0 by updating the openssl gem.  Updated to Ruby 3.0.3. The 3 CVEs did not affect TruffleRuby, this is to bring the stdlib and gem update.  Implemented several changes that improve Ruby performance on GraalVM:          Reimplemented Float#to_s for better performance.      Updated reference processing by making C object free functions and other finalizers more lightweight.      Improved performance of RSTRING_PTR for interned strings.      Enabled caching constant argument formats used with rb_scan_args_kw.        Improved compatibility with CRuby 3.2: -Werror=implicit-function-declaration is now used for compiling C extensions to fail more clearly and earlier if a function is missing.A full list of changes is available in the changelog.Python  Updated to HPy version 0.0.4, which adds support for the finished HPy port of Kiwi, and the in-progress ports of Matplotlib and NumPy.  Added an experimental bytecode interpreter for faster startup and better interpreter performance. Using either the previous AST interpreter or the new bytecode interpreter can be switched using the --python.EnableBytecodeInterpreter option.The project changelog is available on GitHub.R  Implemented SET_GROWABLE_BIT and IS_GROWABLE C API functions. This fixes installation of the cpp11 0.2.6 package.  Added akima package to the list of “native packages”, so it is by default loaded by the native backend.The project changelog is available on GitHub.LLVM Runtime  The LLVM runtime is now decoupled from the base GraalVM installation and can be easily added with this command: gu install llvm.  Updated LLVM toolchain to version 14.0.3.  Added support for AArch64 distribution for macOS (Apple Silicon).  Improved support for POSIX Threads, pthreads, managed execution mode. In mode does not allow to call native code and access native memory.Java on Truffle  Added support for AArch64 distribution for macOS (Apple Silicon).  Improved class redefinition: added support appending enum constants. This makes HotSwap capabilites more powerful while changing classes at runtime during a debugging session. See the Enhanced HotSwap Capabilities with Java on Truffle guide.  Enable the new Class Hierarchy Analysis by default. It provides information about class hierarchy in the guest code, evolving as new classes are loaded.WebAssembly  This release is marked by significant performance improvements in GraalVM WebAssembly implementation based on our benchmarks:          Internal AST memory footprint improvements 3.18x      Peak performance improvements 1.24xs      Polyglot Embedding  Added the ability to spawn a native-image isolate for each Engine or Context in a native launcher or library. This feature was previously supported only for the JVM deployment. GraalVM Enterprise only  Added Value.hasMetaParents() and Value.getMetaParents() methods that allow lookup of the hierarchy of parents for meta objects (for example, a super class or implemented interface of Java classes).  Added HostAccess.Builder.allowAccessInheritance to inherit access to methods that have been explicitly exported in an interface or superclass versus only explicitly vetted method implementations (for example, via @HostAccess.Export).  Added List#add support for polyglot values that are mapped to java.util.List.A full list of changes is available in the changelog.Truffle Language and Tool Implementations  Added new static APIs to com.oracle.truffle.api.frame.Frame:          Implemented a new static option to FrameSlotKind for index-based slots. Frame slots using this kind cannot be changed to another kind later on. Static frame slots can simultaneously hold one primitive and one object value. Static frame slots are intended for situations where the type of a variable in frame slots is known ahead of time and does not need any type checks (for example, in statically typed languages).      Static frame slots are intended for situations where the type of a variable in a frame slots is known ahead-of-time and does not need any type checks (for example, in statically typed languages).        The Static Object Model offers preliminary support for field-based storage also for GraalVM Native Image.  Truffle IGV dumping with log level 5 (-Dgraal.Dump=Truffle:5) now dumps the graph after each method that was fully partially evaluated. This enables debugging of problems only visible during partial evaluation.A full list of updates can be found in the changelog.Tools  Improved building native images on Windows with our GraalVM for Java VS Code Extension. Now, .gradlew nativeBuild on Windows 10 runs inside x64 Native Tools Command Prompt.  GraalVM Updater can now produce JSON output for the available, list, and info commands, which makes it easier for other tools such as the GraalVM for Java VS Code Extension to programmatically use it.",
          "url": " /release-notes/22_2/"
          },
          
          "release-notes-22-3":  {
          "title": "22.3.3",
          "content": "22.3.3(2023-07-25)This is the July 2023 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM features bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition 22.3.2.  Updated the OpenJDK release on which GraalVM Community Edition is built to:          17.0.8+7 for Java 17-based GraalVM. See OpenJDK 17 Updates.      11.0.20+8 for Java 11-based GraalVM. See OpenJDK 11 Updates.        Graal compiler: Updated counted strip mining optimization to do not strip mine overflowing loops.  Native Image: Fixed reachability handlers.  Native Image: Fixed generic array signature registration.  Truffle framework: Fixed default time zone to always be passed with polyglot isolates.22.3.2(2023-04-25)This is the April 2023 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, and platform updates.It is a full distribution and supersedes the previous release of GraalVM Community Edition 22.3.1.NOTE: JDK 19 is not supported in GraalVM Community Edition 22.3.2. With the release of Java 20, JDK 19.0.2 (included in GraalVM 22.3.2) is below the security baseline and may contain unpatched vulnerabilities. Therefore, it should not be used. If you wish to continue using GraalVM 22.3.x, you should move to JDK 17. This may require application code changes.  Updated the OpenJDK release on which GraalVM Community Edition is built to:          17.0.7 for Java 17-based GraalVM. See OpenJDK 17 Updates.      11.0.19 for Java 11-based GraalVM. See OpenJDK 11 Updates.        Updated Node.js to version 16.19.1.22.3.1(2022-01-24)This is the January 2023 Critical Patch Update (CPU) for GraalVM Community Edition.It is a full distribution and supersedes the previous release of GraalVM Community Edition 22.3.0.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, and platform updates.  Updated the OpenJDK release on which GraalVM Community Edition is built to:          11.0.18 for Java 11-based GraalVM. See OpenJDK 11 Updates.      17.0.6 for Java 17-based GraalVM. See OpenJDK 17 Updates.      19.0.2 for Java 19-based GraalVM. See OpenJDK 19 Updates.        Updated Node.js to version 16.18.1.22.3.0(2022-10-25)  Platform Updates  Java and Compiler Updates  Native Image  Polyglot Runtime  JavaScript and Node.js  Python  Ruby  R  LLVM Runtime  Java on Truffle  WebAssembly  Polyglot Embedding  Truffle Language and Tool ImplementationsPlatform UpdatesThe 22.3.0 release is the final Feature release in the annual release train and will be supported for the next 12 months with bug and vulnerability fixes. GraalVM Community releases from the 21.x branch are end-of-life. See the Version Roadmap for the release schedule and the new GraalVM Community Roadmap for upcoming features.  Released experimental JDK 19 GraalVM builds including the Graal compiler, Native Image, and all GraalVM languages and tools except Espresso (Java on Truffle). These builds enable users to take advantage of the latest JDK 18 and JDK 19 features such as Virtual Threads, the Simple Web Server, Structured Concurrency, and more. Support for JDK 19 will be available in a future release. See #4957 and #5063.  Reduced the GraalVM Native Image installable file size by around 80MB: the LLVM backend is now shipped as a separate native-image-llvm-backend component (no longer shipped by default with native-image).      Released the LLVM runtime for GraalVM Community Edition for Windows under experimental support.    Updated the OpenJDK release on which GraalVM Community Edition is built to:          11.0.17 for Java 11-based GraalVM Community. See OpenJDK 11.0.16 Updates      17.0.5 for Java 17-based GraalVM Community. See OpenJDK 17 Updates      19.0.1 for Java 19-based GraalVM Community. See OpenJDK 19 Updates        Updated the Oracle JDK release on which GraalVM Enterprise Edition is built to:          11.0.17 for Java 11-based GraalVM Enterprise. See Java SE 11 Release Notes      17.0.5 for Java 17-based GraalVM Enterprise. See Java SE 17 Release Notes      19.0.1 for Java  19-based GraalVM Community. See Java SE 19 Release Notes      Java and Compiler Updates  Added support for JDK 18 and JDK 19 features such as Virtual Threads, the Simple Web Server, Structured Concurrency, and more in the GraalVM based on JDK 19 builds.  Improved JIT compilation isolation by using one isolate per the libgraal compiler thread. This avoids all GC interference between the compiler threads which reduces GC pauses during compilation. This translates to improved compilation speed in general. On the DaCapo benchmarks, compilation as measured in bytecodes-per-second at least doubled, with individual benchmarks such as fop and pmd showing a 3x speed up. To enable the old mode, add -XX:JVMCINativeLibraryThreadFraction=0.66 -XX:JVMCIThreadsPerNativeLibraryRuntime=0 to the command line.  Added a dedicated Native Image GC policy for libgraal that will adjust the Eden space aggressively to minimize RSS memory usage.  Improved jlink behavior so that it produces images which use the Graal compiler (libgraal) as the top-tier compiler. A jlink-ed image produced from GraalVM uses JVMCI by default, and java -version output is GraalVM-branded.  Enabled StripMineCountedLoops and EarlyGVN compiler optimizations by default. These were first introduced in the 22.2 release with the -Dgraal.StripMineCountedLoops=true and -Dgraal.EarlyGVN=true options.  Implemented loop vectorization for integer min/max operations. This implementation handles all integer sizes, hand-written min/max patterns (for example, x &amp;gt; y ? x : y, not just Math.min/Math.max), unsigned min/max, and fold-shaped loops (for example, computing the minimum or maximum element of an array).  Removed the deprecated JMX HotSpotGraalRuntime management bean from both libgraal and jargraal.Native Image  Added support for JDK 19 and OpenJDK Project Loom Virtual Threads (JEP 425): virtual threads for high-throughput lightweight concurrency are supported with both the Serial GC and the G1 GC. Since virtual threads are a preview feature in JDK 19, they are also a preview feature for GraalVM Native Image. They can be enabled with the new option --enable-preview. Virtual threads are not available on GraalVM based on JDK 11 and JDK 17, and they are not available yet for native executables that contain a Truffle language (JavaScript, Python, etc.). See #4920 for more details.  Identified and added missing parts in the Native Image API: functionality where applications and frameworks reached into internals of the native-image generator. It includes a new public API for programmatic registration of JNI, Resource, Proxy, and Serialization classes from Feature interface classes, and moving annotations for method substitutions to the Graal SDK. Even though these annotations are not supported APIs, for practical reasons they can now be used without depending on the native-image generator. For this release, the native-image internals are still published to Maven Central, but this will be stopped in a future release. We therefore encourage all users to only rely on the Graal SDK starting with this release, and if this is not possible, report further missing API on GitHub.  Update the G1 GC version that is available in Native Image to JDK 19. This G1 version is also used for native executables based on JDK 11 and JDK 17. In addition, the G1 GC can now be used with native executables that are statically linked with the musl C library.  Added RuntimeResourceAccess#addResource(Module module, String resourcePath, byte[] resource) API method that enables resources to be injected into native executables.Debugging and monitoring experience improvements:  Improved the debugging experience to identify memory usage and memory leaks (contributed by Red Hat). For example, perf report is able to associate code addresses sampled during a perf record session with Java methods and print the DWARF-derived method name for the method in its output histogram. Read more about special considerations for using perf and valgrind in the documentation.  Added the --enable-monitoring=&amp;lt;all,heapdump,jfr,jvmstat&amp;gt; option to enable fine-grained control over monitoring features included in native executables. The old option -H:±AllowVMInspection should no longer be used. The new option is part of the supported API.  Added initial support for jvmstat to GraalVM Community Edition. Previously, this was available in GraalVM Enterprise Edition only.  Added support for the JFR events JavaMonitorEnter, JavaMonitorWait, and ThreadSleep (contributed by Red Hat).  Add the option --enable-sbom to the supported API. The old non-API option -H:IncludeSBOM should no longer be used.Build output enhancements:  Introduced the experimental -H:BuildOutputJSONFile=&amp;lt;file.json&amp;gt; option to export build output information in JSON format. In addition, the old build output style and the -H:±BuildOutputUseNewStyle option are removed.  Added the --silent option to silence the build output.GraalVM Native Image ecosystem updates:  Spring Boot 3.0.0-M5 comes with improved AOT processing and GraalVM Native Image support.  JUnit framework 5.9.1 introduced the @EnabledInNativeImage and @DisabledInNativeImage annotations to enable users to include/exclude testing GraalVM native executables.  Micronaut added a new Test Resources feature with support for GraalVM Native Image.  IntelliJ IDEA 2022.2 has added experimental support for debugging GraalVM Native Image executables.Known Issues with JDK 19 SupportNote that the java.io.Console API does not work properly on JDK 19: The information whether or not a Console is available is wrongly computed at build time. This means that, for example, when building a native executable on a CI system without a terminal, the executable will not have a Console available even when running inside a terminal. This also affects the Truffle language launchers that are shipped with GraalVM.The project changelog is available on GitHub.Polyglot Runtime  Introduced the SnippetRun#getException() method that provides an IllegalArgumentException thrown during snippet execution. IllegalArgumentException is converted to a PolyglotException before it is returned.A full list of updates can be found in the changelog.JavaScript and Node.js  Implemented the WebAssembly multi-value proposal to add support for returning multiple values to WebAssembly.  Updated Node.js to version 16.16.0.  Enabled ECMA-402 Internationalization API by default. It can be disabled using the --js.intl-402=false option.  Added an experimental option --js.unhandled-rejections=handler that enables using a custom callback to track unhandled promise rejections.  Implemented the Decorators (stage 3) proposal.The project changelog is available on GitHub.Python  Renamed the entire project from GraalPython to GraalPy, and the launcher from graalpython to graalpy. This change also updates GraalVM’s launchers to include symlinks from python and python3 to graalpy for better integration with other tools.Performance improvements:  Switched to the new bytecode interpreter by default. This change brings better startup performance and memory footprint while retaining good JIT-compiled performance. For example, the development time actions such as pip install &amp;lt;package&amp;gt; or running import &amp;lt;package&amp;gt; in the REPL are now 20-25% faster and use around 25% less memory on average.Compatibility improvements:  Switched to a new parser generated from CPython’s new PEG grammar definition. It brings better compatibility and enables us to implement the ast module.  Added support for Tracing API (sys.settrace), which makes pdb and related tools work on GraalPy.  Added support for Profiling API (sys.setprofile), which makes the profile package work.  Updated pip to automatically choose the best version for known packages. You can use pip install pandas, and pip will select the versions of pandas and numpy that is tested in the GraalPy continuous integration.  Added support for Flask.  Implemented PEP 405 for full support of virtual environments. This fixes issues with the virtualenv package and tox that are used in PyCharm or in many projects’ continuous integration (CI) jobs.A full list of updates can be found in the changelog.RubyNew features:  Foreign strings now have all methods of Ruby String. They are treated as #frozen? UTF-8 Ruby Strings.  Added the Java.add_to_classpath method to add JAR paths at runtime. It enables users to modify the JVM classpath when running in the JVM mode (--jvm). For example, a Ruby gem, managed via Bundler, loads a Java library can update the classpath itself. See #2693 for more details.  Added support for Ruby 3.1’s Hash shorthand and punning syntax, and anonymous block forwarding syntax.  Added the following keyword arguments to Polyglot::InnerContext.new: languages, language_options, inherit_all_access, code_sharing.Performance-related improvements:  Improved interpreter performance by optimizing for better host inlining.  Used poll instead of select for simple IO waiting to reduce overheads (#1584).  Improved interoperability with Java: no more conversion between Java Strings and Ruby Strings at the interop boundary.Compatibility updates:  Added support for #dup and #clone on foreign strings.  Implemented rb_ivar_foreach to iterate over instance and class variables like in CRuby. See #2701 for more details.Changes:  Removed Truffle::Interop.{import_without_conversion,export_without_conversion}. Use Polyglot.{import,export} instead.  Removed Truffle::Interop.members_without_conversion. Use Truffle::Interop.members instead.A full list of changes is available in the changelog.R  Implemented the global native variable API to improve R graphics isolation when using multiple R contexts. Users can now use a native package from two R contexts at the same time. The API consists of several upcalls, named with the FASTR_GlobalVar prefix, for example, FASTR_GlobalVarAlloc. Currently, only grid and graphics built-in packages are refactored to use the global native variable API.  Added partial support for dplyr 1.0.3 to enable users to work with data frames such as objects, both in memory and out of memory. The SET_PRCODE, SET_PRENV, and SET_PRVALUE upcalls are now implemented.The project changelog is available on GitHub.LLVM Runtime  Updated LLVM toolchain to version 14.0.6.  Released the LLVM runtime for GraalVM Community Edition for Windows under experimental support.  Improved support for the x86 extended precision for floating-point numbers. It is now possible to call native functions (for example, libc) with long double arguments on the x86 architecture. The long double variants of math.h functions now use full precision. Previously they were implemented using double arithmetic.Java on Truffle (Espresso)  Added the polyglot automatic interface type mapping for 1:1 mappings between a host and an embedded guest context.  Improved interoperability: when an Espresso-to-Espresso conversion was seen, then an Espresso-to-primitive conversion happens. The latter would fail.  Methods from Espresso objects can now be read to obtain a new interop executable object, isExecutable.  Fixed exit status on uncaught exceptions in the main thread.  Added the addPath invokable member to Espresso bindings (polyglot.getBindings(&quot;espresso&quot;), the entry point where class loading happens) if java.UseBindingsLoader=true. It enables adding a new path to the classloader associated with the bindings. It was a necessary addition to better control the behavior of Espresso when going through the Truffle TCK.The project changelog is available on GitHub.WebAssembly  Implemented the Multi-Value proposal. It can be disabled with the option --wasm.MultiValue=false.  Enabled the Sign-Extension-Ops and Saturating-Float-To-Int conversions by default.The project changelog is available on GitHub.Polyglot Embedding  Implemented the FieldValueTransformer API as a more generic mechanism to intercept and constant fold field values (replaces the existing RecomputeFieldValue for the kind Custom). It allows modifying the value of a particular field if it is marked as a transformer with BeforeAnalysisAccess#registerFieldValueTransformer. A transformer must be registered before the field is seen reachable by the static analysis, and only one transformer per field. At build time, the field value transformer provides the value of the field for the image heap. Without a transformer, the value of the field in the image heap is the same as the hosted. This API is necessary for compatibility with Spring.  Added Context.Builder.allowInnerContextOptions(boolean) which enables the context to spawn inner contexts and modify and override language options. Inner contexts no longer share code with the initial context. The default value for this privilege is determined according to whether Context.Builder.allowAllPrivilages(boolean) is set or not. Do not enable this privilege in security-sensitive scenarios.  Moved Native Image strictly-internal annotation classes from com.oracle.svm.core.annotate to (@Alias, @TargetClass, @Substitute, etc.) to org.graalvm.sdk module.A full list of changes is available in the changelog.Truffle Language and Tool Implementations  Tuned the host inlining heuristic for reduced code size. A new host inlining tuning guide is available in the documentation.  Added new capabilities to TruffleContext, for example, TruffleContext.Builder.forceSharing(Boolean) to force or deny code sharing for inner contexts, and many others. Check the Truffle project changelog to see a full list.  Removed several deprecated core APIs, for example, FrameSlot, CompilerOptions, etc. Check the Truffle project changelog to see a full list.  Added TruffleInstrument.Env#createSystemThread and TruffleLanguage.Env#createSystemThread to create a new thread designed to process instrument tasks in the background.  Added copyStatic, clearStatic and swap...Static additional methods to the Static Frame API.  Added a check if the static frame access is validated when assertions are enabled. Reading a slot with a different type than written to leads to an AssertionError.  Deprecated the TruffleLanguage.Env.newContextBuilder() method and replaced it with a new method TruffleLanguage.Env.newInnerContextBuilder(String...). The new method no longer inherits all privileges from the parent context and no longer initializes the creator context by default. The new method also allows setting the permitted languages for the inner context similarly to the Polyglot Embedding API.  Changed the behavior of setting application arguments: inner contexts no longer inherit application arguments from their outer context. Now you can set application arguments explicitly for inner contexts using TruffleContext.Builder.arguments(String, String[]).  Modified behavior of inner contexts: an inner context no longer uses system exit on exit, even if the polyglot embedder specified it with Context.Builder.useSystemExit(boolean) for an outer context.  Introduced the RootNode.getParentFrameDescriptor method to support identifying lexical scope parents of hot methods and compiling them earlier.A full list of updates can be found in the changelog.",
          "url": " /release-notes/22_3/"
          },
          
          "404-html":  {
          "title": "Page Not Found",
          "content": "",
          "url": " /404.html"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-aot":  {
          "title": "Truffle AOT Tutorial",
          "content": "Truffle AOT TutorialMany statically compiled languages, like C are designed to be compilable without prior execution.By default, Truffle first interprets code before it is compiled.In order to improve warmup speed of static languages AOT compilation can be supported.The following tutorial describes how to support Truffle AOT in your language, how to trigger and test it.Language SupportIn order for languages to support AOT compilation the language needs to implement the RootNode.prepareForAOT() method.The language implementation can indicate support for AOT by returning a non null value in this method.The goal for implementing a root node for AOT is to prepare all the AST nodes such that they no longer deoptimize when they are compiled without prior execution.Typical actions performed in an implementation of this method are:  Initialize local variable types in the FrameDescriptor of the root node. If a language uses local variables and their types are known, then this information must be provided to the FrameDescriptor. This step can often be done already during parsing.  Compute the expected execution signature of a root node and return it. This step requires the parser to infer expected typesfor arguments and return values.  Prepare specializing nodes with profiles that do not invalidate on first execution. Truffle DSL supports preparation of specializing nodes for AOT. See the example AOT language for details.Trigger AOT compilationAOT compilation can be triggered and tested by using the --engine.CompileAOTOnCreate=true option.This will trigger AOT compilation for every created call target with a root node that supports AOT compilation.A root node supports AOT compilation if it returns a non null value in RootNode.prepareForAOT().Note that enabling this flag will also disable background compilation which makes it not suitable for production usage.Example UsageUse the following documented and executable Truffle language as inspiration for AOT support:AOT TutorialThe example is executable as mx unittest using mx unittest AOTTutorial.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/AOT/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-aotoverview":  {
          "title": "Truffle AOT Overview",
          "content": "Truffle AOT OverviewThere are several different flavors of AOT preinitialization, compilation, and caching supported in Truffle.This document is intended to provide an overview of these capabilities.Note that some of the features mentioned here are only supported in Oracle GraalVM.Preinitialization of the First ContextNative image allows running Java code in static initializers at image build time.After static initialization was run, values referenced from static fields are snapshotted and persisted in the image.Context preinitialization leverages this feature by creating and initializing a language context at image build time to be used by the first context that gets created in an isolate or process at runtime.This typically improves the initialization time of the first context significantly.Context preinitialization can be enabled by setting the system property -Dpolyglot.image-build-time.PreinitializeContexts=ruby,llvm at image build time.A language needs to implement TruffleLanguage.patchContext and return true to support context preinitialization.In addition, languages need to be careful not to bind any host-specific data or create objects that would not be allowed to be stored in a native image, like java.lang.Thread instances.For more information see TruffleLanguage.patchContext javadoc.Code sharing within the same Isolate/ProcessA polyglot engine can be used in order to determine the scope of code sharing between contexts.An example of how that can be done can be found in the reference manual.When a language is initialized for a polyglot context, a new language instance is requested from an engine.If the language supports ContextPolicy.SHARED, then the language instance will be reused for an engine instance.The source parsing cache is associated with a language instance, so parsing happens once per language instance.Languages may choose to disallow reuse of a language instance for a new additional context by implementing TruffleLanguage.areOptionsCompatible.This allows languages to assume specific context options to be compilation final for all root nodes created by the language.An exception from this rule is InteropLibrary, where nodes may be shared unconditionally between languages instances.Supporting Context Independent CodeCodesharing requires that all code data structures are independent of their context.For example, code is context-independent if it can be executed with one context and then executed again with a new context without deoptimizing the code.A good test to verify a language implementation’s context independence is to create a context with an explicit engine, run a test application, and then verify that the second context does not cause deoptimizations when running the same deterministic application.The Truffle framework announces the potential use of a language instance in multiple contexts by calling TruffleLanguage.initializeMultipleContexts, typically even before the first context is created.The framework is able to initialize multiple contexts before the first context is created when an explicit engine is used or --engine.CacheStore is set to true.The following criteria should be satisfied when supporting context independent code:  All speculation on runtime value identity must be disabled with multiple contexts initialized, as they will lead to a guaranteed deoptimization when used with the second context.  Function inline caches should be modified and implemented as a two-level inline cache. The first level speculates on the function instance’s identity and the second level on the underlying CallTarget instance. The first level cache must be disabled if multiple contexts are initialized, as this would unnecessarily cause deoptimization.  The DynamicObject root Shape instance should be stored in the language instance instead of the language context. Otherwise, any inline cache on shapes will not stabilize and ultimately end up in the generic state.  All Node implementations must not store context-dependent data structures or context-dependent runtime values.  Loading and parsing of sources, even with language-internal builtins, should be performed using TruffleLanguage.Env.parse to cache Source parsing per language instance.  All assumption instances should be stored in the language instance instead of the context. With multiple contexts initialized, the context instance read using context references may no longer be a constant. In this case any assumption read from the context would not be folded and they would cause significant runtime performance overhead. Assumptions from the language can be folded by the compiler in both single and multiple context mode.It is expected that an AST created for multiple contexts is compiled to less efficient machine code as it does not allow for speculation on the identity of runtime values.For example, instead of speculating on the function instance in an inline cache, it is necessary to speculate on the contained CallTarget.This is slower because it requires an additional read to access the CallTarget stored in the function.It may be costly to create context independent code, therefore, speculation on runtime values should still be performed if multiple contexts are not initialized.SimpleLanguage and JavaScript are two languages that already support context independent code and might be useful as a guidance on concrete problems.Persistent Context Independent Code with Auxiliary Engine Caching (Oracle GraalVM)Oracle GraalVM supports persisting code data structures to disk.This enables to almost eliminate warmup time for the first run of an application in an isolate/process.The SVM auxiliary image feature is used to persist and load the necessary data structures to the disk.Persisting the image can take a significant amount of time as compilation needs to be performed.However, loading is designed to be as fast as possible, typically almost instantaneous.Engine caching is enabled using options and functional even if the context was created without an explicit engine.More information on engine caching can be found in the engine caching tutorial.Compilation without ProfilingBy default, if language functions are created but never executed, they are not compiled when they are stored in an auxiliary engine cache image.Auxiliary engine caching supports triggering compilation for root nodes that were loaded but never executed.In such a case the framework calls the RootNode.prepareForAOT method.More information on making a language implementation ready for compilation without prior execution can be found in the AOT tutorial.Note that not every language can be compiled without prior execution and produce efficient machine code.Statically typed languages are typically more suitable for this.Application SnapshottingIt is planned to also support persisting runtime values of polyglot context instances to disk.More information will appear here as soon as this feature is implemented.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/AOTOverview/"
          },
          
          "latest-reference-manual-native-image-metadata-automaticmetadatacollection":  {
          "title": "Collect Metadata with the Tracing Agent",
          "content": "Collect Metadata with the Tracing AgentThe Native Image tool relies on the static analysis of an application’s reachable code at runtime. However, the analysis cannot always completely predict all usages of the Java Native Interface (JNI), Foreign Function and Memory (FFM) API, Java Reflection, Dynamic Proxy objects, or class path resources. Undetected usages of these dynamic features must be provided to the native-image tool in the form of metadata (precomputed in code or as JSON configuration files).Here you will find information how to automatically collect metadata for an application and write JSON configuration files.To learn how to compute dynamic feature calls in code, see Reachability Metadata.Table of Contents  Tracing Agent  Conditional Metadata Collection  Agent Advanced Usage  Native Image Utils ToolTracing AgentGraalVM provides a Tracing Agent to easily gather metadata and prepare configuration files. The agent tracks all usages of dynamic features during application execution on a regular Java VM.Enable the agent on the command line with the java command from the GraalVM JDK:$JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/ ...  Note: -agentlib must be specified before a -jar option or a class name or any application parameters as part of the java command.When run, the agent looks up classes, methods, fields, resources for which the native-image tool needs additional information.When the application completes and the JVM exits, the agent writes metadata to JSON files in the specified output directory (/path/to/config-dir/).It may be necessary to run the application more than once (with different execution paths) for improved coverage of dynamic features.The config-merge-dir option adds to an existing set of configuration files, as follows:$JAVA_HOME/bin/java -agentlib:native-image-agent=config-merge-dir=/path/to/config-dir/ ...                                                              ^^^^^The agent also provides the following options to write metadata on a periodic basis:  config-write-period-secs=n: writes metadata files every n seconds; n must be greater than 0.  config-write-initial-delay-secs=n: waits n seconds before first writing metadata; defaults to 1.For example:$JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/,config-write-period-secs=300,config-write-initial-delay-secs=5 ...The above command will write metadata files to /path/to/config-dir/ every 300 seconds after an initial delay of 5 seconds.It is advisable to manually review the generated configuration files.Because the agent observes only executed code, the application input should cover as many code paths as possible.The generated configuration files can be supplied to the native-image tool by placing them in a META-INF/native-image/ directory on the class path. This directory (or any of its subdirectories) is searched for the file named reachability-metadata.json that is then automatically included in the build process. Not all of those files must be present. When multiple files with the same name are found, all of them are considered.To test the agent collecting metadata on an example application, go to the Build a Native Executable with Reflection guide.Conditional Metadata CollectionThe agent can deduce metadata conditions based on their usage in executed code.Conditional metadata is mainly aimed towards library maintainers with the goal of reducing overall footprint.To collect conditional metadata with the agent, see Conditional Metadata Collection.Agent Advanced UsageCaller-based FiltersBy default, the agent filters dynamic accesses which Native Image supports without configuration.The filter mechanism works by identifying the Java method performing the access, also referred to as caller method, and matching its declaring class against a sequence of filter rules.The built-in filter rules exclude dynamic accesses which originate in the JVM, or in parts of a Java class library directly supported by Native Image (such as java.nio) from the generated configuration files.Which item (class, method, field, resource, etc.) is being accessed is not relevant for filtering.In addition to the built-in filter, custom filter files with additional rules can be specified using the caller-filter-file option.For example: -agentlib:caller-filter-file=/path/to/filter-file,config-output-dir=...Filter files have the following structure:{ &quot;rules&quot;: [    {&quot;excludeClasses&quot;: &quot;com.oracle.svm.**&quot;},    {&quot;includeClasses&quot;: &quot;com.oracle.svm.tutorial.*&quot;},    {&quot;excludeClasses&quot;: &quot;com.oracle.svm.tutorial.HostedHelper&quot;}  ],  &quot;regexRules&quot;: [    {&quot;includeClasses&quot;: &quot;.*&quot;},    {&quot;excludeClasses&quot;: &quot;.*$$Generated[0-9]+&quot;}  ]}The rules section contains a sequence of rules.Each rule specifies either includeClasses, which means that lookups originating in matching classes will be included in the resulting configuration, or excludeClasses, which excludes lookups originating in matching classes from the configuration.Each rule defines a pattern to match classes. The pattern can end in .* or .**, interpreted as follows:    - .* matches all classes in the package and only that package;    - .** matches all classes in the package as well as in all subpackages at any depth. Without .* or .**, the rule applies only to a single class with the qualified name that matches the pattern.All rules are processed in the sequence in which they are specified, so later rules can partially or entirely override earlier ones.When multiple filter files are provided (by specifying multiple caller-filter-file options), their rules are chained together in the order in which the files are specified.The rules of the built-in caller filter are always processed first, so they can be overridden in custom filter files.In the example above, the first rule excludes lookups originating in all classes from package com.oracle.svm and from all of its subpackages (and their subpackages, etc.) from the generated metadata.In the next rule however, lookups from those classes that are directly in package com.oracle.svm.tutorial are included again.Finally, lookups from the HostedHelper class is excluded again. Each of these rules partially overrides the previous ones.For example, if the rules were in the reverse order, the exclusion of com.oracle.svm.** would be the last rule and would override all other rules.The regexRules section also contains a sequence of rules.Its structure is the same as that of the rules section, but rules are specified as regular expression patterns which are matched against the entire fully qualified class identifier.The regexRules section is optional.If a regexRules section is specified, a class will be considered included if (and only if) both rules and regexRules include the class and neither of them exclude it.With no regexRules section, only the rules section determines whether a class is included or excluded.For testing purposes, the built-in filter for Java class library lookups can be disabled by adding the no-builtin-caller-filter option, but the resulting metadata files are generally unsuitable for the build.Similarly, the built-in filter for Java VM-internal accesses based on heuristics can be disabled with no-builtin-heuristic-filter and will also generally lead to less usable metadata files.For example: -agentlib:native-image-agent=no-builtin-caller-filter,no-builtin-heuristic-filter,config-output-dir=...Access FiltersUnlike the caller-based filters described above, which filter dynamic accesses based on where they originate, access filters apply to the target of the access.Therefore, access filters enable directly excluding packages and classes (and their members) from the generated configuration.By default, all accessed classes (which also pass the caller-based filters and the built-in filters) are included in the generated configuration.Using the access-filter-file option, a custom filter file that follows the file structure described above can be added.The option can be specified more than once to add multiple filter files and can be combined with the other filter options, for example, -agentlib:access-filter-file=/path/to/access-filter-file,caller-filter-file=/path/to/caller-filter-file,config-output-dir=....Specify Configuration Files as ArgumentsA directory containing configuration files that is not part of the class path can be specified to native-image via -H:ConfigurationFileDirectories=/path/to/config-dir/.This directory must directly contain reachability-metadata.json or the formerly-used individual metadata files (jni-config.json, reflect-config.json, proxy-config.json, serialization-config.json, and resource-config.json).A directory with the same metadata files that is on the class path, but not in META-INF/native-image/, can be provided via -H:ConfigurationResourceRoots=path/to/resources/.Both -H:ConfigurationFileDirectories and -H:ConfigurationResourceRoots can also take a comma-separated list of directories.Injecting the Agent via the Process EnvironmentAltering the java command line to inject the agent can prove to be difficult if the Java process is launched by an application or script file, or if Java is even embedded in an existing process.In that case, it is also possible to inject the agent via the JAVA_TOOL_OPTIONS environment variable.This environment variable can be picked up by multiple Java processes which run at the same time, in which case each agent must write to a separate output directory with config-output-dir.(The next section describes how to merge sets of configuration files.)In order to use separate paths with a single global JAVA_TOOL_OPTIONS variable, the agent’s output path options support placeholders:export JAVA_TOOL_OPTIONS=&quot;-agentlib:native-image-agent=config-output-dir=/path/to/config-output-dir-{pid}-{datetime}/&quot;The {pid} placeholder is replaced with the process identifier, while {datetime} is replaced with the system date and time in UTC, formatted according to ISO 8601. For the above example, the resulting path could be: /path/to/config-output-dir-31415-20181231T235950Z/.Trace FilesIn the examples above, native-image-agent has been used to both keep track of the dynamic accesses on a JVM and then to generate a set of configuration files from them.However, for a better understanding of the execution, the agent can also write a trace file in JSON format that contains each individual access:$JAVA_HOME/bin/java -agentlib:native-image-agent=trace-output=/path/to/trace-file.json ...The native-image-utils tool can transform trace files to configuration files.The following command reads and processes trace-file.json and generates a set of configuration files in the directory /path/to/config-dir/:native-image-utils generate --trace-input=/path/to/trace-file.json --output-dir=/path/to/config-dir/InteroperabilityThe agent uses the JVM Tool Interface (JVMTI) and can potentially be used with other JVMs that support JVMTI.In this case, it is necessary to provide the absolute path of the agent:/path/to/some/java -agentpath:/path/to/graalvm/jre/lib/amd64/libnative-image-agent.so=&amp;lt;options&amp;gt; ...Experimental OptionsThe agent has options which are currently experimental and might be enabled in future releases, but can also be changed or removed entirely.See the ExperimentalAgentOptions.md guide.Native Image Utils ToolWhen using the agent in multiple processes at the same time as described in the previous section, config-output-dir is a safe option, but it results in multiple sets of configuration files.The native-image-utils tool can be used to merge these configuration files:native-image-utils generate --input-dir=/path/to/config-dir-0/ --input-dir=/path/to/config-dir-1/ --output-dir=/path/to/merged-config-dir/This command reads one set of configuration files from /path/to/config-dir-0/ and another from /path/to/config-dir-1/ and then writes a set of configuration files that contains both of their information to /path/to/merged-config-dir/.An arbitrary number of --input-dir arguments with sets of configuration files can be specified. See native-image-utils help for all options.Further Reading  Build a Native Executable with Reflection  Reachability Metadata  Experimental Agent Options  Foreign Function and Memory API in Native Image",
          "url": " /latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-auxiliaryenginecachingenterprise":  {
          "title": "Auxiliary Engine Caching",
          "content": "Auxiliary Engine CachingThe following document describes how the auxiliary engine cache of GraalVM works.This feature is only available in Oracle GraalVM. In GraalVM Community Edition, these options are not available.IntroductionWarmup of Truffle guest language programs can take a significant amount of time.Warmup consists of work that is repeated every time a program is executed until peak performance is reached.This includes:  Loading and parsing the guest application into Truffle AST data structures.  Execution and profiling of the guest application in the interpreter.  Compilation of the AST to machine code.Within a single OS process, the work performed during warmup can be shared by specifying an explicit engine.This requires language implementations to disable context-related optimizations to avoid deoptimizations between contexts that share code.Auxiliary engine caching builds upon the mechanism for disabling context-related optimizations and adds the capability to persist an engine with ASTs and optimized machine code to disk.This way, the work performed during warmup can be significantly reduced in the first application context of a new process.We use the SVM auxiliary image feature to persist and load the necessary data structures to the disk.Persisting the image can take significant time as compilation needs to be performed.However, loading is designed to be as fast as possible, typically almost instantaneous.This reduces the warmup time of an application significantly.Getting StartedStarting from Oracle GraalVM installation, you first need to (re)build an image with auxiliary engine caching capabilities.For example, one can rebuild the JavaScript image by adding the auxiliary engine cache feature:graalvm/bin/native-image --macro:js-launcher -H:+AuxiliaryEngineCache -H:ReservedAuxiliaryImageBytes=1073741824The --macro argument value depends on the guest languageBy default, auxiliary images of up to 1GB are possible.The maximum size can be increased or decreased as needed.The amount of reserved bytes does not actually impact the memory consumed by the application.In future versions, the auxiliary engine cache will be enabled by default when the --macro:js-launcher macro is used.After rebuilding the JavaScript launcher, the feature is used as follows:Create a new file fib.js:function fib(n) {   if (n == 1 || n == 2) {       return 1;   }   return fib(n - 1) + fib(n - 2);}console.log(fib(32))In order to persist the engine of a profiling run to disk use the following command line:graalvm/bin/js --experimental-options --engine.TraceCache=true --engine.CacheStore=fib.image fib.jsThe ` –engine.TraceCache=true` option is optional and allows you to see what is going on.The output is as follows:[engine] [cache] No load engine cache configured.2178309[engine] [cache] Preparing engine for store (compile policy hot)...[engine] [cache] Force compile targets mode: hot[engine] [cache] Prepared engine in 1 ms.[engine] [cache] Persisting engine for store ...[engine] [cache] Persisted engine in 20 ms.[engine] [cache] Detecting changes (update policy always)...[engine] [cache]     New image contains         1 sources and  82 function roots.[engine] [cache]     Always persist policy.[engine] [cache] Writing image to fib.image...[engine] [cache] Finished writing 1,871,872 bytes in 4 ms.The engine can now be loaded from disk using the following command:graalvm/bin/js --experimental-options --engine.TraceCache --engine.CacheLoad=fib.image fib.jswhich prints:[engine] [cache] Try loading image &#39;./fib.image&#39;...[engine] [cache] Loaded image in 0 ms. 1,871,872 bytes   1 sources  82 roots[engine] [cache] Engine from image successfully patched with new options.2178309[engine] [cache] No store engine cache configured.Since there is no need to warm up the application, the application’s execution time should be significantly improved.UsageThe cache store and load operations can be controlled using the following options:  --engine.Cache=&amp;lt;path&amp;gt; Loads and stores the cached engine from/to  path.  --engine.CacheStore=&amp;lt;path&amp;gt; Stores the cached engine to  path.  --engine.CacheLoad=&amp;lt;path&amp;gt; Loads the cached engine from path.  --engine.CachePreinitializeContext=&amp;lt;boolean&amp;gt; Preinitialize a new context in the image (default true).  --engine.TraceCache=&amp;lt;boolean&amp;gt; Enables debug output.  --engine.TraceCompilation=&amp;lt;boolean&amp;gt; Prints forced compilations.The compilation of roots may be forced when an image is stored using the --engine.CacheCompile=&amp;lt;policy&amp;gt; option. The supported policies are:  none: No compilations will be persisted, and existing compilations will be invalidated.  compiled: No compilations will be forced, but finished compilations will be persisted.  hot: All started compilations will be completed and then persisted. (default)  aot: All started, and AOT compilable roots will be forced to compile and persisted.  executed: All executed and all AOT compilable roots will be forced to compile.By default, all started compilations in the compile queue will be completed and then persisted.Whether a function root is AOT compilable is determined by the language.A language supports AOT by implementing RootNode.prepareForAOT().An update policy can be specified if both load and store operations are set using the --engine.UpdatePolicy=&amp;lt;policy&amp;gt; option.Available policies are:  always Always persist.  newsource Store if new source was loaded that was not contained in the previously loaded image.  newroot Store if a new root was loaded and not contained in the previously loaded image.  never Never persist.Known Restrictions      There are generally no restrictions on the kind of applications that can be persisted.If the language supports a shared context policy, auxiliary engine caching should work.If the language does not support it, then no data will be persisted.        The persisted auxiliary engine image can only be used with the same SVM native image that it was created with.Using the engine image with any other native-image will fail.        There can only be one active auxiliary image per native-image isolate.Trying to load multiple auxiliary images at the same time will fail.Currently, auxiliary images can also not be unloaded, but it is planned to lift this restriction in the future.  Security ConsiderationsAll data that is persisted to disk represents code only and no application context-specific data like global variables.However, profiled ASTs and code may contain artifacts of the optimizations performed in a Truffle AST.For example, it is possible that runtime strings are used for optimizations and therefore persisted to an engine image.Development and Debugging on NativeImageThere are several options useful for debugging auxiliary engines caching when running on NativeImage:  -XX:+TraceAuxiliaryImageClassHistogram Prints a class histogram of all the objects contained in an image when persisting.  -XX:+TraceAuxiliaryImageReferenceTree Prints a class reference tree of all the objects contained in an image when persisting.Development and Debugging on HotSpotIt can be useful to debug language implementation issues related to auxiliary image on HotSpot.On Oracle GraalVM in JVM mode, we have additional options that can be used to help debug issues with this feature:Since storing partial heaps on HotSpot is not supported, these debug features do not work on HotSpot.  --engine.DebugCacheStore=&amp;lt;boolean&amp;gt; Prepares the engine for caching and stores it to a static field instead of writing it to disk.  --engine.DebugCacheLoad=&amp;lt;boolean&amp;gt; Prepares the engine to use the engine stored in the static field instead of reading it from disk.  --engine.DebugCacheCompile=&amp;lt;boolean&amp;gt; Policy to use to force compilation for executed call targets before persisting the engine. This supports the same values as --engine.CacheCompile.  --engine.DebugCacheTrace=&amp;lt;boolean&amp;gt; Enables tracing for the engine cache debug feature.For example:js --experimental-options --engine.TraceCompilation --engine.DebugCacheTrace --engine.DebugCacheStore --engine.DebugCacheCompile=executed fib.jsPrints the following output:[engine] opt done         fib                                                         |ASTSize            32 |Time   231( 147+84  )ms |Tier             Last |DirectCallNodes I    6/D    8 |GraalNodes   980/ 1857 |CodeSize         7611 |CodeAddress 0x10e20e650 |Source       fib.js:22178309[engine] [cache] Preparing debug engine for storage...[engine] [cache] Force compile targets mode: executed[engine] [cache] Force compiling 4 roots for engine caching.[engine] opt done         @72fa3b00                                                   |ASTSize             3 |Time   211( 166+45  )ms |Tier             Last |DirectCallNodes I    2/D    1 |GraalNodes   500/ 1435 |CodeSize         4658 |CodeAddress 0x10e26c8d0 |Source            n/a[engine] opt done         :program                                                    |ASTSize            25 |Time   162( 123+39  )ms |Tier             Last |DirectCallNodes I    1/D    1 |GraalNodes   396/ 1344 |CodeSize         4407 |CodeAddress 0x10e27fd50 |Source       fib.js:1[engine] opt done         Console.log                                                 |ASTSize             3 |Time    26(  11+15  )ms |Tier             Last |DirectCallNodes I    0/D    0 |GraalNodes    98/  766 |CodeSize         2438 |CodeAddress 0x10e285710 |Source    &amp;lt;builtin&amp;gt;:1[engine] [cache] Stored debug engine in memory.This allows rapidly iterating on problems related to the compilation as well as to attach a Java debugger.A Java debugger can be attached using --vm.Xdebug --vm.Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000.Debugging the loading of persisted engines is more difficult as writing an engine to disk is not supported on HotSpot.However, it is possible to use the polyglot embedding API to simulate this use-case in a unit test.See the com.oracle.truffle.enterprise.test.DebugEngineCacheTest class as an example.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/AuxiliaryEngineCachingEnterprise/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-branchinstrumentation":  {
          "title": "Truffle Branches Instrumentation",
          "content": "Truffle Branches InstrumentationIn languages implemented on top of Truffle, it is common that the AST implementations contain fast and slowexecution paths, usually based on some condition, such as a profile. These executionpaths are organized into different conditional branches. In these cases, it is oftenhelpful to know if running the program actually exercised the code in each of thoseexecutions paths.The branch instrumentation functionality instruments if-statements in target methodsto track which of the branches have been taken during execution. Branch instrumentationdoes this by instrumenting branches with code that writes to a globaltable. Each branch has an entry in this table. When the program ends, thecontents of the table are decoded and dumped to the standard output in readableform.There are several flags that control how branch instrumentation works. These flags arespecified as system properties:  --compiler.InstrumentBranches - controls whether instrumentation is on (trueor false, default is false)  --compiler.InstrumentFilter - filters methods in which instrumentationshould be done (method filter syntax, essentially &amp;lt;package&amp;gt;.&amp;lt;class&amp;gt;.&amp;lt;method&amp;gt;[.&amp;lt;signature&amp;gt;])  --compiler.InstrumentationTableSize - controls the maximum number ofinstrumented locations  --compiler.InstrumentBranchesPerInlineSite - controls whether instrumentationprovides separate branch profiles for each guest language function/compilation unit(default is false).Example UsageHere is an example of how to enable branch instrumentation on a program.When using instrumentation to detect hot or infrequently used branches in a Trufflelanguage implementation, it usually starts by finding a language node with aproblematic method. The following command runs a unit test for the SimpleLanguage,and instruments all the if-statements:mx --jdk jvmci sl --engine.BackgroundCompilation=false   --compiler.InstrumentBranches   &#39;--compiler.InstrumentFilter=*.*.*&#39;   ../truffle/truffle/com.oracle.truffle.sl.test/src/tests/LoopObjectDyn.slYou get the following output:Execution profile (sorted by hotness)=====================================  0: *****************************************************  1: **************************com.oracle.truffle.sl.nodes.access.SLPropertyCacheNode.namesEqual(SLPropertyCacheNode.java:109) [bci: 120][0] state = IF(if=36054#, else=0#)com.oracle.truffle.sl.nodes.controlflow.SLWhileRepeatingNode.executeRepeating(SLWhileRepeatingNode.java:102) [bci: 5][1] state = BOTH(if=18000#, else=18#)This output tells that both branches were visited in the if-statement in the fileSLWhileRepeatingNode.java at line 102, and only the true branch was visited forthe if-statement in the file SLPropertyCacheNode.java at line 109.However, it does not tell, e.g., where this specific SLPropertyCacheNode node wasused from – the same execute method can be called from many different SimpleLanguagenodes, and you may wish to distinguish these occurrences. Therefore, set theper-inline-site flag to true, and change the filter to focus only onSLPropertyCacheNode:mx --jdk jvmci sl -Djdk.graal.TruffleBackgroundCompilation=false   --compiler.InstrumentBranchesPerInlineSite   --compiler.InstrumentBranches   &#39;--compiler.InstrumentFilter=*.SLPropertyCacheNode.*&#39;   ../truffle/truffle/com.oracle.truffle.sl.test/src/tests/LoopObjectDyn.slThis time you get more output, because the method namesEqual was inlined atmultiple sites (each site is represented by its inlining chain). The following outputfragment first shows the histogram with the if-statement ID and its occurrencecount. It then shows the exact call stacks and execution counts for the branches.For example, for [1], when namesEqual is called from executeRead, the truebranch is taken 18018 times. When the namesEqual is called from executeWrite([0]), the true branch is taken only 18 times:Execution profile (sorted by hotness)=====================================  1: ***************************************  2: ***************************************  0:  3:com.oracle.truffle.sl.nodes.access.SLPropertyCacheNode.namesEqual(SLPropertyCacheNode.java:109) [bci: 120]com.oracle.truffle.sl.nodes.access.SLReadPropertyCacheNodeGen.executeRead(SLReadPropertyCacheNodeGen.java:76) [bci: 88]com.oracle.truffle.sl.nodes.access.SLReadPropertyNode.read(SLReadPropertyNode.java:71) [bci: 7]com.oracle.truffle.sl.nodes.access.SLReadPropertyNodeGen.executeGeneric(SLReadPropertyNodeGen.java:30) [bci: 35]com.oracle.truffle.sl.nodes.SLExpressionNode.executeLong(SLExpressionNode.java:81) [bci: 2]com.oracle.truffle.sl.nodes.expression.SLLessThanNodeGen.executeBoolean_long_long0(SLLessThanNodeGen.java:42) [bci: 5]com.oracle.truffle.sl.nodes.expression.SLLessThanNodeGen.executeBoolean(SLLessThanNodeGen.java:33) [bci: 14]com.oracle.truffle.sl.nodes.controlflow.SLWhileRepeatingNode.evaluateCondition(SLWhileRepeatingNode.java:133) [bci: 5]com.oracle.truffle.sl.nodes.controlflow.SLWhileRepeatingNode.executeRepeating(SLWhileRepeatingNode.java:102) [bci: 2]com.oracle.truffle.runtime.OptimizedOSRLoopNode.executeLoop(OptimizedOSRLoopNode.java:113) [bci: 61]com.oracle.truffle.sl.nodes.controlflow.SLWhileNode.executeVoid(SLWhileNode.java:69) [bci: 5]com.oracle.truffle.sl.nodes.controlflow.SLBlockNode.executeVoid(SLBlockNode.java:84) [bci: 37]com.oracle.truffle.sl.nodes.controlflow.SLFunctionBodyNode.executeGeneric(SLFunctionBodyNode.java:81) [bci: 5]com.oracle.truffle.sl.nodes.SLRootNode.execute(SLRootNode.java:78) [bci: 28][1] state = IF(if=18018#, else=0#)...com.oracle.truffle.sl.nodes.access.SLPropertyCacheNode.namesEqual(SLPropertyCacheNode.java:109) [bci: 120]com.oracle.truffle.sl.nodes.access.SLWritePropertyCacheNodeGen.executeWrite(SLWritePropertyCacheNodeGen.java:111) [bci: 244]com.oracle.truffle.sl.nodes.access.SLWritePropertyNode.write(SLWritePropertyNode.java:73) [bci: 9]com.oracle.truffle.sl.nodes.access.SLWritePropertyNodeGen.executeGeneric(SLWritePropertyNodeGen.java:33) [bci: 47]com.oracle.truffle.sl.nodes.access.SLWritePropertyNodeGen.executeVoid(SLWritePropertyNodeGen.java:41) [bci: 2]com.oracle.truffle.sl.nodes.controlflow.SLBlockNode.executeVoid(SLBlockNode.java:84) [bci: 37]com.oracle.truffle.sl.nodes.controlflow.SLFunctionBodyNode.executeGeneric(SLFunctionBodyNode.java:81) [bci: 5]com.oracle.truffle.sl.nodes.SLRootNode.execute(SLRootNode.java:78) [bci: 28][0] state = IF(if=18#, else=0#)...Truffle Call Boundary InstrumentationThe Truffle Call Boundary Instrumentation tool instruments callsites to methods thathave a TruffleCallBoundary annotation, and counts the calls to those methods. It iscontrolled by the following set of flags:  --compiler.InstrumentBoundaries - controls whether instrumentation is on (trueor false, default is false)  --compiler.InstrumentFilter - filters methods in which instrumentationshould be done (method filter syntax, essentially &amp;lt;package&amp;gt;.&amp;lt;class&amp;gt;.&amp;lt;method&amp;gt;[.&amp;lt;signature&amp;gt;])  --compiler.InstrumentationTableSize - controls the maximum number ofinstrumented locations  --compiler.InstrumentBoundariesPerInlineSite - controls whether instrumentationis done per a declaration of an Truffle boundary call (false), or per every callstack where that callsite was inlined (true)This tool can be used together with the Branch Instrumentation tool.Assume that you need to find frequently occurring methods that were not, for example,inlined. The usual steps in identifying the Truffle call boundaries is to first run theprogram with the InstrumentBoundariesPerInlineSite flag set to false, andthen, after identifying the problematic methods, set that flag to true and set theInstrumentFilter to identify the particular call stacks for those methods.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/BranchInstrumentation/"
          },
          
          "latest-reference-manual-native-image-overview-buildconfiguration":  {
          "title": "Native Image Build Configuration",
          "content": "Native Image Build ConfigurationNative Image supports a wide range of options to configure the native-image builder.Table of Contents  Embed a Configuration File  Configuration File Format  Order of Arguments Evaluation  Memory Configuration for Native Image Build  Specify Types Required to Be Defined at Build TimeEmbed a Configuration FileWe recommend that you provide the configuration for the native-image builder by embedding a native-image.properties file into a project JAR file.The native-image builder will also automatically pick up all configuration options provided in the META-INF/native-image/ directory (or any of its subdirectories) and use it to construct native-image command-line options.To avoid a situation when constituent parts of a project are built with overlapping configurations, we recommended you use subdirectories within META-INF/native-image: a JAR file built from multiple maven projects cannot suffer from overlapping native-image configurations.For example:  foo.jar has its configurations in META-INF/native-image/foo_groupID/foo_artifactID  bar.jar has its configurations in META-INF/native-image/bar_groupID/bar_artifactIDThe JAR file that contains foo and bar will then contain both configurations without conflict.Therefore the recommended layout to store configuration data in JAR files is as follows:META-INF/└── native-image    └── groupID        └── artifactID            └── native-image.propertiesNote that the use of ${.} in a native-image.properties file expands to the resource location that contains that exact configuration file.This can be useful if the native-image.properties file refers to resources within its subdirectory, for example, -H:ResourceConfigurationResources=${.}/custom_resources.json.Always make sure you use the option variants that take resources, that is, use -H:ResourceConfigurationResources instead of -H:ResourceConfigurationFiles.Other options that work in this context are:  -H:DynamicProxyConfigurationResources  -H:JNIConfigurationResources  -H:ReflectionConfigurationResources  -H:ResourceConfigurationResources  -H:SerializationConfigurationResourcesBy having such a composable native-image.properties file, building a native executable does not require any additional option on the command line.It is sufficient to run the following command:$JAVA_HOME/bin/native-image -jar target/&amp;lt;name&amp;gt;.jarTo identify which configuration is applied when building a native executable, use native-image --verbose.This shows from where native-image picks up the configurations to construct the final composite configuration command-line options for the native image builder.native-image --verbose -jar build/basic-app-0.1-all.jarApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/common/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/buffer/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/transport/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/handler/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/codec-http/native-image.properties...Executing [    &amp;lt;composite configuration command line options for the image builder&amp;gt;]Typical examples of configurations that use a configuration from META-INF/native-image can be found in Native Image configuration examples.Configuration File FormatA native-image.properties file is a Java properties file that specifies configurations for native-image. The following properties are supported.ArgsUse this property if your project requires custom native-image command-line options to build correctly.For example, the native-image-configure-examples/configure-at-runtime-example contains Args = --initialize-at-build-time=com.fasterxml.jackson.annotation.JsonProperty$Access in its native-image.properties file to ensure the class com.fasterxml.jackson.annotation.JsonProperty$Access is initialized at executable build time.JavaArgsSometimes it can be necessary to provide custom options to the JVM that runs the native-image builder.Use the JavaArgs property in this case.ImageNameThis property specifies a user-defined name for the executable.If ImageName is not used, a name is automatically chosen:    * native-image -jar &amp;lt;name.jar&amp;gt; has a default executable name &amp;lt;name&amp;gt;    * native-image -cp ... fully.qualified.MainClass has a default executable name fully.qualified.mainclassNote that using ImageName does not prevent you from overriding the name via the command line.For example, if foo.bar contains ImageName=foo_app:    * native-image -jar foo.bar generates the executable foo_app but    * native-image -jar foo.bar application generates the executable applicationChanging the Default Configuration DirectoryNative Image by default stores configuration information in the user’s home directory: $HOME/.native-image/.To change this default, set the environment variable NATIVE_IMAGE_USER_HOME to a different location. For example:export NATIVE_IMAGE_USER_HOME= $HOME/.local/share/native-imageOrder of Arguments EvaluationThe options passed to native-image are evaluated from left to right.This also extends to options that are passed indirectly via configuration files in the META-INF/native-image directory.Consider the example where there is a JAR file that includes native-image.properties containing Args = -H:Optimize=0.You can override the setting that is contained in the JAR file by using the -H:Optimize=2 option after -cp &amp;lt;jar-file&amp;gt;.Memory Configuration for Native Image BuildThe native-image builder runs on a JVM and uses the memory management of the underlying platform.The usual Java command-line options for garbage collection apply to the native-image builder.During the creation of a native executable, the representation of the whole application is created to determine which classes and methods will be used at runtime.It is a computationally intensive process that uses the following default values for memory usage:-Xss10M -XX:MaxRAMPercentage=&amp;lt;percentage based on available memory&amp;gt; -XX:GCTimeRatio=19 -XX:+ExitOnOutOfMemoryError These defaults can be changed by passing -J + &amp;lt;jvm option for memory&amp;gt; to the native-image tool.The -XX:MaxRAMPercentage value determines the maximum heap size of the builder and is computed based on available memory of the system.It maxes out at 32GB by default and can be overwritten with, for example, -J-XX:MaxRAMPercentage=90.0 for 90% of physical memory or -Xmx4g for 4GB.-XX:GCTimeRatio=19 increases the goal of the total time for garbage collection to 5%, which is more throughput-oriented and reduces peak RSS.The build process also exits on the first OutOfMemoryError (-XX:+ExitOnOutOfMemoryError) to provide faster feedback in environments under a lot of memory pressure.By default, the native-image tool uses up to 32 threads (but not more than the number of processors available). For custom values, use the --parallelism=... option.For other related options available to the native-image tool, see the output from the command native-image --expert-options-all.Specify Types Required to Be Defined at Build TimeA well-structured library or application should handle linking of Java types (ensuring all reachable Java types are fully defined at build time) when building a native binary by itself.The default behavior is to throw linking errors, if they occur, at runtime. However, you can prevent unwanted linking errors by specifying which classes are required to be fully linked at build time.For that, use the --link-at-build-time option. If the option is used in the right context (see below), you can specify required classes to link at build time without explicitly listing classes and packages.It is designed in a way that libraries can only configure their own classes, to avoid any side effects on other libraries.You can pass the option to the native-image tool on the command line, embed it in a native-image.properties file on the module path or the class path.Depending on how and where the option is used it behaves differently:  If you use --link-at-build-time without arguments, all classes in the scope are required to be fully defined. If used without arguments on command line, all classes will be treated as “link-at-build-time” classes. If used without arguments embedded in a native-image.properties file on the module path, all classes of the module will be treated as “link-at-build-time” classes. If you use --link-at-build-time embedded in a native-image.properties file on the class path, the following error will be thrown:      Error: Using &#39;--link-at-build-time&#39; without args only allowed on module path. &#39;META-INF/native-image/org.mylibrary/native-image.properties&#39; in &#39;file:///home/test/myapp/MyLibrary.jar&#39; not part of module path.    If you use the  --link-at-build-time option with arguments, for example, --link-at-build-time=foo.bar.Foobar,demo.myLibrary.Name,..., the arguments should be fully qualified class names or package names. When used on the module path or class path (embedded in native-image.properties files), only classes and packages defined in the same JAR file can be specified. Packages for libraries used on the class path need to be listed explicitly. To make this process easy, use the @&amp;lt;prop-values-file&amp;gt; syntax to generate a package list (or a class list) in a separate file automatically.Another handy option is --link-at-build-time-paths which allows to specify which classes are required to be fully defined at build time by other means.This variant requires arguments that are of the same type as the arguments passed via -p (--module-path) or -cp (--class-path):--link-at-build-time-paths &amp;lt;class search path of directories and ZIP/JAR files&amp;gt;The given entries are searched and all classes inside are registered as --link-at-build-time classes.This option is only allowed to be used on command line.Related Documentation  Class Initialization in Native Image  Native Image Basics  Native Image Build Options  Native Image Build Overview  Reachability Metadata",
          "url": " /latest/reference-manual/native-image/overview/BuildConfiguration/"
          },
          
          "latest-reference-manual-native-image-overview-options":  {
          "title": "Command-line Options",
          "content": "Command-line OptionsOptions to configure Native Image are provided in the following categories:  Build options: run native-image --help for help on build options.  Extra build options: run native-image --help-extra for help on extra build options.  Expert build options: run native-image --expert-options for help on expert options.Depending on the GraalVM version, the options to the native-image builder may differ.Native Image options can also be categorized as hosted or runtime options:  Hosted options: to configure the build process and set default values for run-time behavior. These options use the prefix -H:. For example, -H:MaxHeapSize=2g sets the default maximum heap size for the native executable.  Runtime options: to provide explicit values when building the native binary, using the prefix -R:. At run time, the default prefix is -XX: (this is application-specific and not mandated by Native Image).You can use -H: options at build time to configure both build-time behavior and run-time defaults. For most use cases, -H: options are sufficient and you typically do not need to distinguish between build-time and run-time configuration.For more information describing how to define and use these options, read the com.oracle.svm.core.option package documentation.Build OptionsRun native-image --help for help on build options.  -cp, -classpath, --class-path &amp;lt;class search path of directories and ZIP/JAR files&amp;gt;: a : (; on Windows) separated list of directories, JAR archives, and ZIP archives to search for class files  -p &amp;lt;module path&amp;gt;, --module-path &amp;lt;module path&amp;gt;: a : (; on Windows) separated list of directories. Each directory is a directory of modules.  --add-modules &amp;lt;module name&amp;gt;[,&amp;lt;module name&amp;gt;...]: add root modules to resolve in addition to the initial module. &amp;lt;module name&amp;gt; can also be ALL-DEFAULT, ALL-SYSTEM, ALL-MODULE-PATH.  -D&amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;: set a system property for image build time only  -J&amp;lt;flag&amp;gt;: pass an option directly to the JVM running the native-image builder  --diagnostics-mode: enable diagnostics output: class initialization, substitutions, etc.  --enable-preview: allow classes to depend on preview features of this release  --verbose: enable verbose output  --version: print the product version and exit  --help: print this help message  --help-extra: print help on non-standard options  --color: color build output (always, never, or auto)  --configure-reflection-metadata: enable runtime instantiation of reflection objects for non-invoked methods  --emit: emit additional data as a result of the build. Use build-report to emit a detailed Build Report, for example: --emit build-report or --emit build-report=report.html  --enable-all-security-services: add all security service classes to the generated native executable  --enable-http: enable HTTP support in a native executable  --enable-https: enable HTTPS support in a native executable  --enable-monitoring: enable monitoring features that allow the VM to be inspected at run time. A comma-separated list can contain heapdump, jfr, jvmstat, jmxserver (experimental), jmxclient (experimental), threaddump, or all (deprecated behavior: defaults to all if no argument is provided). For example: --enable-monitoring=heapdump,jfr.  --enable-native-access &amp;lt;module name&amp;gt;[,&amp;lt;module name&amp;gt;...]: enable modules that are permitted to perform restricted native operations. &amp;lt;module name&amp;gt; can also be ALL-UNNAMED  --enable-sbom: assemble a Software Bill of Materials (SBOM) for the executable or shared library based on the results from the static analysis. Comma-separated list can contain embed to store the SBOM in data sections of the binary, export to save the SBOM in the output directory, classpath to include the SBOM as a Java resource on the classpath at META-INF/native-image/sbom.json, strict to abort the build if any type (such as a class, interface, or annotation) cannot be matched to an SBOM component, cyclonedx (the only format currently supported), and class-level to include class-level metadata. Defaults to embedding an SBOM: --enable-sbom=embed. To disable the SBOM feature, use --enable-sbom=false on the command line.  --enable-url-protocols: list comma-separated URL protocols to enable  --exact-reachability-metadata: enables exact and user-friendly handling of reflection, resources, JNI, and serialization  --exact-reachability-metadata-path: trigger exact handling of reflection, resources, JNI, and serialization from all types in the given class-path or module-path entries  --features: a comma-separated list of fully qualified Feature implementation classes  --future-defaults: enable options that are planned to become defaults in future releases. A comma-separated list can contain all, run-time-initialized-jdk, none.  --gc=&amp;lt;value&amp;gt;: select a Native Image garbage collector implementation. Allowed options for &amp;lt;value&amp;gt; are: G1 for G1 garbage collector (not available in GraalVM Community Edition); epsilon for Epsilon garbage collector; serial for Serial garbage collector (default).  --initialize-at-build-time: a comma-separated list of packages and classes (and implicitly all of their superclasses) that are initialized during generation of a native executable. An empty string designates all packages.  --initialize-at-run-time: a comma-separated list of packages and classes (and implicitly all of their subclasses) that must be initialized at run time and not during generation. An empty string is currently not supported.  --libc: select the libc implementation to use. Available implementations are glibc, musl, bionic.  --link-at-build-time: require types to be fully defined at native executable build time. If used without arguments, all classes in scope of the option are required to be fully defined.  --link-at-build-time-paths: require all types in given class or module path entries to be fully defined at native executable build time  --list-cpu-features: show CPU features specific to the target platform and exit  --list-modules: list observable modules and exit  --native-compiler-options: provide a custom C compiler option used for query code compilation  --native-compiler-path: provide a custom path to the C compiler used to query code compilation and linking  --native-image-info: show the native toolchain information and executable’s build settings  --parallelism: specify the maximum number of threads to use concurrently during native executable generation  --pgo: provide a comma-separated list of files from which to read the data collected for Profile-guided optimization of AOT-compiled code (reads from  default.iprof if nothing is specified). Each file must contain a single PGOProfiles object, serialized in JSON format, optionally compressed by gzip. (Not available in GraalVM Community Edition.)  --pgo-instrument: instrument AOT-compiled code to collect data for Profile-guided optimization into the default.iprof file. (Not available in GraalVM Community Edition.)  --pgo-sampling: perform profiling by sampling the AOT compiled code to collect data for Profile-guided optimization. (Not available in GraalVM Community Edition.)  --shared: build a shared library  --silent: silence build output  --static: build a statically-linked executable (requires libc and zlib static libraries)  --static-nolibc: build statically linked executable with libc dynamically linked  --target: select the compilation target for native-image (in the &amp;lt;OS&amp;gt;-&amp;lt;architecture&amp;gt; format). It defaults to host’s OS-architecture pair.  --trace-object-instantiation: provide a comma-separated list of fully-qualified class names that an object instantiation is traced for  -O&amp;lt;level&amp;gt;: control code optimizations where available variants are: b - optimize for fastest build time, s - optimize for size, 0 - no optimizations, 1 - basic optimizations, 2 - aggressive optimizations, 3 - all optimizations for best performance (enabled automatically with Profile-Guided Optimization (PGO))  -da, -da[:[packagename]|:[classname], disableassertions[:[packagename]|:[classname]: disable assertions with specified granularity at run time  -dsa, -disablesystemassertions: disable assertions in all system classes at run time  -ea, -ea[:[packagename]|:[classname], enableassertions[:[packagename]|:[classname]: enable assertions with specified granularity at run time  -esa, -enablesystemassertions: enable assertions in all system classes at run time  -g: generate debugging information  -march: generate instructions for a specific machine type. Defaults to x86-64-v3 on AMD64 and armv8-a on AArch64. Use -march=compatibility for best compatibility, or -march=native for best performance if a native executable is deployed on the same machine or on a machine with the same CPU features. To list all available machine types, use -march=list.  -o: name of the output file to be generatedExtra Build OptionsRun native-image --help-extra for help on additional options.  --exclude-config: exclude configuration for a space-separated pair of class path/module path pattern and resource pattern. For example: --exclude-config foo.jar META-INF/native-image/.*.properties ignores all properties files in META-INF/native-image in all JAR files named foo.jar.  --expert-options: list image build options for experts  --expert-options-all: list all image build options for experts (use at your own risk). Options marked with Extra help available contain help that can be shown with --expert-options-detail  --expert-options-detail: display all available help for a comma-separated list of option names. Pass * to show extra help for all options that contain it.  --configurations-path &amp;lt;search path of option-configuration directories&amp;gt;: a separated list of directories to be treated as option-configuration directories.  --debug-attach[=&amp;lt;port or host:port (* can be used as host meaning bind to all interfaces)&amp;gt;]: attach to a debugger during native executable generation (default port is 8000)  --diagnostics-mode: Enables logging of image-build information to a diagnostics directory.  --dry-run: output the command line that would be used for building  --bundle-create[=new-bundle.nib]: in addition to image building, create a native image bundle file (*.nibfile) that allows rebuilding of that image again at a later point. If a bundle file gets passed, the bundle will be created with the given name. Otherwise, the bundle file name is derived from the image name. Note both bundle options can be extended with dry-run and container.          dry-run: only perform the bundle operations without any actual native executable building      container: set up a container image and perform a native executable generation from inside that container. Requires Podman or rootless Docker to be installed. If available, Podman is preferred and rootless Docker is the fallback. Specifying one or the other as =&amp;lt;container-tool&amp;gt; forces the use of a specific tool.      dockerfile=&amp;lt;Dockerfile&amp;gt;: use a user provided Dockerfile instead of the default based on Oracle Linux 8 base images for GraalVM        --bundle-apply=some-bundle.nib[,dry-run][,container[=&amp;lt;container-tool&amp;gt;][,dockerfile=&amp;lt;Dockerfile&amp;gt;]]: an image will be built from the given bundle file with the exact same arguments and files that have been passed to Native Image originally to create the bundle. Note that if an extra --bundle-create gets passed after --bundle-apply, a new bundle will be written based on the given bundle arguments plus any additional arguments that haven been passed afterwards. For example: native-image --bundle-apply=app.nib --bundle-create=app_dbg.nib -g creates a new bundle app_dbg.nib based on the given app.nib bundle. Both bundles are the same except the new one also uses the -g option.  -E&amp;lt;env-var-key&amp;gt;[=&amp;lt;env-var-value&amp;gt;]: allow Native Image to access the given environment variable during native executable generation. If the optional &amp;lt;env-var-value&amp;gt; is not given, the value of the environment variable will be taken from the environment Native Image was invoked from.  -V&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;:  provide values for placeholders in the native-image.properties files  --add-exports: value &amp;lt;module&amp;gt;/&amp;lt;package&amp;gt;=&amp;lt;target-module&amp;gt;(,&amp;lt;target-module&amp;gt;) updates &amp;lt;module&amp;gt; to export &amp;lt;package&amp;gt; to &amp;lt;target-module&amp;gt;, regardless of module declaration. &amp;lt;target-module&amp;gt; can be ALL-UNNAMED to export to all unnamed modules  --add-opens: value &amp;lt;module&amp;gt;/&amp;lt;package&amp;gt;=&amp;lt;target-module&amp;gt;(,&amp;lt;target-module&amp;gt;) updates &amp;lt;module&amp;gt; to open &amp;lt;package&amp;gt; to &amp;lt;target-module&amp;gt;, regardless of module declaration  --add-reads: value &amp;lt;module&amp;gt;=&amp;lt;target-module&amp;gt;(,&amp;lt;target-module&amp;gt;) updates &amp;lt;module&amp;gt; to read &amp;lt;target-module&amp;gt;, regardless of module declaration. &amp;lt;target-module&amp;gt; can be ALL-UNNAMED to read all unnamed modulesList of Useful OptionsThere are some expert level options that a user may find useful or needed. For example, the option to dump graphs of the native-image builder, or to print various statistics during the build process.Build Output and Build ReportNative Image provides an informative build output including various statistics during the build process.The build output in a JSON-based, machine-readable format can be requested using the -H:BuildOutputJSONFile option, and later processed by a monitoring tool.The JSON files validate against the JSON schema defined in build-output-schema-v0.9.4.json.A comprehensive report with additional information can be requested using the --emit build-report option.  Note: The --emit build-report option is not available in GraalVM Community Edition.Graph DumpingNative Image re-used the options for graph dumping, logging, counters, and everything else from the GraalVM debug environment.These GraalVM options can be used both as hosted options (if you want to dump graphs of the native-image builder), and as runtime options (if you want to dump graphs during dynamic compilation at runtime).The Graal compiler options that work as expected include Dump, DumpOnError, Log, MethodFilter, and the options to specify file names and ports for the dump handlers.For example:  -H:Dump= -H:MethodFilter=ClassName.MethodName: dump the compiler graphs of the native-image builder.  -XX:Dump= -XX:MethodFilter=ClassName.MethodName: dump the compile graphs at runtime.Preserving Packages, Modules, or ClassesGraalVM 25 introduces the -H:Preserve option. This lets you instruct the native-image tool to keep entire packages, modules, or all classes on the classpath in the native executable, even when static analysis cannot discover them.You can use -H:Preserve in the following ways:  -H:Preserve=all: preserves all elements from the entire JDK and classpath. This creates larger images but ensures all code is included, which can help resolve missing metadata issues.  -H:Preserve=module=&amp;lt;module&amp;gt;: preserves all elements from a given module.  -H:Preserve=module=ALL-UNNAMED: preserves all elements from the classpath (provided with -cp).  -H:Preserve=package=&amp;lt;package&amp;gt;: preserves all elements from a given package. You can use * to include all subpackages, for example: -H:Preserve=package=com.my.pkg.*,package=com.another.pkg.*. Note that only the * wildcard is supported; other regex patterns are not allowed.  -H:Preserve=path=&amp;lt;cp-entry&amp;gt;: preserves all elements from a given class-path entry  You can combine any of the previous uses by separating them with a comma (,). For example: -H:Preserve=path=&amp;lt;cp-entry&amp;gt;,module=&amp;lt;module&amp;gt;,module=&amp;lt;module2&amp;gt;,package=&amp;lt;package&amp;gt;You must explicitly configure multi-interface proxy classes, arrays of dimension 3 and higher, and .class files as resources in the native image. Tooling-related Java modules are not included by default with -H:Preserve=all and must be added with -H:Preserve=module=&amp;lt;module&amp;gt; if needed.If you get errors related to --initialize-at-build-time, follow the suggestions in the error messages.  Note: Using -H:Preserve=all requires significant memory and will result in much larger native images. Use the -Os flag to reduce image size. For more information, see Optimizations and Performance.For a practical demonstration, see the preserve-package demo.Memory RequirementsNative Image compilation is memory-intensive, particularly when building large projects or when using -H:Preserve=all or --pgo-instrument.If you encounter OutOfMemoryError: Java heap space you can:  use the -Os flag to reduce image size. For more information, see Optimizations and Performance  use more specific preservation options like -H:Preserve=package=&amp;lt;package&amp;gt; instead of -H:Preserve=all  use more RAM by increasing the heap size with -J-Xmx&amp;lt;n&amp;gt;g where &amp;lt;n&amp;gt; varies based on your machine’s available memory and build requirementsSystem PropertiesYou can define system properties at image build time using the -D&amp;lt;system.property&amp;gt;=&amp;lt;value&amp;gt; option syntax.It sets a system property for the native-image tool, but the property will not be included in the generated executable.However, JDK system properties are included in generated executables and are visible at runtime.For example:  -D&amp;lt;system.property&amp;gt;=&amp;lt;value&amp;gt; will only be visible at build time. If this system property is accessed in the native executable, it will return null.  -Djava.version=25 will be visible at both build time and in the native executable because the value is copied into the binary by default.The following system properties are automatically copied into the generated executable:            Name      Description                  file.separator      File separator              file.encoding      Character encoding for the default locale              java.version      Java Runtime Environment version              java.version.date      General-availability (GA) date of the release              java.class.version      Java class format version number              java.runtime.version      Java Runtime Environment version              java.specification.name      Java Runtime Environment specification name              java.specification.vendor      Java Runtime Environment specification vendor              java.specification.version      Java Virtual Machine specification version              java.vm.specification.name      Java Virtual Machine specification name              java.vm.specification.vendor      Java Virtual Machine implementation vendor              java.vm.specification.version      Java Virtual Machine specification version              line.separator      Line separator              native.encoding      Specifies the host environment’s character encoding              org.graalvm.nativeimage.kind      Specifies if the image is built as a shared library or executable              path.separator      Path separator              stdin.encoding      Specifies the encoding for System.in              stdout.encoding      Specifies the encoding for System.out and System.err              sun.jnu.encoding      Specifies encoding when parsing values passed via the commandline      Related Documentation  Build Configuration  Build Overview",
          "url": " /latest/reference-manual/native-image/overview/Options/"
          },
          
          "latest-reference-manual-native-image-overview-buildoutput":  {
          "title": "Native Image Build Output",
          "content": "Native Image Build Output  Build Stages  Security Report  Recommendations  Resource Usage Statistics  Build Artifacts  Machine-Readable Build Output  PGO Profile FormatHere you will find information about the build output of GraalVM Native Image.Below is the example output when building a native executable of the HelloWorld class:================================================================================GraalVM Native Image: Generating &#39;helloworld&#39; (executable)...================================================================================[1/8] Initializing...                                           (4.4s @ 0.29GiB) Builder configuration: - Java version: 26+13, vendor version: Oracle GraalVM 26-dev+13.1 - Graal compiler: optimization level: 2, target machine: x86-64-v3, PGO: ML-inferred - C compiler: gcc (linux, x86_64, 13.3.0) - Assertions: enabled, system assertions: enabled - 1 user-specific feature(s):   - com.oracle.svm.thirdparty.gson.GsonFeature Image configuration: - Garbage collector: Serial GC (max heap size: 80% of RAM) - Assertions: disabled (class-specific config may apply), system assertions: disabled--------------------------------------------------------------------------------Build resources: - 30.00GiB of memory (48.0% of system memory, capped at 30GiB) - 32 thread(s) (88.9% of 36 available processor(s), determined at start)[2/8] Performing analysis...  [*******]                         (3.7s @ 0.58GiB)    2,140 types,   1,939 fields, and   8,997 methods found reachable      775 types,      35 fields, and     244 methods registered for reflection       49 types,      35 fields, and      48 methods registered for JNI access       52 resource accesses registered with 107B total size        4 native libraries: dl, pthread, rt, z[3/8] Building universe...                                      (0.9s @ 0.74GiB)[4/8] Parsing methods...      [*]                               (1.6s @ 0.72GiB)[5/8] Inlining methods...     [***]                             (0.5s @ 0.66GiB)[6/8] Compiling methods...    [***]                             (9.9s @ 0.81GiB)[7/8] Laying out methods...   [*]                               (1.1s @ 0.67GiB)[8/8] Creating image...       [**]                              (2.5s @ 0.90GiB)   2.86MiB (21.13%) for code area:     4,078 compilation units   3.56MiB (26.33%) for image heap:   63,478 objects and 1 resource   6.01MiB (44.40%) for debug info generated in 0.4s   7.11MiB (52.55%) for other data  13.53MiB in total image size, 6.88MiB in total file size--------------------------------------------------------------------------------Top 10 origins of code area:            Top 10 object types in image heap: 342.94KiB java.base/java.util           820.99KiB byte[] for string data 289.94KiB java.base/java.lang           750.97KiB byte[] for code metadata 270.50KiB o.g.n.~e/c.o.svm.core.code    347.48KiB java.base/java.lang.String 189.67KiB o.g.n.~e/c.o.s.c.genscavenge  217.34KiB o.g.n.~e/c.o.s.c.h.Dyna~anion 129.09KiB java.base/j.util.concurrent   209.51KiB java.base/java.lang.Class  83.00KiB o.g.n.~e/c.o.s.c.j.functions  184.75KiB java.base/j.u.HashMap$Node  81.76KiB java.base/java.util.stream    115.53KiB java.base/char[]  76.73KiB o.g.n.~e/com.oracle.svm.core  107.66KiB java.base/j.i.u.SoftR~nceKey  60.32KiB o.g.n.~e/c.o.svm.core.thread  105.09KiB java.base/java.lang.Object[]  58.18KiB o.g.n.~e/c.o.svm.graal.stubs   88.63KiB java.base/j.u.c.Concu~p$Node   1.25MiB for 119 more packages         700.05KiB for 585 more object types        Use &#39;--emit build-report&#39; to create a report with more details.--------------------------------------------------------------------------------Security report: - Binary includes Java deserialization. - CycloneDX SBOM with 5 component(s) is embedded in binary (406B). 6 type(s) could not be associated to a component. - Advanced obfuscation not enabled; enable with &#39;-H:AdvancedObfuscation=&quot;&quot;&#39; (experimental support).--------------------------------------------------------------------------------Recommendations: G1GC: Use the G1 GC (&#39;--gc=G1&#39;) for improved latency and throughput. PGO:  Use Profile-Guided Optimizations (&#39;--pgo&#39;) for improved throughput. FUTR: Use &#39;--future-defaults=all&#39; to prepare for future releases. HEAP: Set max heap for improved and more predictable memory usage. CPU:  Enable more CPU features with &#39;-march=native&#39; for improved performance.--------------------------------------------------------------------------------   1.3s (4.8% of total time) in 88 GCs | Peak RSS: 2.14GiB | CPU load: 18.03--------------------------------------------------------------------------------Build artifacts: /home/janedoe/helloworld/gdb-debughelpers.py (debug_info, 80.60KiB) /home/janedoe/helloworld/helloworld (executable, 6.88MiB) /home/janedoe/helloworld/helloworld.debug (debug_info, 6.66MiB) /home/janedoe/helloworld/sources (debug_info, 37.61MiB)================================================================================Finished generating &#39;helloworld&#39; in 25.5s.Build StagesInitializingIn this stage, the Native Image build process is set up and Features are initialized.Native Image KindBy default, Native Image generates executables but it can also generate native shared libraries and static executables.Java Version InfoThe Java and vendor version of the Native Image process.Both are also used for the java.vm.version and java.vendor.version properties within the generated native binary.Please report version and vendor when you file issues.Graal CompilerThe selected optimization level and targeted machine type used by the Graal compiler.The optimization level can be controlled with the -O option and defaults to 2, which enables aggressive optimizations.Use -Ob to enable quick build mode, which speeds up the compilation stage.This is useful during development to reduce image build time.Use -Os to optimize for size.The targeted machine type can be selected with the -march option and defaults to x86-64-v3 on AMD64 and armv8-a on AArch64.See here for recommendations on how to use this option.On Oracle GraalVM, the line also shows information about Profile-Guided Optimization (PGO).  off: PGO is not used  instrument: The generated executable or shared library is instrumented to collect data for PGO (--pgo-instrument)  user-provided: PGO is enabled and uses a user-provided profile (for example --pgo default.iprof)  ML-inferred: A machine learning (ML) model is used to infer profiles for control split branches statically.C CompilerThe C compiler executable, vendor, target architecture, and version info used by the Native Image build process.Assertions in the BuilderThis shows whether Java assertions and system assertions are enabled for the Native Image Builder process.Enabling them can help the GraalVM team identify and debug problems in the Builder.User-Specific FeaturesAll Features that are provided or explicitly enabled by the user, or implicitly registered on the user’s behalf (for example, by a framework).Internal features used by GraalVM Native Image are not included in this list.Garbage CollectorThe garbage collector used within the generated executable:  The Serial GC is the default GC and optimized for low memory footprint and small Java heap sizes.  The G1 GC (not available in GraalVM Community Edition) is a multithreaded GC that is optimized to reduce stop-the-world pauses and therefore improve latency while achieving high throughput.  The Epsilon GC does not perform any garbage collection and is designed for very short-running applications that only allocate a small amount of memory.For more information see the docs on Memory Management.Maximum Heap SizeBy default, the heap size is limited to a certain percentage of your system memory, allowing the garbage collector to freely allocate memory according to its policy.Use the -Xmx option when invoking your native executable (for example ./myapp -Xmx64m for 64MB) to limit the maximum heap size for a lower and more predictable memory footprint.This can also improve latency in some cases.Use the -R:MaxHeapSize option when building with Native Image to preconfigure the maximum heap size.Assertions in the Generated ImageThis shows whether Java assertions and system assertions are enabled in the generated image.Enabling them can help identifying and debugging problems in the Java code built into the image.Experimental OptionsA list of all active experimental options, including their origin and possible API option alternatives if available.Using experimental options should be avoided in production and can change in any release.If you rely on experimental features and would like an option to be considered stable, please file an issue.Picked up NATIVE_IMAGE_OPTIONSAdditional build options picked up via the NATIVE_IMAGE_OPTIONS environment variable.Similar to JAVA_TOOL_OPTIONS, the value of the environment variable is prefixed to the options supplied to native-image.Argument files are not allowed to be passed via NATIVE_IMAGE_OPTIONS.The NATIVE_IMAGE_OPTIONS environment variable is designed to be used by users, build environments, or tools to inject additional build options.Build ResourcesThe memory limit and number of threads used by the build process.More precisely, the memory limit of the Java heap, so actual memory consumption can be higher.Please check the peak RSS reported at the end of the build to understand how much memory was actually used.The actual memory consumption can also be lower than the limit set, as the GC only commits memory that it needs.By default, the build process uses the dedicated mode (which uses 85% of system memory) in containers or CI environments (when the $CI environment variable is set to true), but never more than 30GiB of memory.Otherwise, it uses shared mode, which uses the available memory to avoid memory pressure on developer machines.If less than 8GiB of memory are available, the build process falls back to the dedicated mode.Therefore, consider freeing up memory if your machine is slow during a build, for example, by closing applications that you do not need.It is possible to override the default behavior and set relative or absolute memory limits, for example with -J-XX:MaxRAMPercentage=60.0 or -J-Xmx16g.Xms (for example, -J-Xms9g) can also be used to ensure a minimum for the limit, if you know the image needs at least that much memory to build.By default, the build process uses all available processors to maximize speed, but not more than 32 threads.Use the --parallelism option to set the number of threads explicitly (for example, --parallelism=4).Use fewer threads to reduce load on your system as well as memory consumption (at the cost of a slower build process).Performing AnalysisIn this stage, a points-to analysis is performed.The progress indicator visualizes the number of analysis iterations.A large number of iterations can indicate problems in the analysis likely caused by misconfiguration or a misbehaving feature.Reachable Types, Fields, and MethodsThe number of types (primitives, classes, interfaces, and arrays), fields, and methods that are found reachable by the static analysis.The reachability metrics give an impression of how small or large the application is.These metrics can be helpful when compared before and after merging code changes or adding, removing, or upgrading dependencies of an application.This can help to understand the impact that certain code changes or dependencies have on the overall native binary.A larger number of reachable types, fields, and methods will also result in a larger native binary.Reflection RegistrationsThe number of types, fields, and methods that are registered for reflection.Large numbers can cause significant reflection overheads, slow down the build process, and increase the size of the native binary (see reflection metadata).JNI Access RegistrationsThe number of types, fields, and methods that are registered for JNI access.Foreign Access RegistrationsThe number of downcalls and upcalls registered for foreign function access.Runtime Compiled MethodsThe number of methods marked for runtime compilation.This number is only shown if runtime compilation is built into the executable, for example, when building a Truffle language.Runtime-compiled methods account for graph encodings in the heap.Building UniverseIn this stage, a universe with all types, fields, and methods is built, which is then used to create the native binary.Parsing MethodsIn this stage, the Graal compiler parses all reachable methods.The progress indicator is printed periodically at an increasing interval.Inlining MethodsIn this stage, trivial method inlining is performed.The progress indicator visualizes the number of inlining iterations.Compiling MethodsIn this stage, the Graal compiler compiles all reachable methods to machine code.The progress indicator is printed periodically at an increasing interval.Laying Out MethodsIn this stage, compiled methods are laid out.The progress indicator is printed periodically at an increasing interval.Creating ImageIn this stage, the native binary is created and written to disk.Debug info is also generated as part of this stage (if requested).This section breaks down the total image size as well as code area and image heap (see below for more details).The total image size is calculated before linking by summing the sizes of the code area, image heap, debug information (if requested and embedded in the binary), and other data.The total file size is the actual size of the image on disk after linking.Typically, the file size is slightly smaller than the image size due to additional link time optimizations.Code AreaThe code area contains machine code produced by the Graal compiler for all reachable methods.Therefore, reducing the number of reachable methods also reduces the size of the code area.Origins of Code AreaTo help users understand where the machine code of the code area comes from, the build output shows a breakdown of the top origins.An origin is a group of Java sources and can be a JAR file, a package name, or a class name, depending on the information available.The java.base module, for example, contains base classes from the JDK.The svm.jar file, the org.graalvm.nativeimage.base module, and similar origins contain internal sources for the Native Image runtime.To reduce the size of the code area and with that, the total size of the native executable, re-evaluate the dependencies of your application based on the code area breakdown.Some libraries and frameworks are better prepared for Native Image than others, and newer versions of a library or framework may improve (or worsen) their code footprint.Image HeapThe heap contains reachable objects such as static application data, metadata, and byte[] for different purposes (see below).General Heap Data Stored in byte[]The total size of all byte[] objects that are neither used for java.lang.String, nor code metadata, nor reflection metadata, nor graph encodings.Therefore, this can also include byte[] objects from application code.Embedded Resources Stored in byte[]The total size of all byte[] objects used for storing resources (for example, files accessed via Class.getResource()) within the native binary.The number of resources is shown in the Heap section.A list of all resources including additional information such as their module, name, origin, and size are included in the build reports.This information can also be requested in the JSON format using the -H:+GenerateEmbeddedResourcesFile option.Such a JSON file validates against the JSON schema defined in embedded-resources-schema-v1.0.0.json.Code Metadata Stored in byte[]The total size of all byte[] objects used for metadata for the code area.Therefore, reducing the number of reachable methods also reduces the size of this metadata.Reflection Metadata Stored in byte[]The total size of all byte[] objects used for reflection metadata, including types, field, method, and constructor data.To reduce the amount of reflection metadata, reduce the number of elements registered for reflection.Graph Encodings Stored in byte[]The total size of all byte[] objects used for graph encodings.These encodings are a result of runtime compiled methods.Therefore, reducing the number of such methods also reduces the size of corresponding graph encodings.Heap AlignmentAdditional space reserved to align the heap for the selected garbage collector.The heap alignment may also contain GC-specific data structures.Its size can therefore only be influenced by switching to a different garbage collector.Debug InfoThe total size of generated debug information (if enabled).Other DataThe amount of data in the binary that is neither in the code area, nor in the heap, nor debug info.This data typically contains internal information for Native Image and should not be dominating.Security ReportThis section is not available in GraalVM Community Edition.DeserializationThis shows whether Java deserialization is included in the native executable or not.If not included, the attack surface of the executable is reduced as the executable cannot be exploited with attacks based on Java deserialization.Software Bill of Material (SBOM)This section indicates whether an SBOM was assembled and in what ways it was stored.The storage formats include: embed, which embeds the SBOM in the binary; classpath, which saves the SBOM to the classpath; and export, which includes the SBOM as a JSON build artifact.The SBOM feature is enabled by default and defaults to the embed option.When embedded, the SBOM size is displayed.The number of components is always displayed.The SBOM feature can be disabled with --enable-sbom=false.Unassociated types are displayed when certain types (such as classes, interfaces, or annotations) cannot be linked to an SBOM component.If these types contain vulnerabilities, SBOM scanning will not detect them.To fix this, ensure that proper GAV coordinates (Group ID, Artifact ID, and Version) are defined in the project POM’s properties or in MANIFEST.MF using standard formats.Hashes are computed for JAR inputs and GraalVM internal components if the hashes option is used.Hashes are not computed for directories.If hashes is enabled and hashes cannot be computed, the number of components without hashes is displayed.To list these components, use:jq &#39;.components[] | select(.hashes == null)&#39; /path/to/app.sbom.jsonUse the build report to view included components, their dependencies, and any unassociated types.For more information, see Software Bill of Materials (SBOM) in Native Image.Advanced ObfuscationThis section indicates whether advanced obfuscation was applied.Advanced obfuscation is applied to your application code and third-party dependencies, but not to the JDK or Substrate VM code.Obfuscated elements include:  Module, package, and class names  Method and source file names (as seen in stack traces)  Field names (as seen in heap dumps)Elements that are not obfuscated:  Names affected by registrations in reachability metadata  Names in preserved code (via -H:Preserve)  Module and package names containing a class that loads a resource  Names of annotations, lambdas, and proxiesTo export a mapping from original to obfuscated names, use -H:AdvancedObfuscation=export-mapping.Use the mapping file and the native-image-utils deobfuscate command to deobfuscate stack traces.See the build report for summary statistics, such as the percentage of class and method names that were obfuscated.For more information, see Advanced Obfuscation in Native Image.  Native Image obfuscates binaries by removing class files, applying aggressive optimizations, and eliminating dead code. The advanced obfuscation feature also obfuscates symbol names.Backwards-Edge Control-Flow Integrity (CFI)Control-Flow Integrity (CFI) can be enforced with the experimental -H:CFI=HW option.This feature is currently only available for code compiled by Graal for Linux AArch64 and leverages pointer authentication codes (PAC) to ensure integrity of a function’s return address.Software Control-Flow Integrity (CFI)Control-Flow Integrity (CFI) can be enforced in software with the experimental -H:CFI=SW_NONATIVE option.This feature is currently only available for code compiled by Graal for Linux AMD64 and validates targets of indirect branches and method returns.RecommendationsThe build output may contain one or more of the following recommendations that help you get the best out of Native Image.FUTR: Use the Correct Semantics and Prepare for Future ReleasesUse --future-defaults=all to enable all features that are planned to be default in a future GraalVM release.This option is unlikely to affect your program’s behavior but guarantees that it adheres to the correct execution semantics.Additionally, it safeguards against unexpected changes in future GraalVM updates.AWT: Missing Reachability Metadata for Abstract Window ToolkitThe Native Image analysis has included classes from the java.awt package but could not find any reachability metadata for it.Use the Tracing Agent to collect such metadata for your application.Otherwise, your application is unlikely to work properly.If your application is not a desktop application (for example using Swing or AWT directly), you may want to re-evaluate whether the dependency on AWT is actually needed.HOME: Set java.home When Running the BinaryThe Native Image analysis has detected the usage of System.getProperty(&quot;java.home&quot;).To ensure it returns a valid value, set java.home by passing the -Djava.home=&amp;lt;path&amp;gt; option to the binary. If not set, System.getProperty(&quot;java.home&quot;) will return null.CPU: Enable More CPU Features for Improved PerformanceThe Native Image build process has determined that your CPU supports more features, such as AES or LSE, than currently enabled.If you deploy your application on the same machine or a similar machine with support for the same CPU features, consider using -march=native at build time.This option allows the Graal compiler to use all CPU features available, which in turn can significantly improve the performance of your application.Use -march=list to list all available machine types that can be targeted explicitly.G1GC: Use G1 Garbage Collector for Improved Latency and ThroughputThe G1 garbage collector is available for your platform.Consider enabling it using --gc=G1 at build time to improve the latency and throughput of your application.For more information see the docs on Memory Management.For best peak performance, also consider using Profile-Guided Optimization.HEAP: Specify a Maximum Heap SizePlease refer to Maximum Heap Size.PGO: Use Profile-Guided Optimization for Improved ThroughputConsider using Profile-Guided Optimization (PGO) to optimize your application for improved throughput.These optimizations allow the Graal compiler to leverage profiling information, similar to when it is running as a JIT compiler, when AOT-compiling your application.For this, perform the following steps:  Build your application with --pgo-instrument.  Run your instrumented application with a representative workload to generate profiling information in the form of an .iprof file.  Re-build your application and pass in the profiling information with --pgo=&amp;lt;your&amp;gt;.iprof to generate an optimized version of your application.Relevant guide: Optimize a Native Executable with Profile-Guided Optimization.For best peak performance, also consider using the G1 garbage collector.QBM: Use Quick Build Mode for Faster BuildsConsider using the quick build mode (-Ob) to speed up your builds during development.More precisely, this mode reduces the number of optimizations performed by the Graal compiler and thus reduces the overall time of the compilation stage.The quick build mode is not only useful for development, it can also cause the generated executable file to be smaller in size.Note, however, that the overall peak throughput of the executable may be lower due to the reduced number of optimizations.INIT: Use the Strict Image Heap ConfigurationStart using --strict-image-heap to reduce the amount of configuration and prepare for future GraalVM releases where this will be the default.This mode requires only the classes that are stored in the image heap to be marked with --initialize-at-build-time.This effectively reduces the number of configuration entries necessary to achieve build-time initialization.When adopting the new mode it is best to start introducing build-time initialization from scratch.During this process, it is best to select individual classes (as opposed to whole packages) for build time initialization.Also, before migrating to the new flag make sure to update all framework dependencies to the latest versions as they might need to migrate too.  Note that --strict-image-heap is enabled by default in Native Image starting from GraalVM for JDK 22.Resource Usage StatisticsGarbage CollectionsThe total time spent in all garbage collectors, total GC time divided by the total process time as a percentage, and the total number of garbage collections.A large number of collections or time spent in collectors usually indicates that the system is under memory pressure.Increase the amount of available memory to reduce the time to build the native binary.Peak RSSPeak resident set size as reported by the operating system.This value indicates the maximum amount of memory consumed by the build process.You may want to compare this value to the memory limit reported in the build resources section.If there is enough headroom and the GC statistics do not show any problems, the amount of total memory of the system can be reduced to a value closer to the peak RSS to lower operational costs.CPU loadThe CPU time used by the process divided by the total process time.Increase the number of CPU cores to reduce the time to build the native binary.Build ArtifactsThe list of all build artifacts.This includes the generated native binary, but it can also contain other artifacts such as additional libraries, C header files, or debug info.Some of these artifacts must remain in the same location with the native binary as they are needed at run time.For applications using AWT, for example, the build process will also output libraries from the JDK and shims to provide compatible AWT support.These libraries need to be copied and distributed together with the native binary.Use the -H:+GenerateBuildArtifactsFile option to instruct the builder to produce a machine-readable version of the build artifact list in JSON format.Such a JSON file validates against the JSON schema defined in build-artifacts-schema-v0.9.0.json.This schema also contains descriptions for each possible artifact type and explains whether they are needed at run time or not.Machine-Readable Build OutputThe build output produced by the native-image builder is designed for humans, can evolve with new releases, and should thus not be parsed in any way by tools.Instead, use the -H:BuildOutputJSONFile=&amp;lt;file.json&amp;gt; option to instruct the builder to produce machine-readable build output in JSON format that can be used, for example, for building monitoring tools.Such a JSON file validates against the JSON schema defined in build-output-schema-v0.9.4.json.Note that a JSON file is produced if and only if a build succeeds.The following example illustrates how this could be used in a CI/CD build pipeline to check that the number of reachable methods does not exceed a certain threshold:native-image -H:BuildOutputJSONFile=build.json HelloWorld# ...cat build.json | python3 -c &quot;import json,sys;c = json.load(sys.stdin)[&#39;analysis_results&#39;][&#39;methods&#39;][&#39;reachable&#39;]; assert c &amp;lt; 12000, f&#39;Too many reachable methods: {c}&#39;&quot;Traceback (most recent call last):  File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;AssertionError: Too many reachable methods: 12128Colorful Build OutputBy default, the native-image builder colors the build output for better readability when it finds an appropriate terminal.It also honors the NO_COLOR, CI, and TERM environment variables when checking for color support.To explicitly control colorful output, set the --color option to always, never, or auto (default).Related Documentation  Build a Native Shared Library  Build a Statically Linked or Mostly-Statically Linked Native Executable  Feature  Interoperability with Native Code  Java Native Interface (JNI) in Native Image  Memory Management  Native Image Build Overview  Native Image Build Configuration",
          "url": " /latest/reference-manual/native-image/overview/BuildOutput/"
          },
          
          "latest-reference-manual-native-image-overview-build-overview":  {
          "title": "Native Image Build Overview",
          "content": "Native Image Build OverviewThe syntax of the native-image command is:  native-image [options] &amp;lt;mainclass&amp;gt; [imagename] [options] to build a native binary from the main class in the current working directory. The class path may optionally be provided with the -cp &amp;lt;classpath&amp;gt; option where &amp;lt;classpath&amp;gt; is a colon-separated (on Windows, semicolon-separated) list of paths to directories and JAR files.  native-image [options] -jar jarfile [imagename] [options] to build a native binary from a JAR file.  native-image [options] -m &amp;lt;module&amp;gt;/&amp;lt;mainClass&amp;gt; [imagename] [options] to build a native binary from a Java module.The options passed to native-image are evaluated from left to right.For an overview of options that can be passed to native-image, see here.Getting Notified When the Build Process Is DoneDepending on the size of your application and the available resources of your build machine, it can take a few minutes to compile your Java application into a native executable.If you are building your application in the background, consider using a command that notifies you when the build process is completed.Below, example commands are listed per operating system:Linux# Ring the terminal bellnative-image -jar App.jar ... ; printf &#39;a&#39;# Use libnotify to create a desktop notificationnative-image -jar App.jar ... ; notify-send &quot;GraalVM Native Image build completed with exit code $?&quot;# Use Zenity to open an info dialog box with textnative-image -jar App.jar ... ; zenity --info --text=&quot;GraalVM Native Image build completed with exit code $?&quot;macOS# Ring the terminal bellnative-image -jar App.jar ... ; printf &#39;a&#39;# Use Speech Synthesisnative-image -jar App.jar ... ; say &quot;GraalVM Native Image build completed&quot;Windows# Ring the terminal bell (press Ctrl+G to enter ^G)native-image.exe -jar App.jar &amp;amp; echo ^G# Open an info dialog box with textnative-image.exe -jar App.jar &amp;amp; msg &quot;%username%&quot; GraalVM Native Image build completedFurther ReadingIf you are new to GraalVM Native Image or have little experience using it, see the Native Image Basics to better understand some key aspects before going further.For more tweaks and how to properly configure the native-image tool, see Build Configuration.Native Image outputs the progress and various statistics when building a native binary. To learn more about the output, and the different build phases, see Build Output.For more detailed information about the build process, its phases, and the contents of a produced native binary, see Build Report.",
          "url": " /latest/reference-manual/native-image/overview/Build-Overview/"
          },
          
          "latest-reference-manual-native-image-overview-build-report":  {
          "title": "Native Image Build Report",
          "content": "Native Image Build ReportBuild Report is a single HTML page report specifically tailored for GraalVM Native Image.The report provides broad information about each build stage as well as the generated binary’s contents.Here you will learn how to generate a Build Report and how to use each report section.  Note: Build Report is not available in GraalVM Community Edition.Table of Contents  Report Generation  Report Structure          Summary      Code Area                  Method-Based Breakdown          List of Packages and Classes                    Image Heap      Resources      Software Bill of Materials (SBOM)      PGO Sampling Profile        Dynamic Access  Related DocumentationReport GenerationA simple HelloWorld Micronaut application (available in the GraalVM Demos repository) is used to demonstrate Build Report generation and its structure.A Build Report can simply be generated using the --emit option when running the native-image command:native-image --emit build-report -cp . ApplicationIn the case of the Micronaut example using the Maven plugin for Native Image, simply add the option --emit build-report in the plugin’s configuration:&amp;lt;plugin&amp;gt;  &amp;lt;groupId&amp;gt;org.graalvm.buildtools&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;native-maven-plugin&amp;lt;/artifactId&amp;gt;  &amp;lt;configuration&amp;gt;    ...    &amp;lt;buildArgs combine.children=&quot;append&quot;&amp;gt;      &amp;lt;buildArg&amp;gt;--emit build-report&amp;lt;/buildArg&amp;gt;      ...    &amp;lt;/buildArgs&amp;gt;  &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;The report is automatically created alongside the generated binary after the successful build.A link to the HTML page (named &amp;lt;binary-name&amp;gt;-build-report.html by default) will be listed in Build artifacts section at the end of the build output:========================================================================================================================GraalVM Native Image: Generating &#39;MnHelloRest&#39; (executable)...========================================================================================================================...Build artifacts: .../graalvm-demos/micronaut-hello-rest-maven/target/MnHelloRest (executable) .../graalvm-demos/micronaut-hello-rest-maven/target/MnHelloRest-build-report.html (build_info) &amp;lt;----- generated report========================================================================================================================Finished generating &#39;MnHelloRest&#39; in 36.0s.Additionally, a report’s filename or path can be customized by appending it to the build-report argument.This can be very useful, for example, when creating multiple binaries of the same application using different configurations:native-image -0b --emit build-report=/tmp/application-build-report-default.html -cp . Applicationnative-image -0s --emit build-report=/tmp/application-build-report-size-optimized.html -cp . ApplicationReport StructureEvery report page consists of multiple sections, or tabs, each displaying the data corresponding to their title.The Summary section is initially shown, and there are also Code Area, Image Heap, Resources, Software Bill of Materials (SBOM), and PGO Sampling Profile (only in PGO builds) sections.Each section is described in detail the following subsections.SummaryThe Summary section provides a general overview of the build.The section consists of four subsections that correspond to a stage in the build process or provide additional useful information:  Environment provides the information about the environment used in the build (Java version, GraalVM version, Graal compiler configuration, and so on).  Analysis Results displays the results of the points-to analysis (Types, Fields, and Methods) grouped by category (Reachable, Reflection, JNI, and Loaded).  Image Details gives an overview of the contents of the binary. The chart visualizes how different parts of the binary (Code area, Image heap, Debug info, and Other data) relate to each other in terms of their size.  Security Report reports various kinds of security-related information about the build (Deserialization, Embedded SBOM, and Backwards-Edge Control-Flow Integrity (CFI)).  Resource Usage provides additional information about the resources used for the build (Garbage collection, Peak RSS, and CPU load) as well as total time spent generating the binary.  Note: Hover over each bar in Image Details to see more information.Also, click the Code Area and Image Heap bars to link to their respective sections.All this information is also available in JSON format and can be downloaded by clicking Download as JSON at top-right of the page.Code AreaThe Code Area section provides an in-depth view of code found reachable after the static analysis.It consists of two interconnected parts: a breakdown chart and list of packages and classes.Method-Based BreakdownThe code area of the binary is broken down by packages on fine-grained method-level.The breakdown considers only reachable methods found by the points-to analysis.It is visualized in the form of a sunburst chart: a hierarchical multi-level pie chart.The chart displays how different packages (and classes) relate to each other.The ratios are calculated based on either cumulative method bytecode size (by default) or total number of methods.This can be selected using the Breakdown type drop-down list at the top-right of the page.  Note: A fixed threshold is used to limit the amount of data shown on the chart (0.1 of total percentage relative to the current root package).The threshold only applies to the breakdown chart, whereas the table underneath contains the complete list of packages and classes (on the current level).The percentages (shown in every package arc) represent the relationship between sibling packages.All the percentages are calculated relative to the root package (abstract Total package for the top-level view, and arbitrary package when drilled-down to it).Additionally, concrete values for specific packages (either its method bytecode size or total method count) can be seen by hovering over that package arc.The most important functionality of this breakdown is the ability to deeply explore the relationships for an arbitrary package.This can be simply achieved by clicking any package of interest (that has at least one child package or class).The reverse operation of going back one level to the parent package is similarly achieved by clicking on the “root” package (in the center of the chart).It is also possible to go back to any package in the drill-down chain (from Total to the current package).This is simply achieved by clicking the particular package in the drill-down chain displayed right above the chart.Also, the breakdown chart and the list of packages and classes are synchronized — every drill-down simultaneously updates the table below and vice versa.List of Packages and ClassesThe list of packages and classes serves as an extension to the main breakdown.It lists every package and class that is part of the selected package (Total initially).The table also shows all the information about each package and class: its method bytecode size (or total method count) as well as its relative percentage.Packages that have children (at least one package or class) are shown as links.Click on a link to drill-down in the breakdown chart — they are synchronized.Similarly, the reverse can be achieved by clicking ↑ (shown in the first row) which goes back one level (to the parent package).  Note: Only the direct descendants of the selected package are listed (and updates with each drill-down).Image HeapThe object heap of the binary is broken down and grouped by object type (similar to the Image Heap table in CLI Build Output).The main difference is that Build Report shows a complete list of object types along with more detailed information such as their counts, sizes, and relative percentages (visualized in the form of progress bars).One common use case for the full list is to determine if any instances of a specific class are a part of the image heap (using Find in page).ResourcesThe Resources tab can be used to explore the Java resources included in the native image, their origin, and how their size contributes to the overall image size.This is useful, for example, to detect resources that are accidentally included or missing due to incorrect reachability metadata.All the resources are listed in the main table.By default, the resources that are explicitly requested through configuration file(s) are shown.Additionally, there are three more kinds of resources that are provided:  Missing resources were requested through configuration files(s), but did not exist on the system.  Injected resources were registered programmatically through the GraalVM SDK (typically used by a framework to assist Native Image compilation).  Directory resources are special type of resources that represent directories (typically small as they only contain the names of files and directories within that directory).Each of resource kind can be shown in the table via its corresponding checkbox.Resources in the table can be filtered by their name using the search box on the top-left.Furthermore, the list can be sorted by any of the resource attributes (using the dedicated &amp;amp;updownarrow; sorting button in the table header).Software Bill of Materials (SBOM)A Software Bill of Materials represents an inventory of all the artifacts involved in building the final binary.Each artifact is uniquely identified by its fully-qualified name (organization name + artifact name) and its specific version.All the artifacts used in the build are listed in the table.All of this information is also available as JSON in the CycloneDX format and can be downloaded by clicking Download as JSON.PGO Sampling ProfileThe PGO Sampling Profile is a section that is only present in reports generated when building PGO-optimized binaries.This section is described in detail in its dedicated PGO guide - Inspecting a Profile in a Build Report.Dynamic AccessDynamic access refers to all method calls and operations that require reachability metadata to function correctly in a native image. This includes reflection, resource access, serialization, and native calls. GraalVM 25 introduces an experimental reporting feature to help you identify dynamic access (such as reflection) before it causes runtime issues. When you build with both -H:+ReportDynamicAccess and --emit=build-report, the Native Image build report includes a Dynamic Access tab that highlights reflective usage present in the image.After building your application, open the generated report (for example, target/[x]-build-report.html) and navigate to the Dynamic Access tab to review dynamic access usage.This section of the report highlights code that may require review to ensure your application runs successfully as a native executable. For example, classes loaded via Class.forName(...) must be included in the executable.Understanding the Dynamic Access Tab  If no dynamic calls are detected for a class or module path entry, no further action is needed.  If another entry provides metadata for this entry, no further investigation is needed.  If the entry includes native-image.properties or reachability-metadata.json, or these files are provided externally, no further investigation is required.  If integrated configuration or external metadata (such as reflect-config.json) exists for each detected call type, no further investigation is required.  If none of the above apply, the entry may require further investigation.For each entry with detected dynamic calls, you can expand the entry in the report to see the specific methods and their call locations. The report also provides links to configuration files, whether they are packaged in JARs or available in directories.  Only dynamic calls found in reachable code are reported. Some entries may have existing metadata but no reported dynamic calls.Dynamic Access MetadataThe Dynamic Access tab uses a dynamic-access-metadata.json file that maps which classpath entries provide reachability metadata for other entries. Place this file on your classpath for the Build Report to automatically discover metadata relationships between different classpath entries.The schema includes the following keys:  metadataProvider: The absolute path to the JAR or directory that provides reachability metadata  providesFor: An array of classpath entries that receive metadata from this providerFor the complete JSON schema specification, see the dynamic-access-metadata-schema-v1.0.0.json file.The Build Report uses this information to create a comprehensive view of metadata relationships and highlight potential coverage gaps.For a practical demonstration of running and using the -H:+ReportDynamicAccess option, see the preserve-package demo.Related Documentation  Native Image Build Output  Inspecting a Profile in a Build Report  Native Image Build Overview  Debugging and Diagnostics",
          "url": " /latest/reference-manual/native-image/overview/build-report/"
          },
          
          "latest-reference-manual-native-image-overview-bundles":  {
          "title": "Native Image Bundles",
          "content": "Native Image BundlesNative Image provides a feature that enables users to build native executables from a self-contained bundle. In contrast to regular native-image building, this mode of operation takes only a single *.nib file as input.The file contains everything required to build a native executable (or a native shared library).This can be useful when large applications consisting of many input files (JAR files, configuration files, auto-generated files, downloaded files) need to be rebuilt at a later point in time without worrying whether all files are still available.Often complex builds involve downloading many libraries that are not guaranteed to remain accessible later in time.Using Native Image bundles is a safe solution to encapsulate all this input required for building into a single file.  Note: The feature is experimental.Table of Contents  Creating Bundles  Building with Bundles  Capturing Environment Variables  Creating New Bundles from Existing Bundles  Executing a Bundled Application  Bundle File FormatCreating BundlesTo create a bundle, pass the --bundle-create option along with the other arguments for a specific native-image command line invocation.This will cause native-image to create a *.nib file in addition to the actual image.Here is the option description:--bundle-create[=new-bundle.nib][,dry-run][,container[=&amp;lt;container-tool&amp;gt;][,dockerfile=&amp;lt;Dockerfile&amp;gt;]]                      in addition to image building, create a Native Image bundle file (*.nib                      file) that allows rebuilding of that image again at a later point. If a                      bundle-file gets passed, the bundle will be created with the given                      name. Otherwise, the bundle-file name is derived from the image name.                      Note both bundle options can be extended with &quot;,dry-run&quot; and &quot;,container&quot;                      * &#39;dry-run&#39;: only perform the bundle operations without any actual image building.                      * &#39;container&#39;: sets up a container image for image building and performs image building                        from inside that container. Requires podman or rootless docker to be installed.                        If available, &#39;podman&#39; is preferred and rootless &#39;docker&#39; is the fallback. Specifying                        one or the other as &#39;=&amp;lt;container-tool&amp;gt;&#39; forces the use of a specific tool.                      * &#39;dockerfile=&amp;lt;Dockerfile&amp;gt;&#39;: Use a user provided &#39;Dockerfile&#39; instead of the default based on                        Oracle Linux 8 base images for GraalVM (see https://github.com/graalvm/container)Creating Bundles with MavenAssuming a Java application is built with Maven, pass the --bundle-create as a build argument in the Maven plugin for Native Image building configuration:&amp;lt;plugin&amp;gt;  &amp;lt;groupId&amp;gt;org.graalvm.buildtools&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;native-maven-plugin&amp;lt;/artifactId&amp;gt;  &amp;lt;configuration&amp;gt;      &amp;lt;buildArgs combine.children=&quot;append&quot;&amp;gt;          &amp;lt;buildArg&amp;gt;--bundle-create&amp;lt;/buildArg&amp;gt;      &amp;lt;/buildArgs&amp;gt;  &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;Then, run the Maven package command:./mvnw -Pnative native:compile  Note: The command to create a native executable with Maven for a Micronaut project is: ./mvnw package -Dpackaging=native-image.You get the following build artifacts:Finished generating &#39;application&#39; in 2m 0s.Native Image Bundles: Bundle build output written to /application/target/application.outputNative Image Bundles: Bundle written to /application/target/application.nibThis output indicates that you have created a native executable, application, and a bundle, application.nib.The bundle file is created in the target/ directory.It should be copied to some safe place where it can be found if the native executable needs to be rebuilt later.Creating Bundles with GradleAssuming a Java application is built with Gradle, pass the --bundle-create as a build argument in the Gradle plugin for Native Image building configuration:graalvmNative {    binaries {        main {            buildArgs.add(&quot;--bundle-create&quot;)        }    }}Then, run the Gradle build command:./gradlew nativeCompileYou get the following build artifacts:Finished generating &#39;application&#39; in 2m 0s.Native Image Bundles: Bundle build output written to /application/build/native/nativeCompile/application.outputNative Image Bundles: Bundle written to /application/build/native/nativeCompile/application.nibThis output indicates that you have created a native executable, application, and a bundle, application.nib.The bundle file is created in the build/native/nativeCompile/ directory.Bundle File and Output DirectoryObviously, a bundle file can be large because it contains all input files as well as the executable itself (the executable is compressed within the bundle). Having the native image inside the bundle allows comparing a native executable rebuilt from the bundle against the original one.A bundle is just a JAR file with a specific layout. This is explained in detail below.To see what is inside a bundle, run:jar tf application.nibNext to the bundle, you can also find the output directory: application.output.It contains the native executable and all other files that were created as part of the build. Since you did not specify any options that would produce extra output (for example, -g to generate debugging information or --diagnostics-mode), only the executable can be found there.Combining –bundle-create with dry-runAs mentioned in the --bundle-create option description, it is also possible to let native-image build a bundle but not actually create the image.This might be useful if a user wants to move the bundle to a more powerful machine and build the image there.Modify the --bundle-create argument in the Maven / Gradle Native Image plugin configuration above to &amp;lt;buildArg&amp;gt;--bundle-create,dry-run&amp;lt;/buildArg&amp;gt;.Then building a project takes only seconds and the created bundle is much smaller. For example, check the contents of target/application.nib and notice that the executable is not included:jar tf application.nibMETA-INF/MANIFEST.MFMETA-INF/nibundle.properties...Note that this time you do not see the following message in the Maven output:Native Image Bundles: Bundle build output written to /application/target/application.outputSince no executable is created, no bundle build output is available.Building with BundlesAssuming that the native executable is used in production and once in a while, an unexpected exception is thrown at run time.Since you still have the bundle that was used to create the executable, it is trivial to build a variant of that executable with debugging support.Use --bundle-apply=application.nib like this:native-image --bundle-apply=application.nib -gAfter running this command, the executable is rebuilt from the bundle with debug info enabled.The full option help of --bundle-apply shows a more advanced use case that will be discussed later in detail:--bundle-apply=some-bundle.nib[,dry-run][,container[=&amp;lt;container-tool&amp;gt;][,dockerfile=&amp;lt;Dockerfile&amp;gt;]]                      an image will be built from the given bundle file with the exact same                      arguments and files that have been passed to native-image originally                      to create the bundle. Note that if an extra --bundle-create gets passed                      after --bundle-apply, a new bundle will be written based on the given                      bundle arguments plus any additional arguments that have been passed                      afterwards. For example:                      &amp;gt; native-image --bundle-apply=app.nib --bundle-create=app_dbg.nib -g                      creates a new bundle app_dbg.nib based on the given app.nib bundle.                      Both bundles are the same except the new one also uses the -g option.Building in a ContainerAnother addition to the --bundle-create and --bundle-apply options is to perform image building inside a container image.This ensures that during the image build native-image can not access any resources that were not explicitly specified via the class path or module path.Modify the --bundle-create argument in the Maven / Gradle Native Image plugin configuration above to &amp;lt;buildArg&amp;gt;--bundle-create,container&amp;lt;buildArg&amp;gt;.This still creates the same bundle as before. However, a container image is built and then used for building the native executable.If the container image is newly created, you can also see the build output from the container tool. The name of the container image is the hash of the used Dockerfile.If the container image already exists you will see the following line in the build output instead:Native Image Bundles: Reusing container image c253ca50f50b380da0e23b168349271976d57e4e.For building in a container you require either podman or rootless docker to be available on your system.  Building in a container is currently only supported for Linux. Using any other OS native image will not create and use a container image.The container tool used for running the image build can be specified with &amp;lt;buildArg&amp;gt;--bundle-create,container=podman&amp;lt;buildArg&amp;gt; or &amp;lt;buildArg&amp;gt;--bundle-create,container=docker&amp;lt;buildArg&amp;gt;.If not specified, native-image uses one of the supported tools. If available, podman is preferred and rootless docker is the fallback.The Dockerfile used to build the container image may also be explicitly specified with --bundle-create,container,dockerfile=&amp;lt;path-to-dockerfile&amp;gt;.If no Dockerfile was specified, a default Dockerfile is used, which is based on the Oracle Linux 8 container images for GraalVM from here.Whichever Dockerfile is finally used to build the container image is stored in the bundle.Even if you do not use the container option, native-image creates a Dockerfile and stores it in the bundle.Other than creating a container image on the host system, building inside a container does not create any additional build output.However, the created bundle contains some additional files:jar tf application.nibMETA-INF/MANIFEST.MFMETA-INF/nibundle.properties...input/stage/path_substitutions.jsoninput/stage/path_canonicalizations.jsoninput/stage/build.jsoninput/stage/run.jsoninput/stage/environment.jsoninput/stage/Dockerfileinput/stage/container.jsonThe bundle contains the Dockerfile used for building the container image and stores the used container tool, its version and the name of the container image in container.json. For example:{    &quot;containerTool&quot;:&quot;podman&quot;,    &quot;containerToolVersion&quot;:&quot;podman version 3.4.4&quot;,    &quot;containerImage&quot;:&quot;c253ca50f50b380da0e23b168349271976d57e4e&quot;}The container option may also be combined with dry-run, in this case native-image does neither create an executable nor a container image.It does not even check if the selected container tool is available.In this case, container.json is omitted, or, if you explicitly specified a container tool, just contains the containerTool field without any additional information.Containerized builds are sticky, which means that if a bundle was created with --bundle-create,container the bundle is marked as a container build.If you now use --bundle-apply with this bundle, it is automatically built in a container again.However, this does not apply to executing a bundle, a bundled application is still executed outside a container by default.The extended command line interface for containerized builds is shown in the option help texts for --bundle-create and --bundle-apply above.Capturing Environment VariablesBefore bundle support was added, all environment variables were visible to the  native-image builder.This approach does not work well with bundles and is problematic for image building without bundles.Consider having an environment variable that holds sensitive information from your build machine.Due to Native Image’s ability to run code at build time that can create data to be available at run time, it is very easy to build an image where you accidentally leak the contents of such variables.Passing environment variables to native-image now requires explicit arguments.Suppose a user wants to use an environment variable (for example, KEY_STORAGE_PATH) from the environment in which the native-image tool is invoked, in the class initializer that is set to be initialized at build time.To allow accessing the variable in the class initializer (with java.lang.System.getenv), pass the option -EKEY_STORAGE_PATH to the builder.To make an environment variable accessible to build time, use:-E&amp;lt;env-var-key&amp;gt;[=&amp;lt;env-var-value&amp;gt;]                      allow native-image to access the given environment variable during                      image build. If the optional &amp;lt;env-var-value&amp;gt; is not given, the value                      of the environment variable will be taken from the environment                      native-image was invoked from.Using -E works as expected with bundles.Any environment variable specified with -E will be captured in the bundle.For variables where the optional &amp;lt;env-var-value&amp;gt; is not given, the bundle would capture the value the variable had at the time the bundle was created.The prefix -E was chosen to make the option look similar to the related -D&amp;lt;java-system-property-key&amp;gt;=&amp;lt;java-system-property-value&amp;gt; option (which makes Java system properties available at build time).Combining –bundle-create and –bundle-applyAs already mentioned in Building with Bundles, it is possible to create a new bundle based on an existing one.The --bundle-apply help message has a simple example.A more interesting example arises if an existing bundle is used to create a new bundle that builds a PGO-optimized version of the original application.Assuming you have already built your application into a bundle named application.nib.To produce a PGO-optimized variant of that bundle, first build a variant of the native executable that generates PGO profiling information at run time (you will use it later):native-image --bundle-apply=application.nib --pgo-instrumentNow run the generated executable so that profile information is collected:./target/applicationOnce completed, stop the application.Looking into the current working directory, you can find a new file, default.iprof. It contains the profiling information that was created because you ran the application from the executable built with --pgo-instrument.Now you can create a new optimized bundle out of the existing one:native-image --bundle-apply=application.nib --bundle-create=application-pgo-optimized.nib,dry-run --pgoNow take a look how application-pgo-optimized.nib is different from application.nib:$ ls -lh *.nib-rw-r--r-- 1 testuser testuser  20M Mar 28 11:12 application.nib-rw-r--r-- 1 testuser testuser  23M Mar 28 15:02 application-pgo-optimized.nibThe new bundle should be larger than the original.The reason, as can be guessed, is that now the bundle contains the default.iprof file.Using a tool to compare directories, you can inspect the differences in detail.As you can see that application-pgo-optimized.nib contains default.iprof in the directory input/auxiliary, and there are also changes in other files. The contents of META-INF/nibundle.properties, input/stage/path_substitutions.json and input/stage/path_canonicalizations.json will be explained later. For now, look at the diff in build.json:@@ -4,5 +4,6 @@   &quot;--no-fallback&quot;,   &quot;-H:Name=application&quot;,   &quot;-H:Class=example.com.Application&quot;,-  &quot;--no-fallback&quot;+  &quot;--no-fallback&quot;,+  &quot;--pgo&quot;As expected, the new bundle contains the --pgo option that you passed to native-image to build an optimized bundle.Building a native executable from this new bundle generates a PGO-optimized executable out of the box (see PGO: on in build output):native-image --bundle-apply=application-pgo-optimized.nibExecuting a Bundled ApplicationAs described later in Bundle File Format, a bundle file is a JAR file with a contained launcher for launching the bundled application.This means you can use a native image bundle with any JDK and execute it as a JAR file with &amp;lt;jdk&amp;gt;/bin/java -jar [bundle-file.nib].The launcher uses the command line arguments stored in run.json and adds all JAR files and directories in input/classes/cp/ and input/classes/p/ to the class path and module path, respectively.The launcher also comes with a separate command-line interface described in its help text:This native image bundle can be used to launch the bundled application.Usage: java -jar bundle-file [options] [bundle-application-options]where options include:    --with-native-image-agent[,update-bundle[=&amp;lt;new-bundle-name&amp;gt;]]                runs the application with a native-image-agent attached                &#39;update-bundle&#39; adds the agents output to the bundle-files class path.                &#39;=&amp;lt;new-bundle-name&amp;gt;&#39; creates a new bundle with the agent output instead.                Note &#39;update-bundle&#39; requires native-image to be installed    --container[=&amp;lt;container-tool&amp;gt;][,dockerfile=&amp;lt;Dockerfile&amp;gt;]                sets up a container image for execution and executes the bundled application                from inside that container. Requires podman or rootless docker to be installed.                If available, &#39;podman&#39; is preferred and rootless &#39;docker&#39; is the fallback. Specifying                one or the other as &#39;=&amp;lt;container-tool&amp;gt;&#39; forces the use of a specific tool.                &#39;dockerfile=&amp;lt;Dockerfile&amp;gt;&#39;: Use a user provided &#39;Dockerfile&#39; instead of the Dockerfile                bundled with the application    --verbose   enable verbose output    --help      print this help messageRunning the bundled application with the --with-native-image-agent argument requires a native-image-agent library to be available.The output of the native-image-agent is written to _.output/launcher/META-INF/native-image/-agent_.If native image agents output should be inserted into the bundle with `,update-bundle`, the launcher then also requires `native-image`.The `update-bundle` option executes the command `native-image --bundle-apply=.nib --bundle-create=.nib -cp .output/launcher` after executing the bundled application with the `native-image-agent` attached.The container option realizes a similar behavior to containerized image builds.However, the only exception is that in this case the application is executed inside the container instead of native-image.Every bundle contains a Dockerfile which is used for executing the bundled application in a container.However, this Dockerfile can be overwritten by adding ,dockerfile=&amp;lt;path-to-dockerfile&amp;gt; to the --container argument.The bundle launcher only consumes options it knows, all other arguments are passed on to the bundled application.If the bundle launcher parses -- without a specified option, the launcher stops parsing arguments.All remaining arguments are then also passed on to the bundled application.Bundle File FormatA bundle file is a JAR file with a well-defined internal layout.Inside a bundle you can find the following inner structure:[bundle-file.nib]├── META-INF│   ├── MANIFEST.MF│   └── nibundle.properties &amp;lt;- Contains build bundle version info:│                              * Bundle format version (BundleFileVersion{Major,Minor})│                              * Platform and architecture the bundle was created on │                              * GraalVM / Native-image version used for bundle creation├── com.oracle.svm.driver.launcher &amp;lt;- launcher for executing the bundled application├── input &amp;lt;- All information required to rebuild the image│   ├── auxiliary &amp;lt;- Contains auxiliary files passed to native-image via arguments│   │                (for example, external `config-*.json` files or PGO `*.iprof`-files)│   ├── classes   &amp;lt;- Contains all class-path and module-path entries passed to the builder│   │   ├── cp│   │   └── p│   └── stage│       ├── build.json          &amp;lt;- Full native-image command line (minus --bundle options)│       ├── container.json            &amp;lt;- Containerization tool, tool version and container│       │                                image name (not available information is omitted)│       ├── Dockerfile                 &amp;lt;- Dockerfile used for building the container image│       ├── environment.json              &amp;lt;- Environment variables used in the image build│       ├── path_canonicalizations.json  &amp;lt;- Record of path-canonicalizations that happened│       │                                       during bundle creation for the input files│       ├── path_substitutions.json          &amp;lt;- Record of path-substitutions that happened│       │                                       during bundle creation for the input files                                        │       └── run.json            &amp;lt;- Full command line for executing the bundled application│                                                        (minus class path and module path)└── output    ├── default    │   ├── myimage         &amp;lt;- Created image and other output created by the image builder     │   ├── myimage.debug    |   └── sources    └── other      &amp;lt;- Other output created by the builder (not relative to image location)META-INFThe layout of a bundle file itself is versioned.There are two properties in META-INF/nibundle.properties that declare which version of the layout a given bundle file is based on.Bundles currently use the following layout version:BundleFileVersionMajor=0BundleFileVersionMinor=9Future versions of GraalVM might alter or extend the internal structure of bundle files.The versioning enables us to evolve the bundle format with backwards compatibility in mind.Input DataThis directory contains all input data that gets passed to the native-image builder. The file input/stage/build.json holds the original command line that was passed to native-image when the bundle was created.Parameters that make no sense to get reapplied in a bundle-build are already filtered out.These include:  --bundle-{create,apply}  --verbose  --dry-runThe state of environment variables that are relevant for the build are captured in input/stage/environment.json.For every -E argument that was seen when the bundle was created, a snapshot of its key-value pair is recorded in the file.The remaining files path_canonicalizations.json and path_substitutions.json contain a record of the file-path transformations that were performed by the native-image tool based on the input file paths as specified by the original command line arguments.Output DataIf a native executable is built as part of building the bundle (for example, the dry-run option was not used), you also have an output directory in the bundle.It contains the executable that was built along with any other files that were generated as part of building.Most output files are located in the directory output/default (the executable, its debug info, and debug sources).Builder output files, that would have been written to arbitrary absolute paths if the executable had not been built in the bundle mode, can be found in output/other.Related Documentation  Native Image Build Configuration  Native Image Build Output",
          "url": " /latest/reference-manual/native-image/overview/Bundles/"
          },
          
          "latest-reference-manual-native-image-native-code-interoperability-c-api":  {
          "title": "Native Image C API",
          "content": "Native Image C APINative Image provides a GraalVM-specific API to manage Java objects from the C/C++ languages, initialize isolates and attach threads.The C API is available when Native Image is built as a shared library and its declarations are included in the header file that is generated during the native image build./* * Structure representing an isolate. A pointer to such a structure can be * passed to an entry point as the execution context. */struct __graal_isolate_t;typedef struct _graal_isolate_t graal_isolate_t;/* * Structure representing a thread that is attached to an isolate. A pointer to * such a structure can be passed to an entry point as the execution context, * requiring that the calling thread has been attached to that isolate. */struct __graal_isolatethread_t;typedef struct __graal_isolatethread_t graal_isolatethread_t;/* Parameters for the creation of a new isolate. */struct __graal_create_isolate_params_t {    /* for future use */};typedef struct __graal_create_isolate_params_t graal_create_isolate_params_t;/* * Create a new isolate, considering the passed parameters (which may be NULL). * Returns 0 on success, or a non-zero value on failure. * On success, the current thread is attached to the created isolate, and the * address of the isolate and the isolate thread structures is written to the * passed pointers if they are not NULL. */int graal_create_isolate(graal_create_isolate_params_t* params, graal_isolate_t** isolate, graal_isolatethread_t** thread);/* * Attaches the current thread to the passed isolate. * On failure, returns a non-zero value. On success, writes the address of the * created isolate thread structure to the passed pointer and returns 0. * If the thread has already been attached, the call succeeds and also provides * the thread&#39;s isolate thread structure. */int graal_attach_thread(graal_isolate_t* isolate, graal_isolatethread_t** thread);/* * Given an isolate to which the current thread is attached, returns the address of * the thread&#39;s associated isolate thread structure.  If the current thread is not * attached to the passed isolate or if another error occurs, returns NULL. */graal_isolatethread_t* graal_get_current_thread(graal_isolate_t* isolate);/* * Given an isolate thread structure, determines to which isolate it belongs and * returns the address of its isolate structure. If an error occurs, returns NULL * instead. */graal_isolate_t* graal_get_isolate(graal_isolatethread_t* thread);/* * Detaches the passed isolate thread from its isolate and discards any state or * context that is associated with it. At the time of the call, no code may still * be executing in the isolate thread&#39;s context. * Returns 0 on success, or a non-zero value on failure. */int graal_detach_thread(graal_isolatethread_t* thread);/* * Tears down the isolate of the passed (and still attached) isolate thread * waiting for any attached threads to detach from it, then discards its objects, * threads, and any other state or context that is associated with it. * Returns 0 on success, or a non-zero value on failure. */int graal_tear_down_isolate(graal_isolatethread_t* thread);In addition to the C level API, you can use the JNI Invocation API to create an isolate from Java, expose and call Java methods embedded in a native shared library.Related Documentation  Build a Native Shared Library  Interoperability with Native Code  JNI Invocation API",
          "url": " /latest/reference-manual/native-image/native-code-interoperability/C-API/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-certificatemanagement":  {
          "title": "Certificate Management in Native Image",
          "content": "Certificate Management in Native ImageNative Image provides multiple ways to specify the certificate file used to define the default TrustStore.In the following sections we describe the available build-time and run-time options.Note: The default behavior for native-image is to capture and use the default TrustStore from the build-time host environment.Build-time OptionsDuring the image building process, the native-image builder captures the host environment’s default TrustStore and embeds it into the native executable.This TrustStore is by default created from the root certificate file provided within the JDK, but can be changed to use a different certificate file by setting the build-time system property javax.net.ssl.trustStore (see Properties for how to do it).Since the contents of the build-time certificate file is embedded into the native executable, the file itself does not need to be present in the target environment.Runtime OptionsThe certificate file can also be changed dynamically at run time via setting the javax.net.ssl.trustStore* system properties.If any of the following system properties are set during the image execution, native-image also requires javax.net.ssl.trustStore to be set, and for it to point to an accessible certificate file:  javax.net.ssl.trustStore  javax.net.ssl.trustStoreType  javax.net.ssl.trustStoreProvider  javax.net.ssl.trustStorePasswordIf any of these properties are set and javax.net.ssl.trustStore does not point to an accessible file, then an UnsupportedFeatureError will be thrown.Note that this behavior is different than OpenJDK.When the javax.net.ssl.trustStore system property is unset or invalid, OpenJDK will fallback to using a certificate file shipped within the JDK.However, such files will not be present alongside the image executable and hence cannot be used as a fallback.During the execution, it also possible to dynamically change the javax.net.ssl.trustStore* properties and for the default TrustStore to be updated accordingly.Finally, whenever all of the javax.net.ssl.trustStore* system properties listed above are unset, the default TrustStore will be the one captured during the build time, as described in the prior section.Untrusted CertificatesDuring the image building process, a list of untrusted certificates is loaded from the file &amp;lt;java.home&amp;gt;/lib/security/blacklisted.certs.This file is used when validating certificates at both build time and run time.In other words, when a new certificate file is specified at run time via setting the javax.net.ssl.trustStore* system properties, the new certificates will still be checked against the &amp;lt;java.home&amp;gt;/lib/security/blacklisted.certs loaded atimage build time.Further Reading  Native Image Build Configuration",
          "url": " /latest/reference-manual/native-image/dynamic-features/CertificateManagement/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-classinitialization":  {
          "title": "Class Initialization in Native Image",
          "content": "Class Initialization in Native ImageThe semantics of Java requires that a class is initialized the first time it is accessed at runtime.Class initialization has negative consequences for compiling Java applications ahead-of-time for the following two reasons:  It significantly degrades the performance of a native executable: every access to a class (via a field or method) requires a check to ensure the class is already initialized. Without optimization, this can reduce performance by more than twofold.  It increases the amount of computation—and time—to start up an application. For example, the simple “Hello, World!” application requires more than 300 classes to be initialized.To reduce the negative impact of class initialization, Native Image supports class initialization at build time: it can initialize classes when it builds an executable, making runtime initialization and checks unnecessary.All the static state from initialized classes is stored in the executable.Access to a class’s static fields that were initialized at build time is transparent to the application and works as if the class was initialized at runtime.However, Java class initialization semantics impose several constraints that complicate class initialization policies, such as:  When a class is initialized, all its superclasses and superinterfaces with default methods must also be initialized.Interfaces without default methods, however, are not initialized.To accommodate this requirement, a short-term “relevant supertype” is used, as well as a “relevant subtype” for subtypes of classes and interfaces with default methods.  Relevant supertypes of types initialized at build time must also be initialized at build time.  Relevant subtypes of types initialized at runtime must also be initialized at runtime.  No instances of classes that are initialized at runtime must be present in the executable.To enjoy the complete out-of-the-box experience of Native Image and still get the benefits of build-time initialization, Native Image does two things:  Build-Time Initialization  Automatic Initialization of Safe ClassesTo track which classes were initialized and why, pass the command-line option -H:+PrintClassInitialization to the native-image tool.This option helps you configure the native image builder to work as required.The goal is to have as many classes as possible initialized at build time, yet keep the correct semantics of the application.Build-Time InitializationNative Image initializes most JDK classes at build time, including the garbage collector, important JDK classes, and the deoptimizer.For all of the classes that are initialized at build time, Native Image gives proper support so that the semantics remain consistent despite class initialization occurring at build time.If you discover an issue with a JDK class behaving incorrectly because of class initialization at build time, please report an issue.Automatic Initialization of Safe ClassesFor application classes, Native Image tries to find classes that can be safely initialized at build time.A class is considered safe if all of its relevant supertypes are safe and if the class initializer does not call any unsafe methods or initialize other unsafe classes.A method is considered unsafe if:  It transitively calls into native code (such as System.out.println): native code is not analyzed so Native Image cannot know if illegal actions are performed.  It calls a method that cannot be reduced to a single target (a virtual method).This restriction avoids the explosion of search space for the safety analysis of static initializers.  It is substituted by Native Image. Running initializers of substituted methods would yield different results in the hosting Java Virtual Machine (JVM) than in the produced executable.As a result, the safety analysis would consider some methods safe but calling them would lead to illegal states.The list of all classes that are proven safe is output to a file via the -H:+PrintClassInitialization command-line option to the native-image tool.  Note: You can also Specify Class Initialization Explicitly.Related Documentation  Native Image Basics  Native Image Compatibility Guide  Specify Class Initialization Explicitly",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/ClassInitialization/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-closeongc":  {
          "title": "Automatic Close of Unreachable Context and Engine Objects in Polyglot API",
          "content": "Automatic Close of Unreachable Context and Engine Objects in Polyglot APIAs of Polyglot version 24.2.0, Context and Engine objects are automatically closed when they are no longer strongly referenced.This feature ensures that unreachable Context and Engine instances are correctly cleaned up to minimize memory leaks.However, it remains highly recommended to manage the lifecycle of Context and Engine explicitly, ideally using a try-with-resources statement, rather than relying on garbage collection for this purpose.Context Lifecycle ManagementA Context instance is eligible for automatic closure when no strong references to it remain. These references can include the following:  Direct strong references to the Context object.  Strong references to objects bound to the Context, such as Value and PolyglotException instances.  Active polyglot threads or any host thread that has explicitly entered the Context. A Context that is explicitly entered will not be garbage-collected until it is explicitly left.  Inner Context objects, as inner contexts prevent their parent contexts from being closed if they remain reachable.When any of these conditions hold, the Context instance remains active and will not be garbage-collected and closed.The presence of active system threads does not prevent a Context from being closed.Engine Lifecycle ManagementThe Engine object follows a similar approach to lifecycle management.An Engine will only be closed when it no longer has any strong references to it, such as:  Direct references to the Engine.  Strong references to Language, Instrument, or ExecutionListener instances that were obtained from the Engine.Furthermore, an Engine cannot be closed if there is an active Context within it or if any Context objects that uses this Engine remain reachable.Similar to Context objects, the presence of active system threads does not interfere with the automatic closure of an Engine.TruffleContext and Inner ContextsIn scenarios where a language implementation creates inner contexts using TruffleLanguage.Env.newInnerContextBuilder(), both the Polyglot API Context representing this inner context and the TruffleContext must be unreachable to enable automatic closure.This situation is illustrated in the diagram below, showing an engine with one top-level context and one inner context. Strong references are represented by solid lines, and weak references by dashed lines.When an inner Context is no longer referenced by the embedder, and the corresponding TruffleContext instance is no longer referenced by its language implementation, weak references from PolyglotContext to Context and TruffleContext are added to a reference queue.During the next lifecycle event (such as when a new context is created or closed), this queue is processed, and any unreachable context is closed automatically.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/CloseOnGc/"
          },
          
          "latest-reference-manual-native-image-contributing-codestyle":  {
          "title": "Native Image Code Style",
          "content": "Native Image Code StyleTo ensure the quality of code and that all contributors follow the same standards, we established a ruleset that grew over time and proved to be useful. Note that the rules are open for discussion!Source Code FormattingThe IDE projects generated with mx ideinit are configured with strict formatting rules.In Eclipse, when a file is saved, it is automatically formatted according to these rules.The configuration includes special comments which can be used to relax checks in particular regions of code.Source code formatting can be disabled with special comments://@formatter:off//@formatter:onComment reformatting can be disabled like this:/*- * */Checks with CheckstyleCheckstyle is used to verify adherence to the style rules.It can be run manually with mx checkstyle.The default Checkstyle rules are defined in src/com.oracle.svm.core/.checkstyle_checks.xml and define various special comments, including//Checkstyle: stop method name check//Checkstyle: resume method name checkand similar commands for other checks that can be disabled (including general stop and resume commands).Of course, ensuring a reasonable use of these comments is a matter for code review.If a project requires a different set of Checkstyle rules, this can be specified in mx.substratevm/suite.py by changing the value of the project’s checkstyle attribute (which, by default, references com.oracle.svm.core).Specific code files can be excluded from checkstyle on a directory granularity with a file src/&amp;lt;project name&amp;gt;/.checkstyle.exclude.Such an exclusion file must contain one directory per line, with paths relative to the project root.The file must be explicitly added with git add because git will ignore it by default.When pulling a changeset which adds or removes Checkstyle XML files, the IDE might show inappropriate style warnings or errors.This is resolved by running mx ideinit and cleaning the affected projects.IDE IntegrationIDE plugins can be helpful in adhering to style rules.Some examples are:  Eclipse Checkstyle Plugin: reports Checkstyle violations in Eclipse, making it unnecessary to run mx checkstyle manually.  IntelliJ Eclipse Code Formatter: formats source files in IntelliJ according to Eclipse IntelliJ rules. This plugin is automatically configured by mx ideinit.  IntelliJ Save Actions to automatically format files before saving them.See the documentation on IDE integration for further suggestions.",
          "url": " /latest/reference-manual/native-image/contributing/CodeStyle/"
          },
          
          "latest-reference-manual-llvm-compatibility":  {
          "title": "LLVM Compatibility",
          "content": "LLVM CompatibilityGraalVM supports LLVM bitcode versions 4.0 to 12.0.1.It is recommended to use the LLVM toolchain shipped with GraalVM.Optimizations FlagsIn contrast to the static compilation model of LLVM languages, in GraalVM the machine code is not directly produced from the LLVM bitcode.There is an additional dynamic compilation step by the Graal compiler.First, the LLVM frontend (for example, clang) performs optimizations on the bitcode level, and then the Graal compiler does its own optimizations on top of that during dynamic compilation.Some optimizations are better when done ahead-of-time on bitcode, while other optimizations are better left for the dynamic compilation of the Graal compiler, when profiling information is available.The LLVM toolchain that is shipped with GraalVM automatically selects the recommended flags by default.Generally, all optimization levels should work, but for a better result, it is recommended to compile the bitcode with the optimization level -O1.For cross-language interoperability, the -mem2reg optimization is required.There are two ways to get that: either compile with at least -O1, or use the opt tool to apply the -mem2reg optimization manually.",
          "url": " /latest/reference-manual/llvm/Compatibility/"
          },
          
          "latest-reference-manual-native-image-metadata-compatibility":  {
          "title": "Native Image Compatibility Guide",
          "content": "Native Image Compatibility GuideNative Image uses a different way of compiling a Java application than the traditional Java virtual machine (VM).It distinguishes between build time and run time.At the image build time, the native-image builder performs static analysis to find all the methods that are reachable from the entry point of an application.The builder then compiles these (and only these) methods into an executable binary.Because of this different compilation model, a Java application can behave somewhat differently when compiled into a native image.Native Image provides an optimization to reduce the memory footprint and startup time of an application.This approach relies on a “closed-world assumption” in which all code is known at build time. That is, no new code is loaded at run time.As with most optimizations, not all applications are amenable to this approach.If the native-image builder is unable to optimize an application at build time, it generates a so-called “fallback file” that requires a Java VM to run.We recommend to check Native Image Basics for a detailed description what happens with your Java application at build and run times.Features Requiring MetadataTo be suitable for closed-world assumption, the following Java features generally require metadata to pass to native-image at build time. This metadata ensures that a native image uses the minimum amount of space necessary.The compatibility of Native Image with the most popular Java libraries was recently enhanced by publishing shared reachability metadata on GitHub. The users can share the burden of maintaining metadata for third-party dependencies and reuse it.See Reachability Metadata to learn more.Features Incompatible with Closed-World AssumptionSome Java features are not yet supported within the closed-world assumption, and if used, result in a fallback file.invokedynamic Bytecode and Method HandlesUnder the closed-world assumption, all methods that are called and their call sites must be known.The invokedynamicmethod and method handles can introduce calls at run time or change the method that is invoked.Note that invokedynamic use cases generated by javac for, for example, Java lambda expressions and String concatenation that are supported because they do not change called methods at run time.Features That May Operate Differently in a Native ImageNative Image implements some Java features differently to the Java VM.Security Managerjava.lang.System#getSecurityManager() always returns null even if the security manager is set via -Djava.security.manager at startup.java.lang.System#setSecurityManager(SecurityManager) invoked with a non-null argument throws a java.lang.SecurityException if -Djava.security.manager is set to anything but disallow at program startup.Class InitializersBy default, classes are initialized at run time.This ensures compatibility, but limits some optimizations.For faster startup and better peak performance, it is better to initialize classes at build time.Class initialization behavior can be specified using the options --initialize-at-build-time or --initialize-at-run-time for specific classes and packages or for all classes.Classes that are members of the JDK class libraries are initialized by default.Note: Class initialization at build time may break specific assumptions in existing code.For example, files loaded in a class initializer may not be in the same place at build time as at run time.Also, certain objects such as a file descriptors or running threads must not be stored in a native executable.If such objects are reachable at build time, the native image builder fails with an error.For more information, see Class Initialization in Native Image.FinalizersThe Java base class java.lang.Object defines the method finalize().It is called by the garbage collector on an object when garbage collection determines that there are no more references to the object.A subclass can override the finalize() method to dispose of system resources or to perform other cleanup operations.Finalizers have been deprecated since Java SE 9.They are complicated to implement, and have badly designed semantics.For example, a finalizer can cause an object to be reachable again by storing a reference to it in a static field.Therefore, finalizers are not invoked.We recommend you replace finalizers with weak references and reference queues.ThreadsNative Image does not implement long-deprecated methods in java.lang.Thread such as Thread.stop().Unsafe Memory AccessFields that are accessed using sun.misc.Unsafe need to be marked as such for the static analysis if classes are initialized at build time.In most cases, that happens automatically: field offsets stored in static final fields are automatically rewritten from the hosted value (the field offset for the Java VM on which the native image builder is running) to the native executable value, and as part of that rewrite the field is marked as Unsafe-accessed.For non-standard patterns, field offsets can be recomputed manually using the annotation RecomputeFieldValue.Debugging and MonitoringJava has some optional specifications that a Java implementation can use for debugging and monitoring Java programs, including JVMTI.They help you monitor the Java VM at runtime for events such as compilation, for example, which do not occur in most native images.These interfaces are built on the assumption that Java bytecode is available at run time, which is not the case for native images built with the closed-world optimization.Because the native-image builder generates a native executable, users must use native debuggers and monitoring tools (such as GDB or VTune) rather than tools targeted for Java.JVMTI and other bytecode-based tools are not supported with Native Image.Limitations on Linux AArch64 ArchitectureMostly all Native Image features are supported on Linux AArch64 architecture, except for the limitations described below.  -R:[+|-]WriteableCodeCache: must be disabled.  --libc=&amp;lt;value&amp;gt;: musl is not supported.Find a list of options for the native-image builder here.Related Documentation  Class Initialization in Native Image  Reachability Metadata  GraalVM Reachability Metadata Repository",
          "url": " /latest/reference-manual/native-image/metadata/Compatibility/"
          },
          
          "latest-reference-manual-llvm-compiling":  {
          "title": "Compiling to LLVM Bitcode",
          "content": "Compiling to LLVM BitcodeGraalVM can execute C/C++, Rust, and other languages that can be compiled to LLVM bitcode.As the first step, you have to compile a program to LLVM bitcode using some LLVM compiler front end, for example, clang for C and C++, rust for the Rust programming language, etc.File FormatWhile the GraalVM LLVM runtime can execute plain bitcode files, the preferred format is a native executable with embedded bitcode.The executable file formats differ on Linux and macOS.Linux by default uses ELF files.The bitcode is stored in a section called .llvmbc.The macOS platform uses Mach-O files.The bitcode is in the __bundle section of the __LLVM segment.Using native executables with embedded bitcode offers two advantages over plain bitcode files.First, build systems for native projects, for example a Makefile, expect the result to be an executable.Embedding the bitcode instead of changing the output format improves compatibility with existing projects.Second, executables allow specifying library dependencies which is not possible with LLVM bitcode.The GraalVM LLVM runtime utilizes this information to find and load dependencies.LLVM Toolchain for Compiling C/C++To simplify compiling C/C++ to executables with embedded bitcode, the LLVM runtime comes with a prebuilt LLVM toolchain.The toolchain contains compilers such as clang for C or clang++ for C++, but also other tools that are neededfor building native projects such as a linker (ld), or an archiver (ar) for creating static libraries.  Get the location of the toolchain, using the --print-toolchain-path argument of lli:     ./path/to/bin/lli --print-toolchain-path    Set the LLVM_TOOLCHAIN environment variable:     export LLVM_TOOLCHAIN=$(./path/to/bin/lli --print-toolchain-path)    Then see the content of the toolchain path for a list of available tools:     ls $LLVM_TOOLCHAIN  Use those tools just as you would for native compilation. For example, save this C code in a file named hello.c:#include &amp;lt;stdio.h&amp;gt;int main() {    printf(&quot;Hello from GraalVM!n&quot;);    return 0;}Then you can compile hello.c to an executable with embedded LLVM bitcode as follows:$LLVM_TOOLCHAIN/clang hello.c -o helloThe resulting executable, hello, can be executed on GraalVM using lli:$JAVA_HOME/bin/lli helloExternal Library DependenciesIf the bitcode file depends on external libraries, GraalVM will automatically pick up the dependencies from the binary headers.For example:#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;ncurses.h&amp;gt;int main() {    initscr();    printw(&quot;Hello, Curses!&quot;);    refresh();    sleep(1);    endwin();    return 0;}This hello-curses.c file can be then compiled and run with:$LLVM_TOOLCHAIN/clang hello-curses.c -lncurses -o hello-curseslli hello-cursesRunning C++For running C++ code, the GraalVM LLVM runtime requires the libc++ standard library from the LLVM project.The LLVM toolchain shipped with GraalVM automatically links against libc++.For example, save this code as a hello-c++.cpp file:#include &amp;lt;iostream&amp;gt;int main() {    std::cout &amp;lt;&amp;lt; &quot;Hello, C++ World!&quot; &amp;lt;&amp;lt; std::endl;}Compile it with clang++ shipped with GraalVM and execute:$LLVM_TOOLCHAIN/clang++ hello-c++.cpp -o hello-c++lli hello-c++Hello, C++ World!Running RustThe LLVM toolchain, bundled with GraalVM, does not come with the Rust compiler.To install Rust, run the following in your command prompt, then follow the onscreen instructions:curl https://sh.rustup.rs -sSf | shSave this example Rust code in a hello-rust.rs file:fn main() {    println!(&quot;Hello Rust!&quot;);}This can be then compiled to bitcode with the --emit=llvm-bc flag:rustc --emit=llvm-bc hello-rust.rsTo run the Rust program, we have to tell GraalVM where to find the Rust standard libraries:lli --lib $(rustc --print sysroot)/lib/libstd-* hello-rust.bcHello Rust!Since the Rust compiler is not using the LLVM toolchain shipped with GraalVM, depending on the local Rust installation, an error similar to one of the following might happen:Mismatching target triple (expected x86_64-unknown-linux-gnu, got x86_64-pc-linux-gnu)Mismatching target triple (expected x86_64-apple-macosx10.11.0, got x86_64-apple-darwin)This indicates that the Rust compiler used a different target triple than the LLVM toolchain shipped with GraalVM.In this particular case, the differences are just different naming conventions across Linux distributions or MacOS versions, there is no real difference.In that case, the error can be safely ignored:lli --experimental-options --llvm.verifyBitcode=false --lib $(rustc --print sysroot)/lib/libstd-* hello-rust.bcThis option should only be used after manually verifying that the target triples are really compatible, i.e., the architecture, operating system, and C library all match.For example, x86_64-unknown-linux-musl and x86_64-unknown-linux-gnu are really different, the bitcode is compiled for a different C library.The --llvm.verifyBitcode=false option disables all checks, GraalVM will then try to run the bitcode regardless, which might randomly fail in unexpected ways.",
          "url": " /latest/reference-manual/llvm/Compiling/"
          },
          
          "latest-reference-manual-native-image-contributing":  {
          "title": "Contributing to Native Image",
          "content": "Contributing to Native ImageGraalVM is an open source project, so is Substrate VM - the codename for the Native Image technology.We welcome contributors to the core!There are two common ways to contribute:  Submit GitHub issues for bug reports, questions, or requests for enhancements.  Open a GitHub pull request.If you want to contribute changes to Native Image core, you must adhere to the project’s standards of quality. For more information, see Native Image Code Style.If you would like to ensure complete compatibility of your library with Native Image, consider contributing your library metadata to the GraalVM Reachability Metadata Repository. Follow contributing rules for this repository. Using this open source repository, users can share the burden of maintaining metadata for third-party dependencies.",
          "url": " /latest/reference-manual/native-image/contributing/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-dslguidelines":  {
          "title": "Truffle DSL Guidelines",
          "content": "Truffle DSL GuidelinesThis document describes some Truffle DSL guidelines. Keep in mind that those are only guidelines that do not haveto be strictly followed in every case. The most important part is the reasoning behind every guideline - usethat to assess the trade-offs for the specific situation at hand and to chose appropriate solution.One of the general high-level guidelines for partially evaluated (PE) code is to minimize code duplication duringthe PE process. This not only helps the Truffle compilation that uses partial evaluation, but alsohost inlining, whichfollows similar rules to PE when compiling the interpreter.Another general high-level guideline for any Truffle interpreter code is to have as little code as possiblein order to minimize the native-image size. This applies to runtime code and PE code, but is evenmore important for PE code, since native-image also AOT compiles it, but the host-inlining greatlyincreases the amount of code the AOT compilation produces, and on top of that native-image also needsto retain serialized Graal IR graphs of all PE code for runtime compilation.Avoid subclassing for minor changesExample:abstract class MyBaseNode extends Node {  abstract int execute(Object o);  @Specialization(guards = &quot;arg == 0&quot;)  int doZero(int arg) { /* ... */ }  @Specialization(guards = &quot;arg != 0&quot;)  int doInt(int arg) { /* ... */ }  @Specialization  int doOther(Object o) { throw new AbstractMethodError(); }}abstract class Node1 extends MyBaseNode {  @Specialization  @Override  final int doOther(Object o) { return 42; }}abstract class Node2 extends MyBaseNode {  @Specialization  @Override  final int doOther(Object o) { return -1; }}Why: native-image binary sizeTruffle DSL will generate multiple execute and executeAndSpecialize methods,which will contain the same code. Native-image does not deduplicate the code.Solution: use delegation to a child node instead of inheritance or, if the code is simple enough,inline all the implementations and switch on a field value or argument to the execute method.Example of the former:abstract class MyNodeHandleOther extends Node {    abstract int execute(Object o);}abstract class MyNode extends Node {  @Child MyNodeHandleOther otherHandler;  MyNode(MyNodeHandleOther otherHandler) {      this.otherHandler = otherHandler;  }  abstract int execute(Object o);  @Specialization(guards = &quot;arg == 0&quot;)  int doZero(int arg) { /* ... */ }  @Specialization(guards = &quot;arg != 0&quot;)  int doInt(int arg) { /* ... */ }  @Specialization  int doOther(Object o) {      return otherHandler.execute(o);  }}Alternative solution: if the common code is only one @Specialization or there is a simple and efficient guardthat captures all the common @Specializations, then move the common @Specializations to an inline node andin all the former subclasses add one @Specialization that delegates to the common inline node.@GenerateCached(false)@GenerateInlineabstract class MyCommonNode extends Node {  abstract int execute(Node node, Object o);  @Specialization(guards = &quot;arg == 0&quot;)  int doZero(int arg) { /* ... */ }  @Specialization(guards = &quot;arg != 0&quot;)  int doInt(int arg) { /* ... */ }}abstract class Node1 extends Node {    abstract int execute(Object o);    @Specialization    int doInts(int o,               @Cached MyCommonNode node) {        return node.execute(this, o);    }    @Specialization    int doOther(Object o) { return 42; }}// analogically for Node2Avoid duplicated SpecializationsAvoid specializations with (almost) the same method body.When two or more @Specializations differ only in guards or in some minor detail. This includes @Specializationsthat delegate to the same helper method. Example:abstract class MyNode extends Node {  abstract void execute(Object o);  @Specialization  void doObj1(MyObject1 o) { helper(o); }  @Specialization  void doObj2(MyObject2 o) { helper(o); }  void helper(Object o) { /* some code */ }  // ... more @Specializations}Why:  code duplication during PEWe want to reduce code duplication as seen by PE process and not by the developer. Refactoring the codeto a helper method does not help PE, because it explores every call separately.For instance, with host inlining and our code example, the cost of fully inlining Node#execute will be(omitting some details):size(Node#execute) + size(Node#doIt1) + size(Node#doIt2) + 2 * size(Node#helper)Solution: refactor the code to avoid the duplication. The concrete approach differs depending on concretesituation. There is no one-size-fits-all solution. General advice is to try to merge the @Specializationsthat contain the code duplication. One can create an inline node that profiles the now merged conditionsthat used to be implicitly profiled by being separate @Specializations. For example:@GenerateInline@GenerateCached(false)abstract class GuardNode extends Node {  abstract boolean execute(Node inliningTarget, Object o);  @Specialization  static boolean doObj1(MyObject1 o) { return true; }  @Specialization  static boolean doObj2(MyObject2 o) { return true; }  @Fallback  static boolean doFallback(Object o) { return false; }}abstract class MyNode extends Node {  abstract void execute(Object o);  @Specialization(guards = &quot;guardNode.execute(this, o)&quot;, limit = &quot;1&quot;)  void doObj(Object o,             @Cached GuardNode guardNode) { helper(o); }  // ...other @Specializations}Note that if the guard needs to be used for multiple specializations, or will be used by generated fallback guard,we are duplicating the guard logic in the same way as we were duplicating the logic inside the specializations.This may be acceptable as guards tend to be simple, but the user needs to assess if that is a good trade-off.Avoid duplicated calls to helper methods/nodesExample:@Specializationvoid doDefault(boolean b, Object o) {  if (b) {    helper.execute(o, 42);  } else {    helper.execute(o, -1);  }}Why: code duplication during PEThe PE process has to explore each call separately and only in later phases the Graal compiler may deduplicate the code.Solution: common-out the calls if possible  int num = b ? 42 : -1;  helper.execute(o, num);Mixing @Shared and non-@Shared inline nodes/profilesAvoid mixing @Shared and non-@Shared inline nodes/profiles in one @Specialization if Truffle DSL generates“data-class” for the @Specialization.Example:@GenerateInline(false)class MyNode extends Node {  // ...  @Specialization  void doIt(...,      @Bind(&quot;this&quot;) Node node,      /* more @Cached arguments such that data-class is generated */      @Exclusive @Cached InlinedBranchProfile b1,      @Shared @Cached InlinedBranchProfile b2)Why: Truffle DSL generates code that is less efficient in the interpreter.In our example: non-shared inline profile has its data stored in the data-class object, but the shared inline profilehas its data stored in the instance of MyNode. However, both profiles receive the same node argument,which will be an instance of the generated data-class, so the shared profile must call node.getParent() to accessits data stored in MyNode. In general, such inline nodes/profiles may need to traverse multiple parent pointersuntil they reach their data.Note: this does not concern any non-inline nodes, it is OK to mix those, and it is OK to mix them with inline nodes,however, inline nodes used in one @Specialization should be either all shared or all exclusive.Solution: change the @Shared nodes/profiles to @Exclusive or refactor the code such that sharing is notnecessary anymore. Usage of @Shared (not only inline nodes/profiles) can be a sign ofduplicated @Specializations, and refactoring the @Specializations will resolve the problem.If the footprint benefit outweighs the possible interpreter performance degradation, this guideline can be ignored.Generic solution that trades off some code readability for good interpreter performance and lower footprint at thesame time is to split the code into two nodes, where the outer node takes only the shared inline nodes/profilesand the inner node takes only the non-shared. The outer node can execute some common logic and also forward theshared nodes along with their inlining target node to the inner node.Avoid unused large inline nodesAvoid inlining large nodes that are used only on rarely executed code-paths.Example:@Specializationvoid doObject(Object arg,    @Bind(&quot;this&quot;) Node inliningTarget,    @Cached LargeInlineNode n) {    if (arg == null) {        // unlikely situation        n.execute(inliningTarget, ...);    }}Why: runtime memory footprintAll the fields of LargeInlineNode node will be inlined into the caller node (or Specialization data-class)increasing its memory footprint significantly.For code-paths that are not performance sensitive in the interpreter, better alternative isthe lazily initialized nodes.For Code-paths that are performance sensitive in the interpreter:  The footprint increase may be justified by the performance  Use the handwritten lazily initialized @Child field pattern if applicable  If possible restructure the code to avoid such situationAvoid generating cached, uncached, and inline variant of one nodeIf possible avoid having all three variants, because it increases the PE code footprint.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/DSLGuidelines/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-dslnodeobjectinlining":  {
          "title": "Truffle DSL Node Object Inlining",
          "content": "Truffle DSL Node Object InliningIn 23.0, we have introduced a new annotation called @GenerateInline. This annotation instructs the Truffle DSL annotation processor to generate an inlinable version of a node. This works analogously to @GenerateCached and @GenerateUncached, which generate a cached or uncached node version.By default, the DSL does not generate an inlined version of a node.Node inlining provides a simple way to reduce the memory footprint of nodes but often also improves interpreter execution speed.Basic UsageLet us assume we have a node with specializations that computes the sum of the absolute value of two values.For simplicity, we will only look at the long typed specializations in this example.A runnable but slightly more advanced version of this example can be found in the Truffle unit tests.  NodeInliningExample1_1.java shows an example without any inlining.  NodeInliningExample1_2.java shows an example without partial inlining.  NodeInliningExample1_3.java shows an example with full inlining.Consider the following examples that specify two regular nodes it specializations. One node computes the sum of two values, and one computes the absolute number of a number. The AbsNode is then reused in the AddAbsNode to share the implementation.public abstract class AddAbsNode extends Node {    abstract long execute(Object left, Object right);    @Specialization    long add(long left, long right,                    @Cached AbsNode leftAbs,                    @Cached AbsNode rightAbs) {        return leftAbs.execute(left) + rightAbs.execute(right);    }    // ...}public abstract class AbsNode extends Node {    abstract long execute(long value);    @Specialization(guards = &quot;v &amp;gt;= 0&quot;)    long doInt(long v) {        return v;    }    @Specialization(guards = &quot;v &amp;lt; 0&quot;)    long doLong(long v) {        return -v;    }}The compressed memory footprint for AbsNode and AddAbsNode after one execution are computed as follows:AbsNodeGen = object header   + Node field for Node.parent   + int field for stateAddAbsNodeGen = object header   + Node field for Node.parent   + int  field for state   + Node field for @Cached AbsNode leftAbs   + Node field for @Cached AbsNode rightAbsFootprint = headerCount * 12 + pointerCount * 4 + primitiveByteSizeFootprint = 3 * 12 + 5 * 4 + 12 = 68 bytesTherefore, we use 68 bytes to represent a single operation with nodes.With 23.0, the Truffle DSL annotation processor will produce the following warning for the AbsNode class:This node is a candidate for node object inlining. The memory footprint is estimated to be reduced from 20 to 1 byte(s). Add @GenerateInline(true) to enable object inlining for this node or @GenerateInline(false) to disable this warning. Also, consider disabling cached node generation with @GenerateCached(false) if all usages will be inlined. This warning may be suppressed using @SuppressWarnings(&quot;truffle-inlining&quot;).Following the recommendation of this warning, we modify our example as follows by adding the @GenerateInline annotation:@GenerateInlinepublic abstract class AbsNode extends Node {    abstract long execute(long value);    @Specialization(guards = &quot;v &amp;gt;= 0&quot;)    long doInt(long v) {        return v;    }    @Specialization(guards = &quot;v &amp;lt; 0&quot;)    long doLong(long v) {        return -v;    }}Now the DSL reports a compile error for AbsNode:Error generating code for @GenerateInline: Found non-final execute method without a node parameter execute(long). Inlinable nodes must use the Node type as the first parameter after the optional frame for all non-final execute methods. A valid signature for an inlinable node is execute([VirtualFrame frame, ] Node node, ...).For inlinable nodes, we must pass a node parameter to the execute method as the first parameter.This is necessary as inlined nodes become singletons and no longer have their own state, but instead, it is passed as a parameter to the execute method.Again, we follow the error and modify our example as follows:@GenerateInlinepublic abstract class AbsNode extends Node {    abstract long execute(Node node, long value);    @Specialization(guards = &quot;v &amp;gt;= 0&quot;)    static long doInt(long v) {        return v;    }    @Specialization(guards = &quot;v &amp;lt; 0&quot;)    static long doLong(long v) {        return -v;    }}Note that the node parameter is optional for specialization methods, but they are typically needed if transitively inlined nodes are used.Next, we also need to modify AddAbsNode to pass this as a node parameter to the new execute signature:public abstract static class AddAbsNode extends Node {    abstract long execute(long left, long right);    @Specialization    long add(long left, long right,                    @Cached AbsNode leftAbs,                    @Cached AbsNode rightAbs) {        return leftAbs.execute(this, left) + rightAbs.execute(this, right);    }    // ...}The DSL now produces a warning for each of the @Cached AbsNode parameters:The cached type &#39;AbsNode&#39; supports object-inlining. The footprint is estimated to be reduced from 36 to 1 byte(s). Set @Cached(..., inline=true|false) to determine whether object-inlining should be performed. Alternatively, @GenerateCached(alwaysInlineCached=true) can be used to enable inlining for an entire class or in combination with the inherit option for a hierarchy of node classes. This warning may be suppressed using @SuppressWarnings(&quot;truffle-inlining&quot;).We follow the recommendation in this message and enable object inlining:public abstract static class AddAbsNode extends Node {    abstract long execute(long left, long right);    @Specialization    long add(long left, long right,                    @Cached(inline = true) AbsNode leftAbs,                    @Cached(inline = true) AbsNode rightAbs) {        return leftAbs.execute(this, left) + rightAbs.execute(this, right);    }    // ...}Now we have achieved object-inlining of AbsNode into  AddAbsNode.The new memory footprint computes as follows:AddAbsNodeGen = object header   + Node field for Node.parent   + int  field for stateFootprint = headerCount * 12 + pointerCount * 4 + primitiveByteSizeFootprint = 1 * 12 + 1 * 4 + 4 = 20 bytesThe footprint has gone down from 68 bytes to only 20 bytes for each instance of AddAbsNodeGen.But we are still going. Since all cached nodes are inlined we can also make the AddAbsNode inlinable for its usages.The DSL helps us again by detecting such cases and prints a warning for AddAbsNode now:This node is a candidate for node object inlining. The memory footprint is estimated to be reduced from 20 to 1 byte(s). Add @GenerateInline(true) to enable object inlining for this node or @GenerateInline(false) to disable this warning. Also consider disabling cached node generation with @GenerateCached(false) if all usages will be inlined. This warning may be suppressed using @SuppressWarnings(&quot;truffle-inlining&quot;).Again, we follow the guide and add a @GenerateInline annotation to AddAbsNode. Just like before, we also add a Node parameter to the execute method:@GenerateInlinepublic abstract static class AddAbsNode extends Node {    abstract long execute(Node node, long left, long right);    @Specialization    static long add(Node node, long left, long right,                    @Cached AbsNode leftAbs,                    @Cached AbsNode rightAbs) {        return leftAbs.execute(node, left) + rightAbs.execute(node, right);    }    // ...}We also need to use the Node parameter in the specialization method and pass it on to the child nodes.Again, we want all specializations to be static to avoid accidentally passing this.In addition, the DSL complained about the inline=true attribute, which is now always implied as the parent node uses the @GenerateInline annotation.To measure the overhead of our new inlinable AddAbsNode node, we declare a new operation called Add4AbsNode that adds four numbers using our AddAbsNode operation:@GenerateCached(alwaysInlineCached = true)public abstract static class Add4AbsNode extends Node {    abstract long execute(long v0, long v1, long v2, long v3);    @Specialization    long doInt(long v0, long v1, long v2, long v3,                    @Cached AddAbsNode add0,                    @Cached AddAbsNode add1,                    @Cached AddAbsNode add2) {        long v;        v = add0.execute(this, v0, v1);        v = add1.execute(this, v, v2);        v = add2.execute(this, v, v3);        return v;    }}This time, instead of specifying @Cached(inline=true), we auto-enable inlining wherever possible using @GenerateCached(alwaysInlineCached = true).Depending on the use case, it can hinder readability to repeat individual inlining commands for every cached node.Computing the overhead now becomes more tricky. We need to understand how many state bits each node requires to keep track of active specializations.That computation is generally implementation specific and subject to change. However, a good rule of thumb is that the DSL requires one bit per declared specialization.Implicit casts, replace rules, @Fallback and specializations with multiple instances may further increase the number of required state bits.For this example, each AddAbsNode requires 5 bits. 2 bits for each of the AbsNode usages and one bit for the AddAbsNode specializations.The Add4AbsNode uses three instances of AddAbsNode, has one specialization, and therefore needs 3 * 5 + 1 state bits in total.Since the number of bits is below 32, we can assume that we need a single int field in the generated code.The memory footprint of an executed Add4AbsNode is therefore computed as follows:Footprint = 1 * 12 + 1 * 4 + 4 = 20 bytesAs you can see, this is the same memory footprint a single AddAbsNode had.If we use the same formula to compute the memory footprint of an Add4AbsNode without any object inliningFootprint = 1 * 12 + 4 * 4 + 4 + 3 * 68 = 236 bytesWe have reduced the overhead from 236 bytes to 20 bytes.In addition to the memory footprint advantages, interpreter-only execution may be faster, as we save the reads for the node fields and benefit from better CPU cache locality due to smaller memory consumption.After compilation using partial evaluation, both cached and uncached versions are expected to perform the same.There is a last thing we should do. Since our AddAbsNode and AbsNode are no longer used in their cached version, we can turn off cached generation using @GenerateCached(false) to save Java code footprint.After doing this we can omit the alwaysInlineCached property in the @GenerateCached annotation as nodes are automatically inlined if only an inlined version is available.This is the final example:@GenerateInline@GenerateCached(false)public abstract static class AbsNode extends Node {    abstract long execute(Node node, long value);    @Specialization(guards = &quot;v &amp;gt;= 0&quot;)    static long doInt(long v) {        return v;    }    @Specialization(guards = &quot;v &amp;lt; 0&quot;)    static long doLong(long v) {        return -v;    }}@GenerateInline@GenerateCached(false)public abstract static class AddAbsNode extends Node {    abstract long execute(Node node, long left, long right);    @Specialization    static long add(Node node, long left, long right,                    @Cached AbsNode leftAbs,                    @Cached AbsNode rightAbs) {        return leftAbs.execute(node, left) + rightAbs.execute(node, right);    }    // ...}@GenerateCached(alwaysInlineCached = true)@GenerateInline(false)public abstract static class Add4AbsNode extends Node {    abstract long execute(long v0, long v1, long v2, long v3);    @Specialization    long doInt(long v0, long v1, long v2, long v3,                    @Cached AddAbsNode add0,                    @Cached AddAbsNode add1,                    @Cached AddAbsNode add2) {        long v;        v = add0.execute(this, v0, v1);        v = add1.execute(this, v, v2);        v = add2.execute(this, v, v3);        return v;    }}Note that the DSL again informed us that Add4AbsNode could use @GenerateInline by emitting the following warning:This node is a candidate for node object inlining. The memory footprint is estimated to be reduced from 20 to 2 byte(s). Add @GenerateInline(true) to enable object inlining for this node or @GenerateInline(false) to disable this warning. Also consider disabling cached node generation with @GenerateCached(false) if all usages will be inlined. This warning may be suppressed using @SuppressWarnings(&quot;truffle-inlining&quot;).This time we suppressed the warning by explicitly specifying @GenerateInline(false).Advanced Inline Cache UsageThe following example explains how specialization unrolling and new inlinable cache classes can be helpful in reducing the memory footprint of nodes with specializations that have multiple instances.Examples:  NodeInliningExample2_1.java shows an example without any inlining.  NodeInliningExample2_2.java shows an example without partial inlining.  NodeInliningExample2_3.java shows an example with full inlining.Passing along Nodes correctlyThe usage of inlined nodes requires to access and pass the correct node to execute methods of the respective inlined nodes.It is a common mistake to pass the wrong node to execute methods.Typically such mistakes fail with an error at runtime, but the DSL also emits warnings and errors depending on the situation at compile time.Inlined NodesFor inlined nodes that use themselves inlined nodes it is sufficient to pass a long the Node dynamic parameter.For example. in the previous section we used AddAbsNode with a similar pattern:@GenerateInline@GenerateCached(false)public abstract static class AddAbsNode extends Node {    abstract long execute(Node node, long left, long right);    @Specialization    static long add(Node node, long left, long right,                    @Cached AbsNode leftAbs,                    @Cached AbsNode rightAbs) {        return leftAbs.execute(node, left) + rightAbs.execute(node, right);    }    // ...}Cached Nodes with Multiple InstancesFor nodes with specializations that may have multiple instances a @Bind(&quot;this&quot;) Node node parameter must be used to access the inline target node.This is similar to the SumArrayNode node in the advanced usage example.@ImportStatic(AbstractArray.class)public abstract static class SumArrayNode extends Node {    abstract int execute(Object v0);    @Specialization(guards = {&quot;kind != null&quot;, &quot;kind.type == array.getClass()&quot;}, limit = &quot;2&quot;, unroll = 2)    static int doDefault(Object array,                    @Bind(&quot;this&quot;) Node node,                    @Cached(&quot;resolve(array)&quot;) ArrayKind kind,                    @Cached GetStoreNode getStore) {        Object castStore = kind.type.cast(array);        int[] store = getStore.execute(node, castStore);        int sum = 0;        for (int element : store) {            sum += element;            TruffleSafepoint.poll(node);        }        return sum;    }    static Class&amp;lt;?&amp;gt; getCachedClass(Object array) {        if (array instanceof AbstractArray) {            return array.getClass();        }        return null;    }}Exported Library MessagesFor exported library messages the this keyword is already reserved for the receiver value, so $node can be used instead.For example:    @ExportLibrary(ExampleArithmeticLibrary.class)    static class ExampleNumber {        final long value;        /* ... */        @ExportMessage        final long abs(@Bind Node node,                       @Cached InlinedConditionProfile profile) {            if (profile.profile(node, this.value &amp;gt;= 0)) {                return  this.value;            } else {                return  -this.value;            }        }    }LimitationsNode object inlining supports arbitrary deep nestings. However, there are some limitations to using @GenerateInline.  There must not be any instance fields on the node class or a parent class.  The node must not use @NodeField or @NodeChild.  The usage of inlined nodes must not be recursive.Manually implementing Inlinable Nodes and ProfilesNodes or profiles that can be inlined in the DSL can also be implemented manually.The class must implement a static method called inline.For example, most inlinable Truffle profiles use custom inlining.Extra care must be taken when implementing such inlinable classes and if possible, a DSL generated node should be used instead.See InlinedBranchProfile or InlinedIntValueProfile class as an example on how to implement the inline method.API Compatibility for Inlinable NodesThe TruffleString API extensively uses DSL nodes like in the above example.However, allowing nodes to be inlined makes every change to the specializations of that node an incompatible API change.This is because the signature of the static inline method changes depending on the required state bits of the specializations.In order to support inlining across stable API boundaries, it is recommended to manually specify an inline method that forwards to the generated inline method.As an example, consider the following node:@GenerateInline@GenerateUncached@GeneratePackagePrivatepublic abstract static class APINode extends Node {    abstract long execute(Node node, long value);    @Specialization(guards = &quot;v &amp;gt;= 0&quot;)    static long doInt(long v) {        return v;    }    @Specialization(guards = &quot;v &amp;lt; 0&quot;)    static long doLong(long v) {        return -v;    }    public static APINode inline(@RequiredField(value = StateField.class, bits = 32) InlineContext context) {        return APINodeGen.inline(context);    }    public static APINode create() {        return APINodeGen.create();    }    public static APINode getUncached() {        return APINodeGen.getUncached();    }}We use @GeneratePackagePrivate in order not to expose any generated code as public.We specify a manual inline method that specifies the required bits for this node.If the specializations of a node require more bits or more additional fields other than specified, then the annotation processor fails with an error.If the node requires fewer bits, then this does not cause any compiler error.This allows API to use node inlining across stable API boundaries as long as the reserved field capacity is not exceeded.A change is compatible if:  There was previously no inline method for this node before.  If the required bit space is reduced and all other fields are changed.A change is incompatible if:  A new @RequiredField annotation to an existing inline method was added or removed.  The required bits were increased.The DSL validates whether the required fields are matching to the state specification of the parent node and emits a warning if it is not compatible to the node specification.Lazy Initialized Nodes with DSL InliningFull source code of the example: NodeInliningAndLazyInitExample.java.DSL inlining can be used to provide lazy initialization for otherwise cached node that is only used in code blocks thatare protected by conditions that trigger rarely. Consider this example:@GenerateInline(false)@GenerateUncachedpublic abstract static class RaiseErrorNode extends Node {    abstract void execute(Object type, String message);    // ...}@GenerateInline(false)@GenerateUncached(false)public abstract static class LazyInitExampleBefore extends Node {    abstract void execute(Object value);    @Specialization    void doIt(Object value,              @Cached RaiseErrorNode raiseError) {        Object result = doSomeWork(value);        if (result == null) {            raiseError.execute(value, &quot;Error: doSomeWork returned null&quot;);        }    }}RaiseErrorNode is always instantiated even-though we do not need it if doSomeWork always returnsnon null result at runtime. Before DSL inlining, this issue was usually solved by lazy-initialized@Child node:@GenerateInline(false)@GenerateUncached(false)public abstract static class LazyInitExampleBefore2 extends Node {    @Child RaiseErrorNode raiseError;    abstract void execute(Object value);    @Specialization    void doIt(Object value) {        Object result = doSomeWork(value);        if (result == null) {            if (raiseError == null) {                CompilerDirectives.transferToInterpreterAndInvalidate();                raiseError = insert(RaiseErrorNodeGen.create());            }            raiseError.execute(value, &quot;Error: doSomeWork returned null&quot;);        }    }}However @Child nodes have some drawbacks. Most notably, the @Specialization cannot be static and wecannot generate uncached variant of the node.With DSL inlining, one should either make the RaiseErrorNode inlineable if beneficial, or if it is a node that:  has a lot of specializations with multiple instances, or  cannot currently be inlined, or  has a lot of cached fields that cannot be inlinedthen one can create an inlinable wrapper node that initializes the RaiseErrorNode on demand:@GenerateInline@GenerateUncached@GenerateCached(false)public abstract static class LazyRaiseNode extends Node {    public final RaiseErrorNode get(Node node) {        return execute(node);    }    abstract RaiseErrorNode execute(Node node);    @Specialization    static RaiseErrorNode doIt(@Cached(inline = false) RaiseErrorNode node) {        return node;    }}@GenerateInline(false)@GenerateUncachedpublic abstract static class LazyInitExample extends Node {    abstract void execute(Object value);    @Specialization    void doIt(Object value,              @Cached LazyRaiseNode raiseError) {        Object result = doSomeWork(value);        if (result == null) {            raiseError.get(this).execute(value, &quot;Error: doSomeWork returned null&quot;);        }    }}Unless LazyRaiseNode.execute gets called, the cost of the wrapper is single reference fieldand one bit from the bitset of LazyInitExample node. Except for the extra bit, it is the same aswith the lazy initialized @Child node field.Note that, at the moment, the lazy initialization pattern cannot be fully inlined byhost inlining,and it is therefore not recommended to be used on interpreter hot code-paths.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/DSLNodeObjectInlining/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-dslwarnings":  {
          "title": "Truffle DSL Warnings ",
          "content": "Truffle DSL WarningsSince version 23.0, Truffle DSL now produces significantly more warnings. These warnings are intended to guide the user to better DSL usage.The following sections describe how to handle and eventually suppress warnings.All warnings of Truffle DSL can be suppressed using the -Atruffle.dsl.SuppressAllWarnings=true option. If a language uses strict checks where warnings are treated as errors in their CI, it is recommended to add this option to the Java compilation command line. This can be useful to avoid CI failures when Truffle DSL adds new warning messages. Adding new warning messages in Truffle DSL is considered a compatible change.Truffle DSL warnings can be suppressed just like Java warnings using the @SuppressWarnings annotation or with@SuppressPackageWarnings for entire packages.The following warning keys are supported:  all all warnings emitted by the Java compiler or Truffle DSL  truffle all warnings emitted by Truffle DSL  truffle-sharing warnings when the DSL recommends sharing between cached values  truffle-inlining warnings when the DSL recommends using node object inlining.  truffle-neverdefault warnings for when cached initializers should be marked as never having a default value.  truffle-limit warnings when a specialization limit is recommended, but not specified.  truffle-static-method warnings when the DSL recommends to use the static modifier.  truffle-unused warnings if a DSL attribute or annotation has no effect and is recommended to be removed.  truffle-abstract-export warnings if an abstract message of a Truffle library is not exported.  truffle-assumption if the assumptions feature is used with a specialization that reaches a @Fallback specialization.  truffle-guard if a guard uses methods where a @Idempotent or @NonIdempotent method may be beneficial for the generated code.Specific warnings can also be suppressed globally using the -Atruffle.dsl.SuppressWarnings=truffle-inlining,truffle-neverdefault Java compiler processor option. Note that also Java system properties can be used to configure the annotation processor. (e.g. by passing -J-Dtruffle.dsl.SuppressWarnings=truffle-inlining,truffle-neverdefault to javac)Suppressing a specific warning should be preferred over suppressing all warnings.Find the latest list of warnings in the source code",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/DSLWarnings/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-debuginfo":  {
          "title": "Debug Info Feature",
          "content": "Debug Info FeatureTable of Contents  Introduction  Source File Caching  Special Considerations for Debugging Java from GDB  Identifying Source Code Location  Configuring Source Paths in GNU Debugger  Checking Debug Info on Linux  Debugging with Isolates  Debugging Helper Methods  Special Considerations for using perf and valgrindIntroductionTo build a native executable with debug information, provide the -g command-line option for javac when compiling the application, and then to the native-image builder:javac -g Hello.javanative-image -g HelloThis enables source-level debugging, and the debugger (GDB) then correlates machine instructions with specific source lines in Java files.The resulting image will contain debug records in a format the GNU Debugger (GDB) understands.Additionally, you can pass -O0 to the builder which specifies that no compiler optimizations should be performed.Disabling all optimizations is not required, but in general it makes the debugging experience better.Debug information is not just useful to the debugger. It can also be used by the Linux performance profiling tools perf and valgrind to correlate execution statistics such as CPU utilization or cache misses with specific, named Java methods and even link them to individual lines of Java code in the original Java source file.By default, debug info will only include details of some of the values of parameters and local variables.This means that the debugger will report many parameters and local variables as being undefined. If you pass -O0 to the builder then full debug information will be included.If you want more parameter and local variable information to be included when employing higher levels of optimization (-O1 or, the default, -O2) you need to pass an extra command line flag to the native-image command:native-image -g -H:+SourceLevelDebug HelloEnabling debuginfo with flag -g does not make any difference to how a generatednative image is compiled and does not affect how fast it executes nor how much memory it uses at runtime.However, it can significantly increase the size of the generated image on disk. Enabling full parameterand local variable information by passing flag -H:+SourceLevelDebug can cause a program to be compiledslightly differently and for some applications this can slow down execution.The basic perf report command, which displays a histogram showing percentage execution time in each Java method, only requires passing flags -g and -H:+SourceLevelDebug to the native-image command.However, more sophisticated uses of perf (for example, perf annotate) and use ofvalgrind requires debug info to be supplemented with linkage symbols identifying compiled Java methods.Java method symbols are omitted from the generated native image by default but they can be retained achieved by passing one extra flag to the native-image commandnative-image -g -H:+SourceLevelDebug -H:-DeleteLocalSymbols HelloUse of this flag will result in a small increase in the size of theresulting image file.  Note: Native Image debugging currently works on Linux with initial support for macOS. The feature is experimental.  Note: Debug info support for perf and valgrind on Linux is an experimental feature.Source File CachingThe -g option also enables caching of sources for any JDK runtime classes, GraalVM classes, and application classes which can be located when generating a native executable.By default, the cache is created alongside the generated binary in a subdirectory named sources.If a target directory for the native executable is specified using option -H:Path=... then the cache is also relocated under that same target. Use a command line option to provide an alternative path to sources and to configure source file search path roots for the debugger.Files in the cache are located in a directory hierarchy that matches the file path information included in the debug records of the native executable.The source cache should contain all the files needed to debug the generated binary and nothing more.This local cache provides a convenient way of making just the necessary sources available to the debugger or IDE when debugging a native executable.The implementation tries to be smart about locating source files.It uses the current JAVA_HOME to locate the JDK src.zip when searching for JDK runtime sources.It also uses entries on the class path to suggest locations for GraalVM source files and application source files (see below for precise details of the scheme used to identify source locations).However, source layouts do vary and it may not be possible to find all sources.Hence, users can specify the location of source files explicitly on the command line using option DebugInfoSourceSearchPath:javac --source-path apps/greeter/src     -d apps/greeter/classes org/my/greeter/*Greeter.javajavac -cp apps/greeter/classes     --source-path apps/hello/src     -d apps/hello/classes org/my/hello/Hello.javanative-image -g     -H:DebugInfoSourceSearchPath=apps/hello/src     -H:DebugInfoSourceSearchPath=apps/greeter/src     -cp apps/hello/classes:apps/greeter/classes org.my.hello.HelloThe DebugInfoSourceSearchPath option can be repeated as many times as required to notify all the target source locations.The value passed to this option can be either an absolute or relative path.It can identify either a directory, a source JAR file, or a source ZIP file.It is also possible to specify several source roots at once using a comma separator:native-image -g     -H:DebugInfoSourceSearchPath=apps/hello/target/hello-sources.jar,apps/greeter/target/greeter-sources.jar     -cp apps/target/hello.jar:apps/target/greeter.jar     org.my.HelloBy default, the cache of application, GraalVM, and JDK sources is created in a directory named sources.The DebugInfoSourceCacheRoot option can be used to specify an alternative path, which can be absolute or relative.In the latter case the path is interpreted relative to the target directory for the generated executable specified via option -H:Path (which defaults to the current working directory).As an example, the following variant of the previous command specifies an absolute temporary directory path constructed using the current process id:SOURCE_CACHE_ROOT=/tmp/$$/sourcesnative-image -g     -H:DebugInfoSourceCacheRoot=$SOURCE_CACHE_ROOT     -H:DebugInfoSourceSearchPath=apps/hello/target/hello-sources.jar,apps/greeter/target/greeter-sources.jar     -cp apps/target/hello.jar:apps/target/greeter.jar     org.my.HelloThe resulting cache directory will be something like /tmp/1272696/sources.If the source cache path includes a directory that does not yet exist, it will be created during population of the cache.Note that in all the examples above the DebugInfoSourceSearchPath options are actually redundant.In the first case, the class path entries for apps/hello/classes/ and apps/greeter/classes/ will be used to derive the default search roots apps/hello/src/ and apps/greeter/src/.In the second case, the class path entries for apps/target/hello.jar and apps/target/greeter.jar will be used to derive the default search roots apps/target/hello-sources.jar and apps/target/greeter-sources.jar.Supported FeaturesThe currently supported features include:  break points configured by file and line, or by method name  single stepping by line including both into and over function calls  stack backtraces (not including frames detailing inlined code)  printing of primitive values  structured (field by field) printing of Java objects  casting/printing objects at different levels of generality  access through object networks via path expressions  reference by name to methods and static field data  reference by name to values bound to parameter and local vars  reference by name to class constantsNote that single stepping within a compiled method includes file and line number info for inlined code, including inlined GraalVM methods.So, GDB may switch files even though you are still in the same compiled method.Special considerations for debugging Java from GDBGDB does not currently include support for Java debugging.In consequence, debug capability has been implemented by generating debug info that models the Java program as an equivalent C++ program. Java class, array and interface references are actually pointers to records that contain the relevant field/array data.In the corresponding C++ model the Java name is used to label the underlying C++ (class/struct) layout types and Java references appear as pointers.So, for example in the DWARF debug info model java.lang.String identifies a C++ class.This class layout type declares the expected fields like hash of type int and value of type byte[] and methods like String(byte[]), charAt(int), etc. However, the copy constructor which appears in Java as String(String) appears in gdb with the signature String(java.lang.String *).The C++ layout class inherits fields and methods from class (layout) type java.lang.Object using C++ public inheritance.The latter in turn inherits standard oop (ordinary object pointer) header fields from a special struct class named _objhdr which includes up to two fields (depending on the VM configuration).The first field is called hub and its type is java.lang.Class * that is, it is a pointer to the object’s class.The second field (optional) is called idHash and has type int.It stores an identity hashcode for the object.The ptype command can be used to print details of a specific type.Note that the Java type name must be specified in quotes because to escape the embedded . characters.(gdb) ptype &#39;java.lang.String&#39;type = class java.lang.String : public java.lang.Object {  private:    byte [] *value;    int hash;    byte coder;  public:    void String(byte [] *);    void String(char [] *);    void String(byte [] *, java.lang.String *);    . . .    char charAt(int);    . . .    java.lang.String * concat(java.lang.String *);    . . .}The ptype command can also be used to identify the static type of a Javadata value. The current example session is for a simple hello worldprogram. Main method Hello.main is passed a single parameterargs whose Java type is String[]. If the debugger is stopped atentry to main we can use ptype to print the type of args.(gdb) ptype argstype = class java.lang.String[] : public java.lang.Object {  public:    int len;    java.lang.String *data[0];} *There are a few details worth highlighting here. Firstly, the debuggersees a Java array reference as a pointer type, as it does every Java objectreference.Secondly, the pointer points to a structure, actually a C++ class,that models the layout of the Java array using an integer length fieldand a data field whose type is a C++ array embedded into the block ofmemory that models the array object.Elements of the array data field are references to the base type, inthis case pointers to java.lang.String. The data array has a nominallength of 0. However, the block of memory allocated for the String[]object actually includes enough space to hold the number of pointersdetermined by the value of field len.Finally, notice that the C++ class java.lang.String[] inherits fromthe C++ class java.lang.Object. So, an array is still also an object.In particular, as we will see when we print the object contents, thismeans that every array also includes the object header fields that allJava objects share.The print command can be used to display the object reference as a memoryaddress.(gdb) print args$1 = (java.lang.String[] *) 0x7ffff7c01130It can also be used to print the contents of the object field by field. Thisis achieved by dereferencing the pointer using the * operator.(gdb) print *args$2 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0xaa90f0,      idHash = 0    }, &amp;lt;No data fields&amp;gt;},   members of java.lang.String[]:  len = 1,  data = 0x7ffff7c01140}The array object contains embedded fields inherited from class_objhdr via parent class Object. _objhdr is a synthetic typeadded to the deubg info to model fields that are present at the startof all objects. They include hub which is a reference to the object’sclass and hashId a unique numeric hash code.Clearly, the debugger knows the type (java.lang.String[]) and locationin memory (0x7ffff7c010b8) of local variable args. It also knows aboutthe layout of the fields embedded in the referenced object. This meansit is possible to use the C++ . and -&amp;gt; operators in debugger commandsto traverse the underlying object data structures.(gdb) print args-&amp;gt;data[0]$3 = (java.lang.String *) 0x7ffff7c01160(gdb) print *args-&amp;gt;data[0]$4 = {   &amp;lt;java.lang.Object&amp;gt; = {     &amp;lt;_objhdr&amp;gt; = {      hub = 0xaa3350     }, &amp;lt;No data fields&amp;gt;},   members of java.lang.String:   value = 0x7ffff7c01180,   hash = 0,   coder = 0 &#39;000&#39; }(gdb) print *args-&amp;gt;data[0]-&amp;gt;value$5 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0xaa3068,      idHash = 0    }, &amp;lt;No data fields&amp;gt;},   members of byte []:  len = 6,  data = 0x7ffff7c01190 &quot;Andrew&quot;}Returning to the hub field in the object header it wasmentioned before that this is actually a reference to the object’sclass. This is actually an instance of Java type java.lang.Class.Note that the field is typed by gdb using a pointerto the underlying C++ class (layout) type.(gdb) print args-&amp;gt;hub$6 = (java.lang.Class *) 0xaa90f0All classes, from Object downwards inherit from a common, automatically generated header type _objhdr.It is this header type which includes the hub field:(gdb) ptype _objhdrtype = struct _objhdr {    java.lang.Class *hub;    int idHash;}(gdb) ptype &#39;java.lang.Object&#39;type = class java.lang.Object : public _objhdr {  public:    void Object(void);    . . .The fact that all objects have a common header pointing to a classmakes it possible to perform a simple test to decide if an addressis an object reference and, if so,  what the object’s class is.Given a valid object reference it is always possible to print thecontents of the String referenced from the hub’s name field.Note that as a consequence, this enables every object observed by the debuggerto be downcast to its dynamic type. That is, even if the debugger only sees the statictype of (for example) java.nio.file.Path, we can easily downcast to the dynamic type, whichmight be a subtype such as jdk.nio.zipfs.ZipPath, thus making it possible to inspectfields that we would not be able to observe from the static type alone.First the value is cast to an object reference.Then a path expression is used to dereference through the hub field and the hub’s name field to the byte[] value array located in the name String.(gdb) print/x ((_objhdr *)$rdi)$7 = (_objhdr *) 0x7ffff7c01130(gdb) print *$7-&amp;gt;hub-&amp;gt;name-&amp;gt;value$8 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0xaa3068,      idHash = 178613527    }, &amp;lt;No data fields&amp;gt;},    members of byte []:   len = 19,  data = 0x8779c8 &quot;[Ljava.lang.String;&quot; }The value in register rdi is obviously a reference to a String array.Indeed, this is no coincidence. The example session has stopped at a breakpoint placed at the entry to Hello.main and at that point the value forthe String[] parameter args will be located in register rdi. Lookingback we can see that the value in rdi is the same value as was printed bycommand print args.A simpler command which allows just the name of the hub object to be printed is as follows:(gdb) x/s $7-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;data798:&quot;[Ljava.lang.String;&quot;Indeed it is useful to define a gdb command hubname_raw to execute this operation on an arbitrary raw memory address.define hubname_raw  x/s ((&#39;java.lang.Object&#39; *)($arg0))-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;dataend(gdb) hubname_raw $rdi0x8779c8:&quot;[Ljava.lang.String;&quot;Attempting to print the hub name for an invalid reference will failsafe, printing an error message.(gdb) p/x $rdx$5 = 0x2(gdb) hubname $rdxCannot access memory at address 0x2If gdb already knows the Java type for a reference it can be printed without casting using a simpler version of the hubname command.For example, the String array retrieved above as $1 has a known type.(gdb) ptype $1type = class java.lang.String[] : public java.lang.Object {    int len;    java.lang.String *data[0];} *define hubname  x/s (($arg0))-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;dataend(gdb) hubname $10x8779c8:&quot;[Ljava.lang.String;&quot;The native image heap contains a unique hub object (an instance ofjava.lang.Class) for every Java type that is included in theimage. It is possible to refer to these class constants using thestandard Java class literal syntax:(gdb) print &#39;Hello.class&#39;$6 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0xaabd00,      idHash = 1589947226    }, &amp;lt;No data fields&amp;gt;},   members of java.lang.Class:  typeCheckStart = 13,  name = 0xbd57f0,  ...Unfortunately it is necessary to quote the class constant literal toavoid gdb interpreting the embedded . character as a field access.Note that the type of a class constant literal is java.lang.Classrather than java.lang.Class *.Class constants exist for Java instance classes, interfaces, arrayclasses and arrays, including primitive arrays:(gdb)  print &#39;java.util.List.class&#39;.name$7 = (java.lang.String *) 0xb1f698(gdb) print &#39;java.lang.String[].class&#39;.name-&amp;gt;value-&amp;gt;data$8 = 0x8e6d78 &quot;[Ljava.lang.String;&quot;(gdb) print &#39;long.class&#39;.name-&amp;gt;value-&amp;gt;data$9 = 0xc87b78 &quot;long&quot;(gdb) x/s  &#39;byte[].class&#39;.name-&amp;gt;value-&amp;gt;data0x925a00:&quot;[B&quot;(gdb) Interface layouts are modeled as C++ union types.The members of the union include the C++ layout types for all Java classes which implement the interface.(gdb) ptype &#39;java.lang.CharSequence&#39;type = union java.lang.CharSequence {    java.nio.CharBuffer _java.nio.CharBuffer;    java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;    java.lang.String _java.lang.String;    java.lang.StringBuilder _java.lang.StringBuilder;    java.lang.StringBuffer _java.lang.StringBuffer;}Given a reference typed to an interface it can be resolved to the relevant class type by viewing it through the relevant union element.If we take the first String in the args array we can ask gdb to cast it to interface CharSequence.(gdb) print args-&amp;gt;data[0]$10 = (java.lang.String *) 0x7ffff7c01160(gdb) print (&#39;java.lang.CharSequence&#39; *)$10$11 = (java.lang.CharSequence *) 0x7ffff7c01160The hubname command will not work with this union type because it is only objects of the elements of the union that include the hub field:(gdb) hubname $11There is no member named hub.However, since all elements include the same header any one of them can be passed to hubname in order to identify the actual type.This allows the correct union element to be selected:(gdb) hubname $11-&amp;gt;&#39;_java.nio.CharBuffer&#39;0x95cc58:&quot;java.lang.String`302236&quot;(gdb) print $11-&amp;gt;&#39;_java.lang.String&#39;$12 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0xaa3350,      idHash = 0    }, &amp;lt;No data fields&amp;gt;},  members of java.lang.String:  hash = 0,  value = 0x7ffff7c01180,  coder = 0 &#39;000&#39;}Notice that the printed class name for hub includes some trailing characters.That is because a data array storing Java String text is not guaranteed to be zero-terminated.The debugger does not just understand the name and type of local andparameter variables. It also knows about method names and static fieldnames.The following command places a breakpoint on the main entry point for class Hello.Note that since GDB thinks this is a C++ method it uses the :: separator to separate the method name from the class name.(gdb) info func ::mainAll functions matching regular expression &quot;::main&quot;:File Hello.java:void Hello::main(java.lang.String[] *);(gdb) x/4i Hello::main=&amp;gt; 0x4065a0 &amp;lt;Hello::main(java.lang.String[] *)&amp;gt;:sub    $0x8,%rsp   0x4065a4 &amp;lt;Hello::main(java.lang.String[] *)+4&amp;gt;:cmp    0x8(%r15),%rsp   0x4065a8 &amp;lt;Hello::main(java.lang.String[] *)+8&amp;gt;:jbe    0x4065fd &amp;lt;Hello::main(java.lang.String[] *)+93&amp;gt;   0x4065ae &amp;lt;Hello::main(java.lang.String[] *)+14&amp;gt;:callq  0x406050 &amp;lt;Hello$Greeter::greeter(java.lang.String[] *)&amp;gt;(gdb) b Hello::mainBreakpoint 1 at 0x4065a0: file Hello.java, line 43.An example of a static field containing Object data is provided by the static field powerCache in class BigInteger.(gdb) ptype &#39;java.math.BigInteger&#39;type = class _java.math.BigInteger : public _java.lang.Number {  public:    int [] mag;    int signum;  private:    int bitLengthPlusOne;    int lowestSetBitPlusTwo;    int firstNonzeroIntNumPlusTwo;    static java.math.BigInteger[][] powerCache;    . . .  public:    void BigInteger(byte [] *);    void BigInteger(java.lang.String *, int);    . . .}(gdb) info var powerCacheAll variables matching regular expression &quot;powerCache&quot;:File java/math/BigInteger.java:java.math.BigInteger[][] *java.math.BigInteger::powerCache;The static variable name can be used to refer to the value stored in this field.Note also that the address operator can be used identify the location (address) of the field in the heap.(gdb) p &#39;java.math.BigInteger&#39;::powerCache$13 = (java.math.BigInteger[][] *) 0xced5f8(gdb) p &amp;amp;&#39;java.math.BigInteger&#39;::powerCache$14 = (java.math.BigInteger[][] **) 0xced3f0The debugger dereferences through symbolic names for static fields to access the primitive value or object stored in the field.(gdb) p *&#39;java.math.BigInteger&#39;::powerCache$15 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {    hub = 0xb8dc70,    idHash = 1669655018    }, &amp;lt;No data fields&amp;gt;},  members of _java.math.BigInteger[][]:  len = 37,  data = 0xced608}(gdb) p &#39;java.math.BigInteger&#39;::powerCache-&amp;gt;data[0]@4$16 = {0x0, 0x0, 0xed5780, 0xed5768}(gdb) p *&#39;java.math.BigInteger&#39;::powerCache-&amp;gt;data[2]$17 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {    hub = 0xabea50,    idHash = 289329064    }, &amp;lt;No data fields&amp;gt;},  members of java.math.BigInteger[]:  len = 1,  data = 0xed5790}(gdb) p *&#39;java.math.BigInteger&#39;::powerCache-&amp;gt;data[2]-&amp;gt;data[0]$18 = {  &amp;lt;java.lang.Number&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0xabed80      }, &amp;lt;No data fields&amp;gt;}, &amp;lt;No data fields&amp;gt;},  members of java.math.BigInteger:  mag = 0xcbc648,  signum = 1,  bitLengthPlusOne = 0,  lowestSetBitPlusTwo = 0,  firstNonzeroIntNumPlusTwo = 0}Identifying Source Code LocationOne goal of the implementation is to make it simple to configure the debugger so that it can identify the relevant source file when it stops during program execution. The native-image tool tries to achieve this by accumulating the relevant sources in a suitably structured file cache.The native-image tool uses different strategies to locate source files for JDK runtime classes, GraalVM classes, and application source classes for inclusion in the local sources cache.It identifies which strategy to use based on the package name of the class.So, for example, packages starting with java.* or jdk.* are JDK classes; packages starting with org.graal.* or com.oracle.svm.* are GraalVM classes; any other packages are regarded as application classes.Sources for JDK runtime classes are retrieved from the src.zip found in the JDK release used to run the native image generation process.Retrieved files are cached under subdirectory sources, using the module name (for JDK11) and package name of the associated class to define the directory hierarchy in which the source is located.For example, on Linux the source for class java.util.HashMap will be cached in file sources/java.base/java/util/HashMap.java.Debug info records for this class and its methods will identify this source file using the relative directory path java.base/java/util and file name HashMap.java. On Windows things will be the same modulo use of  rather than / as the file separator.Sources for GraalVM classes are retrieved from ZIP files or source directories derived from entries on the class path.Retrieved files are cached under subdirectory sources, using the package name of the associated class to define the directory hierarchy in which the source is located (for example, class com.oracle.svm.core.VM has its source file cached at sources/com/oracle/svm/core/VM.java).The lookup scheme for cached GraalVM sources varies depending upon what is found in each class path entry.Given a JAR file entry like /path/to/foo.jar, the corresponding file /path/to/foo.src.zip is considered as a candidate ZIP file system from which source files may be extracted.When the entry specifies a directory like /path/to/bar, then directories /path/to/bar/src and /path/to/bar/src_gen are considered as candidates.Candidates are skipped when the ZIP file or source directory does not exist, or it does not contain at least one subdirectory hierarchy that matches one of the expected GraalVM package hierarchies.Sources for application classes are retrieved from source JAR files or source directories derived from entries in the class path.Retrieved files are cached under subdirectory sources, using the package name of the associated class to define the directory hierarchy in which the source is located (for example, class org.my.foo.Foo has its source file cached as sources/org/my/foo/Foo.java).The lookup scheme for cached application sources varies depending upon what is found in each class path entry.Given a JAR file entry like /path/to/foo.jar, the corresponding JAR file /path/to/foo-sources.jar is considered as a candidate ZIP file system from which source files may be extracted.When the entry specifies a directory like /path/to/bar/classes/ or /path/to/bar/target/classes/ then one of the directories/path/to/bar/src/main/java/, /path/to/bar/src/java/ or /path/to/bar/src/ is selected as a candidate (in that order of preference).Finally, the current directory in which the native executable is being run is also considered as a candidate.These lookup strategies are only provisional and may need extending in the future.However, it is possible to make missing sources available by other means.One option is to unzip extra app source JAR files, or copy extra app source trees into the cache.Another is to configure extra source search paths.Configuring Source Paths in GNU DebuggerBy default, GDB will employ the local directory root sources to locate the source files for your application classes, GraalVM classes, and JDK runtime classes.If the sources cache is not located in the directory in which you run GDB, you can configure the required paths using the following command:(gdb) set directories /path/to/sources/The argument to the set directories command should identify the location of the sources cache as an absolute path or a relative path from the working directory of the gdb session.Note that the current implementation does not yet find some sources for the GraalVM JIT compiler in the jdk.graal.compiler* package subspace.You can supplement the files cached in sources by unzipping application source JAR files or copying application source trees into the cache.You will need to ensure that any new subdirectory you add to sources corresponds to the top level package for the classes whose sources are being included.You can also add extra directories to the search path using the set directories command:(gdb) set directories /path/to/my/sources/:/path/to/my/other/sourcesNote that the GNU Debugger does not understand ZIP format file systems so any extra entries you add must identify a directory tree containing the relevant sources.Once again, top level entries in the directory added to the search path must correspond to the top level package for the classes whose sources are being included.Checking Debug Info on LinuxNote that this is only of interest to those who want to understand how the debug info implementation works or want to troubleshoot problems encountered during debugging that might relate to the debug info encoding.The objdump command can be used to display the debug info embedded into a native executable.The following commands (which all assume the target binary is called hello) can be used to display all generated content:objdump --dwarf=info hello &amp;gt; infoobjdump --dwarf=abbrev hello &amp;gt; abbrevobjdump --dwarf=ranges hello &amp;gt; rangesobjdump --dwarf=decodedline hello &amp;gt; decodedlineobjdump --dwarf=rawline hello &amp;gt; rawlineobjdump --dwarf=str hello &amp;gt; strobjdump --dwarf=loc hello &amp;gt; locobjdump --dwarf=frames hello &amp;gt; framesThe info section includes details of all compiled Java methods.The abbrev section defines the layout of records in the info section that describe Java files (compilation units) and methods.The ranges section details the start and end addresses of method code segments.The decodedline section maps subsegments of method code range segments to files and line numbers.This mapping includes entries for files and line numbers for inlined methods.The rawline segment provides details of how the line table is generated using DWARF state machine instructions that encode file, line, and address transitions.The loc section provides details of address ranges withinwhich parameter and local variables declared in the info sectionare known to have a determinate value. The details identify wherethe value is located, either in a machine register, on the stack orat a specific address in memory.The str section provides a lookup table for strings referenced from records in the info section.The frames section lists transition points in compiled methods where a (fixed size) stack frame is pushed or popped, allowing the debugger to identify each frame’s current and previous stack pointers and its return address.Note that some of the content embedded in the debug records is generated by the C compiler and belongs to code that is either in libraries or the C lib bootstrap code that is bundled in with the Java method code.Currently Supported TargetsThe prototype is currently implemented only for the GNU Debugger on Linux:      Linux/x86_64 support has been tested and should work correctly        Linux/AArch64 support is present but has not yet been fully verified (break points should work ok but stack backtraces may be incorrect)  Windows support is still under development.Debugging with IsolatesThe use of isolates in native image affects the way ordinary object pointers (oops) are encoded.In turn, that means the debug info generator has to provide gdb with information about how to translate an encoded oop to the address in memory, where the object data is stored.This sometimes requires care when asking gdb to process encoded oops vs decoded raw addresses.If isolates were disabled, oops would essentially be raw addresses pointing directly at the object contents.This is generally the same whether the oop is embedded in a static/instance field or is referenced from a local or parameter variable located in a register or saved to the stack.It is not quite that simple because the bottom 3 bits of some oops may be used to hold “tags” that record certain transient properties of an object.However, the debug info provided to gdb means that it will remove these tag bits before dereferencing the oop as an address.With the use of isolates, oops references stored in static or instance fields are actually relative addresses, offsets from a dedicated heap base register (r14 on x86_64, r29 on AArch64), rather than direct addresses (in a few special cases the offset may also have some low tag bits set).When an “indirect” oop of this kind gets loaded during execution, it is almost always immediately converted to a “raw” address by adding the offset to the heap base register value.So, oops which occur as the value of local or parameter vars are actually raw addresses.  Note that on some operating systems enabling isolates causes problems with printing of objects when using a gdb release version 10 or earlier. It is strongly recommended to upgrade your debugger to a later version.The DWARF info encoded into the image, when isolates are enabled, tells gdb to rebase indirect oops whenever it tries to dereference them to access underlying object data.This is normally automatic and transparent, but it is visible in the underlying type model that gdb displays when you ask for the type of objects.For example, consider the static field we encountered above.Printing its type in an image that uses isolates shows that this static field has a different type to the expected one:(gdb) ptype &#39;java.math.BigInteger&#39;::powerCachetype = class _z_.java.math.BigInteger[][] : public java.math.BigInteger[][] {} *The field is typed as _z_.java.math.BigInteger[][] which is an empty wrapper class that inherits from the expected type java.math.BigInteger[][].This wrapper type is essentially the same as the original but the DWARF info record that defines it includes information that tells gdb how to convert pointers to this type.When gdb is asked to print the oop stored in this field it is clear that it is an offset rather than a raw address.(gdb) p/x &#39;java.math.BigInteger&#39;::powerCache$1 = 0x286c08(gdb) x/x 0x286c080x286c08:Cannot access memory at address 0x286c08However, when gdb is asked to dereference through the field, it applies the necessary address conversion to the oop and fetches the correct data.(gdb) p/x *&#39;java.math.BigInteger&#39;::powerCache$2 = {  &amp;lt;java.math.BigInteger[][]&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1ec0e2,        idHash = 0x2f462321      }, &amp;lt;No data fields&amp;gt;},    members of java.math.BigInteger[][]:    len = 0x25,    data = 0x7ffff7a86c18  }, &amp;lt;No data fields&amp;gt;}Printing the type of the hub field or the data array shows that they are also modelled using indirect types:(gdb) ptype $1-&amp;gt;hubtype = class _z_.java.lang.Class : public java.lang.Class {} *(gdb) ptype $2-&amp;gt;datatype = class _z_.java.math.BigInteger[] : public java.math.BigInteger[] {} *[0]The debugger still knows how to dereference these oops:(gdb) p $1-&amp;gt;hub$3 = (_z_.java.lang.Class *) 0x1ec0e2(gdb) x/x $1-&amp;gt;hub0x1ec0e2:Cannot access memory at address 0x1ec0e2(gdb) p *$1-&amp;gt;hub$4 = {  &amp;lt;java.lang.Class&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1dc860,        idHash = 1530752816      }, &amp;lt;No data fields&amp;gt;},    members of java.lang.Class:    name = 0x171af8,    . . .  }, &amp;lt;No data fields&amp;gt;}Since the indirect types inherit from the corresponding raw type it is possible to use an expression that identifies an indirect type pointer in almost all cases where an expression identifying a raw type pointer would work.The only case where care might be needed is when casting a displayed numeric field value or displayed register value.For example, if the indirect hub oop printed above is passed to hubname_raw, the cast to type Object internal to that command fails to force the required indirect oops translation.The resulting memory access fails:(gdb) hubname_raw 0x1dc860Cannot access memory at address 0x1dc860In this case it is necessary to use a slightly different command that casts its argument to an indirect pointer type:(gdb) define hubname_indirect x/s ((&#39;_z_.java.lang.Object&#39; *)($arg0))-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;dataend(gdb) hubname_indirect 0x1dc8600x7ffff78a52f0:&quot;java.lang.Class&quot;Debugging Helper MethodsOn platforms where the debugging information is not fully supported, or when debugging complex issues, it can be helpful to print or query high-level information about the Native Image execution state.For those scenarios, Native Image provides debug helper methods that can be embedded into a native executable by specifying the build-time option -H:+IncludeDebugHelperMethods.While debugging, it is then possible to invoke those debug helper methods like any normal C method.This functionality is compatible with pretty much any debugger.While debugging with gdb, the following command can be used to list all debug helper methods that are embedded into the native image:(gdb) info functions svm_dbg_Before invoking a method, it is best to directly look at the source code of the Java class DebugHelper to determine which arguments each method expects.For example, calling the method below prints high-level information about the Native Image execution state similar to what is printed for a fatal error:(gdb) call svm_dbg_print_fatalErrorDiagnostics($r15, $rsp, $rip)Special Considerations for using perf and valgrindDebug info includes details of address ranges for top level andinlined compiled method code as well as mappings from code addressesto the corresponding source files and lines.perf and valgrind are able to use this information for some oftheir recording and reporting operations.For example, perf report is able to associate code addresses sampledduring a perf record session with Java methods and print theDWARF-derived method name for the method in its output histogram.    . . .    68.18%     0.00%  dirtest          dirtest               [.] _start            |            ---_start               __libc_start_main_alias_2 (inlined)               |                         |--65.21%--__libc_start_call_main               |          com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b (inlined)               |          com.oracle.svm.core.JavaMainWrapper::run (inlined)               |          |                         |          |--55.84%--com.oracle.svm.core.JavaMainWrapper::runCore (inlined)               |          |          com.oracle.svm.core.JavaMainWrapper::runCore0 (inlined)               |          |          |                         |          |          |--55.25%--DirTest::main (inlined)               |          |          |          |                         |          |          |           --54.91%--DirTest::listAll (inlined)               . . .Unfortunately, other operations require Java methods to be identifiedby an ELF (local) function symbol table entry locating the start ofthe compiled method code.In particular, assembly code dumps provided by both tools identifybranch and call targets using an offset from the nearest symbol.Omitting Java method symbols means that offsets are generallydisplayed relative to some unrelated global symbol, usually the entrypoint for a method exported for invocation by C code.As an illustration of the problem, the following excerpted output fromperf annotate displays the first few annotated instructions of thecompiled code for method java.lang.String::String().    . . .         : 501    java.lang.String::String():         : 521    public String(byte[] bytes, int offset, int length, Charset charset) {    0.00 :   519d50: sub    $0x68,%rsp    0.00 :   519d54: mov    %rdi,0x38(%rsp)    0.00 :   519d59: mov    %rsi,0x30(%rsp)    0.00 :   519d5e: mov    %edx,0x64(%rsp)    0.00 :   519d62: mov    %ecx,0x60(%rsp)    0.00 :   519d66: mov    %r8,0x28(%rsp)    0.00 :   519d6b: cmp    0x8(%r15),%rsp    0.00 :   519d6f: jbe    51ae1a &amp;lt;graal_vm_locator_symbol+0xe26ba&amp;gt;    0.00 :   519d75: nop    0.00 :   519d76: nop         : 522    Objects.requireNonNull(charset);    0.00 :   519d77: nop         : 524    java.util.Objects::requireNonNull():         : 207    if (obj == null)    0.00 :   519d78: nop    0.00 :   519d79: nop         : 209    return obj;    . . .The leftmost column shows percentages for the amount of time recordedat each instruction in samples obtained during the perf record run.Each instruction is prefaced with it’s address in the program’s codesection.The disassembly interleaves the source lines from which the code isderived, 521-524 for the top level code and 207-209 for the codeinlined from Objects.requireNonNull().Also, the start of the method is labeled with the name defined in theDWARF debug info, java.lang.String::String().However, the branch instruction jbe at address 0x519d6f uses avery large offset from graal_vm_locator_symbol.The printed offset does identify the correct address relative to thelocation of the symbol.However, this fails to make clear that the target address actuallylies within the compiled code range for method String::String(), in other words that this is a method-local branch.Readability of the tool output is significantly improved ifoption -H-DeleteLocalSymbols is passed to the native-imagecommand.The equivalent perf annotate output with this option enabled is asfollows:    . . .         : 5      000000000051aac0 &amp;lt;String_constructor_f60263d569497f1facccd5467ef60532e990f75d&amp;gt;:         : 6      java.lang.String::String():         : 521    *          {@code offset} is greater than {@code bytes.length - length}         : 522    *         : 523    * @since  1.6         : 524    */         : 525    @SuppressWarnings(&quot;removal&quot;)         : 526    public String(byte[] bytes, int offset, int length, Charset charset) {    0.00 :   51aac0: sub    $0x68,%rsp    0.00 :   51aac4: mov    %rdi,0x38(%rsp)    0.00 :   51aac9: mov    %rsi,0x30(%rsp)    0.00 :   51aace: mov    %edx,0x64(%rsp)    0.00 :   51aad2: mov    %ecx,0x60(%rsp)    0.00 :   51aad6: mov    %r8,0x28(%rsp)    0.00 :   51aadb: cmp    0x8(%r15),%rsp    0.00 :   51aadf: jbe    51bbc1 &amp;lt;String_constructor_f60263d569497f1facccd5467ef60532e990f75d+0x1101&amp;gt;    0.00 :   51aae5: nop    0.00 :   51aae6: nop         : 522    Objects.requireNonNull(charset);    0.00 :   51aae7: nop         : 524    java.util.Objects::requireNonNull():         : 207    * @param &amp;lt;T&amp;gt; the type of the reference         : 208    * @return {@code obj} if not {@code null}         : 209    * @throws NullPointerException if {@code obj} is {@code null}         : 210    */         : 211    public static &amp;lt;T&amp;gt; T requireNonNull(T obj) {         : 212    if (obj == null)    0.00 :   51aae8: nop    0.00 :   51aae9: nop         : 209    throw new NullPointerException();         : 210    return obj;    . . .In this version the start address of the method is now labelled withthe mangled symbol name String_constructor_f60263d569497f1facccd5467ef60532e990f75das well as the DWARF name.The branch target is now printed using an offset from that startsymbol.Unfortunately, perf and valgrind do not correctly understand themangling algorithm employed by GraalVM, nor are they currently able toreplace the mangled name with the DWARF name in the disassembly eventhough both symbol and DWARF function data are known to identify codestarting at the same address.So, the branch instruction still prints its target using a symbol plusoffset but it is at least using the method symbol this time.Also, because address 51aac0 is now recognized as a method start,perf has preceded the first line of the method with 5 context lines,which list the tail end of the method’s javadoc comment.Unfortunately, perf has numbered these lines incorrectly, labellingthe first comment with 521 rather than 516.Executing command perf annotate will provide a disassembly listingfor all methods and C functions in the image.It is possible to annotate a specific method by passing it’s name asan argument to the perf annotate command.Note, however, that perf requires the mangled symbol name asargument rather than the DWARF name.So, in order to annotate method java.lang.String::String() it isnecessary to run command perf annotateString_constructor_f60263d569497f1facccd5467ef60532e990f75d.The valgrind tool callgrind also requires local symbols to beretained in order to provide high quality output.When callgrind is used in combination with a viewer likekcachegrind it is possible to identify a great deal of valuableinformation about native image execution and relate it back tospecific source code lines.Call-graph recording with perf recordNormally when perf does stack frame recording (when --call-graph is used), it uses frame pointers to recognize the individual stack frames.This assumes that the executable that gets profiled actually preserves frame pointers whenever a function gets called.For native images, this can be achieved by using -H:+PreserveFramePointer as an image build argument.An alternative solution is to make perf use dwarf debug info (specifically debug_frame data) to help unwind stack frames.To make this work, the image needs to be built with -g (to generate debuginfo), and perf record needs to use the argument --call-graph dwarf to make sure dwarf debug info (instead of frame pointers) is used for stack unwinding.Related Documentation  Debug Native Executables with GDB",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/"
          },
          
          "latest-reference-manual-llvm-debugging":  {
          "title": "Debugging on the GraalVM LLVM Runtime",
          "content": "Debugging on the GraalVM LLVM RuntimeThe GraalVM LLVM runtime supports source-level (for example, the C language) debugging with the Chrome Developer Tools using GraalVM’s Chrome Inspector implementation.This includes support for single-stepping, breakpoints, and inspection of local and global variables.To use this feature, make sure to compile your program with debug information enabled by specifying the -g argument when compiling with clang (the LLVM toolchain shipped with GraalVM will automatically enable debug information).This gives you the ability to step through the program’s source code and set breakpoints in it.To start debugging, run lli with the --inspect option:$JAVA_HOME/bin/lli --inspect &amp;lt;bitcode file&amp;gt;When launched, the inspector will suspend execution at the first instruction of the program and print a link to the console.Pasting this link into Chrome’s address bar will open the developer tools for you.BreakpointsBreakpoints can only be set in functions that have already been parsed.GraalVM defaults to parsing functions in LLVM bitcode files only when they are first being executed.To instead parse functions eagerly, and be able to set breakpoints also in functions not yet executed, you can use the option lli --llvm.lazyParsing=false.Program-defined Breakpoints Using __builtin_debugtrap()Program-defined breakpoints using the __builtin_debugtrap function enables you to mark locations in the program at which you explicitly want GraalVM to halt the program and switch to the debugger.The debugger automatically halts at each call to this function as if a breakpoint were set on the call.You can use this feature to quickly reach the code you are actually trying to debug without having to first find and set a breakpoint on it after launching your application.You can also instruct Chrome Inspector not to suspend your program at the first source-level statement being executed.When doing so, GraalVM will instead execute your program until it reaches a call to __builtin_debugtrap() before invoking the debugger.To enable this behavior you need to pass the arguments lli --inspect.Suspend=false --inspect.WaitAttached=true.Locating Source FilesDebug information in LLVM bitcode files contains absolute search paths to identify the location of source code.If the source files did not move, it should be found automatically.If the source files moved, or were compiled on a different machine, a search path can be specified using the --inspect.SourcePath=&amp;lt;path&amp;gt; option (multiple paths can be separated by :).",
          "url": " /latest/reference-manual/llvm/Debugging/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics":  {
          "title": "Debugging and Diagnostics",
          "content": "Debugging and DiagnosticsNative Image provides utilities for debugging and inspecting the produced binary:  For debugging produced binaries and obtaining performance profile statistics, see Debug Information  For generating heap dumps, see Heap Dump Support  For JFR events recording, see JDK Flight Recorder (JFR)  For checking which methods were included in a native executable or a shared library, use the Inspection Tool  For an overview of static analysis results, see Static Analysis Reports  For performance analysis, see Linux Perf Profiler Support in Native Image  For an overall insight regarding build phases and the contents of a native executable, use Build Reports  For native memory tracking, see Native Memory Tracking (NMT)  See the Java Diagnostic Command documentation for instructions on using jcmd.  For Java Debug Wire Protocol (JDWP) support in Native Image to enable debugging with standard Java tooling, see Java Debug Wire Protocol (JDWP).",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/"
          },
          
          "latest-reference-manual-espresso-demos":  {
          "title": "Running Demo Applications",
          "content": "Running Demo ApplicationsEspresso is an implementation of the Java Virtual Machine Specification, which offers some interesting capabilities in addition to being able to run applications in Java or other JVM languages.For example, the enhanced HotSwap capabilities boosts developer productivity by enabling unlimited hot code reloading.Moreover, to illustrate what Espresso can do, consider the following short examples.Mixing AOT and JIT for JavaGraalVM Native Image technology allows compiling applications ahead-of-time (AOT) to executable native binaries which:  are standalone  start instantly  have lower memory usageThe main trade off for using Native Image is that the analysis and compilation of your program happens under the closed world assumption, meaning the static analysis needs to process all bytecode which will ever be executed in the application.This makes using some language features such as dynamic class loading or reflection tricky.Espresso is a JVM implementation of a JVM bytecode interpreter, built on the Truffle framework.It is essentially a Java application, as are the Truffle framework itself and the GraalVM JIT compiler.All three of them can be compiled ahead-of-time with native-image.Using Espresso for some parts of your application makes it possible to isolate the required dynamic behavior and still use the native executable on the rest of your code.Consider a canonical Java Shell tool (JShell) as an example command line application.It is a REPL capable of evaluating Java code and consists of two parts:  the UI - CLI app handling input-output  the backend processor for running code you enter into Shell.This design naturally fits the point we are trying to illustrate. We can build a native executable of the JShell’s UI part, and make it include Espresso to run the code dynamically specified at run time.Prerequisites:  GraalVM JDK  EspressoClone the project with the demo applications and navigate to the espresso-jshell directory:git clone https://github.com/graalvm/graalvm-demos.gitcd graalvm-demos/espresso-jshellThe JShell implementation is actually the normal JShell launcher code, which only accepts Espresso implementation of the execution engine.The “glue” code that binds the part which is AOT compiled with the component that dynamically evaluates the code is located in the EspressoExecutionControl class.It loads the JShell classes within the Espresso context and delegate the input to them:protected final Lazy&amp;lt;Value&amp;gt; ClassBytecodes = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ClassBytecodes&quot;));protected final Lazy&amp;lt;Value&amp;gt; byte_array = Lazy.of(() -&amp;gt; loadClass(&quot;[B&quot;));protected final Lazy&amp;lt;Value&amp;gt; ExecutionControlException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ExecutionControlException&quot;));protected final Lazy&amp;lt;Value&amp;gt; RunException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$RunException&quot;));protected final Lazy&amp;lt;Value&amp;gt; ClassInstallException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ClassInstallException&quot;));protected final Lazy&amp;lt;Value&amp;gt; NotImplementedException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$NotImplementedException&quot;));protected final Lazy&amp;lt;Value&amp;gt; EngineTerminationException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$EngineTerminationException&quot;));protected final Lazy&amp;lt;Value&amp;gt; InternalException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$InternalException&quot;));protected final Lazy&amp;lt;Value&amp;gt; ResolutionException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ResolutionException&quot;));protected final Lazy&amp;lt;Value&amp;gt; StoppedException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$StoppedException&quot;));protected final Lazy&amp;lt;Value&amp;gt; UserException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$UserException&quot;));There is more code to pass the values correctly and transform the exceptions.To try it out, build the espresso-jshell binary using the provided script, which will:  Build the Java sources to the bytecode  Build the JAR file  Build a native executableAfter the build you can observe the resulting binary file (file and ldd are Linux commands):file ./espresso-jshellldd ./espresso-jshellIt is indeed a binary file not depending on the JVM, and you can run it noticing how fast it starts:./espresso-jshell|  Welcome to JShell -- Version 11.0.10|  For an introduction type: /help introjshell&amp;gt; 1 + 11 ==&amp;gt; 2Experiment with loading new code into JShell and see how Espresso executes it.Watch a video version of the mixing AOT and JIT compiled code with the Espresso demo.                      watch video                            GraalVM Tools with EspressoEspresso is a proper part of the GraalVM ecosystem, and like other GraalVM-supported languages gets the support of developer tooling by default. The Truffle framework integrates with the tools such as the debugger, profiler, memory analyzer, the Instrumentation API.The interpreter for a language needs to mark the AST nodes with some annotations to support those tools.For example, to be able to use a profiler, a language interpreter needs to mark the root nodes.For the debugger purposes, the language expressions should be marked as instrumental, the scopes for the variables specified, and so on. The language interpreter does not need to integrate with the tools itself.As a result, you can profile a Java application on Espresso out of the box using either the CPU Sampler or Memory Tracer tools.For example, if we have a class like the following one computing the prime numbers:import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.stream.LongStream;public class Main {    public static void main(String[] args) {        Main m = new Main();        for (int i = 0; i &amp;lt; 100_000; i++) {            System.out.println(m.random(100));        }    }    private Random r = new Random(41);    public List&amp;lt;Long&amp;gt; random(int upperbound) {        int to = 2 + r.nextInt(upperbound - 2);        int from = 1 + r.nextInt(to - 1);        return primeSequence(from, to);    }    public static List&amp;lt;Long&amp;gt; primeSequence(long min, long max) {        return LongStream.range(min, max)                .filter(Main::isPrime)                .boxed()                .collect(Collectors.toList());    }    public static boolean isPrime(long n) {        return LongStream.rangeClosed(2, (long) Math.sqrt(n))                .allMatch(i -&amp;gt; n % i != 0);    }}Build this program, and run it with the --cpusampler option.javac Main.javajava -truffle --cpusampler Main &amp;gt; output.txtAt the end of the output.txt file you will find the profiler output, the histogram of the methods, and how much time the execution took.You can also try an experiment with the --memtracer option, to see where the allocations in this program are happening.java -truffle --experimental-options --memtracer Main &amp;gt; output.txtOther tools that GraalVM offers are Chrome Debugger, Code Coverage, and GraalVM Insight.Having the “out-of-the-box” support for the developer tooling makes Espresso an interesting choice of the JVM.Watch a short demonstration of GraalVM built-in tools for Espresso.                      watch video                            ",
          "url": " /latest/reference-manual/espresso/demos/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-deoptcyclepatterns":  {
          "title": "Deoptimization Cycle Patterns",
          "content": "Deoptimization Cycle PatternsAs of GraalVM 25, the Truffle framework includes an automatic deoptimization cycle detection feature, which is a powerful tool for identifying existing deoptimization cycles.The goal of this document is to help prevent deoptimization cycles by describing common patterns that can lead to such cycles, which should be avoided.Always Deoptimizing NodeOne of the simplest patterns that causes a deoptimization cycle is as follows:class AlwaysDeoptNode extends RootNode {    @Override    public Object execute(VirtualFrame frame) {        CompilerDirectives.transferToInterpreterAndInvalidate();        return null;    }}When the above code is compiled, it deoptimizes and invalidates on the first execution.The same occurs with each subsequent compilation and execution.This is an extreme example, and it is hard to imagine how the code could be useful for anything other than testing purposes, but it is a clear cause of unbounded repeated deoptimization—that is, a deoptimization cycle.Invalid Argument Profiling NodeThe following is an example of non-stabilizing argument profiling:class InvalidArgumentProfilingNode extends RootNode {    @CompilerDirectives.CompilationFinal int cachedValue;    @Override    public Object execute(VirtualFrame frame) {        int arg = (int) frame.getArguments()[0];        if (this.cachedValue != arg) {            // Bug: repeated non-stabilizing deoptimization            CompilerDirectives.transferToInterpreterAndInvalidate();            this.cachedValue = arg;        }        return this.cachedValue;    }}The number of deoptimizations and invalidations in the above code is unbounded because the profiled argument can keep changing with no limit on the number of these changes.Consequently, there is no bound on the number of deoptimizations.A possible solution to this problem would be to use IntValueProfile, which caches the value only once and switches to a generic state when the value changes.Stabilize Late NodeThe following code does not cause a true deoptimization cycle.It eventually stabilizes, but stabilization occurs so late that the deoptimization cycle detection tool might still report a cycle:class StabilizeLateNode extends RootNode {    static final int GENERIC = Integer.MIN_VALUE;    @CompilationFinal int cachedValue;    int seenCount = 0;    @Override    public Object execute(VirtualFrame frame) {        int arg = (int) frame.getArguments()[0];        // we assume Integer.MIN_VALUE is never used in value        assert arg != Integer.MIN_VALUE;        int result;        if (cachedValue == GENERIC) {            result = arg;        } else {            if (cachedValue != arg) {                CompilerDirectives.transferToInterpreterAndInvalidate();                if (seenCount &amp;lt; 20) {                    this.cachedValue = arg;                } else {                    cachedValue = GENERIC;                }                seenCount++;                result = arg;            } else {                result = cachedValue;            }        }        return result;    }}After 20 consecutive executions where the argument arg is different from cachedValue, the variable seenCount reaches 20. At this point, deoptimizations stop.Until then, the code may be compiled and deoptimized once for each seenCount value below 20—up to twenty times.Since deoptimization cycle detection is enabled by default after 15 compilations, it could be triggered by this late-stabilizing code.The solution to this problem is to ensure that the optimizations stabilize more quickly.Compilation Final Field of a Non-Constant ObjectTruffle compilation final fields are a powerful optimization tool, often used to control speculations.For example, they are used in conditions checking whether a certain specialized piece of code is valid for the current input.When it is not, the compiled code is deoptimized and invalidated. This allows the code to re-specialize and recompile with the updated assumption.However, this usage must follow one key rule:  The number of possible deoptimizations (and invalidations) caused by the condition involving a compilation final field should be small. As seen in the previous examples, failing to follow this rule can lead to issues.Extra caution must be taken when the object containing the compilation field is not a partial evaluation (PE) constant because, in that case, the field is not compilation-final, and reading it translates to a normal field read.This makes it more difficult to reason about the number of possible deoptimizations caused by a condition involving the field.The following examples demonstrate what can happen if this caution is not exercised.Example 1: Non-Constant Language ContextThe following code shows repeated deoptimization caused by the initialization of each new language context:class LanguageContext {    private final Env env;    @CompilationFinal boolean initialized;    LanguageContext(Env env) {        this.env = env;    }    void ensureInitialized() {        if (!initialized) {            CompilerDirectives.transferToInterpreterAndInvalidate();            initialize();        }    }    private void initialize() {        // perform initialization        initialized = true;    }    static final ContextReference&amp;lt;LanguageContext&amp;gt; REF = ContextReference.create(MyLanguage.class);}class LanguageContextDrivenInitialization extends RootNode {    @Override    public Object execute(VirtualFrame frame) {        LanguageContext languageContext = LanguageContext.REF.get(this);        languageContext.ensureInitialized();        // ...        return null;    }}If TruffleLanguage.Registration.contextPolicy of MyLanguage is SHARED, a new language context is created for each polyglot context used to run the language code.Therefore, languageContext is not a PE constant and so the number of deoptimizations (and invalidations) driven by the initialized boolean is unbounded.A possible solution for this problem would be to transfer to the interpreter only when languageContext is a PE constant, and to annotate the initialize method with TruffleBoundary:class LanguageContext {    private final Env env;    @CompilationFinal boolean initialized;    LanguageContext(Env env) {        this.env = env;    }    void ensureInitialized() {        if (!initialized) {            if (CompilerDirectives.isPartialEvaluationConstant(this)) {                CompilerDirectives.transferToInterpreterAndInvalidate();            }            initialize();        }    }    @TruffleBoundary    void initialize() {        // perform initialization        initialized = true;    }    static final ContextReference&amp;lt;LanguageContext&amp;gt; REF = ContextReference.create(MyLanguage.class);}class LanguageContextDrivenInitialization extends RootNode {    @Override    public Object execute(VirtualFrame frame) {        LanguageContext languageContext = LanguageContext.REF.get(this);        languageContext.ensureInitialized();        // ...        return null;    }}Annotating the method with TruffleBoundary has the downside of being slow when languageContext is not a PE constant, as it would always produce a runtime call after compilation.Another solution could be to perform the initialization eagerly, which would avoid the problem entirely.Example 2: Dispatch NodeThe following code shows repeated deoptimization caused by the initialization of call targets in a dispatch node:class MyFunction {    private final RootNode root;}class DispatchNode extends RootNode {    @Child IndirectCallNode callNode = Truffle.getRuntime().createIndirectCallNode();    @Override    public Object execute(VirtualFrame frame) {        MyFunction function = (MyFunction) frame.getArguments()[0];        CallTarget target = function.root.getCallTarget();        return callNode.call(target);    }}// Simplified version of the RootNode class from the Truffle framework. It is not complete, only relevant parts are listed.class RootNode {    @CompilationFinal private volatile RootCallTarget callTarget;    public final RootCallTarget getCallTarget() {        if (callTarget == null) {            CompilerDirectives.transferToInterpreterAndInvalidate();            initializeTarget();        }        return callTarget;    }}The dispatch node has a single call site, and each uninitialized call target must be initialized before the call.Initialization is performed in the getCallTarget method if the compilation final field callTarget on the callee’s RootNode object is null.The callee’s root node object is not a PE constant.In fact, the number of root nodes the compiled code can see is theoretically unbounded.Initializing a call target causes a deoptimization, so the entire pattern leads to a deoptimization cycle.A possible solution to this problem would be to initialize the call target at parse time or when the function is looked up for the first time.MyFunction objects would then store the call targets directly:class MyFunction {    private final CallTarget target;}class DispatchNode extends RootNode {    @Child IndirectCallNode callNode = IndirectCallNode.create();    @Override    public Object execute(VirtualFrame frame) {        MyFunction funcion = (MyFunction) frame.getArguments()[0];        CallTarget target = function.target;        return callNode.call(target);    }}Skipped ExceptionsThe following code causes a deoptimization by throwing a skipped exception:class SkippedExceptionNode extends RootNode {    @Override    public Object execute(VirtualFrame frame) {        try {            throw new IndexOutOfBoundsException();        } catch (RuntimeException e) {            //        }        return null;    }}Skipped exceptions are exceptions that always cause a deoptimization.The complete list is as follows:  UnexpectedResultException  SlowPathException  ScopedMemoryAccess$ScopedAccessError  ArithmeticException  IllegalArgumentException  IllegalStateException  VirtualMachineError  IndexOutOfBoundsException  ClassCastException  BufferUnderflowException  BufferOverflowException  ReadOnlyBufferException  AssertionErrorAs you can see from the example, catching the exception does not help.Whenever a skipped exception is thrown in Truffle-compiled code, the code is deoptimized and invalidated, and repeated execution of such code leads to a deoptimization cycle.The solution to this problem is to ensure that skipped exceptions are never thrown from compiled code. You can achieve this by either:  Throwing the exception behind TruffleBoundary, or  Using explicit guards to guarantee that the exception cannot be thrown in compiled code.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/DeoptCyclePatterns/"
          },
          
          "latest-reference-manual-native-image-dynamic-features":  {
          "title": "Dynamic Features of Java",
          "content": "Dynamic Features of JavaWhen you build a native image, it only includes the reachable elements starting from your application entry point, its dependent libraries, and the JDK classes discovered through a static analysis. However, the reachability of some elements may not be discoverable due to Java’s dynamic features including reflection, resource access, etc. If an element is not reachable, it will not be included in the generated binary and this can lead to run time failures.Thus, some dynamic Java features may require special “treatment” such as a command line option or provisioning metadata to be compatible with ahead-of-time compilation using Native Image.The reference information here explains how Native Image handles some dynamic features of Java:  Accessing Resources  Certificate Management  Java Native Interface (JNI)  Foreign Function and Memory API in Native Image  JCA Security Services  Reflection  URL Protocols",
          "url": " /latest/reference-manual/native-image/dynamic-features/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-dynamicobjectmodel":  {
          "title": "Dynamic Object Model",
          "content": "Dynamic Object ModelThis guide demonstrates how to use the DynamicObject and node APIs introduced with GraalVM 25.1.The full documentation can be found in the Javadoc.MotivationWhen implementing a dynamic language, the object layout of user-defined objects/classes often cannot be statically inferred and needs to accommodate dynamically added members and changing types.This is where the Dynamic Object API comes in: it takes care of the object layout and classifies objects by their shape, i.e., their properties, and the types of their values.Access nodes can then cache the encountered shapes, forego costly checks and access object properties more efficiently.Getting StartedA guest language should have a common base class for all language objects that extends DynamicObject and implements TruffleObject. For example:@ExportLibrary(InteropLibrary.class)public class BasicObject extends DynamicObject implements TruffleObject {    public BasicObject(Shape shape) {        super(shape);    }    @ExportMessage    boolean hasLanguage() {        return true;    }    // ...}It makes sense to also export common InteropLibrary messages in this class.Builtin object classes can then extend this base class and export additional messages, and, as usual, extra Java fields and methods:@ExportLibrary(InteropLibrary.class)public class Array extends BasicObject {    private final Object[] elements;    public Array(Shape shape, Object[] elements) {        super(shape);        this.elements = elements;    }    @ExportMessage    boolean hasArrayElements() {        return true;    }    @ExportMessage    long getArraySize() {        return elements.length;    }    // ...}You can access dynamic object members through DynamicObject access nodes. To obtain these nodes, cache them using the @Cached annotation provided in the Truffle DSL.Here is an example of how it could be used to implement InteropLibrary messages:@ExportLibrary(InteropLibrary.class)public class SimpleObject extends BasicObject {    public UserObject(Shape shape) {        super(shape);    }    @ExportMessage    boolean hasMembers() {        return true;    }    @ExportMessage    Object readMember(String name,                    @Cached DynamicObject.GetNode getNode)                    throws UnknownIdentifierException {        Object result = getNode.execute(this, name, null);        if (result == null) {            /* Property does not exist. */            throw UnknownIdentifierException.create(name);        }        return result;    }    @ExportMessage    void writeMember(String name, Object value,                    @Cached DynamicObject.PutNode putNode) {        putNode.execute(this, name, value);    }    @ExportMessage    boolean isMemberReadable(String member,                    @Cached DynamicObject.ContainsKeyNode containsKeyNode) {        return containsKeyNode.execute(this, member);    }    // ...}In order to construct instances of these objects, you first need a Shape that you can pass to the DynamicObject constructor.This shape is created using Shape.newBuilder().build().The returned shape describes the initial shape of the object and forms the root of a new shape tree.As you are adding new properties with DynamicObject.PutNode#execute, the object will mutate into other shapes in this shape tree.Note: You should reuse the same initial shapes because shapes are internally cached per root shape.It is recommended that you store the initial shapes in the TruffleLanguage instance, so they can be shared across contexts of the same engine.Static shapes should be avoided except for singletons (like a null value).For example:@TruffleLanguage.Registration(...)public final class MyLanguage extends TruffleLanguage&amp;lt;MyContext&amp;gt; {    private final Shape initialObjectShape;    private final Shape initialArrayShape;    public MyLanguage() {        this.initialObjectShape = Shape.newBuilder().layout(ExtendedObject.class).build();        this.initialArrayShape = Shape.newBuilder().build();    }    public createObject() {        return new MyObject(initialObjectShape);    }    //...}Extended Object LayoutYou can extend the default object layout with extra dynamic fields that you hand over to the dynamic object model by adding @DynamicField-annotated field declarations of type Object or long in your subclasses, and specifying the layout class with Shape.newBuilder().layout(ExtendedObject.class).build();.Dynamic fields declared in this class and its superclasses will then automatically be used to store dynamic object properties and allow faster access to properties that fit into this reserved space.Note: You must not access dynamic fields directly. Always use DynamicObject nodes for this purpose.@ExportLibrary(InteropLibrary.class)public class ExtendedObject extends SimpleObject {    @DynamicField private Object _obj0;    @DynamicField private Object _obj1;    @DynamicField private Object _obj2;    @DynamicField private long _long0;    @DynamicField private long _long1;    @DynamicField private long _long2;    public ExtendedObject(Shape shape) {        super(shape);    }}Caching ConsiderationsTo ensure optimal caching, avoid reusing the same cached DynamicObject node (GetNode, PutNode, etc.) for multiple independent operations.Try to minimize the number of different shapes and property keys that each cached node instance encounters.When the property keys are known statically (compilation-final), always use a separate DynamicObject node for each property key.For example:public abstract class MakePairNode extends BinaryExpressionNode {    @Specialization    Object makePair(Object left, Object right,                    @CachedLanguage MyLanguage language,                    @Cached DynamicObject.PutNode putLeft,                    @Cached DynamicObject.PutNode putRight) {        MyObject obj = language.createObject();        putLeft.execute(obj, &quot;left&quot;, left);        putRight.execute(obj, &quot;right&quot;, right);        return obj;    }}Further ReadingA high-level description of the object model has been published in An Object Storage Model for the Truffle Language Implementation Framework.See Truffle publications for more presentations and publications about Truffle and GraalVM.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/DynamicObjectModel/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-exit":  {
          "title": "Context Exit",
          "content": "Context ExitDifferent Truffle (guest) languages may use different mechanisms for exiting. This is not optimal as a Truffle language has no way to detect and handle an exit triggered by a different language.As of 22.0 Truffle has support for polyglot context hard explicit exit triggered by guest languages using TruffleContext.closeExited(Node,int).It provides a unified way for languages to trigger the exit of the underlying polyglot context. When triggered, all initializedguest languages are first notified using TruffleLanguage.exitContext(C,ExitMode,int), then all context threads are stopped, and finally, the context is closed.The hard explicit exit is simply referred to as “hard exit”.The hard exit is only one of the three types of exit in Truffle. There are the following types of exit.  The new hard exit introduced above          Hard exit notifications are executed with ExitMode.HARD as the second parameter of TruffleLanguage.exitContext(C,ExitMode,int).        Implicit “natural exit”          Occurs during normal context close.      The newly introduced exit notifications are executed for the natural exit as well, but threads are not forced to stop after the natural exit notifications, and so context threads that are still running can block the natural exit.      Natural exit notifications are executed with ExitMode.NATURAL as the second parameter of TruffleLanguage.exitContext(C,ExitMode,int).        “Soft exit”          Explicit exit triggered by throwing a Truffle exception of the exception type ExceptionType.EXIT.      The exception is not automatically thrown in other threads by Truffle and it does not trigger exit notifications or context close on its own.      The context is still fully usable after a soft exit and the soft exit can be followed by either the natural or the hard exit.      For completeness, a polyglot context can be also closed by cancelling it using Context.close(true), TruffleContext.closeCancelled(Node,String), or TruffleContext.closeResourceExhausted(Node,String).The cancel operation leads to immediate stopping of all context threads and closing the context without any exit notifications.Soft exitThe soft exit is triggered by throwing a Truffle exception of the exception type ExceptionType.EXIT - soft exit exception. The exception is not automatically thrown in other threads by Truffle and it does not trigger exit notifications or context close on its own.If not caught by languages, the soft exit exception eventually causes the embedder thread to throw a PolyglotException to the host with PolyglotException.isExit() == true and PolyglotException.getExitStatus() equal to the value specified by the soft exit exception.The context is still fully usable after a soft exit, but the embedder should close the context when it sees the PolyglotException with PolyglotException.isExit() == true, in which case the soft exit is followed by the natural exit.Natural ExitThe natural exit occurs during a normal context close triggered by Context.close() or TruffleContext.close(). The natural exit illustrated in the figure above consists of the following steps:      The natural exit is triggered by Context.close() or TruffleContext.close().    Exit notifications for all initialized languages are executed - TruffleLanguage.exitContext(C,ExitMode,int), where ExitMode.NATURAL is used as the ExitMode parameter.          Guest code runs normally during exit notifications.        All initialized languages are finalized.          TruffleLanguage.finalizeContext(C) is called for all initialized languages.      Guest code runs normally during finalization.        All languages are disposed.          TruffleLanguage.disposeContext(C) is called for all languages.      Hard ExitThis section describes the hard exit process in detail. The hard exit for a polyglot context can be customized by Context.Builder.useSystemExit(boolean). Therefore,the following description is divided into two subsections. One for the case whensystem exit is not enabled (Context.Builder.useSystemExit(false) - the default) and one for the case when system exitis enabled (Context.Builder#useSystemExit(true)). The illustration of the exit process is depicted in the figure above. The figure also relates the exit process to the context cancelling process.The red color of some of the boxes indicates that the context is invalid at that point and no guest code can be run. More precisely, the first Truffle safepoint will throw either a special ThreadDeath exit exception ora special ThreadDeath cancel exception depending on whether the hard exit or the cancel operation is in progress.Behavior if useSystemExit is disabled (default)      The exit is triggered by TruffleContext.closeExited(Node,int).    Exit notifications for all initialized languages are executed - TruffleLanguage.exitContext(C,ExitMode,int), where ExitMode.HARD is used as the ExitMode parameter.          Guest code runs normally during exit notifications.      If the context is not cancelled during exit notifications (during step 2a) and reaches step 2b, the exit process proceeds with the next step. Otherwise, the exit notifications are interrupted and the context is immediately cancelled.        All context threads are forced to stop by throwing a special ThreadDeath exit exception from Truffle safepoints.          To exit threads reliably, languages need to ensure that ThreadDeath is always immediately rethrown and guest language exception handlers and finally blocks are not run.      The embedder threads eventually throw a PolyglotException to the host with PolyglotException.isExit() == true and PolyglotException.getExitStatus()being equal to the exit code originally specified as the second parameter to the first call toTruffleContext.closeExited(Node,int).      Note that from step 3 the exit process is similar to the cancelling process as indicated by the figure, but the cancelling process uses a special ThreadDeath cancel exceptionand the PolyglotException thrown to the host has PolyglotException.isCancelled() == true instead of PolyglotException.isExit() == true.        All initialized languages are finalized.          TruffleLanguage.finalizeContext(C) is called for all initialized languages.      Running any guest code in TruffleLanguage.finalizeContext(C) will throw the special ThreadDeath exit exception from the first Truffle safepoint.      Languages should skip any finalization that would require running guest code. A language can find out if it can run guest code in TruffleLanguage.finalizeContext(C) by checking if TruffleLanguage.exitContext(C,ExitMode,int) was previously called with ExitMode.NATURAL,or by checking that TruffleContext.isClosed() returns false.        All languages are disposed.          TruffleLanguage.disposeContext(C) is called for all languages.        The context is closed.Behavior if useSystemExit is enabled  The exit is triggered by TruffleContext.closeExited(Node,int).          Same as with system exit disabled.        Exit notifications for all initialized languages are executed - TruffleLanguage.exitContext(C,ExitMode,int), where ExitMode.HARD is used as the ExitMode parameter.          Same as with system exit disabled.        System.exit(int) is called to terminate the whole host application providing the fastest exit possible.          The exit code passed to System.exit(int)is the one originally specified as the second parameter to the first call toTruffleContext.closeExited(Node,int).      Example UsageThe SimpleLanguage demonstrates the usage of the hard context exit. The following aspects are demonstrated.  SLExitBuiltin demonstrates triggering the context exit.  SLRegisterShutdownHookBuiltin demonstrates registration of shutdown hooks that are executed during the exit notification defined in SLLanguage.  SLExitTest demonstrates the usage of the builtins defined above.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/Exit/"
          },
          
          "latest-reference-manual-native-image-metadata-experimentalagentoptions":  {
          "title": "Experimental Agent Options",
          "content": "Experimental Agent OptionsThe native-image-agent tool has options which are currently experimental and might be enabled in future releases, but can also be changed or removed entirely.These options are described here.Support For Predefined ClassesNative-image needs all classes to be known at image build time (a “closed-world assumption”).However, Java has support for loading new classes at runtime.To emulate class loading, the agent can be told to trace dynamically loaded classes and save their bytecode for later use by the image builder.This functionality can be enabled by adding experimental-class-define-support to the agent option string, for example: -agentlib:native-image-agent=config-output-dir=config,experimental-class-define-supportApart from the standard configuration files, the agent will create an agent-extracted-predefined-classes directory in the configuration output directory and write bytecode of newly loaded classes on the go.The configuration directory can then be used by image builder without additional tweaks,.The classes will be loaded during the image build, but will not be initialized or made available to the application.At runtime, if there is an attempt to load a class with the same name and bytecode as one of the classes encountered during tracing, the predefined class will be supplied to the application.Known Limitations  Native images support “loading” a predefined class only once per execution, by just a single class loader.  Predefined classes are initialized when they are “loaded” at runtime and cannot be initialized at build time.  The agent collects all classes which are not loaded by one of the Java VM’s built-in class loaders (with some exceptions), that is, from the class path or module path. This includes classes loaded by any custom class loaders.  Classes that are generated with varying data in their name or bytecode, such as sequential or random numbers or timestamps, can generally not be matched to predefined classes at runtime. In these cases, the way such classes are generated needs to be adjusted.Printing Configuration With OriginsFor debugging, it may be useful to know the origin of certain configuration entries.By supplying experimental-configuration-with-origins to the agent option string, the agent will output configuration files with configuration entries broken down to the calling context (stack trace) they originate from in tree form.This option should be used in conjunction with config-output-dir=&amp;lt;path&amp;gt; to tell the agent where to output the configuration files.An example agent option string: -agentlib:native-image-agent=config-output-dir=config-with-origins/,experimental-configuration-with-originsOmitting Configuration From The Agent’s OutputThe agent can omit traced configuration entries present in existing configuration files.There are two ways to specify these existing configuration files:  By using configuration files from the class path or module path. When experimental-omit-config-from-classpath is added to the agent option string, the class path and module path of the running application are scanned for META-INF/native-image/**/*.json configuration files.  By explicitly pointing the agent to an existing configuration file directory using config-to-omit=&amp;lt;path&amp;gt;.Generating Conditional Configuration Using the AgentThe agent can, using a heuristic, generate configuration with reachability conditions on user specified classes.The agent will track configuration origins and try to deduce the conditions automatically.User classes are specified via an agent filter file (for more information on the format, see more about the agent).Additionally, the resulting configuration can further be filtered using another filter file.Currently, this feature supports two modes:  Generating conditional configuration in a single run with the agent.  Generating conditional configuration from multiple runs with the agent and finally merging the collected data.Generating Conditional Configuration During an Agent RunTo enable this mode, add experimental-conditional-config-filter-file=&amp;lt;path&amp;gt; to the agent’s command line, where &amp;lt;path&amp;gt; points to an agent filter file.Classes that are considered included by this filter will be designated as user code classes.To further filter the generated configuration, you can use conditional-config-class-filter-file=&amp;lt;path&amp;gt;, where &amp;lt;path&amp;gt; is a path to an agent filter file.Generating Conditional Configuration From Multiple Agent RunsConditional configuration can be generated from multiple agent runs that reach different code paths in the application.Each agent run produces configuration with metadata. After all agent runs have finished, you can use native-image-utils is then used to merge the collected data and produce a conditional configuration.To generate a conditional configuration, invoke:native-image-utils generate-conditional --user-code-filter=&amp;lt;path-to-filter-file&amp;gt; --class-name-filter=&amp;lt;path-to-filter-file&amp;gt; --input-dir=&amp;lt;path-to-agent-run-output-1&amp;gt; --input-dir=&amp;lt;path-to-agent-run-output-2&amp;gt; ... --output-dir=&amp;lt;path-to-resulting-conditional-config&amp;gt;where:  --user-code-filter=&amp;lt;path-to-filter-file&amp;gt;: path to an agent filter file that specifies user classes  (optional) --class-name-filter=&amp;lt;path-to-filter-file&amp;gt;: path to an agent filter file that further filters the generated configurationThe Underlying HeuristicsConditions are generated using the call tree of the application. The heuristics work as follows:  For each unique method, create a list of all nodes in the call tree that correspond to the method  For each unique method, if the method has more than one call node in the tree:          Find common configuration across all call nodes of that method      For each call node of the method, propagate configuration that isn’t common across these calls to the caller node        Repeat 2. until an iteration produced no changes in the call tree.  For each node that contains configuration, generate a conditional configuration entry with the method’s class as the condition.The primary goal of this heuristic is to attempt to find where a method creates different configuration entries depending on the caller (for example, a method that wraps Class.forName calls.)This implies that the heuristic will not work well for code that generates configuration through a different dependency (for example, same method returns calls Class.forName with different class parameters depending on a system property).Further Reading  Reachability Metadata  Metadata Collection with the Tracing Agent",
          "url": " /latest/reference-manual/native-image/metadata/ExperimentalAgentOptions/"
          },
          
          "latest-reference-manual-espresso-faq":  {
          "title": "Frequently Asked Questions",
          "content": "Frequently Asked QuestionsDoes Java running on Truffle implement the Java language running as a Truffle interpreter?Not quite: it implements the Java Virtual Machine running as a Truffle interpreter.That means it can only run a Java program once it has been compiled to Java bytecode (classes, JAR files, and so on) with your favorite Java compiler (for example, javac) or a build tool (Maven, Gradle, and so on).In the GraalVM family, this is similar to WebAssembly or the LLVM interpreter: while both can run C programs, they have to be compiled by a C compiler first.Does Java running on Truffle run on the HotSpot JVM too?Like other languages implemented with the Truffle framework, it can run both as a native executable or on the HotSpot JVM.Running on the HotSpot JVM is currently only possible on Linux x64.We plan to extend this capability to other platforms.Does running Espresso require the HotSpot JVM?No, it doesn’t, it works fine as a native executable.Espresso does require a standard core Java library (the rt.jar library for Java 8 or the lib/modules file for Java 11+, as well as the associated native libraries: libjava, libnio, and so on).Running Java on GraalVM already brings the highest level of optimization, what benefits will Espresso give me?  Espresso inherits the extensive tooling provided by the Truffle framework. This means that for code coverage and profiling you would no longer need to rely on external tools.  Another important aspect is that Espresso comes with improved isolation of the host Java VM and the Java program running on Truffle.  Moreover, Espresso can run in the context of a native executable while still allowing dynamically-loaded bytecode!  Finally, you can enjoy the benefits of enhanced HotSwap capabilities which will help boost your productivity.What is the license for Espresso?Espresso is an implementation of the Java Virtual Machine. It is open source and is offered as free software under the GNU General Public License version two (GPLv2).Can I run Espresso in production?Yes, you can on Linux x64. Support for other platforms is still experimental.What performance can I expect from executing Espresso?Performance is currently 2-3x slower than the HotSpot JVM.It does not match the speed offered by GraalVM yet for sure, but having created a fully-working Espresso runtime, the development team is now focusing on making it as performant as the GraalVM JIT.Can I embed Java running on Truffle in my application?Yes, you can use GraalVM’s Polyglot API to run Java bytecode in a separate context from the host Java VM.You can even embed a Java 8 context in a Java 11, 17, or 21 application (using the option --java.JavaHome=/path/to/jdk8).Why do I see “Unrecognized option: -javaagent:…/idea_rt.jar…” when I try to run my app from the IDE?It is not possible to attach an agent to Espresso. For the time being, add -XX:+IgnoreUnrecognizedVMOptions to the VM options.",
          "url": " /latest/reference-manual/espresso/faq/"
          },
          
          "latest-reference-manual-js-faq":  {
          "title": "Frequently Asked Questions",
          "content": "Frequently Asked QuestionsBelow are the most frequently asked questions and answers about JavaScript running on GraalVM.CompatibilityIs GraalJS compatible with the JavaScript language?GraalJS is compatible with the ECMAScript 2024 specification and is further developed alongside the 2025 draft specification.The compatibility of GraalJS is verified by external sources, such as the Kangax ECMAScript compatibility table.GraalJS is tested against a set of test engines, such as the official test suite of ECMAScript, test262, as well as tests published by V8 and Nashorn, Node.js unit tests, and GraalJS’s own unit tests.For reference documentation describing the JavaScript APIs that GraalVM supports, see GRAAL.JS-API.My application used to run on Nashorn, why does it not work on GraalJS?Reason:  GraalJS tries to be compatible with the ECMAScript specification, as well as competing engines (including Nashorn). In some cases, this is a contradicting requirement; in these cases, ECMAScript is given precedence. Also, there are cases where GraalJS does not exactly replicate Nashorn features intentionally, for example, for security reasons.Solution:  Enable GraalJS’s Nashorn compatibility mode to add features not enabled by default—this should resolve most cases. However, note that this can have negative effects on application security! See the Nashorn Migration Guide for details.Specific applications:  For JSR 223 ScriptEngine, you might want to set the system property polyglot.js.nashorn-compat to true in order to use the Nashorn compatibility mode.  For ant, use the ANT_OPTS environment variable (ANT_OPTS=&quot;-Dpolyglot.js.nashorn-compat=true&quot;) when using GraalJS via ScriptEngine.Why are built-in functions such as array.map() or fn.apply() not available on non-JavaScript objects such as ProxyArrays from Java?Reason:  Java objects provided to JavaScript are treated as closely as possible to their JavaScript counterparts. For example, Java arrays provided to JavaScript are treated like JavaScript Array exotic objects (JavaScript arrays) whenever possible; the same is true for functions. One obvious difference is that such object’s prototype is null. This means that while you can, for example, read the length or read and write the values of a Java array in JavaScript code, you cannot call sort() on it, as the Array.prototype is not provided by default.Solution:  While the objects do not have the methods of the prototype assigned, you can explicitly call them, for example, Array.prototype.call.sort(myArray).  We offer the option js.foreign-object-prototype. When enabled, objects on the JavaScript side get the most applicable prototype set (such as Array.prototype, Function.prototype, Object.prototype) and can thus behave more similarly to native JavaScript objects of the respective type. Normal JavaScript precedence rules apply here, for example, an object’s own properties (of the Java object in that case) take precedence over and hide properties from the prototype.Note that while the JavaScript built-in functions, for example, from Array.prototype can be called on the respective Java types, those functions expect JavaScript semantics.This means that operations might fail (typically with a TypeError: Message not supported) when an operation is not supported in Java.Consider Array.prototype.push as an example: arrays can grow in size in JavaScript, whereas they are fixed-size in Java, thus pushing a value is semantically not possible and will fail.In such cases, you can wrap the Java object and handle that case explicitly.Use the interfaces ProxyObject and ProxyArray for that purpose.How can I verify GraalJS works on my application?If your module ships with tests, execute them with GraalJS. Of course, this will only test your application, not its dependencies.You can use the GraalVM Language Compatibility tool to discover if the module you are interested in is tested on GraalJS, and whether its tests pass successfully.Additionally, you can upload your package-lock.json or package.json file into that tool and it will analyze all your dependencies.PerformanceWhy is my application slower on GraalJS than on another engine?Reason:  Ensure your benchmark considers warmup. During the first few iterations, GraalJS may be slower than other engines, but after sufficient warmup, this difference should level out.  GraalJS is shipped in two different standalones: Native (default) and JVM (with a -jvm infix). The default Native mode offers faster startup and lower latency, but it might exhibit slower peak performance (lower throughput) once the application is warmed up. In JVM mode, your application might need hundreds of milliseconds more to start, but typically exhibits better peak performance.  Repeated execution of code via newly created org.graalvm.polyglot.Context is slow, despite the same code being executed every time.Solution:  Use proper warmup in your benchmark, and disregard the first few iterations where the application still warms up.  When embedding GraalJS in a Java application, ensure you’re running on a GraalVM JDK for best performance.  Use a JVM standalone for slower startup, but higher peak performance.  Double check you have no options set that might lower your performance, for example, -ea/-esa.  When running code via org.graalvm.polyglot.Context, make sure that one org.graalvm.polyglot.Engine object is shared and passed to each newly created Context. Use org.graalvm.polyglot.Source objects and cache them when possible. Then, GraalVM shares existing compiled code across the Contexts, leading to improved performance. See Code Caching Across Multiple Contexts for more details and an example.  Try to reduce the problem to its root cause and file an issue so the GraalVM team can have a look.How can I achieve the best peak performance?Here are a few tips you can follow to analyze and improve peak performance:  When measuring, ensure you have given the Graal compiler enough time to compile all hot methods before starting to measure peak performance. A useful command line option for that is --engine.TraceCompilation=true—this outputs a message whenever a (JavaScript) method is compiled. Do not begin your measurement until this message becomes less frequent.  Compare the performance between Native Image and JVM mode if possible. Depending on the characteristics of your application, one or the other might show better peak performance.  The Polyglot API comes with several tools and options to inspect the performance of your application:          --cpusampler and --cputracer will print a list of the hottest methods when the application is terminated. Use that list to figure out where most time is spent in your application.      --experimental-options --memtracer can help you understand the memory allocations of your application. Refer to Profiling Command Line Tool for more detail.      What is the difference between running GraalJS in Native Image compared to the JVM?In essence, the GraalJS engine is a plain Java application.Running it on any JVM (JDK 21 or later) is possible, but, for a better result, it should be a GraalVM JDK, or a compatible Oracle JDK using the Graal compiler.This mode gives the JavaScript engine full access to Java at runtime, but also requires the JVM to first (just-in-time) compile the JavaScript engine when executed, just like any other Java application.Running in Native Image means that the JavaScript engine, including all its dependencies from, for example, the JDK, is precompiled into a native executable.This will tremendously reduce the startup of any JavaScript application, as GraalVM can immediately start to compile JavaScript code, without itself requiring to be compiled first.This mode, however, will only give GraalVM access to Java classes known at the time of image creation.Most significantly, this means that the JavaScript-to-Java interoperability features are not available in this mode, as they would require dynamic class loading and execution of arbitrary Java code at runtime.ErrorsTypeError: Access to host class com.myexample.MyClass is not allowed or does not existReason:  You are trying to access a Java class that is unknown to the js process, or is not among the allowed classes that your code can access.Solution:  Ensure there is no typo in the class name.  Ensure the class is on the class path. Use the --vm.cp=&amp;lt;classpath&amp;gt; option.  Ensure access to the class is permitted, by having a @HostAccess.Export annotation on your class and/or the Context.Builder.allowHostAccess() set to a permissive setting. See org.graalvm.polyglot.Context.TypeError: UnsupportedTypeExceptionTypeError: execute on JavaObject[Main$$Lambda$63/1898325501@1be2019a (Main$$Lambda$63/1898325501)] failed due to: UnsupportedTypeExceptionReason:  GraalJS in some cases does not allow concrete callback types when calling from JavaScript to Java. A Java function expecting, for example, a Value object, might fail with the quoted error message due to that.Solution:  Change the signature in the Java callback method.Status:  This is a known limitation and should be resolved in future versions.Example:import java.util.function.Function;import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.HostAccess;public class Minified {  public static void main(String ... args) {    //change signature to Function&amp;lt;Object, String&amp;gt; to make it work    Function&amp;lt;Value, String&amp;gt; javaCallback = (test) -&amp;gt; {      return &quot;passed&quot;;    };    try(Context ctx = Context.newBuilder()    .allowHostAccess(HostAccess.ALL)    .build()) {      Value jsFn = ctx.eval(&quot;js&quot;, &quot;f =&amp;gt; function() { return f(arguments); }&quot;);      Value javaFn = jsFn.execute(javaCallback);      System.out.println(&quot;finished: &quot;+javaFn.execute());    }  }}TypeError: Message not supportedTypeError: execute on JavaObject[Main$$Lambda$62/953082513@4c60d6e9 (Main$$Lambda$62/953082513)] failed due to: Message not supported.Reason:  You are trying to execute an operation (a message) on a polyglot object that this object does not handle. For example, you are calling Value.execute() on a non-executable object.  A security setting (for example, org.graalvm.polyglot.HostAccess) might prevent the operation.Solution:  Ensure the object (type) in question does handle the respective message.  Specifically, ensure the JavaScript operation you try to execute on a Java type is possible semantically in Java. For example, while you can push a value to an array in JavaScript and thus automatically grow the array, arrays in Java are of fixed length and trying to push to a Java array will result in a Message not supported failure. You might want to wrap Java objects for such cases, for example, as a ProxyArray.  Ensure access to the class is permitted, by having a @HostAccess.Export annotation on your class and/or the Context.Builder.allowHostAccess() set to a permissive setting. See org.graalvm.polyglot.Context.  Are you trying to call a Java Lambda expression or Functional Interface? Annotating the proper method with a @HostAccess.Export annotation can be a pitfall. While you can annotate the method to which the functional interface refers, the interface itself (or the Lambda class created in the background) fails to be properly annotated and recognized as exported. See below for examples highlighting the problem and a working solution.An example that triggers a Message not supported error with certain HostAccess settings, e.g., HostAccess.EXPLICIT:{  ...  //a JS function expecting a function as argument  Value jsFn = ...;  //called with a functional interface as argument  jsFn.execute((Function&amp;lt;Integer, Integer&amp;gt;)this::javaFn);  ...}@Exportpublic Object javaFn(Object x) { ... }@Exportpublic Callable&amp;lt;Integer&amp;gt; lambda42 = () -&amp;gt; 42;In the example above, the method javaFn is seemingly annotated with @Export, but the functional interface passed to jsFn is not, as the functional interface behaves like a wrapper around javaFn, thus hiding the annotation.Neither is lambda42 properly annotated—that pattern annotates the field lambda42, nor its executable function in the generated lambda class.In order to add the @Export annotation to a functional interface, use this pattern instead:import java.util.function.Function;import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.HostAccess;public class FAQ {  public static void main(String[] args) {    try(Context ctx = Context.newBuilder()    .allowHostAccess(HostAccess.EXPLICIT)    .build()) {      Value jsFn = ctx.eval(&quot;js&quot;, &quot;f =&amp;gt; function() { return f(arguments); }&quot;);      Value javaFn = jsFn.execute(new MyExportedFunction());      System.out.println(&quot;finished: &quot; + javaFn.execute());    }  }  @FunctionalInterface  public static class MyExportedFunction implements Function&amp;lt;Object, String&amp;gt; {    @Override    @HostAccess.Export    public String apply(Object s) {      return &quot;passed&quot;;    }  };}Another option is to allow access to java.function.Function’s apply method.However, note that this allows access to ALL instances of this interface—in most production environments, this will be too permissive and open potential security holes.HostAccess ha = HostAccess.newBuilder(HostAccess.EXPLICIT)  //warning: too permissive for use in production  .allowAccess(Function.class.getMethod(&quot;apply&quot;, Object.class))  .build();Warning: Implementation does not support runtime compilation.If you get the following warning, you are not running on GraalVM JDK, or a compatible Oracle JDK or OpenJDK using the Graal Compiler:[engine] WARNING: The polyglot context is using an implementation that does not support runtime compilation.The guest application code will therefore be executed in interpreted mode only.Execution only in interpreted mode will strongly impair guest application performance.To disable this warning, use the &#39;--engine.WarnInterpreterOnly=false&#39; option or the &#39;-Dpolyglot.engine.WarnInterpreterOnly=false&#39; system property.To resolve this, use GraalVM or see how to Run GraalJS on a Stock JDK guide for instructions on how to set up the Graal compiler on a compatible Graal-enabled stock JDK.Nevertheless, if this is intentional, you can disable the warning and continue to run with degraded performance by setting the above mentioned option, either via the command line or using the Context.Builder, for example:try (Context ctx = Context.newBuilder(&quot;js&quot;)    .option(&quot;engine.WarnInterpreterOnly&quot;, &quot;false&quot;)    .build()) {  ctx.eval(&quot;js&quot;, &quot;console.log(&#39;Greetings!&#39;);&quot;);}Note that when using an explicit polyglot engine, the option has to be set on the Engine, for example:try (Engine engine = Engine.newBuilder()    .option(&quot;engine.WarnInterpreterOnly&quot;, &quot;false&quot;)    .build()) {  try (Context ctx = Context.newBuilder(&quot;js&quot;).engine(engine).build()) {    ctx.eval(&quot;js&quot;, &quot;console.log(&#39;Greetings!&#39;);&quot;);  }}",
          "url": " /latest/reference-manual/js/FAQ/"
          },
          
          "latest-reference-manual-native-image-native-code-interoperability-ffm-api":  {
          "title": "Foreign Function and Memory API in Native Image",
          "content": "Foreign Function and Memory API in Native ImageThe Foreign Function and Memory (FFM) API is an interface that enables Java code to interact with native code and vice versa.It was finalized in JDK 22 with JEP 454.This page gives an overview of the FFM API support in Native Image.Support for the Foreign Function and Memory API in Native Image is enabled by default starting with GraalVM 25. It can be disabled (for example, to reduce binary size) using the -H:-ForeignAPISupport option, along with -H:+UnlockExperimentalVMOptions.Modules that are permitted to perform restricted native operations (including creating handles for calls to or from native code) must be specified using the --enable-native-access= option.Foreign MemoryNative Image supports all foreign memory features.Foreign FunctionsThe FFM API enables Java code to call down to native functions, and conversely allows native code to call up to invoke Java code via method handles.These two kinds of calls are referred to as “downcalls” and “upcalls”, respectively, and are collectively referred to as “foreign calls”.  Currently supported platforms for downcalls and upcalls are:      Linux/x64    Windows/x64    macOS/AArch64    Linux/AArch64  Looking Up Native FunctionsThe FFM API provides the SymbolLookup interface to find functions in native libraries by name.Native Image supports all available symbol lookup methods, which are SymbolLookup.loaderLookup(), SymbolLookup.libraryLookup(), and Linker.defaultLookup().The default lookup (Linker.defaultLookup()) is currently not supported in static executables (built with option -H:+StaticExecutable).Registering Foreign CallsTo call native code at run time, the native-image builder must generate supporting code at build time.You need to provide the builder with descriptors that describe the functions for downcalls or upcalls at run time.For upcalls, it is recommended to register a specific static method as an upcall target by providing its declaring class and the method name.This allows native-image to create specialized upcall code that can be orders of magnitude faster than an upcall registered only by a function descriptor.Use this approach whenever possible.You can specify the required descriptors for downcalls and upcalls by providing the appropriate configuration in the reachability-metadata.json file. See Using the Configuration File.DowncallsAssume you want to call a C function:int rand(void);To do so, create a downcall handle in Java:Linker linker = Linker.nativeLinker();SymbolLookup stdlib = linker.defaultLookup();ValueLayout intLayout = linker.canonicalLayouts().get(&quot;int&quot;);MethodHandle rand = linker.downcallHandle(        stdlib.find(&quot;rand&quot;).orElseThrow(),        FunctionDescriptor.of(intLayout));To use the downcall handle in Native Image at run time, you must provide the following configuration at build time:{  &quot;foreign&quot;: {    &quot;downcalls&quot;: [      {        &quot;returnType&quot;: &quot;int&quot;,        &quot;parameterTypes&quot;: []      }    ]  }}The return type int denotes a C data type and is one of several canonical types.The following canonical types are guaranteed to be available on all platforms (see also the documentation for java.lang.foreign.Linker):  bool  char  short  int  long  long long  float  double  size_t  wchar_t  void* (for any pointer type)All platforms that Native Image supports also provide canonical layouts for JNI types:  jboolean  jchar  jbyte  jshort  jint  jlong  jfloat  jdoubleThe FFM API also lets you call native functions and pass structured types (such as C structs) by value.Consider the following C struct Point and the C function vector_length:struct Point {    double x;    double y;};double vector_length(struct Point x);In Java, you can create the appropriate downcall handle like this:SymbolLookup lookup = SymbolLookup.libraryLookup(/* ... */);MemoryLayout cDouble = linker.canonicalLayouts().get(&quot;double&quot;);MemoryLayout pointLayout = MemoryLayout.structLayout(cDouble, cDouble);MethodHandle vectorLength = linker.downcallHandle(        lookup.find(&quot;vector_length&quot;).orElseThrow(),        FunctionDescriptor.of(cDouble, pointLayout));To call vector_length, you need this configuration file:{  &quot;foreign&quot;: {    &quot;downcalls&quot;: [      {        &quot;returnType&quot;: &quot;double&quot;,        &quot;parameterTypes&quot;: [&quot;struct(double, double)&quot;]      }    ]  }}In this example, the parameter type struct(double, double) describes a structure consisting of two double members. The structure is compatible with the C type struct Point above.Note that the C compiler automatically aligns struct members which is not the case for Java.If a structure consists of members with different sizes, it may be necessary to use a padding layout in order to align the members.You can also describe more complex layouts:            Layout Type      Description      Code Snippet      Example                  Sequence layout      Corresponds to a fixed-size C array      sequence(&amp;lt;length&amp;gt;, &amp;lt;elementLayout&amp;gt;)      C array int array[10] becomes sequence(10, int)              Union layout      Corresponds to C union types      union(&amp;lt;layout_0&amp;gt;, &amp;lt;layout_1&amp;gt;, ..., &amp;lt;layout_n&amp;gt;)      C union union { int i; long l; } becomes union(int, long)              Padding layout      Specifies extra space for aligning member layouts around word boundaries. This fulfills alignment constraints in struct layouts (explained in “Using Foreign Configuration Files on Different Platforms”)      padding(&amp;lt;bytes&amp;gt;)      -      You can nest these layouts. Consider the following C example:union Foo {    long l;    double d;};struct Bar {    char x;    const char *z;    union Foo z[10];};In the foreign configuration file, express this as:struct(char, padding(7), void*, sequence(10, union(long, double)))The full syntax for specifying memory layouts is described in the “Syntax (EBNF) for Specifying a Memory Layout” section.Linker OptionsThe FFM API can capture the error state of the native run time library (like errno).For example, if you want to call this C library function:double sin(double x);According to the documentation, it may set errno if the argument is an infinity.To capture the value of variable errno after calling the function sin, you need to specify a linker option when creating the downcall handle in Java:Linker linker = Linker.nativeLinker();SymbolLookup stdlib = linker.defaultLookup();MemoryLayout cDouble = linker.canonicalLayouts().get(&quot;double&quot;);MethodHandle sin = linker.downcallHandle(        stdlib.find(&quot;sin&quot;).orElseThrow(),        FunctionDescriptor.of(cDouble, cDouble), Linker.Option.captureCallState(&quot;errno&quot;));In the configuration file, you also need to specify that you want to capture a call state:{  &quot;foreign&quot;: {    &quot;downcalls&quot;: [      {        &quot;returnType&quot;: &quot;double&quot;,        &quot;parameterTypes&quot;: [&quot;double&quot;],        &quot;options&quot;: {          &quot;captureCallState&quot;: true        }      }    ]  }}  Note: While it is necessary to specify the exact variable to capture (for example, errno in the above example) in Java, it is not necessary to do that in the configuration file.In the configuration file, the linker options are specified as properties of a JSON object.You can specify two additional linker options, critical and firstVariadicArg.For a description of those options, please refer to the documentation of java.lang.foreign.Linker.Option.In Java, the linker option critical takes an argument which specifies if the called native function may access heap objects during execution:Linker.Option criticalWithHeapAccess = Linker.Option.critical(true);The corresponding configuration file entry looks as follows:{  &quot;options&quot;: {    &quot;critical&quot;: {      &quot;allowHeapAccess&quot;: true    }  }}The firstVariadicArg linker option expects an int argument that specifies the index of the first variadic argument.Consider the printf function from the standard C library:int printf(const char *fmt, ...);It has one explicit argument and then the variadic arguments start.Therefore, the first variadic argument is at position 1 (note: counting starts at 0).In the configuration file, you specify this as follows:{  &quot;options&quot;: {    &quot;firstVariadicArg&quot;: 1  }}UpcallsYou specify upcalls similarly to downcalls.As an example, you want to use function qsort of the standard C library in order to sort a native array of Java integers:void qsort(void *arr, size_t nmemb, size_t size,           int (*compar)(const void *elem1, const void *elem2));The fourth argument of function qsort is a function pointer of the element compare function.The following Java class uses qsort to sort an array of Java int elements.First, define the class Qsort with the method qsortCompare as the compare function for the native function qsort.Since qsort only provides the addresses of the elements to compare, method qsortCompare expects two parameters of type MemorySegment.The method then reads the integers from the provided addresses and compares them.    public static class Qsort {        public static int qsortCompare(MemorySegment elem1, MemorySegment elem2) {            return Integer.compare(elem1.get(ValueLayout.JAVA_INT, 0), elem2.get(ValueLayout.JAVA_INT, 0));        }    }Next, create the downcall handle for function qsort.Note that the fourth parameter (the function pointer for the compare function) is also a pointer.So, you use C_POINTER in the function descriptor:    private static final SymbolLookup STDLIB = Linker.nativeLinker().defaultLookup();    private static final MemoryLayout C_SIZE_T = Linker.nativeLinker().canonicalLayouts().get(&quot;size_t&quot;);    private static final AddressLayout C_POINTER = (AddressLayout) Linker.nativeLinker().canonicalLayouts().get(&quot;void*&quot;);    private static final MethodHandle QSORT = Linker.nativeLinker().downcallHandle(        STDLIB.find(&quot;qsort&quot;).orElseThrow(),        FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER)    );Next, create the function descriptor for the compare function.The compare function always returns a C int, so use layout C_INT.The parameters are the addresses of the elements to compare, which is represented by the memory layout C_POINTER.However, you are also dereferencing those pointers (since you read the values), so you need to specify the target layout of the pointer.In this case, you want to read Java int, so you use ValueLayout.JAVA_INT:    private static final MemoryLayout C_INT = Linker.nativeLinker().canonicalLayouts().get(&quot;int&quot;);    private static final FunctionDescriptor QSORT_COMPARE_DESC = FunctionDescriptor.of(        C_INT,        C_POINTER.withTargetLayout(ValueLayout.JAVA_INT),        C_POINTER.withTargetLayout(ValueLayout.JAVA_INT)    );In the static constructor, create a method handle to the Java method used as the compare function, then create the upcall stub using the method handle and the previously created function descriptor.The result of the call to Linker.upcallStub(...) is itself a MemorySegment, because the stub needs to be a callable native function pointer.    private static final MemorySegment QSORT_COMPARE_STUB;    static {        try {            MethodHandle ch = MethodHandles.lookup().findStatic(                    Qsort.class,                    &quot;qsortCompare&quot;,                    MethodType.methodType(int.class, MemorySegment.class, MemorySegment.class)            );            // Create function pointer for qsortCompare            QSORT_COMPARE_STUB = Linker.nativeLinker().upcallStub(ch, QSORT_COMPARE_DESC, Arena.ofAuto());        } catch (NoSuchMethodException | IllegalAccessException e) {            throw new RuntimeException(e);        }    }Now you can write a Java method invokeQsort that calls the C function qsort using the downcall handle QSORT.The method invokeQsort takes one parameter, the Java int array to sort.However, the C function qsort cannot directly access a Java array.You need to create a memory arena and copy the elements of the Java array into off-heap memory.Then call qsort, passing the off-heap int array, its length, the size of each element, and the pointer to the compare function.After that, transfer the sorted off-heap array back into a Java int array.    public static int[] invokeQsort(int[] unsortedArray) {        try (Arena arena = Arena.ofConfined()) {            // Allocate off-heap memory and store unsortedArray in it            MemorySegment array = arena.allocateFrom(ValueLayout.JAVA_INT, unsortedArray);            // Call qsort            QSORT.invoke(array, (long) unsortedArray.length, ValueLayout.JAVA_INT.byteSize(), QSORT_COMPARE_STUB);            // Access off-heap memory            return array.toArray(ValueLayout.JAVA_INT);        } catch (Throwable e) {            throw new RuntimeException(e);        }    }To create the downcall and upcall at run time, you need to provide a foreign configuration file that:  Specifies a downcall stub for function qsort  Specifies an upcall stub for the compare function{  &quot;foreign&quot;: {    &quot;downcalls&quot;: [      {        &quot;returnType&quot;: &quot;void&quot;,        &quot;parameterTypes&quot;: [&quot;void*&quot;, &quot;size_t&quot;, &quot;size_t&quot;, &quot;void*&quot;]      }    ],    &quot;upcalls&quot;: [      {        &quot;returnType&quot;: &quot;int&quot;,        &quot;parameterTypes&quot;: [&quot;void*&quot;, &quot;void*&quot;]      }    ]  }}If the target method of an upcall is a static method, use a directUpcall for better performance.This creates an optimized variant of the upcall stub that’s usually much faster and should be preferred.{  &quot;foreign&quot;: {    &quot;downcalls&quot;: [      {        &quot;returnType&quot;: &quot;void&quot;,        &quot;parameterTypes&quot;: [&quot;void*&quot;, &quot;size_t&quot;, &quot;size_t&quot;, &quot;void*&quot;]      }    ],    &quot;directUpcalls&quot;: [      {        &quot;class&quot;: &quot;org.example.QSortInvoke$Qsort&quot;,        &quot;method&quot;: &quot;qsortCompare&quot;,        &quot;returnType&quot;: &quot;int&quot;,        &quot;parameterTypes&quot;: [&quot;void*&quot;, &quot;void*&quot;]      }    ]  }}For completeness, here is the full example:package org.example;// imports ...public class InvokeQsort {    public static class Qsort {        public static int qsortCompare(MemorySegment elem1, MemorySegment elem2) {            return Integer.compare(elem1.get(ValueLayout.JAVA_INT, 0), elem2.get(ValueLayout.JAVA_INT, 0));        }    }    private static final SymbolLookup STDLIB = Linker.nativeLinker().defaultLookup();    private static final MemoryLayout C_SIZE_T = Linker.nativeLinker().canonicalLayouts().get(&quot;size_t&quot;);    private static final AddressLayout C_POINTER = (AddressLayout) Linker.nativeLinker().canonicalLayouts().get(&quot;void*&quot;);    private static final MethodHandle QSORT = Linker.nativeLinker().downcallHandle(            STDLIB.find(&quot;qsort&quot;).orElseThrow(),            FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER)    );    private static final MemoryLayout C_INT = Linker.nativeLinker().canonicalLayouts().get(&quot;int&quot;);    // Function descriptor of the qsort compare function    private static final FunctionDescriptor QSORT_COMPARE_DESC = FunctionDescriptor.of(            C_INT,            C_POINTER.withTargetLayout(ValueLayout.JAVA_INT),            C_POINTER.withTargetLayout(ValueLayout.JAVA_INT)    );    private static final MemorySegment QSORT_COMPARE_STUB;    static {        try {            MethodHandle ch = MethodHandles.lookup().findStatic(                    Qsort.class,                    &quot;qsortCompare&quot;,                    MethodType.methodType(int.class, MemorySegment.class, MemorySegment.class)            );            // Create function pointer for qsortCompare            QSORT_COMPARE_STUB = Linker.nativeLinker().upcallStub(ch, QSORT_COMPARE_DESC, Arena.ofAuto());        } catch (NoSuchMethodException | IllegalAccessException e) {            throw new RuntimeException(e);        }    }    public static int[] invokeQsort(int[] unsortedArray) {        try (Arena arena = Arena.ofConfined()) {            // Allocate off-heap memory and store unsortedArray in it            MemorySegment array = arena.allocateFrom(ValueLayout.JAVA_INT, unsortedArray);            // Call qsort            QSORT.invoke(array, (long) unsortedArray.length, ValueLayout.JAVA_INT.byteSize(), QSORT_COMPARE_STUB);            // Access off-heap memory            return array.toArray(ValueLayout.JAVA_INT);        } catch (Throwable e) {            throw new RuntimeException(e);        }    }}Using the Configuration FileThe foreign configuration is part of the reachability-metadata.json file and is often combined with other metadata for reflection, JNI, and more.You can specify the configuration file to native-image in two ways:  Via command line: Use -H:ConfigurationFileDirectories=/path/to/config-dir/ where the directory directly contains reachability-metadata.json  Via classpath: Put the file in the META-INF/native-image/ directory on the classpath          The builder automatically picks it up at build time      The builder also searches subdirectories of META-INF/native-image/ for files named reachability-metadata.json      Please also refer to the general description of Reachability Metadata and to Specify Configuration Files as Argument for more information.Automatic Metadata Collection Using the Tracing AgentThe FFM API configuration can be collected automatically using the Tracing Agent that is part of GraalVM.The agent tracks all usages of FFM API that creates upcalls or downcalls during application execution on a regular Java VM.When the application completes and the JVM exits, the agent writes configuration to the reachability-metadata.json file in the specified output directory.Register Stubs in a Custom FeatureAs an alternative to writing a foreign configuration file, you can implement a custom Feature to register descriptors and target methods during the image build setup phase using the RuntimeForeignAccess class.This class provides three methods: registerForDowncall, registerForUpcall, and registerForDirectUpcall.Each of those methods registers a single stub corresponding to one entry in the foreign configuration file sections downcalls, upcalls, and directUpcalls, respectively.Referring to the examples in sections Downcalls and Upcalls, the following custom feature would replace the foreign configuration file:package com.example;// imports ...public class CustomFeature implements Feature {    private static final Linker LINKER = Linker.nativeLinker();    private static final MemoryLayout C_INT = LINKER.canonicalLayouts().get(&quot;int&quot;);    private static final MemoryLayout C_DOUBLE = LINKER.canonicalLayouts().get(&quot;double&quot;);    private static final MemoryLayout C_POINTER = LINKER.canonicalLayouts().get(&quot;void*&quot;);    private static final MemoryLayout C_INT_POINTER = C_POINTER.withTargetLayout(ValueLayout.JAVA_INT);    private static final MemoryLayout C_SIZE_T = LINKER.canonicalLayouts().get(&quot;size_t&quot;);    private static final MemoryLayout C_LONG_LONG = LINKER.canonicalLayouts().get(&quot;long long&quot;);    private static final MemoryLayout C_WCHAR_T = LINKER.canonicalLayouts().get(&quot;wchar_t&quot;);    private static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE);    private static final int PADDING_SIZE =  C_LONG_LONG.byteSize() - C_WCHAR_T.byteSize();    private static final MemoryLayout NEEDS_PADDING = MemoryLayout.structLayout(C_WCHAR_T.withName(&quot;x&quot;),                                                                                MemoryLayout.padding(PADDING_SIZE),                                                                                C_LONG_LONG.withName(&quot;y&quot;));    @Override    public void duringSetup(DuringSetupAccess access) {        // required for C function &#39;int rand(void)&#39;        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.of(C_INT));        // required for C function &#39;double vector_length(struct Point x)&#39;        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.of(C_DOUBLE, POINT_LAYOUT));        // required for C function &#39;double sin(double x)&#39;; capture &quot;errno&quot;        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.of(C_DOUBLE, C_DOUBLE), Linker.Option.captureCallState(&quot;errno&quot;));        // required for C function &#39;void qsort(void *arr, size_t nmemb, size_t size, int (*compar)(const void *e0, const void *e1))&#39;        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER));        try {            FunctionDescriptor qsortCompareDesc = FunctionDescriptor.of(C_INT, C_INT_POINTER, C_INT_POINTER);            MethodHandle target = MethodHandles.lookup().findStatic(InvokeQSort.QSort.class, &quot;compare&quot;, qsortCompareDesc.toMethodType());            RuntimeForeignAccess.registerForDirectUpcall(target, qsortCompareDesc);        } catch (NoSuchMethodException | IllegalAccessException e) {            throw new RuntimeException(e);        }        // required for C function &#39;void foo(struct NeedsPadding arg)&#39;        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.ofVoid(NEEDS_PADDING));  }}To activate the custom feature, pass the --features=com.example.CustomFeature option (the fully-qualified name of the feature class) to native-image.It is recommended to do so with a native-image.properties file.Using Foreign Configuration Files on Different PlatformsThe descriptors in foreign configuration files describe the signature of native functions.Therefore, the used type names (for example, long) correspond to C types.When writing foreign configuration files for use on different platforms, you need to be aware that native data types may have different byte size on different platforms.For example, C long has a size of 8 bytes on most platforms, but has a size of only 4 bytes on Windows/x64.Therefore, the C long data type will be mapped to different Java types depending on the platform.In case of 8 bytes, it will be mapped to Java long and in case of 4 bytes, it will be mapped to Java int.Such differences may explain why a certain downcall or upcall stub is not found at run time.Since the data types used in foreign configuration files are resolved using Linker.nativeLinker().canonicalLayouts().get(...), it is recommended to use the canonicalLayouts also in Java code instead of constants like java.lang.foreign.ValueLayout.JAVA_INT.This ensures that they map to the same Java type at run time.For upcalls, you may need to create multiple overloads for the same upcall target method.For example, consider the following C function type declaration:long (*upcall_fun_t)(long);To create an upcall that satisfies this C function type, you need to register this stub in a foreign configuration file:{  &quot;foreign&quot;: {    &quot;upcalls&quot;: [      {        &quot;returnType&quot;: &quot;long&quot;,        &quot;parameterTypes&quot;: [&quot;long&quot;]      }    ]  }}Depending on the platform, you need different Java methods to be able to create an upcall stub at run time.This is because the method type (Java class MethodType) of the method handle for the upcall target needs to be compatible with the method type of the function descriptor.For instance, to use the above foreign configuration file:public class UpcallMethods {    // required on, for example, Linux/x64    public static long upcallTarget(long x) {        return x + 1;    }    // required on, for example, Windows/x64    public static int upcallTarget(int x) {        return x + 1;    }}If possible, use fixed-size data types, such as the JNI types jboolean, jbyte, jchar, jshort, jint, jlong, jfloat and jdouble in C code as well.These always reliably map to the same Java layout on all platforms.For instance, jlong always maps to Java long on all platforms:jlong (*upcall_fun_t)(jlong);You can then use the JNI type in the configuration file:{  &quot;foreign&quot;: {    &quot;upcalls&quot;: [      {        &quot;returnType&quot;: &quot;jlong&quot;,        &quot;parameterTypes&quot;: [&quot;jlong&quot;]      }    ]  }}Structured data types may also be problematic if used on different platforms.For example:struct NeedsPadding {    wchar_t x;    long long y;}void foo(struct NeedsPadding arg) {    /* ... */}C compilers usually align structure members automatically.This is done because aligned memory accesses are more efficient and for portability.Some architectures don’t support misaligned memory accesses, as this reduces hardware complexity.To align the members of a structure, C compilers insert padding between them.When you create a struct layout to describe a C data structure, the members are not aligned automatically.You need to insert the padding manually by creating padding layouts.For example, since the members of struct NeedsPadding have a different byte size, you must explicitly specify the padding.For Linux/x64 this would be done as follows:MemoryLayout cWcharT = LINKER.canonicalLayouts().get(&quot;wchar_t&quot;);MemoryLayout cLongLong = LINKER.canonicalLayouts().get(&quot;long long&quot;);MemoryLayout needsPadding = MemoryLayout.structLayout(cWcharT.withName(&quot;x&quot;), MemoryLayout.padding(4), cLongLong.withName(&quot;y&quot;));However, the memory layout needsPadding cannot be constructed on Windows/x64 because the byte size of wchar_t is 2 and this results in an invalid alignment of member y (it would start at byte offset 6).If you specify a downcall stub in the foreign configuration file, this would look as follows:{  &quot;foreign&quot;: {    &quot;downcalls&quot;: [      {        &quot;returnType&quot;: &quot;void&quot;,        &quot;parameterTypes&quot;: [&quot;struct(wchar_t, padding(4), long long)&quot;]      }    ]  }}Unfortunately, this foreign configuration file cannot be used on Windows/x64 and there is currently no way to express such a difference in the configuration file.There are currently two options to solve that problem:  Write separate configuration files for each platform.  Implement a custom feature class to programmatically register the stubs.If you implement a custom feature class, you can determine the necessary padding programmatically based on the actual size of the members.For structure NeedsPadding, you compute the necessary padding between member x and y by calculating the difference of their byte sizes in method computePadding:package com.example;// imports ...public class ComputePaddingFeature implements Feature {    private static final Linker LINKER = Linker.nativeLinker();    private static final MemoryLayout C_LONG_LONG = LINKER.canonicalLayouts().get(&quot;long long&quot;);    private static final MemoryLayout C_WCHAR_T = LINKER.canonicalLayouts().get(&quot;wchar_t&quot;);    private static final MemoryLayout NEEDS_PADDING = MemoryLayout.structLayout(C_WCHAR_T.withName(&quot;x&quot;),            computePadding(),            C_LONG_LONG.withName(&quot;y&quot;));    private static MemoryLayout computePadding() {        assert C_LONG_LONG.byteSize() &amp;gt; C_WCHAR_T.byteSize();        return MemoryLayout.padding(C_LONG_LONG.byteSize() - C_WCHAR_T.byteSize());    }    @Override    public void duringSetup(DuringSetupAccess access) {        // required for C function &#39;void foo(struct NeedsPadding arg)&#39;        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.ofVoid(NEEDS_PADDING));    }}The padding will be 4 bytes on Linux/x64 and 6 bytes on Windows/x64.Syntax (EBNF) for Specifying a Memory LayoutThe following EBNF defines the syntax for specifying memory layouts in foreign configuration files:Layout ::= Alignment | StructLayout | UnionLayout | ValueLayout | SequenceLayout | PaddingLayoutAlignment ::= &#39;align&#39; &#39;(&#39; Int &#39;,&#39; Layout &#39;)&#39;StructLayout ::= &#39;struct&#39; &#39;(&#39; [ Layout { &#39;,&#39; Layout } ] &#39;)&#39;UnionLayout ::=  &#39;union&#39; &#39;(&#39; [ Layout { &#39;,&#39; Layout } ] &#39;)&#39;SequenceLayout ::= &#39;sequence&#39; &#39;(&#39; Int &#39;,&#39; Layout &#39;)&#39;ValueLayout ::=  canonical layout (for example, &#39;int&#39;, &#39;long&#39;, ...)PaddingLayout ::= &#39;padding&#39; &#39;(&#39; Int &#39;)&#39;Int ::= a positive (decimal) integerInitializing Downcalls and Upcalls During Image BuildIn general, it is not possible to initialize classes at build time if they are creating downcall handles or upcall stubs in the static initializer.This is because, in both cases, the image build would freeze native addresses as constants into the resulting native image.These native addresses are:  Addresses of native functions  Addresses of the call stubs created by the image builder VMHowever, when you run the native image, those addresses will most likely be different and no longer valid.This is also why the native-image tool currently disallows native MemorySegment instances from being included in the resulting image heap.Related Documentation  Interoperability with Native Code  Collect Metadata with the Tracing Agent  Reachability Metadata  reachability-metadata-schema-v1.2.0.json",
          "url": " /latest/reference-manual/native-image/native-code-interoperability/ffm-api/"
          },
          
          "latest-reference-manual-native-image-native-code-interoperability-foreign-interface":  {
          "title": "Foreign Interface",
          "content": "",
          "url": " /latest/reference-manual/native-image/native-code-interoperability/foreign-interface/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-hostoptimization":  {
          "title": "Host Compilation for Interpreter Java code",
          "content": "Host Compilation for Interpreter Java codeFor the following document, we disambiguate between host and guest compilation.  Host compilation is applied to the Java implementation of the interpreter. If the interpreter runs on HotSpot, this kind of compilation is applied when Truffle interpreters are JIT compiled (or dynamically compiled) as Java applications. This compilation is applied ahead of time during native image generation.  Guest compilation is applied to guest language code. This kind of compilation uses Partial Evaluation and Futamura projections to derive optimized code from Truffle ASTs and bytecodes.This section discusses domain-specific host compilations applied to Truffle AST and bytecode interpreters.Host InliningTruffle interpreters are written to support runtime compilation by applying the first Futamura projection.Runtime compilable code, also often referred to as partial evaluatable code, has the following characteristics:  It is naturally designed for high-performance, as it also defines the performance after runtime compilation of a language.  It is written to avoid recursion, as recursive code cannot quickly be partially evaluated.  It avoids complex abstractions and third-party code as they are typically not designed for PE.  The boundaries of partially evaluatable code are reliably defined by methods annotated with @TruffleBoundary, blocks dominated by a call to CompilerDirectives.transferToInterpreter() or a  block protected by a call to CompilerDirectives.inInterpreter().Truffle host inlining leverages these properties and forces inlining during host compilation for runtime compilable code paths as much as possible.The general assumption is that code important for runtime compilation is also important for interpreter execution.Whenever a PE boundary is detected, the host inlining phase no longer makes any inlining decisions and defers them to later inlining phases better suited for regular Java code.The source code for this phase can be found in HostInliningPhase.Truffle host inlining is applied when compiling a method annotated with @HostCompilerDirectives.BytecodeInterpreterSwitch.The maximum node cost for such methods can be configured using -H:TruffleHostInliningByteCodeInterpreterBudget=100000 for native images and -Djdk.graal.TruffleHostInliningByteCodeInterpreterBudget=100000 on HotSpot. If a method that is annotated with  @BytecodeInterpreterSwitch calls a method with the same annotation then the method is directly inlined as long as the cost of both methods do not exceed the budget.In other words, any such method will be treated by the inlining phase just as if they would be part of the root bytecode switch method.This allows bytecode interpreter switches to be composed of multiple methods if needed.Native image, during closed world analysis, computes all methods that are reachable for runtime compilation.Any potentially reachable method from RootNode.execute(...) is determined as runtime compilable.For native images, in addition to bytecode interpreter switches, all runtime compilable methods are optimized using Truffle host inlining.The maximum node cost of such an inlining pass can be configured with -H:TruffleHostInliningBaseBudget=5000.On HotSpot the set of runtime compilable methods is unknown.Therefore, we can only rely on regular Java method inlining for methods not annotated as bytecode interpreter switch on HotSpot.Whenever the maximum budget for a compilation unit is reached, inlining will be stopped. The same budget will be used for the exploration of subtrees during inlining.If a call cannot be fully explored and inlined within the budget, then no decision is taken on the individual subtree.For the vast majority of runtime compilable methods, this limit will not be reached, as it is prevented by natural PE boundaries as well as polymorphic calls to execute methods of @Child nodes.If there are methods that exceed the budget limit, then the recommendation is to optimize such nodes by adding more PE boundaries.If a method exceeds the limit, it is likely that the same code also has a high cost for runtime compilation.Debugging Host InliningThe inlining decisions performed by this phase is best debugged with -H:Log=HostInliningPhase,~CanonicalizerPhase,~GraphBuilderPhase for native images or  -Djdk.graal.Log=HostInliningPhase,~CanonicalizerPhase,~GraphBuilderPhase on HotSpot.You can redirect the output to a file with -Djdk.graal.LogFile=FILE (works for both).Consider the following example, which shows previously described common patterns of partial evaluatable code in Truffle interpreters:class BytecodeNode extends Node {    @CompilationFinal(dimensions = 1) final byte[] ops;    @Children final BaseNode[] polymorphic = new BaseNode[]{new SubNode1(), new SubNode2()};    @Child SubNode1 monomorphic = new SubNode1();    BytecodeNode(byte[] ops) {        this.ops = ops;    }    @BytecodeInterpreterSwitch    @ExplodeLoop(kind = LoopExplosionKind.MERGE_EXPLODE)    public void execute() {        int bci = 0;        while (bci &amp;lt; ops.length) {            switch (ops[bci++]) {                case 0:                    // regular operation                    add(21, 21);                    break;                case 1:                    // complex operation in @TruffleBoundary annotated method                    truffleBoundary();                    break;                case 2:                    // complex operation protected behind inIntepreter                    if (CompilerDirectives.inInterpreter()) {                        protectedByInIntepreter();                    }                    break;                case 3:                    // complex operation dominated by transferToInterpreter                    CompilerDirectives.transferToInterpreterAndInvalidate();                    dominatedByTransferToInterpreter();                    break;                case 4:                    // first level of recursion is inlined                    recursive(5);                    break;                case 5:                    // can be inlined is still monomorphic (with profile)                    monomorphic.execute();                    break;                case 6:                    for (int y = 0; y &amp;lt; polymorphic.length; y++) {                        // can no longer be inlined (no longer monomorphic)                        polymorphic[y].execute();                    }                    break;                default:                    // propagates transferToInterpreter from within the call                    throw CompilerDirectives.shouldNotReachHere();            }        }    }    private static int add(int a, int b) {        return a + b;    }    private void protectedByInIntepreter() {    }    private void dominatedByTransferToInterpreter() {    }    private void recursive(int i) {        if (i == 0) {            return;        }        recursive(i - 1);    }    @TruffleBoundary    private void truffleBoundary() {    }    abstract static class BaseNode extends Node {        abstract int execute();    }    static class SubNode1 extends BaseNode {        @Override        int execute() {            return 42;        }    }    static class SubNode2 extends BaseNode {        @Override        int execute() {            return 42;        }    }}We can run this as a unittest in the Graal repository (see class HostInliningBytecodeInterpreterExampleTest) by running the following command line in graal/compiler:mx unittest  -Djdk.graal.Log=HostInliningPhase,~CanonicalizerPhase,~GraphBuilderPhase -Djdk.graal.Dump=:3  HostInliningBytecodeInterpreterExampleTestThis prints:[thread:1] scope: main  [thread:1] scope: main.Testing  Context: HotSpotMethod&amp;lt;HostInliningBytecodeInterpreterExampleTest$BytecodeNode.execute()&amp;gt;  Context: StructuredGraph:1{HotSpotMethod&amp;lt;HostInliningBytecodeInterpreterExampleTest$BytecodeNode.execute()&amp;gt;}      [thread:1] scope: main.Testing.EnterpriseHighTier.HostInliningPhase      Truffle host inlining completed after 2 rounds. Graph cost changed from 136 to 137 after inlining:      Root[jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode.execute]          INLINE jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode.add(int, int)                      [inlined    2, monomorphic false, deopt false, inInterpreter false, propDeopt false, subTreeInvokes    0, subTreeCost    8, incomplete false,  reason null]          CUTOFF jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode.truffleBoundary()                  [inlined   -1, monomorphic false, deopt false, inInterpreter false, propDeopt false, subTreeInvokes    1, subTreeCost    0, incomplete false,  reason truffle boundary]          INLINE com.oracle.truffle.api.CompilerDirectives.inInterpreter()                                                                    [inlined    0, monomorphic false, deopt false, inInterpreter false, propDeopt false, subTreeInvokes    0, subTreeCost    6, incomplete false,  reason null]          CUTOFF jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode.protectedByInIntepreter()          [inlined   -1, monomorphic false, deopt false, inInterpreter  true, propDeopt false, subTreeInvokes    1, subTreeCost    0, incomplete false,  reason protected by inInterpreter()]          INLINE com.oracle.truffle.api.CompilerDirectives.transferToInterpreterAndInvalidate()                                               [inlined    3, monomorphic false, deopt  true, inInterpreter false, propDeopt false, subTreeInvokes    0, subTreeCost   32, incomplete false,  reason null]            INLINE com.oracle.truffle.api.CompilerDirectives.inInterpreter()                                                                  [inlined    3, monomorphic false, deopt  true, inInterpreter false, propDeopt false, subTreeInvokes    0, subTreeCost    6, incomplete false,  reason null]            CUTOFF com.oracle.truffle.runtime.hotspot.AbstractHotSpotTruffleRuntime.traceTransferToInterpreter()                              [inlined   -1, monomorphic false, deopt  true, inInterpreter  true, propDeopt false, subTreeInvokes    0, subTreeCost    0, incomplete false,  reason dominated by transferToInterpreter()]          CUTOFF jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode.dominatedByTransferToInterpreter() [inlined   -1, monomorphic false, deopt  true, inInterpreter false, propDeopt false, subTreeInvokes    0, subTreeCost    0, incomplete false,  reason dominated by transferToInterpreter()]          INLINE jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode.recursive(int)                     [inlined    4, monomorphic false, deopt false, inInterpreter false, propDeopt false, subTreeInvokes    1, subTreeCost   20, incomplete false,  reason null]            CUTOFF jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode.recursive(int)                   [inlined   -1, monomorphic false, deopt false, inInterpreter false, propDeopt false, subTreeInvokes    1, subTreeCost    0, incomplete false,  reason recursive]          INLINE jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode$SubNode1.execute()                 [inlined    1, monomorphic false, deopt false, inInterpreter false, propDeopt false, subTreeInvokes    0, subTreeCost    6, incomplete false,  reason null]          CUTOFF jdk.graal.compiler.truffle.test.HostInliningBytecodeInterpreterExampleTest$BytecodeNode$BaseNode.execute()                 [inlined   -1, monomorphic false, deopt false, inInterpreter false, propDeopt false, subTreeInvokes    1, subTreeCost    0, incomplete false,  reason not direct call: no type profile]          CUTOFF com.oracle.truffle.api.CompilerDirectives.shouldNotReachHere()                                                               [inlined   -1, monomorphic false, deopt false, inInterpreter false, propDeopt  true, subTreeInvokes    0, subTreeCost   98, incomplete false,  reason propagates transferToInterpreter]Note that we have also used the -Djdk.graal.Dump=:3  option, which sends the graphs to any running IdealGraphVisualizer instance for further inspection.On Native Image, use -H:Dump=:2 -H:MethodFilter=... to dump host compilation graphs of a given method.To debug CUTOFF decisions for incomplete exploration (entries with incomplete  true) use the -Djdk.graal.TruffleHostInliningPrintExplored=true option to see all incomplete subtrees in the log.Tuning Host InliningAfter learning how to debug and trace host inlining decisions, it is time to look at some ways to tune it.As a first step, it is necessary to identify compilation units essential for good interpreter performance.To do this, a Truffle interpreter can be executed in interpreter-only mode by setting the engine.Compilation flag to false. After that, a Java profiler may be used to identify hot spots in the execution.For further details on profiling, see Profiling.mdIf you are looking for advice on how and when to optimize Truffle interpreters, see Optimizing.mdAfter identifying a hot method, for example, the bytecode dispatch loop in a Truffle bytecode interpreter, we can further investigate using host inlining logging as described in the previous section.Interesting entries are prefixed with CUTOFF and have a reason that explains the reason for the individual cutoff.Common reasons for CUTOFF entries are:  dominated by transferToInterpreter() or protected by inInterpreter(): This means that the is call performed in a slow-path. Host inlining will not decide on such calls and just mark them as CUTOFF.  target method not inlinable this happens for host VM methods that cannot be inlined. There is typically not much we can do about that.  Out of budget we ran out of budget for inlining this method. This happens if the cost of the method becomes too high.Additionally, to avoid the explosion of code size, host inlining has a built-in heuristic to detect call subtrees that are considered too complex to inline. For example, the tracing may print the following:CUTOFF com.oracle.truffle.espresso.nodes.BytecodeNode.putPoolConstant(VirtualFrame, int, char, int)   [inlined   -1, explored    0, monomorphic false, deopt false, inInterpreter false, propDeopt false, graphSize 1132, subTreeCost 5136, invokes    1, subTreeInvokes   12, forced false, incomplete false,  reason call has too many fast-path invokes - too complex, please optimize, see truffle/docs/HostCompilation.mdThis indicates that there are too many fast-path invokes (see limit in HostInliningPhase) in the subtree, it also stops exploring after that number.The -Djdk.graal.TruffleHostInliningPrintExplored=true flag may be provided to see the entire subtree for the decision.The following calls are considered fast-path invokes:  Invokes where the target method is annotated by @TruffleBoundary.  Invokes that are polymorphic or where no monomorphic profiling feedback is available. For example, a call to a subexpression’s execute method.  Invokes that are recursive.  Invokes that are too complex themselves. For example, invokes that have too many fast-path invokes.The following calls are not considered fast-path invokes:  Invokes that can be inlined using the host inlining heuristic.  Invokes in a slow-path, like any invoke that is dominated by transferToInterpreter() or protected by isInterpreter().  Invokes that cannot be inlined due to limitations of the host VM, like calls to Throwable.fillInStackTrace().  Invokes that are no longer reachable.It is impossible to avoid fast-path invokes entirely, as, for example, child nodes need to be executed in an AST.It is theoretically possible to avoid all fast-path invokes in a bytecode interpreter. In practice, languages will rely on @TruffleBoundary to the runtime to implement more complex bytecodes.In the following sections, we discuss techniques on how to improve host interpreter code:Optimization: Manually cut code paths with @HostCompilerDirectives.InliningCutoffAs mentioned in the previous section, a heuristic automatically cuts inlining subtrees with too many calls in them.One way to optimize this is by using the @InliningCutoff annotation.Consider the following example:abstract class AddNode extends Node {   abstract Object execute(Object a, Object b);   @Specialization int doInt(int a, int b) { return a + b; }      @Specialization double doDouble(double a, double b) { return a + b; }      @Specialization double doGeneric(Object a, Object b, @Cached LookupAndCallNode callNode) {        return callNode.execute(&quot;__add&quot;, a, b);    }}In this example, the specializations doInt and doDouble are very simple, but there is also the doGeneric specialization, which calls into a complex lookup chain.Assuming that the LookupAndCallNode.execute is a very complex method with many fast-path subtree calls (see limit in HostInliningPhase), we could not expect the execute method to get inlined.Host inlining currently does not support automatic component analysis; though a cutoff can be specified manually using the @InliningCutoff annotation:abstract class AddNode extends Node {   abstract Object execute(Object a, Object b);   @Specialization int doInt(int a, int b) { return a + b; }      @Specialization double doDouble(double a, double b) { return a + b; }      @HostCompilerDirectives.InliningCutoff   @Specialization double doGeneric(Object a, Object b, @Cached LookupAndCallNode callNode) {        return callNode.execute(&quot;__add__&quot;, a, b);    }}After changing the code, host inlining may now decide to inline the execute method of the AddNode if it fits into the host inlining budget, but force a CUTOFF at the doGeneric(...) method call.Please see the javadoc on other use-cases for using this annotation.Optimization: Deduplicating calls from branches that fold during partial evaluationThe following is an example where the code is efficient for compilation using partial evaluation but is not ideal for host compilation.@Child HelperNode helperNode;final boolean negate;// ....int execute(int argument) {if (negate) {return helperNode.execute(-argument);} else {         return helperNode.execute(argument);}}When this code is compiled using partial evaluation, this code is efficient as the condition is guaranteed to fold to a single case, as the negate field is compilation final. During host optimization, the negate field is not compilation final, and the compiler would either inline the code twice or decide not to inline the execute method.In order to avoid this the code can be rewritten as follows:@Child HelperNode helperNode;final boolean negate;// ....int execute(int argument) {    int negatedArgument;    if (negate) {        negatedArgument = -argument;    } else {        negatedArgument = argument;    }    return helperNode.execute(negatedArgument);}Similar code patterns can arise indirectly through code generation if many specializations with the same method body are used.Host compilers typically have a hard time optimizing such patterns automatically.Optimization: Extract complex slow-path code in separate methodsConsider the following example:int execute(int argument) {if (argument == 0) {   CompilerDirectives.transferToInterpreterAndInvalidate();   throw new RuntimeException(&quot;Invalid zero argument &quot; + argument);}return argument;}The Java compiler generates bytecode equivalent to the following code:int execute(int argument) {if (argument == 0) {   CompilerDirectives.transferToInterpreterAndInvalidate();   throw new RuntimeException(new StringBuilder(&quot;Invalid zero argument &quot;).append(argument).build());}return argument;}While this code is efficient for partial evaluation, this code takes up unnecessary space during host inlining.It is therefore recommended to extract a single method for the slow-path part of the code:int execute(int argument) {if (argument == 0) {   CompilerDirectives.transferToInterpreterAndInvalidate();   throw invalidZeroArgument(argument);}return argument;}RuntimeException invalidZeroArgument(int argument) {   throw new RuntimeException(&quot;Invalid zero argument &quot; + argument);}",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/HostOptimization/"
          },
          
          "latest-reference-manual-native-image-overview-hostedvsruntimeoptions":  {
          "title": "Hosted and Runtime Options",
          "content": "",
          "url": " /latest/reference-manual/native-image/overview/HostedvsRuntimeOptions/"
          },
          
          "latest-reference-manual-espresso-hotswap":  {
          "title": "Enhanced HotSwap Capabilities with Espresso",
          "content": "Enhanced HotSwap Capabilities with EspressoWith Espresso you can benefit from enhanced HotSwap capabilities that allow the code to evolve naturally during development without the need for restarting a running application.You do not have to configure anything specific besides launching your app in debug mode and attaching a standard IDE debugger to gain the advantages of enhanced HotSwap.Debugging with EspressoYou can use your favorite IDE debugger to debug Java applications running in the Espresso runtime.For example, starting a debugger session from IntelliJ IDEA is based on the Run Configurations.To ensure you attach the debugger to your Java application in the same environment, navigate in the main menu to Run, Debug…, Edit Configurations, expand Environment, check the JRE value and VM options values.It should show GraalVM as project’s JRE and VM options should include -truffle -XX:+IgnoreUnrecognizedVMOptions. It is necessary to specify -XX:+IgnoreUnrecognizedVMOptions because Intellij automatically adds a -javaagent argument which is not supported yet.Press Debug.This will run the application and start a debugger session in the background.Using HotSwap During a Debugging SessionOnce you have your debugger session running, you will be able to apply extensive code changes (HotSwap) without needing to restart the session.Feel free to try this out on your own applications or by following these instructions:  Create a new Java application.  Use the following main method as a starting point:     public class HotSwapDemo {     private static final int ITERATIONS = 100;     public static void main(String[] args) {         HotSwapDemo demo = new HotSwapDemo();         System.out.println(&quot;Starting HotSwap demo with Espresso: &#39;java.vm.name&#39; = &quot; + System.getProperty(&quot;java.vm.name&quot;));         // run something in a loop         for (int i = 1; i &amp;lt;= ITERATIONS; i++) {             demo.runDemo(i);         }         System.out.println(&quot;Completed HotSwap demo with Espresso&quot;);     }     public void runDemo(int iteration) {         int random = new Random().nextInt(iteration);         System.out.printf(&quot;titeration %d ran with result: %dn&quot;, iteration, random);     } }    Check that the java.vm.name property says you’re running on Espresso.  Place a line breakpoint on the first line in runDemo().      Setup the Run configurations to run with Espresso and press Debug. You will see:            While paused at the breakpoint, extract a method from the body of runDemo():            Reload the changes by navigating to Run -&amp;gt; Debugging Actions -&amp;gt; Reload Changed Classes:            Verify that the change was applied by noticing the &amp;lt;obsolete&amp;gt;:-1 current frame in the Debug -&amp;gt; Frames view:            Place a breakpoint on the first line of the new extracted method and press Resume Program. The breakpoint will hit:            Try to change the access modifiers of printRandom() from private to public static. Reload the changes. Press Resume Program to verify the change was applied:      Watch the video version of the enhanced HotSwap capabilities with Espresso demo.Supported ChangesThe enhanced HotSwap of Espresso is almost feature complete.The following changes are supported:  Add and remove methods  Add and remove constructors  Add and remove methods from interfaces  Change access modifiers of methods  Change access modifiers of constructors  Add and remove fields  Change field type  Move field in hierarchy and preserve state (see note below)  Changes to class access modifiers, for example, abstract and final modifiers  Changes to Lambdas  Add new anonymous inner classes  Remove anonymous inner classes  Changing the superclass  Changing implemented interfacesNote: When instance fields are moved in the class hierarchy the state is preserved whenever possible.Examples include the Pull Up Field refactoring where all existing instances of the origin subclass will be able to read the previously stored value from the super class field.On the other hand, for unrelated subclass instances where the field was not present prior to the change, the new field value will be the language default (null for object-type fields, 0 for int, and so on).The following limitations remain:  Changes to EnumsHotSwap Plugin APIWith Espresso you can benefit from enhanced HotSwap capabilities that allow the code to evolve naturally during development without the need for restarting a running application.While code reloading (HotSwap) is a powerful tool, it is not sufficient to reflect all kinds of changes, for example, changes to annotations, framework-specific changes such as implemented services or beans.For these things the code often needs to be executed to reload configurations or contexts before the changes are fully reflected in the running instance.This is where the Espresso HotSwap Plugin API comes in handy.The HotSwap Plugin API is meant for framework developers by setting up appropriate hooks to reflect changes in response to source code edits in your IDE.The main design principle is that you can register various HotSwap listeners that will be fired on specified HotSwap events.Examples include the ability to re-run a static initializer, a generic post HotSwap callback and hooks when implementations for a certain service provider changes.Note: The HotSwap Plugin API is under development and more fine-grained registration of HotSwap listeners are likely to be added upon requests from the community.You are welcomed to send enhancement requests to help shape the API through our community support channels.Review the HotSwap Plugin API by going through a running example that will enable more powerful reloading support on Micronaut.Micronaut HotSwap PluginThe Micronaut HotSwap plugin example implementation is hosted as a fork of Micronaut-core.The following instructions are based on a macOS X setup and only minor variations are needed for Windows.To get started:  Clone the repository:      git clone git@github.com:javeleon/micronaut-core.git    Build and publish to local Maven repository:      cd micronaut-core  ./gradlew publishMavenPublicationToMavenLocal  Now you will have a HotSwap-ready version of Micronaut.Before setting up a sample application that uses the enhanced version of Micronaut, look at what the plugin does under the hood.The interesting class is MicronautHotSwapPlugin which holds on to an application context that can be reloaded when certain changes are made to the application source code.The class looks like this:final class MicronautHotSwapPlugin implements HotSwapPlugin {    private final ApplicationContext context;    private boolean needsBeenRefresh = false;    MicronautHotSwapPlugin(ApplicationContext context) {        this.context = context;        // register class re-init for classes that provide annotation metadata        EspressoHotSwap.registerClassInitHotSwap(                AnnotationMetadataProvider.class,                true,                () -&amp;gt; needsBeenRefresh = true);        // register ServiceLoader listener for declared bean definitions        EspressoHotSwap.registerMetaInfServicesListener(                BeanDefinitionReference.class,                context.getClassLoader(),                () -&amp;gt; reloadContext());        EspressoHotSwap.registerMetaInfServicesListener(                BeanIntrospectionReference.class,                context.getClassLoader(),                () -&amp;gt; reloadContext());    }    @Override    public String getName() {        return &quot;Micronaut HotSwap Plugin&quot;;    }    @Override    public void postHotSwap(Class&amp;lt;?&amp;gt;[] changedClasses) {        if (needsBeenRefresh) {            reloadContext();        }        needsBeenRefresh = false;    }    private void reloadContext() {        if (Micronaut.LOG.isInfoEnabled()) {            Micronaut.LOG.info(&quot;Reloading app context&quot;);        }        context.stop();        context.flushBeanCaches();        context.start();        // fetch new embedded application bean which will re-wire beans        Optional&amp;lt;EmbeddedApplication&amp;gt; bean = context.findBean(EmbeddedApplication.class);        // now restart the embedded app/server        bean.ifPresent(ApplicationContextLifeCycle::start);    }}The logic regarding the HotSwap API sits in the constructor of this class.Micronaut is architected around compile-time annotation processing where annotation metadata is gathered and stored into static fields in generated classes.Whenever a developer makes a change to a Micronaut-annotated class, the corresponding metadata classes are re-generated.Since standard HotSwap does not (and it should not) re-run static initializers, with HotSwap Plugin static initializer are re-run for all classes that provide metadata (the Micronaut-generated classes). Thus, this API method EspressoHotSwap.registerClassInitHotSwap is used:public static boolean registerClassInitHotSwap(Class&amp;lt;?&amp;gt; klass, boolean onChange, HotSwapAction action)This will register a listener on Class changes for the specific class and importantly any subclass thereof.The onChange variable instructs if static initializers should only be re-run if the code within changed.The action parameter is a hook for firing a specific action whenever a static initializer has been re-run.Here we pass a function for setting the needsBeenRefresh field to true whenever an static initializer is re-run.Upon completion of a HotSwap action the plugin receives a postHotSwap call that, in response to a true needsBeenRefresh, executes the Micronaut-specific code to reload the application context in the reloadContext method.Detecting and Injecting New ClassesHotSwap is designed to enable classes to be HotSwap’ed in a running application.However, if a developer introduces an entirely new class (for example, a new @Controller class in Micronaut), HotSwap does not magically inject a new class, as doing so would require knowledge about internal class loading logic at the very least.A standard way in which classes are discovered by a framework is through the ServiceLoader mechanism.The HotSwap API has built-in support for registering service implementation change listeners by means of the method EspressoHotSwap.registerMetaInfServicesListener:public static boolean registerMetaInfServicesListener(Class&amp;lt;?&amp;gt; serviceType, ClassLoader loader, HotSwapAction action)The current support is limited to listening for implementation changes for class path based service deployment in META-INF/services.Whenever there is a change to the set of service implementations for the registered class type, the action is fired.In the Micronaut HotSwap plugin, reloadContext is executed which will then pickup the changes automatically.Note: HotSwap actions caused by changes to service implementation changes are fired independent of HotSwap. As a developer, you do not need to perform a HotSwap from your IDE to see the new functionality in the running application.Next-Level HotSwap for MicronautNow that you know how the Micronaut HotSwap plugin works, use this feature in a real application.Here is a sample application created from the tutorial “Creating your first Micronaut Graal Application”.Example’s sources can be downloaded as a ready-made Gradle project from here.Download, unzip and open the project in your IDE.Before you proceed, make sure that you have Espresso installed and GraalVM set as the project SDK.  In your IDE navigate to the root build.gradle within the sample project. Add:     run.jvmArgs+=&quot;-truffle&quot;    Also add maven local repository where we previously published the enhanced Micronaut framework. For example:     repositories { mavenLocal() ... }    In gradle.properties update the Micronaut version that you published. For example:     micronautVersion=2.5.8-SNAPSHOT    Now you are all setup.        Executeassemble task and create a run configuration using the defined run Gradle task.        Press the Debug button to start the application in debugging mode, which enables enhanced HotSwap support.        Once the application is started, verify that you get a response from the ConferenceController by going to http://localhost:8080/conferences/random.    Try to make various changes to the classes within the sample app, for example, change the @Controller mapping to a different value, or add a new @Getannotated method and apply HotSwap to see the magic. In case you define a new @Controller class, all you need is compiling the class and once the change is picked up by the file system watch, you will see the reload without the need for explicitly HotSwap.",
          "url": " /latest/reference-manual/espresso/hotswap/"
          },
          
          "latest-reference-manual-espresso-implementation":  {
          "title": "Implementation Details",
          "content": "Implementation DetailsEspresso operates, like other languages implemented with Truffle, both as a native executable or on HotSpot (currently possible on Linux only).In the first case, when the Espresso runtime is compiled to a native executable, it does not require HotSpot to run Java.However, it requires a standard core Java library (the rt.jar library for Java 8 or the lib/modules file for Java 11+, as well as the associated native libraries: libjava, libnio, and so on).Espresso is a minified Java VM that implements all core components of a VM including:  Bytecode interpreter  Bytecode verifier  Single Java Class File parser  Simple object model  Java Native Interface (JNI) implementation in Java  Virtual Machine Implementation in Java  Java Debug Wire Protocol (JDWP)Espresso reuses all JAR files and native libraries from GraalVM.All native libraries and methods are loaded/accessed/called via Truffle Native Function Interface (JNI).JNI handles are implemented in Espresso, for example, all Truffle NFI methods only receive and return primitives.Some methods are substituted for performance, for example, Math.sqrt, System.arraycopy, avoiding the expensive transition to native.Some native libraries might contain static data that would conflict if were used from multiple Espresso contexts or even from both Espresso and Java running on HotSpot.On Linux, Espresso uses the capability of Truffle NFI to try to load libraries in isolated namespaces (dlmopen). This is only available on Linux with glibc and has many limitations.This mode is not used when running in a native executable since there will be no conflict with HotSpot.Current Limitations  Espresso does not implement the JVM Tool Interface (JVMTI). As a result, it does not support the -agentlib, or -agentpath VM options.  Espresso does not implement the java.lang.instrument interface. As a result it does not support the -javaagent VM option.  Espresso currently uses the standard native libraries from the Java core library. This requires allowing a polyglot Context native access. Because of the way these libraries are loaded (via Truffle NFI), running on HotSpot only works on Linux (with glibc). Running as part of a native executable works on Linux, Windows, and macOS but it currently limited to one context.  Support for Java Management Extensions (JMX) is partial and some methods might return partial data.  The Debugger Protocol Implementation (JDWP) lacks some capabilities compared to HotSpot. It will correctly report the supported capabilities. In particular actions that require to enumerate all Java objects are not supported. However, it does support a few hot reloading cases that HotSpot does not.  When the java.MultiThreaded option is set to “false”, reference processing will not happen. Depending on the application, this could create resource leaks. Note that this option is set to “false” automatically if Espresso runs in a context where a single-threaded language is enabled (for example, JavaScript).  Espresso does not support the Polyglot API yet. However, it provides a guest Java Polyglot API, described in polyglot.jar. For more information, see Interoperability with Truffle Languages.",
          "url": " /latest/reference-manual/espresso/implementation/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-inlining":  {
          "title": "Truffle Approach to Function Inlining",
          "content": "Truffle Approach to Function InliningTruffle provides automated inlining for all languages built with the framework.Since the 20.2.0 release a new approach to inlining was introduced.This document describes how the new approach works, compares it to the legacyinlining approach, and motivates the design choices made for the new approach.InliningInlining is the process of replacing a call to a function with the body of that function.This removes the overhead of the call but more importantly it opens up more optimization opportunities for later phases of the compiler.The down side of the process is that the size of the compilation grows with each inlined function.Overly large compilation units are hard to optimize and there is finite memory for installing code.Because of all this, choosing which functions to inline is a delicate trade-offbetween the expected gains of inlining a function versus the cost of theincrease of the size of the compilation unit.Truffle Legacy InliningTruffle has had an approach to inlining for quite a while.Unfortunately, this early approach suffered from multiple issues, the main one being that it relied on the number of Truffle AST nodes in a call target to approximate the size of the call target.AST nodes are a very poor proxy for actual code size of the call target since there is no guarantee how much code a single AST node will produce.For example, an addition node specialized for adding two integers will produce significantly less code than that same node if specialized for adding integers, doubles, and strings (not to mention a different node and nodes from different languages).This made it impossible to have a single inlining approach that would work reliably across all the Truffle languages.One notable thing about the legacy inlining is that, since it only uses information from the AST, inlining decisions are made before partial evaluation begins.This means that we only ever partially evaluate call targets that we decide to inline.The advantage of this approach is that no time is spent on the partial evaluation of call targets that do not end up being inlined.On the other hand this results in frequent compilation problems stemming from the poor decisions made by the inliner.For example, the resulting compilation unit would be too big to compile.Language-agnostic InliningThe main design goal of the new inlining approach is to use the number of Graal nodes (compiler nodes) after partial evaluation as a proxy for call target size.This is a much better size proxy since partial evaluation removes all the abstractions of the AST and results in a graph that is much closer to the low-level instructions that the call target actually performs.This results in a more precise cost model when deciding whether or not to inline a call target, and it removes much ofthe language-specific information that the AST carries (hence the name: Language-agnostic inlining).This is achieved by performing partial evaluation on every candidate call target and then making the inlining decision after that (as opposed to the legacy inlining which made decisions before doing any partial evaluation).Both the amount of partial evaluation that will be done as well as the amount that will be inlined are controlled by the notion of budgets.These are the “exploration budget” and “inlining budget” respectively, both expressed in terms of Graal node counts.The downside of this approach is that we need to do partial evaluation even on call targets which we ultimately decide not to inline.This results in a measurable increase in average compilation time compared to legacy inlining (approximate 10%).Observing and Impacting the InliningThe inliner keeps an internal call tree to keep track of the states of individual calls to targets, as well as the inlining decisions that were made.The following sections explain the states in which calls in the call tree can be, as well as how to find out which decisions were made during compilations.Call Tree StatesNodes in the inline call treerepresent calls to particular targets.This means that if one target calls another twice, we will see this as two nodes despite it being the same call target.Each node can be in one of six states explained here:  Inlined - This state means that the call was inlined. Initially, only theroot of the compilation is in this state since it is implicitly “inlined”(i.e., part of the compilation unit).  Cutoff - This state means that the call target was not partially evaluated,thus was not even considered for inlining. This is normally due to theinliner hitting its exploration budget limitations.  Expanded - This state means that the call target was partially evaluated(thus, considered for inlining) but a decision was made not to inline. Thiscould be due to inlining budget limitations or the target being deemed tooexpensive to inline (e.g., inlining a small target with multiple outgoing“Cutoff” calls would just introduce more calls to the compilation unit).  Removed - This state means that this call is present in the AST but partialevaluation removed the call. This is an advantage over the legacy inliningwhich made the decisions ahead of time and had no way of noticing suchsituations.  Indirect - This state denotes an indirect call. We cannot inline an indirectcall.  BailedOut - This state should be very rare and is considered a performanceproblem. It means that partial evaluation of the target resulted in aBailoutException, i.e., it could not be completed successfully. This means there issome problem with that particular target, but rather than quit the entirecompilation, we treat that call as not possible to inline.Tracing Inlining DecisionsTruffle provides an engine option to trace the final state of the call tree, including a lot of accompanying data, during compilation.This option is TraceInlining and can be set in all the usual ways: by adding --engine.TraceInlining=true to the language launchers, adding -Dpolyglot.engine.TraceInlining=true to the command line ifrunning a regular Java program that executes guest languages (languages implemented with Truffle), or setting the option explicitly for an engine.Here is an example output of TraceInlining for a JavaScript function:[engine] inline start     M.CollidePolygons                                           |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.07 |IR Nodes        27149 |Frequency        1.00 |Truffle Callees     14 |Forced          false |Depth               0[engine] Inlined            M.FindMaxSeparation &amp;lt;opt&amp;gt;                                 |call diff       -8.99 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4617 |Frequency        1.00 |Truffle Callees      7 |Forced          false |Depth               1[engine] Inlined              parseInt &amp;lt;opt&amp;gt;                                          |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               2[engine] Inlined              M.EdgeSeparation                                        |call diff       -3.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4097 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               2[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Inlined              parseInt &amp;lt;opt&amp;gt;                                          |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               2[engine] Expanded             M.EdgeSeparation                                        |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4097 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               2[engine] Inlined              parseInt &amp;lt;opt&amp;gt;                                          |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               2[engine] Inlined              M.EdgeSeparation                                        |call diff       -3.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4097 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               2[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Cutoff               M.EdgeSeparation                                        |call diff        0.01 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        0.01 |Truffle Callees      2 |Forced          false |Depth               2[engine] Cutoff             M.FindMaxSeparation &amp;lt;opt&amp;gt;                                 |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      7 |Forced          false |Depth               1[engine] Cutoff             M.FindIncidentEdge &amp;lt;opt&amp;gt;                                  |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees     19 |Forced          false |Depth               1[engine] Cutoff             parseInt &amp;lt;opt&amp;gt;                                            |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               1[engine] Cutoff             parseInt &amp;lt;opt&amp;gt;                                            |call diff        0.98 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        0.98 |Truffle Callees      0 |Forced           true |Depth               1[engine] Cutoff             A.Set &amp;lt;split-16abdeb5&amp;gt;                                    |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Cutoff             A.Normalize &amp;lt;split-866f516&amp;gt;                               |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      1 |Forced          false |Depth               1[engine] Cutoff             A.Set &amp;lt;split-1f7fe4ae&amp;gt;                                    |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Cutoff             M.ClipSegmentToLine                                       |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               1[engine] Cutoff             M.ClipSegmentToLine                                       |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               1[engine] Cutoff             A.SetV &amp;lt;split-7c14e725&amp;gt;                                   |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Cutoff             A.SetV &amp;lt;split-6029dec7&amp;gt;                                   |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Inlined            L.Set &amp;lt;split-2ef5921d&amp;gt;                                    |call diff       -3.97 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          205 |Frequency        1.98 |Truffle Callees      1 |Forced          false |Depth               1[engine] Inlined              set &amp;lt;split-969378b&amp;gt;                                     |call diff       -1.98 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          716 |Frequency        1.98 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            set                                                       |call diff       -1.98 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          381 |Frequency        1.98 |Truffle Callees      0 |Forced          false |Depth               1[engine] inline done      M.CollidePolygons                                           |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.07 |IR Nodes        27149 |Frequency        1.00 |Truffle Callees     14 |Forced          false |Depth               0Dumping Inlining DecisionsThe same information that is provided in textual form through tracing is also available in the IGV dumps.The graphs are part of the Graal Graphs group in a Call Tree subgroup.The graphs show the state of the call tree before inlining and after.Controlling Inlining BudgetsNote: The default values for inlining-related budgets were carefully chosen with consideration for compilation time, performance, and compiler stability in mind.Changing these parameters can impact all of these.Language-agnostic inlining provides two options to control the amount of exploration and the amount of inlining the compiler can do.These are InliningExpansionBudget and InliningInliningBudget, respectively.Both are expressed in terms of Graal node count.They can be controlled as any other engine options (i.e., the same way as described in the “Tracing inlining decisions” section).InliningExpansionBudget controls at which point the inliner will stop partially evaluating candidates.Increasing this budget can thus have a very negative impact on average compilation time (notably on the time spent doingpartial evaluation), but may provide more candidates for inlining.InliningInliningBudget controls how many Graal nodes the compilation unit is allowed to have as a result of inlining. Increasing this budget will likely result in more candidates being inlined, which will result in a larger compilation unit. This, in turn might slow down compilation, notably in the post partial evaluation phases since larger graphs take more time to optimize.It may also improve performance (removed calls, optimization phases have a bigger picture) or hurt performance, e.g., when a graph is too big to optimize correctly or to compile at all.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/Inlining/"
          },
          
          "latest-tools-graalvm-insight-embedding":  {
          "title": "Embedding Insight into Applications",
          "content": "Embedding Insight into ApplicationsEmbedding Insight into JavaGraal languages (languages implemented with the Truffle framework, such as JavaScript, Python, Ruby, and R) can be embedded into custom Java applications via Polyglot Context API.GraalVM Insight can also be controlled via the same API. Like:final Engine engine = context.getEngine();Instrument instrument = engine.getInstruments().get(&quot;insight&quot;);Function&amp;lt;Source, AutoCloseable&amp;gt; access = instrument.lookup(Function.class);AutoCloseable handle = access.apply(agentSrc);Obtain Engine for Context and ask for the insight instrument.Then create Source with the GraalVM Insight script and apply it while obtaining its instrumentation handle.Use handle.close() to disable all the script’s instrumentation when no longer needed.For example:Source instrument = Source.create(&quot;js&quot;, &quot;&quot;&quot;    insight.on(&#39;return&#39;, function(ctx, frame) {        console.log(`Instrumented where = ${frame.where}`);    }, {        roots: true,        rootNameFilter: &#39;end&#39;,    });    &quot;&quot;&quot;);Source script = Source.create(&quot;js&quot;, &quot;&quot;&quot;    function end() {        var where = &#39;end&#39;;        console.log(where + &#39; invoked&#39;)    }    end();    &quot;&quot;&quot;);try (Context context = Context.newBuilder().build()) {    @SuppressWarnings(&quot;unchecked&quot;)    Function&amp;lt;Source, AutoCloseable&amp;gt; insight = context.getEngine().getInstruments().get(&quot;insight&quot;).lookup(Function.class);    // run without instrumentation    context.eval(script);    // run with instrumentation    try (AutoCloseable handle = insight.apply(instrument)) {        context.eval(script);    }    // run without instrumentation    context.eval(script);}See Embedding Dependency Setup. Add a dependency on insight:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;!-- Select tools: profiler, inspect, coverage, dap, tools --&amp;gt;    &amp;lt;artifactId&amp;gt;insight&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;23.1.1&amp;lt;/version&amp;gt;    &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;Ignoring Internal ScriptsOften one wants to treat certain code written in a dynamic language as a privileged one.Imagine various bindings to OS concepts or other features of one’s application.Such scripts are better to remain blackboxed and hidden from GraalVM Insight instrumentation capabilities.To hide privileged scripts from sight, mark them as internal.By default GraalVM Insight ignores and does not process internal scripts.Extending Functionality of Insight ScriptsWhen embedding GraalVM Insight into a Java application, you can make additional objects available to the Insight scripts being evaluated.For example:@TruffleInstrument.Registration(    id = &quot;meaningOfWorld&quot;, name = &quot;Meaning Of World&quot;, version = &quot;demo&quot;,    services = { Insight.SymbolProvider.class })public final class MeaningOfWorldInstrument extends TruffleInstrument {    @Override    protected void onCreate(Env env) {        Map&amp;lt;String, Integer&amp;gt; symbols = Collections.singletonMap(&quot;meaning&quot;, 42);        Insight.SymbolProvider provider = () -&amp;gt; symbols;        env.registerService(provider);    }}The previous Java code creates an instrument which registers a new symbol meaning to every Insight script evaluated.Each script can then reference it and use it, for example, to limit the number of method invocations:insight.on(&#39;enter&#39;, (ctx, frames) =&amp;gt; { if (--meaning &amp;lt;= 0) throw &#39;Stop!&#39; }, { roots : true });It is possible to expose simple values, as well as complex objects.See the javadoc for more detailed information.Note that instrumentation can alter many aspects of program execution and are not subject to any security sandbox.Embedding Insight into Node.jsThe Insight Manual shows many examples of using GraalVM Insight with node.However most of them rely on the command line option --insight and do not benefit from the dynamic nature of the tool.The next example shows how to create an admin server.Save this code to adminserver.js:function initialize(insight, require) {    const http = require(&quot;http&quot;);    const srv = http.createServer((req, res) =&amp;gt; {        let method = req.method;        if (method === &#39;POST&#39;) {            var data = &#39;&#39;;            req.on(&#39;data&#39;, (chunk) =&amp;gt; {                data += chunk.toString();            });            req.on(&#39;end&#39;, () =&amp;gt; {                const fn = new Function(&#39;insight&#39;, data);                try {                    fn(insight);                    res.write(&#39;GraalVM Insight hook activatedn&#39;);                } finally {                    res.end();                }            });        }    });    srv.listen(9999, () =&amp;gt; console.log(&quot;Admin ready at 9999&quot;));}let waitForRequire = function (event) {  if (typeof process === &#39;object&#39; &amp;amp;&amp;amp; process.mainModule &amp;amp;&amp;amp; process.mainModule.require) {    insight.off(&#39;source&#39;, waitForRequire);    initialize(insight, process.mainModule.require.bind(process.mainModule));  }};insight.on(&#39;source&#39;, waitForRequire, { roots: true });The program opens an HTTP server at port 9999 and listens for incoming scripts to be applied any time later.Invoke the application:node --insight=adminserver.js yourapp.jsAdmin ready at 9999While it is running, connect to the admin port.Send in any GraalVM Insight script to it.For example, the following script is going to observe who calls process.exit:curl --data &#39;insight.on(&quot;enter&quot;, (ctx, frame) =&amp;gt; { console.log(new Error(&quot;call to exit&quot;).stack); }, { roots: true, rootNameFilter: &quot;exit&quot; });&#39; -X POST http://localhost:9999/When writing your own adminserver.js, pay attention to security.Only an authorized person should apply arbitrary hooks to your application.Do not open the admin server port to everybody.What to Read NextTo learn more about Insight and find some use cases, go to the Insight Manual.It starts with an obligatory HelloWorld example and then demonstrates more challenging tasks.",
          "url": " /latest/tools/graalvm-insight/embedding/"
          },
          
          "latest-tools-graalvm-insight-manual":  {
          "title": "Insight Manual",
          "content": "Insight ManualGraalVM Insight is a multipurpose, flexible tool to write reliable applications.The dynamic nature of the tool enables you to selectively apply tracing pointcuts on existing applications with no loss of performance.Any moderately skilled hacker can easily create so called Insight snippets and dynamically apply them to the actual applications.This provides ultimate insights into the execution and behavior of your program without compromising its speed.Table of contents  Quick Start  Hotness Top 10 Example  Apply Insight to Any GraalVM Language  Insights with JavaScript  Insights with Python  Insights with Ruby  Insights with R  Insight into C Code  Inspecting Values  Modifying Local Variables  Insight to a Specific Location  Delaying Insight Initialization in Node.JS  Handling Exceptions  Intercepting and Altering Execution  Minimal Overhead  Minimal Overhead when Accessing Locals  Accessing Execution Stack  Note on GraalVM Insight API  Heap DumpingQuick StartGet started with an obligatory HelloWorld example.Create a script named source-tracing.js with following content:insight.on(&#39;source&#39;, function(ev) {    if (ev.characters) {        print(`Loading ${ev.characters.length} characters from ${ev.name}`);    }});Run it with GraalVM’s node launcher adding the --insight instrument option.Observe the scripts that are loaded and evaluated:./bin/node --js.print --experimental-options --insight=source-tracing.js -e &quot;print(&#39;The result: &#39; + 6 * 7)&quot; | tail -n 10Loading 29938 characters from url.jsLoading 345 characters from internal/idna.jsLoading 12642 characters from punycode.jsLoading 33678 characters from internal/modules/cjs/loader.jsLoading 13058 characters from vm.jsLoading 52408 characters from fs.jsLoading 15920 characters from internal/fs/utils.jsLoading 505 characters from [eval]-wrapperLoading 29 characters from [eval]The result: 42What has just happened? GraalVM Insight source-tracing.js script has used the provided insight object to attach a source listener to the runtime.As such, whenever node loaded a script, the listener was notified of it and could take an action (in this case printing the length and name of processed script).Hotness Top 10 ExampleCollecting insights information is not limited to a print statement.You can perform any Turing-complete computation in your language.For example, a program that counts all method invocations and dumps the most frequent ones when the execution is over.Save the following code to function-hotness-tracing.js:var map = new Map();function dumpHotness() {    print(&quot;==== Hotness Top 10 ====&quot;);    var count = 10;    var digits = 3;    Array.from(map.entries()).sort((one, two) =&amp;gt; two[1] - one[1]).forEach(function (entry) {        var number = entry[1].toString();        if (number.length &amp;gt;= digits) {            digits = number.length;        } else {            number = Array(digits - number.length + 1).join(&#39; &#39;) + number;        }        if (count-- &amp;gt; 0) print(`${number} calls to ${entry[0]}`);    });    print(&quot;========================&quot;);}insight.on(&#39;enter&#39;, function(ev) {    var cnt = map.get(ev.name);    if (cnt) {        cnt = cnt + 1;    } else {        cnt = 1;    }    map.set(ev.name, cnt);}, {    roots: true});insight.on(&#39;close&#39;, dumpHotness);The map is a global variable visible for the whole Insight script that enables the code to share data between the insight.on(&#39;enter&#39;) function and the dumpHotness function.The latter is executed when the node process execution is over (registered via insight.on(&#39;close&#39;, dumpHotness)).Run the program:./bin/node --js.print --experimental-options --insight=function-hotness-tracing.js -e &quot;print(&#39;The result: &#39; + 6 * 7)&quot;The result: 42==== Hotness Top 10 ====516 calls to isPosixPathSeparator311 calls to :=&amp;gt;269 calls to E263 calls to makeNodeErrorWithCode159 calls to :anonymous157 calls to :program 58 calls to getOptionValue 58 calls to getCLIOptionsFromBinding 48 calls to validateString 43 calls to hideStackFrames========================A table with names and counts of function invocations is printed out when the node process exits.Apply Insight to Any GraalVM LanguageThe previous examples were written in JavaScript and used node, but due to the polyglot nature of GraalVM you can take the same instrument and apply it to any language that GraalVM supports.For example, test the Ruby language with GraalVM Insight.To start, create the instrument in the source-trace.js file:insight.on(&#39;source&#39;, function(ev) {   if (ev.uri.indexOf(&#39;gems&#39;) === -1) {     let n = ev.uri.substring(ev.uri.lastIndexOf(&#39;/&#39;) + 1);     print(&#39;JavaScript instrument observed load of &#39; + n);   }});Prepare your Ruby program in the helloworld.rb file:puts &#39;Hello from GraalVM Ruby!&#39;Note: Make sure the Ruby support is enabled. See Polyglot Programming guide.Apply the JavaScript instrument to the Ruby program. Here is what you should see:./bin/ruby --polyglot --insight=source-trace.js helloworld.rbJavaScript instrument observed load of helloworld.rbHello from GraalVM Ruby!It is necessary to start GraalVM’s Ruby launcher with the --polyglot parameter as the source-tracing.js script remains written in JavaScript.Insights with JavaScriptAs stated in the previous section, GraalVM Insight is not limited to Node.js.It is available in all languages runtimes GraalVM provides.Try the JavaScript implementation that comes with GraalVM.Create the function-tracing.js script:var count = 0;var next = 8;insight.on(&#39;enter&#39;, function(ev) {    if (count++ % next === 0) {        print(`Just called ${ev.name} as ${count} function invocation`);        next *= 2;    }}, {    roots: true});Run it on top of sieve.js.It is a sample script which uses a variant of the Sieve of Eratosthenes to compute one hundred thousand of prime numbers:./bin/js --insight=function-tracing.js sieve.js | grep -v ComputedJust called :program as 1 function invocationJust called Natural.next as 17 function invocationJust called Natural.next as 33 function invocationJust called Natural.next as 65 function invocationJust called Natural.next as 129 function invocationJust called Filter as 257 function invocationJust called Natural.next as 513 function invocationJust called Natural.next as 1025 function invocationJust called Natural.next as 2049 function invocationJust called Natural.next as 4097 function invocationInsights with PythonNot only one can instrument any GraalVM language, but also the Insight scripts can be written in that language.In this section you will find a Python example.It is possible to write GraalVM Insight scripts in Python.Such insights can be applied to programs written in Python or any other language.Here is an example of a script that prints out value of variable n when a function minusOne is called.Save this code to the agent.py file:def onEnter(ctx, frame):    print(f&quot;minusOne {frame.n}&quot;)class At:    sourcePath = &quot;.*agent-fib.js&quot;class Roots:    roots = True    at = At()    rootNameFilter = &quot;minusOne&quot;insight.on(&quot;enter&quot;, onEnter, Roots())This code uses a declarative specification of source location introduced in GraalVM 22.2. Use a dynamic sourceFilter with older GraalVM versions:def onEnter(ctx, frame):    print(f&quot;minusOne {frame.n}&quot;)class Roots:    roots = True    rootNameFilter = &quot;minusOne&quot;    def sourceFilter(self, src):        return src.name == &quot;agent-fib.js&quot;insight.on(&quot;enter&quot;, onEnter, Roots())Apply this script to agent-fib.js using the following command:`./bin/js --polyglot --insight=agent.py agent-fib.js`Note: Make sure the Python support is enabled. See Polyglot Programming guide.Insights with RubyIt is possible to write GraalVM Insight scripts in Ruby.Such insights can be applied to programs written in Ruby or any other language.Note: Make sure the Ruby support is enabled. See Polyglot Programming guide.Create the source-tracing.rb script:puts(&quot;Ruby: Insight version #{insight.version} is launching&quot;)insight.on(&quot;source&quot;, -&amp;gt; (env) {  puts &quot;Ruby: observed loading of #{env.name}&quot;})puts(&quot;Ruby: Hooks are ready!&quot;)Launch a Node.js program and instrument it with the Ruby script:./bin/node --js.print --experimental-options --polyglot --insight=source-tracing.rb agent-fib.jsRuby: Initializing GraalVM Insight scriptRuby: Hooks are ready!Ruby: observed loading of node:internal/errorsRuby: observed loading of node:internal/utilRuby: observed loading of node:events....Ruby: observed loading of node:internal/modules/run_mainRuby: observed loading of &amp;lt;...&amp;gt;/agent-fib.jsThree is the result 3To track variable values, create agent.rb script:insight.on(&quot;enter&quot;, -&amp;gt; (ctx, frame) {    puts(&quot;minusOne #{frame.n}&quot;)}, {  roots: true,  rootNameFilter: &quot;minusOne&quot;,  at: {    sourcePath: &quot;.*agent-fib.js&quot;  }})This code uses a declarative specification of source location introduced in GraalVM 22.2. Use a dynamic sourceFilter with older GraalVM versions:insight.on(&quot;enter&quot;, -&amp;gt; (ctx, frame) {    puts(&quot;minusOne #{frame.n}&quot;)}, {  roots: true,  rootNameFilter: &quot;minusOne&quot;,  sourceFilter: -&amp;gt; (src) {    return src.name == Dir.pwd+&quot;/agent-fib.js&quot;  }})The above Ruby script example prints out value of variable n when a function minusOne in the agent-fib.js program is called:./bin/node --js.print --experimental-options --polyglot --insight=agent.rb agent-fib.jsminusOne 4minusOne 3minusOne 2minusOne 2Three is the result 3Insights with RThe same instrument can be written in the R language.Create the agent-r.R script:cat(&quot;R: Initializing GraalVM Insight scriptn&quot;)insight@on(&#39;source&#39;, function(env) {    cat(&quot;R: observed loading of &quot;, env$name, &quot;n&quot;)})cat(&quot;R: Hooks are ready!n&quot;)Use it to trace a test.R program:./bin/Rscript --insight=agent-r.R test.RR: Initializing GraalVM Insight scriptR: Hooks are ready!R: observed loading of test.RThe only change is the R language. All the other GraalVM Insight features and APIs remain the same.Insight into C CodeNot only it is possible to interpret dynamic languages, but with the help of the GraalVM’s LLI implementation, one can mix in even statically compiled programs written in C, C++, Fortran, Rust, etc.Take, for example, a long running program such as sieve.c, which contains never-ending for loop in its main method. You would like to give it some execution quota.First, execute the program on GraalVM:export TOOLCHAIN_PATH=`.../bin/lli --print-toolchain-path`${TOOLCHAIN_PATH}/clang agent-sieve.c -lm -o sieve./bin/lli sieveThe GraalVM clang wrapper adds special options instructing the regular clang to keep the LLVM bitcode information in the sieve executable along the normal native code.The GraalVM’s lli interpreter can then use the bitcode to interpret the program at full speed.By the way, compare the result of direct native execution via ./sieve and interpreter speed of ./bin/lli sieve.It should show quite good results as for an interpreter.Now focus on breaking the endless loop. You can do it with this JavaScript agent-limit.js Insight script:var counter = 0;insight.on(&#39;enter&#39;, function(ctx, frame) {    if (++counter === 1000) {        throw `GraalVM Insight: ${ctx.name} method called ${counter} times. enough!`;    }}, {    roots: true,    rootNameFilter: &#39;nextNatural&#39;});The script counts the number of invocations of the C nextNatural function and when the function gets invoked a thousand times, it emits an error to stop the sieve execution.Run the program as:./bin/lli --polyglot --insight=agent-limit.js sieveComputed 97 primes in 181 ms. Last one is 509GraalVM Insight: nextNatural method called 1000 times. enough!        at &amp;lt;js&amp;gt; :anonymous(&amp;lt;eval&amp;gt;:7:117-185)        at &amp;lt;llvm&amp;gt; nextNatural(agent-sieve.c:14:186-221)        at &amp;lt;llvm&amp;gt; nextPrime(agent-sieve.c:74:1409)        at &amp;lt;llvm&amp;gt; measure(agent-sieve.c:104:1955)        at &amp;lt;llvm&amp;gt; main(agent-sieve.c:123:2452)It is possible to access primitive local variables from the native code.Replace the above Insight script with:insight.on(&#39;enter&#39;, function(ctx, frame) {    print(`found new prime number ${frame.n}`);}, {    roots: true,    rootNameFilter: (n) =&amp;gt; n === &#39;newFilter&#39;});Print out a message every time a new prime is added into the filter list:./bin/lli --polyglot --insight=agent-limit.js sieve | head -n 3found new prime number 2found new prime number 3found new prime number 5The mixture of lli, polyglot and GraalVM Insight opens enormous possibilities in tracing, controlling and interactive or batch debugging of native programs.Inspecting ValuesGraalVM Insight not only allows one to trace where the program execution is happening, but it also offers access to values of local variables and function arguments during execution.One can for example write instrument that shows a value of argument n in a function fib:insight.on(&#39;enter&#39;, function(ctx, frame) {   print(&#39;fib for &#39; + frame.n);}, {   roots: true,   rootNameFilter: &#39;fib&#39;});This instrument uses the second function argument frame to get access to values of local variables inside of every instrumented function.The above Insight script also uses rootNameFilter to apply its hook only to function named fib:function fib(n) {  if (n &amp;lt; 1) return 0;  if (n &amp;lt; 2) return 1;  else return fib(n - 1) + fib(n - 2);}print(&quot;Two is the result &quot; + fib(3));When the instrument is stored in a fib-trace.js file and the actual code in fib.js, then invoking following command yields detailed information about the program execution and parameters passed between function invocations:./bin/node --js.print --experimental-options --insight=fib-trace.js fib.jsfib for 3fib for 2fib for 1fib for 0fib for 1Two is the result 2To summarize this section, GraalVM Insight is a useful tool for polyglot, language agnostic aspect oriented programming.Modifying Local VariablesNot only that GraalVM Insight can access local variables, but it can also modify them.Take, for example, this program summing an array:function plus(a, b) {  return a + b;}var sum = 0;[1, 2, 3, 4, 5, 6, 7, 8, 9].forEach((n) =&amp;gt; sum = plus(sum, n));print(sum);It prints out a number 45.Apply the following Insight script to “erase” non-even numbers before adding them:insight.on(&#39;enter&#39;, function zeroNonEvenNumbers(ctx, frame) {    if (frame.b % 2 === 1) {        frame.b = 0;    }}, {    roots: true,    rootNameFilter: &#39;plus&#39;});When launched with js --insight=erase.js sumarray.js, only the value 20 gets printed.GraalVM Insight enter and return hooks can only modify existing variables.They cannot introduce new ones.Attempts to do so yield an exception.Insight to a Specific LocationTo get to variables at a specific code location, the at object may have not only one of the mandatory source specifications:a sourcePath property with the regular expression matching the source file path, or sourceURI property with string representation of the source URI.There can also be an optional line and/or column specified. Let’s have a distance.js source file:(function(x, y) {    let x2 = x*x;    let y2 = y*y;    let d = Math.sqrt(x2 + y2);    for (let i = 0; i &amp;lt; d; i++) {        // ...    }    return d;})(3, 4);Then we can apply following distance-trace.js insight script to get values of variables:insight.on(&#39;enter&#39;, function(ctx, frame) {    print(&quot;Squares: &quot; + frame.x2 + &quot;, &quot; + frame.y2);}, {    statements: true,    at: {        sourcePath: &quot;.*distance.js&quot;,        line: 4    }});insight.on(&#39;enter&#39;, function(ctx, frame) {    print(&quot;Loop var i = &quot; + frame.i);}, {    expressions: true,    at: {        sourcePath: &quot;.*distance.js&quot;,        line: 5,        column: 21    }});That gives us:./bin/js --insight=distance-trace.js distance.jsSquares: 9, 16Loop var i = 0Loop var i = 1Loop var i = 2Loop var i = 3Loop var i = 4Loop var i = 5Delaying Insight Initialization in Node.JSGraalVM Insight can be used in any GraalVM language runtime, including the node implementation.However, when in node, one does not want to write plain Insight scripts. You would probably want to use full power of the node ecosystem including its modules.Here is a sample agent-require.js script that does it:let initialize = function (require) {    let http = require(&quot;http&quot;);    print(`${typeof http.createServer} http.createServer is available to the agent`);}let waitForRequire = function (event) {  if (typeof process === &#39;object&#39; &amp;amp;&amp;amp; process.mainModule &amp;amp;&amp;amp; process.mainModule.require) {    insight.off(&#39;source&#39;, waitForRequire);    initialize(process.mainModule.require.bind(process.mainModule));  }};insight.on(&#39;source&#39;, waitForRequire, { roots: true });The Insight scripts are initialized as soon as possible, and at that moment the require function is not yet ready.As such, the script first attaches a listener on loaded scripts and, when the main user script is being loaded, it obtains its process.mainModule.require function.Then it removes the probes using insight.off and invokes the actual initialize function to perform the real initialization while having access to all the node modules.The script can be run with:./bin/node --js.print --experimental-options --insight=agent-require.js yourScript.jsThis initialization sequence is known to work on GraalVM’s node version 12.10.0 launched with the main yourScript.js parameter.Handling ExceptionsThe GraalVM Insight instrument can throw exceptions which are then propagated to the surrounding user scripts.Imagine you have a program seq.js logging various messages:function log(msg) {    print(msg);}log(&#39;Hello GraalVM Insight!&#39;);log(&#39;How&#39;);log(&#39;are&#39;);log(&#39;You?&#39;);You can register an instrument term.js and stop the execution in the middle of the seq.js program, based on observing the logged message:insight.on(&#39;enter&#39;, (ev, frame) =&amp;gt; {    if (frame.msg === &#39;are&#39;) {        throw &#39;great you are!&#39;;    }}, {    roots: true,    rootNameFilter: &#39;log&#39;});The term.js instrument waits for a call to log function with message are and, at that moment, it emits its own exception effectively interrupting the user program execution.As a result one gets:./bin/js --polyglot --insight=term.js seq.jsHello GraalVM Insight!Howgreat you are!        at &amp;lt;js&amp;gt; :=&amp;gt;(term.js:3:75-97)        at &amp;lt;js&amp;gt; log(seq.js:1-3:18-36)        at &amp;lt;js&amp;gt; :program(seq.js:7:74-83)The exceptions emitted by Insight instrument are treated as regular language exceptions.The seq.js program could use the regular try { ... } catch (e) { ... } block to catch them and deal with them as if they were emitted by the regular user code.Intercepting and Altering ExecutionGraalVM Insight is capable to alter the execution of a program.It can skip certain computations and replace them with own alternatives.The the following plus function as an example:function plus(a, b) {    return a + b;}It is easy to change the behavior of the plus method.The following Insight script replaces the + operation with multiplication by using the ctx.returnNow functionality:insight.on(&#39;enter&#39;, function(ctx, frame) {    ctx.returnNow(frame.a * frame.b);}, {    roots: true,    rootNameFilter: &#39;plus&#39;});The returnNow method immediately stops execution and returns to the caller of the plus function.The body of the plus method is not executed at all because the insight on(&#39;enter&#39;, ...) was applied, for example, before the actual body of the function was executed.Multiplying instead of adding two numbers may not sound very tempting, but the same approach is useful in providing add-on caching (for example, memoization) of repeating function invocations.It is also possible to let the original function code run and just alter its result.For example, alter the result of plus function to be always non-negative:insight.on(&#39;return&#39;, function(ctx, frame) {    let result = ctx.returnValue(frame);    ctx.returnNow(Math.abs(result));}, {    roots: true,    rootNameFilter: &#39;plus&#39;});The Insight hook is executed on return of the plus function and is using the returnValue helper function to obtain the computed return value from the current frame object.Then it can alter the value and returnNow returns a new result instead.The returnValue function is always available on the provided ctx object, but it only returns a meaningful value when used in on(&#39;return&#39;, ...) hooks.Minimal OverheadIf you ask whether GraalVM Insight causes any performance overhead when the scripts are applied, the answer is “No” or “Minimal”.The overhead depends on what your scripts do.When they add and spread complex computations all around your code base, then the price for the computation will be paid.However, that would be overhead of your code, not of the instrumentation.Using a simple function-count.js script, measure overhead.var count = 0;function dumpCount() {    print(`${count} functions have been executed`);}insight.on(&#39;enter&#39;, function(ev) {    count++;}, {    roots: true});insight.on(&#39;close&#39;, dumpCount);Use the script on fifty iterations of the sieve.js sample which uses a variant of the Sieve of Eratosthenes to compute one hundred thousand of prime numbers.Repeating the computation fifty times gives the runtime a chance to warm up and properly optimize.Here is the optimal run:./bin/js sieve.js | grep -v ComputedHundred thousand prime numbers in 75 msHundred thousand prime numbers in 73 msHundred thousand prime numbers in 73 msNow compare it to execution time when running with the GraalVM Insight script enabled:./bin/js --insight=function-count.js sieve.js  | grep -v ComputedHundred thousand prime numbers in 74 msHundred thousand prime numbers in 74 msHundred thousand prime numbers in 75 ms72784921 functions have been executedThe difference is 2 milliseconds.GraalVM Insight blends the difference between program code and insight gathering scripts making all code work as one.The count++ invocation becomes a natural part of the program at all the places representing ROOT of program functions.Minimal Overhead when Accessing LocalsGraalVM Insight is capable to access local variables, almost “for free”.GraalVM Insight code, accessing local variables, blends with the actual function code defining them and there is no visible slowdown.This can be demonstrated with this sieve.js algorithm to compute hundred thousand of prime numbers.It keeps the found prime numbers in a linked list constructed via following function:function Filter(number) {    this.number = number;    this.next = null;    this.last = this;}First, test the behavior by invoking the computation fifty times and measuring time it takes to finish the last round:./bin/js -e &quot;var count=50&quot; --file sieve.js | grep Hundred | tail -n 1Hundred thousand prime numbers in 73 msThen “tease” the system by observing each allocation of a new prime number slot, for example, the call to new Filter constructor:var sum = 0;var max = 0;insight.on(&#39;enter&#39;, (ctx, frame) =&amp;gt; {    sum += frame.number;    if (frame.number &amp;gt; max) {        max = frame.number;    }}, {  roots: true,  rootNameFilter: &#39;Filter&#39;});insight.on(&#39;return&#39;, (ctx, frame) =&amp;gt; {    log(`Hundred thousand prime numbers from 2 to ${max} has sum ${sum}`);    sum = 0;    max = 0;}, {    roots: true,    rootNameFilter: &#39;measure&#39;});Every time a new Filter(number) is allocated, the maximum value of number is captured (for example, the highest prime number found), and also sum of all prime numbers found so far.When the main loop in measure is over (meaning there are hundred thousand prime numbers), the result is printed.Now try the following:./bin/js  -e &quot;var count=50&quot; --insight=sieve-filter1.js --file sieve.js | grep Hundred | tail -n 2Hundred thousand prime numbers from 2 to 1299709 has sum 62260698721Hundred thousand prime numbers in 74 msThere is no slowdown at all.GraalVM Insight, when combined with inlining algorithms of the GraalVM compiler, enables great instrumentation capabilities with almost no performance penalty.Accessing Execution StackThere is a way for GraalVM Insight to access the whole execution stack.The following code snippet shows how to do that:insight.on(&quot;return&quot;, function(ctx, frame) {  print(&quot;dumping locals&quot;);  ctx.iterateFrames((at, vars) =&amp;gt; {      for (let p in vars) {          print(`    at ${at.name} (${at.source.name}:${at.line}:${at.column}) ${p} has value ${vars[p]}`);      }  });  print(&quot;end of locals&quot;);}, {  roots: true});Whenever the Insight hook is triggered, it prints the current execution stack with name of the function, source.name, line and column.Moreover, it also prints values of all local vars at each frame.It is also possible to modify values of existing variables by assigning new values to them: vars.n = 42.Accessing the whole stack is flexible, but unlike access to locals in the current execution frame, it is not a fast operation, use it wisely, if you want your program to continue running at full speed.Heap DumpingGraalVM Insight can be used to snapshot a region of your program heap during the execution.Use the --heap.dump=/path/to/output.hprof option together with a regular --insight one.The Insight script will get access to heap object with the dump function.Place your hook wherever needed and at the right moment dump the heap:insight.on(&#39;return&#39;, (ctx, frame) =&amp;gt; {    heap.dump({        format: &#39;1.0&#39;,        depth: 50, // set max depth for traversing object references        events: [            {                stack : [                    {                        at : ctx, // location of dump sieve.js:73                        frame : {                            // assemble frame content as you want                            primes : frame.primes, // capture primes object                            cnt : frame.cnt, // capture cnt value                        },                        depth : 10 // optionally override depth to ten references                    }, // there can be more stack elements like this one                ]            },            // there can be multiple events like the previous one        ],    });    throw &#39;Heap dump written!&#39;;}, {    roots: true,    rootNameFilter: &#39;measure&#39;});Save the code snippet as a dump.js file.Get the sieve.js file and launch it as:./bin/js --insight=dump.js --heap.dump=dump.hprof --file sieve.jsA dump.hprof file is going to be created at the end of the measure function capturing the state of your program memory.Inspect the generated .hprof file with regular tools such as VisualVM or NetBeans:The previous picture shows the heap dump taken at the end of the measure function in the sieve.js script.The function has just computed one hundred thousand (count available in variable cnt) prime numbers.The picture shows a linked list Filter holding prime numbers from 2 to 17.The rest of the linked list is hidden (only references up to depth 10 were requested) behind unreachable object.Last variable x shows the number of searched natural numbers to compute all the prime numbers.Heap Dumping CacheTo speed up the heap dumping process and optimize the resulting dump, it’s possible to enable a memory cache.Objects whose properties are not changed between dumps to the cache are stored only once, reducing the resulting heap dump size.Add (for example) the --heap.cacheSize=1000 option to use a memory cache for 1000 events. By default, the cache is dumped to the file and cleared when full.That policy can be changed by --heap.cacheReplacement=lru option, which keeps the most recent dump events in the cache and drops the oldest ones whenthe cache size limit is reached.To flush the cache to the heap dump file, heap.flush() needs to be called explicitly.Note on GraalVM Insight APIThe compatibility of the GraalVM Insight API exposed via the insight object is implemented in a compatible way.The GraalVM Insight API can be found by this link.The insight object properties and functions is available as part of its javadoc.Future versions will add new features, but whatever has once been exposed, remains functional.If your script depends on some new feature, it may check version of the exposed API:print(`GraalVM Insight version is ${insight.version}`);New elements in the APIcarry associated @since tag to describe the minimal version the associated functionality is available since.",
          "url": " /latest/tools/graalvm-insight/manual/"
          },
          
          "latest-tools-graalvm-insight-tracing":  {
          "title": "Tracing with Insight",
          "content": "Tracing with InsightIt is possible to use the GraalVM Insight to implement smooth, declarative, ad hoc tracing via standard OpenTracing API.The traces can be added into running application and customized on the fly to extract the right information needed to investigate any misbehavior incident.The following examples will demonstrate the tracing capabilities with GraalVM Insight.To start, install the Jaeger’s client side instrumentation library for Node.js:./bin/npm install jaeger-client@3.17.1Now you can use the OpenTracing API provided by the jaeger-client module in your instrument agent.js via the tracer object (once it becomes available, it will discussed later in this guide):let initialize = function(tracer) {    var counter = 0;    insight.on(&#39;enter&#39;, function(ctx, frame) {        const args = frame.args;        if (&#39;request&#39; !== frame.type || args.length !== 2 || typeof args[0] !== &#39;object&#39; || typeof args[1] !== &#39;object&#39;) {            return;        }        const req = args[0];        const res = args[1];        const span = tracer.startSpan(&quot;request&quot;);        span.setTag(&quot;span.kind&quot;, &quot;server&quot;);        span.setTag(&quot;http.url&quot;, req.url);        span.setTag(&quot;http.method&quot;, req.method);        res.id = ++counter;        res.span = span;        console.log(`agent: handling #${res.id} request for ${req.url}`);    }, {        roots: true,        rootNameFilter: &#39;emit&#39;,        at: {            sourcePath: &#39;.*events.js&#39;        }    });    insight.on(&#39;return&#39;, function(ctx, frame) {        var res = frame[&#39;this&#39;];        if (res.span) {            res.span.finish();            console.log(`agent: finished #${res.id} request`);        } else {            //Caused, for example, by Tracer itself connecting to the Jaeger server        }    }, {        roots: true,        rootNameFilter: &#39;end&#39;,        at: {            sourcePath: &#39;.*_http_outgoing.js&#39;        }    });    console.log(&#39;agent: ready&#39;);};The system hooks into emit(&#39;request&#39;, ...) and res.end() functions which are used to initialize a response to an HTTP request and finish it.Because the res object is a dynamic JavaScript object, it is possible to add id and span attributes to it in the enter handler of the emit function from the source events.js.Then it is possible to use these attributes in the return handler of the end function.GraalVM Insight provides access to frame variables and their fields.As such, the instrument can read value of req.url or req.method and provide them as span.setTag values to the OpenTracing server.With this instrument, it is just a matter of being able to enable it at the right time.Check the Embedding Insight into Node.js Application section to see how to create an admin server and apply any trace scripts (including OpenTracing based ones) dynamically when needed.For purposes of this guide, something simpler will be used.Enable the instrument when the jaeger object is provided to it:let initializeJaeger = function (ctx, frame) {    insight.off(&#39;enter&#39;, initializeJaeger);    let jaeger = frame.jaeger;    var initTracer = jaeger.initTracer;    console.log(&#39;agent: Jaeger tracer obtained&#39;);    // See schema https://github.com/jaegertracing/jaeger-client-node/blob/master/src/configuration.js#L37    var config = {      serviceName: &#39;insight-demo&#39;,      reporter: {        // Provide the traces endpoint. This forces the client to connect directly to the Collector and send        // spans over HTTP        collectorEndpoint: &#39;http://localhost:14268/api/traces&#39;,        // Provide username and password if authentication is enabled in the Collector        // username: &#39;&#39;,        // password: &#39;&#39;,      },      sampler: {          type : &#39;const&#39;,          param : 1      }    };    var options = {      tags: {        &#39;insight-demo.version&#39;: &#39;1.1.2&#39;,      },    //  metrics: metrics,      logger: console,      sampler: {          type : &#39;const&#39;,          param : 1      }    };    var tracer = initTracer(config, options);    initialize(tracer);};insight.on(&#39;return&#39;, initializeJaeger, {  roots: true,  rootNameFilter: &#39;jaegerAvailable&#39;});This instrument needs help from the main server script.Let the server.js obtain the jaeger-client module and pass it to the agent via the jaegerAvailable function.Then it creates a typical HTTP server.The content of server.js is:function jaegerAvailable(jaeger) {    console.log(&quot;Providing Jaeger object to the agent&quot;);}jaegerAvailable(require(&quot;jaeger-client&quot;));const http = require(&quot;http&quot;);const srv = http.createServer((req, res) =&amp;gt; {    console.log(`server: obtained request ${res.id}`);    setTimeout(() =&amp;gt; {        res.write(`OK# ${res.id}`);        console.log(`server: replied to request ${res.id}`);        res.end();    }, 5);});srv.listen(8080);With these two files you can launch the node application as well as the agent.But, first of all, start the Jaeger server:docker run -d --name jaeger -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 -p 5775:5775/udp   -p 6831:6831/udp   -p 6832:6832/udp -p 5778:5778   -p 16686:16686   -p 14268:14268   -p 9411:9411 jaegertracing/all-in-one:latest./bin/node --insight=agent.js server.jsProviding Jaeger object to the agentagent: Jaeger tracer obtainedInitializing Jaeger Tracer with RemoteReporter and ConstSampler(always)agent: readyNow you can connect to the Jaeger UI available at http://localhost:16686/ and put the server under some load:ab -c 10 -n 10000 http://localhost:8080/The server prints to the console detailed information while handling the requests and the Jaeger UI fills with the traces:This completes the guide how to enhance a plain Node.js application with tracing.The traces remain separated in its own agent.js file and can be applied at start time (demonstrated here) or dynamically when needed.What to Read NextTo learn more about Insight and find some challenging tasks, go to the Insight Manual.",
          "url": " /latest/tools/graalvm-insight/tracing/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-inspecttool":  {
          "title": "Native Image Inspect Tool",
          "content": "Native Image Inspect Tool  The Native Image Inspect Tool is deprecated and will be removed in a future release. To extract embedded SBOMs, use:  $JAVA_HOME/bin/native-image-utils extract-sbom --image-path=&amp;lt;path_to_binary&amp;gt;The Native Image Inspect Tool extracts embedded Software Bill of Materials (SBOM) from native executables. The functionality for extracting class-level metadata is no longer supported.Extracting Embedded SBOM (Deprecated)Native Image embeds an SBOM at build time to detect any libraries that may be susceptible to known security vulnerabilities.(Not available in GraalVM Community Edition.)The Native Image Inspect Tool can extract the compressed SBOM using the --sbom parameter, as shown in the command:$JAVA_HOME/bin/native-image-inspect --sbom &amp;lt;path_to_binary&amp;gt;The Native Image Inspect Tool previously supported listing the classes, fields, and methods included in a native executable or a native shared library.This functionality is no longer supported for security reasons.Migrate to using class-level SBOMs instead by passing --enable-sbom=class-level,export to the native-image builder, which generates an SBOM containing the same kind of class-level metadata information.Further Reading  Software Bill of Materials (SBOM) in Native Image",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/InspectTool/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-interopmigration":  {
          "title": "Truffle Interop 2.0",
          "content": "Truffle Interop 2.0This document is targeted at guest language and tool implementers.It is recommended to read the Truffle Library Tutorial first, before proceeding.MotivationIn Truffle Version 1.0 RC15 a new API called “Truffle Libraries” was introduced.Truffle Libraries allow users to use polymorphism with support for profiling/caching.With Interop 2.0 it is planned to use Truffle Libraries for the interoperability protocol.The current interoperability APIs are mature and well-tested and alreadyadopted by languages and tools.Here is a list of arguments why current interoperability APIs were changed and Interop 2.0 was introduced:  Footprint: In the current interop API every message send goes through a CallTarget and the arguments are boxed into an Object[]. This makes current interop inefficient for interpreter calls and it requires additional memory. Truffle Libraries use simple nodes and type-specialized call signatures that do not require argument array boxing or call targets.  Uncached dispatch: There is no way to execute current interop messages from the slow-path without allocating a temporary node. Truffle Libraries automatically generate an uncached version of every exported message. This allows the use of interop messages from slow-path/runtime without allocating any temporary data structures.  Reuse dispatch for multiple messages: In current interop, the dispatch to exported messages is repeated for each message that is sent. If multiple messages need to be sent and the receiver type becomes polymorphic, this produces bad code. Interop libraries instances can be specialized for input values. This allows users to do the dispatch once and invoke multiple messages without repeating the dispatch. This leads to more efficient code in polymorphic cases.  Support for default implementations: Current interop can only be used for implementations of TruffleObject. Truffle Libraries can be used with any receiver type. For example, it is possible to invoke the isExecutable message on primitive numbers and it just returns false.  Error proneness: There were some common issues with message resolutions that Truffle Libraries try to avoid by not making them possible, such as mixing up receiver types or implementing a wrong type check. The new assertion feature for Truffle Libraries allows specifying message specific assertions that allow verifying invariants, pre, and post-conditions.  Redundancy in documentation: Current interop documents the messages in the Message constant and in the ForeignAccess static accessor method. This leads to mostly redundant documentation. With Truffle interop, there is only one place for the documentation, which is the instance method in the library class.  Generality: Truffle Libraries can be used for language representation abstractions, since it is now efficient enough in terms of memory consumption and interpreter performance. The current interop API could not realistically be used that way because of this issue.  Address protocol issues: There are some design issues with the current interop API that interop 2.0 tries to address (see later).CompatibilityThe change from interop 1.0 to 2.0 was done in a compatible way.Therefore, the old interop should continue to work and adoption can be incremental.This means that if one language still calls using the old interop API and the other language has already adopted the new interop API, a compatibility bridge will map the APIs.If you are curious about how this works, look for the class DefaultTruffleObjectExports for new interop calls to old interop. And LegacyToLibraryNode for old interop calls to new interop. Note that using the compatibility bridge may cause performance regressions.That is why languages should migrate as early as possible.Interop Protocol ChangesInterop 2.0 comes with many protocol changes. This section is intended to provide rationales for these changes. For fully detailed reference documentation see the InteropLibrary Javadoc.Note: Every deprecated API describes its migration path in the Javadoc tagged by @deprecated.Replace IS_BOXED and UNBOX with Explicit TypesThere are some problems with the IS_BOXED/UNBOX design:  In order to find out if a value is of a particular type, e.g., a String, the value needs to be unboxed first. Unboxing may be an expensive operation leading to inefficient code just to check the type of a value.  The old API cannot be used for values that did not implement TruffleObject. Therefore, the handling of primitive numbers needed to be separated from the TruffleObject case, making the UNBOX design necessary to reuse existing code. Truffle Libraries support primitive receiver types.  The design of UNBOX relies on the specified set of primitive types that it returns. It is hard to introduce additional, new interop types this way, as language refers to the primitive types directly.The following new messages were introduced in InteropLibrary as a replacement:boolean isBoolean(Object)boolean asBoolean(Object)boolean isString(Object)String  asString(Object)boolean isNumber(Object)boolean fitsInByte(Object)boolean fitsInShort(Object)boolean fitsInInt(Object)boolean fitsInLong(Object)boolean fitsInFloat(Object)boolean fitsInDouble(Object)byte asByte(Object)short asShort(Object)int asInt(Object)long asLong(Object)float asFloat(Object)double asDouble(Object)The InteropLibrary specifies default implementations for the receiver types Boolean, Byte, Short, Integer, Long, Float, Double, Character, and String.This design is extendable to support new values like big numbers or a custom String abstraction as Java primitive types are no longer directly used.It is no longer recommended to use primitive types in specializations directly, as the set of interop primitive types may change in the future.Instead, always use the interop library to check for a particular type, e.g., use fitsInInt instead of instanceof Integer.By using the new messages it is possible to emulate the original UNBOX message like this:@Specialization(limit=&quot;5&quot;)Object doUnbox(Object value, @CachedLibrary(&quot;value&quot;) InteropLibrary interop) {    if (interop.isBoolean(value)) {      return interop.asBoolean(value);    } else if (interop.isString(value)) {      return interop.asString(value);    } else if (interop.isNumber(value)) {      if (interop.fitsInByte(value)) {        return interop.asByte(value);      } else if (interop.fitsInShort(value)) {        return interop.asShort(value);      } else if (interop.fitsInInt(value)) {        return interop.asInt(value);      } else if (interop.fitsInLong(value)) {        return interop.asLong(value);      } else if (interop.fitsInFloat(value)) {        return interop.asFloat(value);      } else if (interop.fitsInDouble(value)) {        return interop.asDouble(value);      }    }    throw UnsupportedMessageException.create();}Note: It is not recommended to unbox all primitive types like this.Instead a language should only unbox to the primitive types it actually uses.Ideally an unbox operation is not needed and the interop library is directly used to implement the operation, like this:@Specialization(guards = {                &quot;leftValues.fitsInLong(l)&quot;,                &quot;rightValues.fitsInLong(r)&quot;}, limit=&quot;5&quot;)long doAdd(Object l, Object r,             @CachedLibrary(&quot;l&quot;) InteropLibrary leftValues,             @CachedLibrary(&quot;r&quot;) InteropLibrary rightValues) {       return leftValues.asLong(l) + rightValues.asLong(r);}Explicit Namespaces for Array and Member ElementsThe generic READ and WRITE messages were originally designed with primarily JavaScript use-cases in mind.With the adoption of interop by more languages, it became apparent that there is a need for explicit namespaces for arrays and object members.Over time, the interpretation of READ and WRITE was changed to represent array accesses when used with numbers and object member accesses when used with strings.The HAS_SIZE message was reinterpreted as whether the value contains array elements with additional guarantees, e.g., that array elements were iterable between index 0 and size.For better interop between languages, there is a need for an explicit Hash/Map/Dictionary entry namespace.Originally it was intended to reuse the generic READ/WRITE namespace for this.For JavaScript, this was possible, as the dictionary and member namespaces were equivalent.Most languages, however, separate Map entries from Object members, which leads to ambiguous keys.It is not possible for the source language (the protocol implementer) to know how this conflict needs to be resolved.Instead, by having explicit namespaces we can let the target language (the protocol caller) decide how to resolve the ambiguity.For example, whether dictionary or member elements should take precedence can now be decided in the target language operation.The following interop messages were changed:READ, WRITE, REMOVE, HAS_SIZE, GET_SIZE, HAS_KEYS, KEYSThe updated protocol with separate member and array namespace in InteropLibrary looks like this:Object Namespace:hasMembers(Object)getMembers(Object, boolean)readMember(Object, String)writeMember(Object, String, Object)removeMember(Object, String)invokeMember(Object, String, Object...)Array Namespace:hasArrayElements(Object)readArrayElement(Object, long)getArraySize(Object)writeArrayElement(Object, long, Object)removeArrayElement(Object, long)Array access messages no longer throw UnknownIdentifierException; they instead throw InvalidArrayIndexException.This was a bug in the original design, where the accessed number needed to be converted to the identifier string in the UnknownIdentifierException.Replaced KeyInfo with Individual MessagesIn the previous section, we did not mention the KEY_INFO message.The KEY_INFO message was useful to query all properties of a member or array element.While this was a conveniently small API, it was often inefficient as it required the implementer to return all the key info properties.At the same time, it is rare that the caller really needed all key info properties. With Interop 2.0 we removed the KEY_INFO message.Instead, we introduced explicit messages for each namespace, to address this issue.Object Namespace:isMemberReadable(Object, String)isMemberModifiable(Object, String)isMemberInsertable(Object, String)isMemberRemovable(Object, String)isMemberInvocable(Object, String)isMemberInternal(Object, String)isMemberWritable(Object, String)isMemberExisting(Object, String)hasMemberReadSideEffects(Object, String)hasMemberWriteSideEffects(Object, String)Array Namespace:isArrayElementReadable(Object, long)isArrayElementModifiable(Object, long)isArrayElementInsertable(Object, long)isArrayElementRemovable(Object, long)isArrayElementWritable(Object, long)isArrayElementExisting(Object, long)Note: The array namespace no longer supports querying for read or write side-effects.These messages might be reintroduced but, at the moment, there was no use-case.Also, the array namespace does not allow invocations.Remove Return Type for TO_NATIVEThe TO_NATIVE message was renamed to toNative in the InteropLibrary with the difference that it no longer returns a value, but performs the native transition as a side-effect if supported by the receiver.This allows the caller of the message to simplify their code. No cases the toNative transition required to return a different value were found.The default behaviour of toNative was changed to not return any value.Minor ChangesThe following messages were mostly unchanged. The NEW message was renamed to instantiate to be consistent with isInstantiable.Message.IS_NULL         -&amp;gt; InteropLibrary.isNullMessage.EXECUTE         -&amp;gt; InteropLibrary.executeMessage.IS_INSTANTIABLE -&amp;gt; InteropLibrary.isInstantiableMessage.NEW             -&amp;gt; InteropLibrary.instantiateMessage.IS_EXECUTABLE   -&amp;gt; InteropLibrary.isExecutableMessage.EXECUTE         -&amp;gt; InteropLibrary.executeMessage.IS_POINTER      -&amp;gt; InteropLibrary.isPointerMessage.AS_POINTER      -&amp;gt; InteropLibrary.asPointerStronger AssertionsMany new assertions were introduced as part of the migration. The concrete pre-post and invariant conditions are described in the Javadoc. Unlike the old interop nodes, cached libraries can only be used when adopted as part of the AST.No More Unchecked/Checked ExceptionsWith Interop 2.0 InteropException.raise was deprecated.While possible, it is considered an anti-pattern to rethrow checked exceptions as unchecked exceptions.With Truffle Libraries the target language nodes are directly inserted into the AST of the caller so there is no longer a limiting CallTarget that does not support checked exceptions.Together with additional support for checked Exceptions from Truffle DSL, it should no longer be necessary to use the raise methods.Instead, a new create factory method was introduced for all interop exception types.It is planned to remove stack traces from interop exceptions in order to improve their efficiency, as interop exceptions are intended to be always immediately caught and never be rethrown.This was deferred until the compatibility layer can be removed.MigrationWith the use of Truffle Libraries for interop, most existing interop APIs had to be deprecated.The following comparison of Interop 1.0 with Interop 2.0 is designed to help migrate existing uses of interop.Fast-Path Sending Interop MessagesThis is the fast-path way of sending interop messages embedded in an operation node.This is the most common way of sending interop messages.Interop 1.0:@ImportStatic({Message.class, ForeignAccess.class})abstract static class ForeignExecuteNode extends Node {    abstract Object execute(Object function, Object[] arguments);    @Specialization(guards = &quot;sendIsExecutable(isExecutableNode, function)&quot;)    Object doDefault(TruffleObject function, Object[] arguments,                    @Cached(&quot;IS_EXECUTABLE.createNode()&quot;) Node isExecutableNode,                    @Cached(&quot;EXECUTE.createNode()&quot;) Node executeNode) {        try {            return ForeignAccess.sendExecute(executeNode, function, arguments);        } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {            // ... convert errors to guest language errors ...        }    }}Interop 2.0:abstract static class ForeignExecuteNode extends Node {    abstract Object execute(Object function, Object[] arguments);    @Specialization(guards = &quot;functions.isExecutable(function)&quot;, limit = &quot;2&quot;)    Object doDefault(Object function, Object[] arguments,                    @CachedLibrary(&quot;function&quot;) InteropLibrary functions) {        try {            return functions.execute(function, arguments);        } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {            // ... convert errors to guest language errors ...        }    }}Note the following differences:  To invoke messages we call instance methods on TruffleLibrary instead of calling a static method on ForeignAccess.  The old interop required the creation of one node for each operation. With the new version, only one specialized interop library is created.  In the old API we needed to specialize the receiver type for TruffleObject. The new interop library can be invoked with any interop value. By default isExecutable will return false for values that don’t export the interop library. E.g., it is now valid to call the library with boxed primitive receiver values.  Instead of using @Cached in the old interop, in the new interop we use @CachedLibrary.  The new @CachedLibrary annotation specifies the value the library specializes on. This allows the DSL to specialize the library instance to that value. This again allows the dispatch on the receiver value to be performed once for all message invocations. In the old interop version, the nodes could not be specialized to values. Therefore the dispatch needed to be repeated for every interop message send.  The specialized library instance requires specifying a limit for the specialization method. If this limit overflows, the uncached version of the library will be used that does not perform any profiling/caching. The old interop API assumed a constant specialization limit of 8 per interop node.  The new interop API allows for using a dispatched version of the library by specifying @CachedLibrary(limit=&quot;2&quot;) instead. This allows the interop library to be used with any value, but it has the disadvantage of duplicating the inline cache for every message invocation, like with the old interop API. It is therefore recommended to use specialized libraries whenever possible.Slow-Path Sending Interop MessagesIt is sometimes necessary to call interop messages from the runtime without the context of a node:Interop 1.0:ForeignAccess.sendRead(Message.READ.createNode(), object, &quot;property&quot;)Interop 2.0:InteropLibrary.getFactory().getUncached().read(object, &quot;property&quot;);Note the following differences:  The old interface allocated a node for each invocation.  The new library uses the uncached version of the library that does not require any allocation or boxing for each invocation.  With InteropLibrary.getFactory().getUncached(object) an uncached and specialized version of a library can be looked up. This can be used to avoid repeated export lookups if multiple uncached interop messages need to be sent to the same receiver.Custom Fast-Path Sending Interop MessagesSometimes Truffle DSL cannot be used and the nodes need to be written manually. Both APIs allow you to do so:Interop 1.0:final class ForeignExecuteNode extends Node {    @Child private Node isExecutableNode = Message.IS_EXECUTABLE.createNode();    @Child private Node executeNode = Message.EXECUTE.createNode();    Object execute(Object function, Object[] arguments) {        if (function instanceof TruffleObject) {            TruffleObject tFunction = (TruffleObject) function;            if (ForeignAccess.sendIsExecutable(isExecutableNode, tFunction)) {                try {                    return ForeignAccess.sendExecute(executeNode, tFunction, arguments);                } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {                    // TODO handle errors                }            }        }        // throw user error    }}Interop 2.0:static final class ForeignExecuteNode extends Node {    @Child private InteropLibrary functions = InteropLibrary.getFactory().createDispatched(5);    Object execute(Object function, Object[] arguments) {        if (functions.isExecutable(function)) {            try {                return functions.execute(function, arguments);            } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {                // handle errors                return null;            }        }        // throw user error    }}Note the following differences:  The new interop creates nodes through the LibraryFactory&amp;lt;InteropLibrary&amp;gt; accessible through InteropLibrary.getFactory(). The old interop creates dispatching nodes through the Message instance.  The dispatch limit can be specified for the new interop libraries. The old interop API always assumed a constant limit of 8.  For the new interop we do not need to check for the type TruffleObject as Truffle Libraries can be used with any receiver type. For non-function values, isExecutable will just return false.Implementing/Exporting Interop MessagesTo implement/export interop library messages, see the following example:Interop 1.0:@MessageResolution(receiverType = KeysArray.class)final class KeysArray implements TruffleObject {    private final String[] keys;    KeysArray(String[] keys) {        this.keys = keys;    }    @Resolve(message = &quot;HAS_SIZE&quot;)    abstract static class HasSize extends Node {        public Object access(KeysArray receiver) {            return true;        }    }    @Resolve(message = &quot;GET_SIZE&quot;)    abstract static class GetSize extends Node {        public Object access(KeysArray receiver) {            return receiver.keys.length;        }    }    @Resolve(message = &quot;READ&quot;)    abstract static class Read extends Node {        public Object access(KeysArray receiver, int index) {            try {                return receiver.keys[index];            } catch (IndexOutOfBoundsException e) {                CompilerDirectives.transferToInterpreter();                throw UnknownIdentifierException.raise(String.valueOf(index));            }        }    }    @Override    public ForeignAccess getForeignAccess() {        return KeysArrayForeign.ACCESS;    }    static boolean isInstance(TruffleObject array) {        return array instanceof KeysArray;    }}Interop 2.0:@ExportLibrary(InteropLibrary.class)final class KeysArray implements TruffleObject {    private final String[] keys;    KeysArray(String[] keys) {        this.keys = keys;    }    @ExportMessage    boolean hasArrayElements() {        return true;    }    @ExportMessage    boolean isArrayElementReadable(long index) {        return index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; keys.length;    }    @ExportMessage    long getArraySize() {        return keys.length;    }    @ExportMessage    Object readArrayElement(long index) throws InvalidArrayIndexException {        if (!isArrayElementReadable(index) {            throw InvalidArrayIndexException.create(index);        }        return keys[(int) index];    }}Note the following differences:  Instead of @MessageResolution we use @ExportLibrary.  Both versions need to implement TruffleObject. The new interop API only requires a TruffleObject type for compatibility reasons.  Instead of @Resolve, the @ExportMessage annotation is used. The latter annotation can infer the name of the message from the method name. If the method name is ambiguous, e.g., when multiple libraries are exported, then the name and library can be specified explicitly.  There is no need to specify classes for exports/resolves. However, it is still possible to do so if an export needs multiple specializations. See the Truffle Library tutorial for details.  Exceptions are now thrown as checked exceptions.  It is no longer needed to implement getForeignAccess(). The implementation discovers implementations for receiver types automatically.  It is no longer needed to implement isInstance. The implementation is now derived from the class signature. Note that the check can be more efficient if the receiver type is declared final. For non-final receiver types, it is recommended to specify exported methods as final.Integration with DynamicObjectThe old interop allowed for specifying a foreign access factory through ObjectType.getForeignAccessFactory(). This method is now deprecated and a new method, ObjectType.dispatch(), was introduced. Instead of a foreign access factory, the dispatch method needs to return a class that exports the InteropLibrary with an explicit receiver:Interop 1.0:public final class SLObjectType extends ObjectType {    public static final ObjectType SINGLETON = new SLObjectType();    private SLObjectType() {    }    public static boolean isInstance(TruffleObject obj) {        return SLContext.isSLObject(obj);    }    @Override    public ForeignAccess getForeignAccessFactory(DynamicObject obj) {        return SLObjectMessageResolutionForeign.ACCESS;    }}@MessageResolution(receiverType = SLObjectType.class)public class SLObjectMessageResolution {    @Resolve(message = &quot;WRITE&quot;)    public abstract static class SLForeignWriteNode extends Node {...}    @Resolve(message = &quot;READ&quot;)    public abstract static class SLForeignReadNode extends Node {...}    ...Interop 2.0:@ExportLibrary(value = InteropLibrary.class, receiverType = DynamicObject.class)public final class SLObjectType extends ObjectType {    public static final ObjectType SINGLETON = new SLObjectType();    private SLObjectType() {    }    @Override    public Class&amp;lt;?&amp;gt; dispatch() {        return SLObjectType.class;    }    @ExportMessage    static boolean hasMembers(DynamicObject receiver) {        return true;    }    @ExportMessage    static boolean removeMember(DynamicObject receiver, String member) throws UnknownIdentifierException {...}    // other exports omitted }Note the following differences:  The object type can be reused as the export class.  The isInstance method no longer needs to be specified.  The new interop requires specifying the receiver type to DynamicObject.Extending InteropThe languages implemented with Truffle rarely need to extend interop, but they might need to extend their own language specific protocol:Interop 1.0:  Add new KnownMessage subclass called FooBar.  Add a new method sendFooBar to ForeignAccess.  Add a new method to ForeignAccess.Factory: createFooBar.  Modify the interop annotation processor to generate the code for createFooBar.Interop 2.0:  Add a new method fooBar in InteropLibrary. Everything else is done automatically.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/InteropMigration/"
          },
          
          "latest-reference-manual-native-image-native-code-interoperability":  {
          "title": "Interoperability with Native Code",
          "content": "Interoperability with Native CodeYou can use Native Image to convert Java code into a native shared library and call it from a native (C/C++) application just like any C function.There are two mechanisms for calling natively-compiled Java methods:  JNI Invocation API, an API to load the JVM into an arbitrary native application. The advantage of using JNI Invocation API is support for multiple, isolated execution environments within the same process.  Native Image C API, an API specific to GraalVM Native Image. The advantage of using Native Image C API is that you can determine what your API will look like, but parameter and return types must be non-object types.Related Documentation  Foreign Function and Memory API in Native Image  Java Native Interface (JNI) on Native Image  JNI Invocation API  Native Image C API  Build a Native Shared Library  Embedding Truffle Languages—a blog post by Kevin Menard where he compares both mechanisms in Native Image for exposing Java methods",
          "url": " /latest/reference-manual/native-image/native-code-interoperability/"
          },
          
          "latest-reference-manual-espresso-interoperability":  {
          "title": "Interoperability with Truffle Languages",
          "content": "Interoperability with Truffle LanguagesEspresso enables you to interface other “Truffle” languages (languages which interpreters are implemented with the Truffle framework) to create polyglot programs—programs written in more than one language.This guide describes how to load code written in other languages, how to export and import objects between languages, how to use Espresso objects from a foreign language, how to use foreign objects from Espresso, and how to embed in a Java application.To avoid confusion, the terms host and guest are used to differentiate the different layers where Java is executed. Espresso refers to the guest layer.You pass polyglot options to the java -truffle launcher.If you are using the native configuration, you will need to use the --polyglot flag to get access to other languages.Foreign objects must “inhabit” a guest Java type when flowing into Espresso.How this type is attached to foreign objects is an implementation detail.PolyglotEspresso provides a guest Java Polyglot API, described in polyglot.jar.This JAR file is automatically injected in a guest Java context, but can be excluded with --java.Polyglot=false.You can import the Polyglot class to interact with other guest languages:// guest javaimport com.oracle.truffle.espresso.polyglot.Polyglot;int two = Polyglot.eval(int.class, &quot;js&quot;, &quot;1+1&quot;);You can determine if an object is foreign:// guest javaObject foreign = Polyglot.eval(&quot;js&quot;, &quot;[2, 0, 2, 1]&quot;);Object local = new int[]{2, 0, 2, 1};System.out.println(Polyglot.isForeignObject(foreign)); // prints trueSystem.out.println(Polyglot.isForeignObject(local));   // prints falseYou can cast foreign objects to guest Java types:// guest javaObject foreignArray = Polyglot.eval(&quot;js&quot;, &quot;[&#39;a string&#39;, 42, 3.14159, null]&quot;);Object[] objects = Polyglot.cast(Object[].class, foreignArray);assert objects.length == 4;String elem0 = Polyglot.cast(String.class, objects[0]);   // eager conversionInteger elem1 = Polyglot.cast(Integer.class, objects[1]); // preserves identityint elem1_ = Polyglot.cast(int.class, objects[1]);        // eager conversiondouble elem2 = Polyglot.cast(double.class, objects[2]);   // eager conversionObject elem3 = objects[3];assert elem3 == null;The Polyglot.cast(targetClass, obj) method is an augmented Java cast, for example, targetClass.cast(obj):  Java cast succeeds ⇒ Polyglot.cast succeeds.  Java cast does not succeeds, Polyglot.cast can “re-type” foreign objects, for example, to cast to Integer, the foreign object must fitsInInt.  If Polyglot.cast fails, it will throw ClassCastException similar to Class#cast.Polyglot.cast supports a natural mapping from common interop “kinds” to Java types, summarized below:            Interop “kind”      Allowed types      Preserves identity                  isBoolean      Boolean/boolean      Yes* (boxed type)              fitsInByte      Byte/byte      Yes* (boxed type)              fitsInShort      Short/short      Yes* (boxed type)              fitsInInt      Integer/int      Yes* (boxed type)              fitsInLong      Long/long      Yes* (boxed type)              fitsInFloat      Float/float      Yes* (boxed type)              fitsInDouble      Double/double      Yes* (boxed type)              isString &amp;amp; 1-character      Character/char      Yes* (boxed type)              isString      String      No (eager conversion)              isException &amp;amp; Polyglot.isForeignObject      ForeignException      Yes              hasArrayElements      Object[]      Yes              isNull      *      Yes              *      Object      Yes      You can access the polyglot bindings:// guest javaObject foreignObject = Polyglot.importObject(&quot;foreign_object&quot;);// typed importsString userName = Polyglot.importObject(&quot;user_name&quot;, String.class);int year = Polyglot.importObject(&quot;year&quot;, int.class);// exportsPolyglot.exportObject(&quot;data&quot;, new double[]{56.77, 59.23, 55.67, 57.50, 64.44, 61.37);Polyglot.exportObject(&quot;message&quot;, &quot;Hello, Espresso!&quot;);Interop ProtocolEspresso provides an explicit guest API to access the Interop protocol.It contains methods mimicking the interop protocol messages.This API can be used on guest Java objects as well.// guest javaimport com.oracle.truffle.espresso.polyglot.Interop;Object foreignArray = Polyglot.eval(&quot;js&quot;, &quot;[2, 0, 2, 1]&quot;);System.out.println(Interop.hasArrayElements(foreignArray)); // prints trueSystem.out.println(Interop.getArraySize(foreignArray));     // prints 4Object elem0 = Interop.readArrayElement(foreignArray, 0);System.out.println(Interop.fitsInInt(elem0)); // prints trueSystem.out.println(Interop.asInt(elem0));     // prints 2Embedding in Host JavaEspresso is embedded via the Polyglot API, which is part of GraalVM.// host javaimport org.graalvm.polyglot.*;class Embedding {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().allowAllAccess(true).build();        // Class loading is exposed through language bindings, with class        // names using the same format as Class#forName(String).        Value intArray = polyglot.getBindings(&quot;java&quot;).getMember(&quot;[I&quot;);        Value objectArray = polyglot.getBindings(&quot;java&quot;).getMember(&quot;[Ljava.lang.Object;&quot;)        Value java_lang_Math = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.Math&quot;);        double sqrt2 = java_lang_Math.invokeMember(&quot;sqrt&quot;, 2).asDouble();        double pi = java_lang_Math.getMember(&quot;PI&quot;).asDouble();        System.out.println(sqrt2);        System.out.println(pi);    }}A number of useful context option can be set with contextBuilder.option(key, value):  Java properties can be added by settings java.Properties.property.name to the desired value (in this case this would set the property.name).  java.Properties.java.class.path can be used to set the class path of the Java on Truffle context.  java.Properties.java.library.path can be used to set the native library path of the Java on Truffle context.  java.EnableAssertions can be set to true to enable assertions.  java.EnableSystemAssertions can be set to true to enable assertions in the Java standard library.  java.Verify can be set to none, remove, or all to control whether bytecode verification does not happen, only happens on user code, or happens for all classes.  java.JDWPOptions can be set to setup and enable debugging over JDWP. For example, it could be set to transport=dt_socket,server=y,address=localhost:8000,suspend=y.  java.Polyglot can be set to true or false to allow or deny access to the polyglot features from the com.oracle.truffle.espresso.polyglot package.  java.PolyglotTypeConverters can be set to declare a type conversion function that maps a meta qualified name to a type converter class. Please refer to more details in a dedicated section below.  java.PolyglotInterfaceMappings can be set to a semicolon-separated list of 1:1 interface type mappings to automatically construct guest proxies for host objects that implement declared interfaces in the list. Please refer to more details in a dedicated section below.*Espresso does not support evaluation (.eval) of Java sources.In Java, methods can be overloaded, for example, several methods can share the same name, with different signatures.To remove ambiguity, Espresso allows to specify the method descriptor in the methodName/methodDescriptor form:// host javaValue java_lang_String = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.String&quot;);// String#valueOf(int)String valueOf = String.format(&quot;%s/%s&quot;, &quot;valueOf&quot;, &quot;(I)Ljava/lang/String;&quot;);Value fortyTwo = java_lang_String.invokeMember(valueOf, 42);assert &quot;42&quot;.equals(fortyTwo.asString());Class&amp;lt;?&amp;gt; instance vs. static class accessor (Klass):The static class accessor allows to access (public) static fields and call (public) static methods.// Class loading through language bindings return the static class accessor.Value java_lang_Number = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.Number&quot;);Value java_lang_Class = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.Class&quot;);// Class#forName(String) returns the Class&amp;lt;Integer&amp;gt; instance.Value integer_class = java_lang_Class.invokeMember(&quot;forName&quot;, &quot;java.lang.Integer&quot;);// Static class accessor to Class&amp;lt;?&amp;gt; instance and vice versa.assert integer_class.equals(java_lang_Integer.getMember(&quot;class&quot;));assert java_lang_Integer.equals(integer_class.getMember(&quot;static&quot;));// Get Integer super class.assert java_lang_Number.equals(java_lang_Integer.getMember(&quot;super&quot;));Converting Host Objects to Guest Types Using Type ConvertersEspresso has built-in support for declaring type conversion of host objects to proper guest-typed objects. This is done via context builder options as described above. The main idea is to allow transparent flow of objects from a host to a guest without having to perform guest type checks when host objects enter an embedded Espresso context. Specifically the following options can be set to control type conversion for an embedded context:java.PolyglotTypeConvertersThis option takes precedence over java.PolyglotInterfaceMappings and thus, if a dedicated type converter function is defined, no other automatic interface mapping proxies are generated Espresso.Note: Declared type converters must implement the GuestTypeConversion interface located in the com.oracle.truffle.espresso.polyglot package in polyglor.jar.package com.oracle.truffle.espresso.polyglot;public interface GuestTypeConversion&amp;lt;T&amp;gt; {    T toGuest(Object polyglotInstance);}For each type converter declared use one option call like this:// host javaContext polyglot = Context.newBuilder().allowAllAccess(true).        option(&quot;java.PolyglotTypeConverters.java.math.BigDecimal&quot;, &quot;guest.context.path.BigDecimalConverter&quot;).        build();...// guest javapackage guest.context.path;import com.oracle.truffle.espresso.polyglot.GuestTypeConversion;import com.oracle.truffle.espresso.polyglot.Interop;import com.oracle.truffle.espresso.polyglot.InteropException;import java.math.BigDecimal;public class BigDecimalConverter implements GuestTypeConversion&amp;lt;BigDecimal&amp;gt; {    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public BigDecimal toGuest(Object polyglotInstance) {        try {            return new BigDecimal(Interop.asString(Interop.invokeMember(polyglotInstance, &quot;toString&quot;)));        } catch (InteropException e) {            throw new ClassCastException(&quot;polyglot instance cannot be cast to java.math.BigDecimal&quot;);        }    }}The java.math.Bigdecimal part of the option declares the fully qualified meta name of a host object entering Espresso.java.PolyglotInterfaceMappingsIf there are no dedicated java.PolyglotTypeConverters for a host object flowing into an embedded Espresso context, automatic interface type mapping kicks in. java.PolyglotInterfaceMappings enables seamless interface type sharing between the host and the embedded context.The following example shows how this option can be used to allow passing common JDK collection types by interface to an embedded Espresso context:// host javabuilder.option(&quot;java.PolyglotInterfaceMappings&quot;, getInterfaceMappings());private static String getInterfaceMappings(){    return &quot;java.lang.Iterable;&quot;+    &quot;java.util.Collection;&quot;+    &quot;java.util.List;&quot;+    &quot;java.util.Set;&quot;+    &quot;java.util.Map;&quot;+    &quot;java.util.Iterator;&quot;+    &quot;java.util.Spliterator;&quot;;}MultithreadingEspresso is designed to be a multithreaded language and much of the ecosystem expects threads to be available.This may be incompatible with other Truffle languages which do not support threading, so you can disable the creation of multiple threads with the option --java.MultiThreaded=false.When this option is enabled, finalizers will not run, neither the ReferenceQueue notification mechanism.Both these features would require starting new threads. Note that the garbage-collection of weakly reachable objects remains unaffected.Instead, reference processing can be manually triggered through a special command, only available in single-threaded environments.// Host Java// Will trigger Reference processing and run finalizerspolyglot.eval(&quot;java&quot;, &quot;&amp;lt;ProcessReferences&amp;gt;&quot;);Note that this command might trigger arbitrary cleaner and finalizer code. As such, this should ideally be run with as few guest java frames on the stack as possible.",
          "url": " /latest/reference-manual/espresso/interoperability/"
          },
          
          "latest-reference-manual-llvm-interoperability":  {
          "title": "Interoperability",
          "content": "InteroperabilityGraalVM supports several other programming languages including JavaScript, Python, Ruby, and R.While GraalVM’s implementation of lli is designed to run LLVM bitcode, it also provides the API for programming language interoperability that lets you execute code from any other GraalVM-supported language.Dynamic languages like JavaScript usually access object members by name.Since normally names are not preserved in LLVM bitcode, it must be compiled with debug information enabled (the LLVM toolchain shipped with GraalVM will automatically enable debugging information).The following example demonstrates how you can use the API for interoperability with other programming languages.Define a C struct for points and implement allocation functions in a file named cpart.c:// cpart.c#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;struct Point {    double x;    double y;};POLYGLOT_DECLARE_STRUCT(Point)void *allocNativePoint() {    struct Point *ret = malloc(sizeof(*ret));    return polyglot_from_Point(ret);}void *allocNativePointArray(int length) {    struct Point *ret = calloc(length, sizeof(*ret));    return polyglot_from_Point_array(ret, length);}void freeNativePoint(struct Point *p) {    free(p);}void printPoint(struct Point *p) {    printf(&quot;Point&amp;lt;%f,%f&amp;gt;n&quot;, p-&amp;gt;x, p-&amp;gt;y);}Make sure LLVM_TOOLCHAIN resolves to the GraalVM LLVM toolchain (lli --print-toolchain-path), and then compile cpart.c  (the graalvm-llvm library defines the Polyglot API functions used in the example):$LLVM_TOOLCHAIN/clang -shared cpart.c -lgraalvm-llvm -o cpart.soYou can then access this C/C++ code from other languages. For example, save this JavaScript code in the jspart.js file:// Load and parse the LLVM bitcode into GraalVMvar cpart = Polyglot.evalFile(&quot;llvm&quot; ,&quot;cpart.so&quot;);// Allocate a light-weight C structvar point = cpart.allocNativePoint();// Access it as if it was a JS objectpoint.x = 5;point.y = 7;// Pass it back to a native functioncpart.printPoint(point);// Allocate an array of structsvar pointArray = cpart.allocNativePointArray(15);// Access this array like it was a JS arrayfor (var i = 0; i &amp;lt; pointArray.length; i++) {    var p = pointArray[i];    p.x = i;    p.y = 2*i;}cpart.printPoint(pointArray[3]);// Additionally, pass a JS object to a native functioncpart.printPoint({x: 17, y: 42});// Free the unmanaged data objectscpart.freeNativePoint(point);cpart.freeNativePoint(pointArray);Finally, run this JavaScript file on a GraalJS JVM standalone:js-polyglot-get llvmjs --polyglot jspart.jsPoint&amp;lt;5.000000,7.000000&amp;gt;Point&amp;lt;3.000000,6.000000&amp;gt;Point&amp;lt;17.000000,42.000000&amp;gt;Polyglot C APIThere are also lower level API functions for directly accessing polyglot values from C.See the Polyglot Programming reference and the comments in polyglot.h for more details.For example, this program allocates and accesses a Java array from C:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 24);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}Compile it to LLVM bitcode:$LLVM_TOOLCHAIN/clang polyglot.c -lgraalvm-llvm -o polyglotThen run it:lli polyglot24Embedding in JavaYou can embed LLVM bitcode in a Java host application.For example, write a Java class Polyglot.java that embeds LLVM bitcode to run the previous example:import java.io.*;import org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) throws IOException {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        File file = new File(&quot;polyglot&quot;);        Source source = Source.newBuilder(&quot;llvm&quot;, file).build();        Value cpart = polyglot.eval(source);        cpart.execute();    }}Compile it and run:javac Polyglot.javajava Polyglot24See the Embedding Languages reference for more information.",
          "url": " /latest/reference-manual/llvm/Interoperability/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-jcasecurityservices":  {
          "title": "JCA Security Services in Native Image",
          "content": "JCA Security Services in Native ImageThis page explains Native Image support of the Java Cryptography Architecture (JCA) framework.The JCA framework uses a provider architecture to access security services such as digital signatures, message digests, certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, etc.To achieve algorithm independence and extensibility it relies on reflection, therefore it requires a custom configuration in Native Image.By default the native-image builder uses static analysis to discover which of these services are used (see next section for details).The automatic registration of security services can be disabled with -H:-EnableSecurityServicesFeature.Then a custom reflection configuration file or feature can be used to register the security services required by a specific application.Note that when automatic registration of security providers is disabled, all providers are, by default, filtered from special JDK caches that are necessary for security functionality.In this case, you must manually mark used providers with -H:AdditionalSecurityProviders.Security Services Automatic RegistrationThe mechanism, implemented in the com.oracle.svm.hosted.SecurityServicesFeature class, uses reachability of specific API methods in the JCA framework to determine which security services are used.Each JCA provider registers concrete implementation classes for the algorithms it supports.Each of the service classes (Signature, Cipher, Mac, KeyPair, KeyGenerator, KeyFactory, KeyStore, etc.) declares a series of getInstance(&amp;lt;algorithm&amp;gt;, &amp;lt;provider&amp;gt; factory methods which provide a concrete service implementation.When a specific algorithm is requested, the framework searches the registered providers for the corresponding implementation classes and dynamically allocates objects for concrete service implementations.The native-image builder uses static analysis to discover which of these services are used.It does so by registering reachability handlers for each of the getInstance() factory methods.When it determines that a getInstance() method is reachable at run time, it automatically performs the reflection registration for all the concrete implementations of the corresponding service type.Tracing of the security services automatic registration can be enabled with -H:+TraceSecurityServices.The report will detail all registered service classes, the API methods that triggered registration, and the parsing context for each reachable API method.  Note: The --enable-all-security-services option is now deprecated and it will be removed in a future release.Provider InitializationCurrently, security providers are initialized at build time.To move their initialization to run time, use the option --future-defaults=run-time-initialize-security-providers, --future-defaults=all, or --future-defaults=run-time-initialize-jdk.Provider verification will still occur at build time.Run-time initialization of security providers helps reduce image heap size.Provider RegistrationThe native-image builder captures the list of providers and their preference order from the underlying JVM.The provider order is specified in the java.security file under &amp;lt;java-home&amp;gt;/conf/security/java.security.New security providers cannot be registered at run time by default (see the section above); all providers must be statically configured at executable build time.If the user specifies --future-defaults=run-time-initialize-security-providers, --future-defaults=all, or --future-defaults=run-time-initialize-jdk to move providers initialization to run time, then a specific properties file can be used via the command line option -Djava.security.properties=&amp;lt;path&amp;gt;.Providers Reordering at Run TimeIt is possible to reorder security providers at run time, however only existing provider instances can be used.For example, if the BouncyCastle provider is registered at build time and you want to insert it at position 1 at run time:Provider bcProvider = Security.getProvider(&quot;BC&quot;);Security.removeProvider(&quot;BC&quot;);Security.insertProviderAt(bcProvider, 1);If --future-defaults=all or --future-defaults=run-time-initialize-jdk is enabled, the list of providers is constructed at run time.The same approach to manipulating providers can then be used.SecureRandomThe SecureRandom implementations open the /dev/random and /dev/urandom files which are used as sources.These files are usually opened in class initializers.To avoid capturing state from the machine that runs the native-image builder, these classes need to be initialized at run time.Custom Service TypesBy default, only services specified in the JCA framework are automatically registered. To automatically register custom service types, you can use the -H:AdditionalSecurityServiceTypes option.Note that for automatic registration to work, the service interface must have a getInstance method and have the same name as the service type.If relying on the third-party code that does not comply to the above requirements, a manual configuration will be required. In that case, providers for such services must explicitly be registered using the -H:AdditionalSecurityProviders option. Note that these options are only required in very specific cases and should not normally be needed.Further Reading  URL Protocols in Native Image  Jipher JCE with Native Image",
          "url": " /latest/reference-manual/native-image/dynamic-features/JCASecurityServices/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-jcmd":  {
          "title": "Java Diagnostic Command (jcmd) with Native Image",
          "content": "Java Diagnostic Command (jcmd) with Native ImageNative Image now supports the Java Diagnostic Command (jcmd), enabling users to interact with native executables using the same jcmd tool they use for Java applications.This support complements existing Native Image monitoring features, including JDK Flight Recorder, heap dumps, and native memory tracking.Enabling jcmd SupportSupport for jcmd is disabled by default and must be explicitly enabled at build time.Use the --enable-monitoring=jcmd option to build a native executable with jcmd enabled.native-image --enable-monitoring=jcmd YourApplicationWhen enabling support for jcmd, you may also want to include additional monitoring features, such as JDK Flight Recorder or heap dumps.Including multiple monitoring features during the Native Image build process unlocks access to more diagnostic commands at runtime. For example:native-image --enable-monitoring=jcmd,jfr,heapdump YourApplicationTo use jcmd at runtime, start your native executable as usual and obtain its process ID (PID).With the PID, you can use jcmd to connect to the running native application.For example, to list the available commands for a specific executable, run: jcmd &amp;lt;pid&amp;gt; help.jcmd 388454 help388454:The following commands are available:GC.heap_dumpGC.runJFR.startJFR.stopJFR.checkJFR.dumpThread.dump_to_fileThread.printVM.command_lineVM.native_memoryVM.system_propertiesVM.uptimeVM.versionhelpFor more information about a specific command use &#39;help &amp;lt;command&amp;gt;&#39;.You might find it useful to also enable the jvmstat monitoring feature so your native executable can be discovered and listed with jcmd -l or jcmd with no arguments provided.native-image --enable-monitoring=jcmd,jvmstat YourApplicationjcmd -l1455557 YourApplication1455667 jdk.jcmd/sun.tools.jcmd.JCmd -lSupported Diagnostic CommandsThe following key-value pairs are supported:            Name      Included with --enable-monitoring=      Description                  Compiler.dump_code_cache      Only available with Truffle runtime compilation      Print information about all compiled methods in the code cache.              GC.heap_dump      heapdump      Generate a HPROF format dump of the Java heap.              GC.run      Always available      Call java.lang.System.gc().              JFR.start      jfr      Starts a new JFR recording.              JFR.stop      jfr      Stops a JFR recording.              JFR.check      jfr      Checks running JFR recording(s).              JFR.dump      jfr      Copies contents of a JFR recording to file. Either the name or the recording id must be specified.              Thread.dump_to_file      Always available      Dump threads, with stack traces, to a file in plain text or JSON format.              Thread.print      Always available      Print all threads with stacktraces.              VM.command_line      Always available      Print the command line used to start this VM instance.              VM.native_memory      nmt      Print native memory usage.              VM.system_properties      Always available      Print system properties.              VM.uptime      Always available      Print VM uptime.              VM.version      Always available      Print JVM version information.              help      Always available      Display help information.      PerformanceAdding jcmd support to Native Image has minimal impact on performance when the application is idle.However, the performance impact varies significantly depending on the diagnostic commands used and how frequently they are invoked.For example, triggering multiple garbage collections will have a much greater overhead than dumping a single native memory tracking report.You can use jcmd &amp;lt;pid&amp;gt; help &amp;lt;command&amp;gt; to print the help information for a specific command which also lists its expected performance impact.LimitationsCurrently, this feature is not available on Windows.Further Reading  Debugging and Diagnostics  Build and Run Native Executables with JFR",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/jcmd/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-jdwp":  {
          "title": "Java Debug Wire Protocol (JDWP) with Native Image",
          "content": "Java Debug Wire Protocol (JDWP) with Native ImageOverviewThis document describes the Java Debug Wire Protocol (JDWP) debugging support for Native Image, a feature that enables debugging of native images using standard Java tooling.InstallationThe JDWP feature relies on a shared library, which is loaded only when the debugger is actively used.This library must be built once before building native images with JDWP enabled.native-image --macro:svmjdwp-library  Note: This is a one-time setup step. The same library will be used for all native images built with JDWP enabled.  Note: This library is stored in the GraalVM installation by default.If that directory is not writable, provide an alternative destination path with -o &amp;lt;path/to/writable/directory&amp;gt;/libsvmjdwp, or on Windows, use -o &amp;lt;pathtowritabledirectory&amp;gt;svmjdwp.Usage  Note: JDWP debugging for Native Image is experimental.To include JDWP support in a native image, add the -H:+JDWP option to your native-image command:native-image -H:+UnlockExperimentalVMOptions -H:+JDWP ... -cp &amp;lt;class/path&amp;gt; YourApplication ...This command produces:  The native executable  An &amp;lt;image-name&amp;gt;.metadata file  The lib:svmjdwp (libsvmjdwp.so, libsvmjdwp.dylib or svmjdwp.dll) shared library that will be necessary when debugging is also copied next to those files.Launching in Debug ModeTo launch the native image in debug mode, use the -XX:JDWPOptions= option, similar to HotSpot’s -agentlib:jdwp=:./your-application -XX:JDWPOptions=transport=dt_socket,server=y,address=8000  Note: Debugging requires the image-name.metadata file generated at build time and the svmjdwp shared library in the same directory as the native executable.For a complete list of supported JDWP options on Native Image, run:./your-application -XX:JDWPOptions=helpAdditional JDWP OptionsNative Image supports additional non-standard JDWP options:  mode=native:&amp;lt;path&amp;gt;: Specifies the path to the svmjdwp library. This can be:          A direct path to lib:svmjdwp      A directory containing lib:svmjdwp      A GraalVM installation containing lib:svmjdwp in the lib or bin directory        If no path is specified, lib:svmjdwp is searched for beside the native executable.  Examples:  -XX:JDWPOptions=...,mode=native:&amp;lt;path/to/lib:svmjdwp&amp;gt;  -XX:JDWPOptions=...,mode=native:&amp;lt;path/to/directory/containing/lib:svmjdwp&amp;gt;  -XX:JDWPOptions=...,mode=native:&amp;lt;path/to/java/home&amp;gt;: Search lib:svmjdwp inside JAVA_HOME, for example lib|bin/lib:svmjdwp.      -XX:JDWPOptions=...,mode=native: Search lib:svmjdwp besides the native executable directory.    -XX:JDWPOptions=...,vm.options=...: VM options, separated by whitespaces, passed to the JDWP server isolate/JVM, should not include a , character.  -XX:JDWPOptions=...,vm.options=@argfile: Also supports Java Command-Line Argument Files.Note: If lib:svmjdwp cannot be found, the application will terminate with error code 1.Goals and ConstraintsThe JDWP debugging support for Native Image aims to:  Expose Native Image through JDWP as-is, maintaining its assumptions and constraints  Incur minimal or no performance overhead when not in use  Add minimal size overhead to the native binary  Be available on all Graal-supported platforms, including Linux and Windows on x64, and Linux and macOS on AArch64 architecture  Provide a debugging experience similar to HotSpot, without requiring additional steps (e.g., setting permissions, environment variables)ArchitectureThe JDWP debugging support is implemented using a Java bytecode interpreter, adapted from Espresso to work with Native Image. Key components include:      Interpreter: Derived from Espresso and adapted for SubstrateVM. It does not enable any dynamic features beyond what Native Image already supports.        PLT/GOT Feature: Used to divert execution to the interpreter. This implementation detail may change for some platforms.        Metadata File: An external .metadata file produced at build time, containing information required for runtime method interpretation.        JDWP Server: Implemented as a native library (lib:svmjdwp), handling network connections and implementing JDWP commands.        JDWP Resident: A component within the application providing access to locals, fields, stack traces, and other runtime information.  LimitationsThe JDWP debugger for Native Image is designed to align with Native Image’s architecture and principles.While many limitations are a natural consequence of Native Image’s design, others may be due to the current implementation of the debugger itself.Here are the key limitations to be aware of:  The debugger follows Native Image closed-world assumptions:          Only classes, methods, and fields included in the image are accessible.      Some types may not be instantiable at runtime, even if there are instances in the image heap.      Some fields cannot be written to.      No support for dynamic class loading.      No class or method redefinition.      There’s no runtime class-path System.getProperty(&quot;java.class.path&quot;) == null        No exception breakpoints.  No field watchpoints.  No early return or frame popping.  Some methods cannot be interpreted by the debugger (see below):          Methods that use “System Java”.      Methods that contain a call to an intrinsic without compiled entry-point.      Breakpoints cannot be set in non-interpretable methods.      Stepping through non-interpretable methods is not possible, these are effectively treated as if they were Java “native” methods, with no guarantee to break/step on the next executed method, only on the next interpreted method.        Not all execution paths are executable/interpretable.          Interpreting “dead-code” may work, but only on a best-effort basis.      Violating compiled-code assumptions, for example, passing a null argument where a non-null was expected, is considered undefined behavior and prone to crashes.        Cannot write locals of compiled frames.  Cannot hit breakpoints or stepping events on actively executing compiled methods.  Step-out operations only work for interpreter frames, not compiled frames.  Can only debug the first isolate of a native image.  Step-into does not work for target methods of a MethodHandle object, for example, lambdas.These limitations reflect the current state of JDWP debugging support in Native Image.Some may be addressed in future iterations of the debugger, while others are fundamental to Native Image’s design.Further Reading  Instructions on how to run the JDWP server in HotSpot, so that the debugger can be debugged: JDWP server  Implementation details about the interpreter and the transitions from and to compiled code: SubstrateVM Interpreter",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/JDWP/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-jfr":  {
          "title": "JDK Flight Recorder (JFR) with Native Image",
          "content": "JDK Flight Recorder (JFR) with Native ImageJDK Flight Recorder (JFR) is an event recorder for capturing information about a JVM, and an application running on the JVM.GraalVM Native Image supports building a native executable with JFR events, and users can use jdk.jfr.Event API with a similar experience to using JFR in the Java HotSpot VM.Include JFR Support at Build Time and Record Events at RuntimeJFR support is disabled by default and must be explicitly enabled at build time.  Note: JFR event recording is not yet available with Native Image on Windows.To build a native executable with JFR, use the --enable-monitoring=jfr option:native-image --enable-monitoring=jfr JavaApplicationThe following options are supported to start a recording, and configure logging at runtime:  -XX:StartFlightRecording: starts a recording on application startup  -XX:FlightRecorderLogging: configures the log output for the JFRTo start a JFR recording, simply use -XX:StartFlightRecording at runtime.For example:./javaapplication -XX:StartFlightRecording=&quot;filename=recording.jfr&quot;Configure JFR RecordingSimilar to how JFR recordings can be started on HotSpot, you start recording by passing a comma-separated list of key-value pairs to the -XX:StartFlightRecording option.For example:-XX:StartFlightRecording=&quot;filename=recording.jfr,dumponexit=true,duration=10s&quot;The following key-value pairs are supported:            Name      Default Value      Description                  name      none      Name to identify the recording, for example, name=MyRecording              settings      none      Settings file (profile.jfc, default.jfc, and so on), for example, settings=myprofile.jfc              delay      none      Delay recording start with (s)econds, (m)inutes, (h)ours, or (d)ays, for example, delay=5h              duration      infinite (0)      Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, for example, duration=300s              filename      none      Resulting recording filename, for example, filename=recording1.jfr              maxage      no limit (0)      Maximum time to keep the recorded data on disk in (s)econds, (m)inutes, (h)ours, or (d)ays, for example, 60m, or 0 for no limit. For example, maxage=1d              maxsize      no limit (0)      Maximum amount of bytes to keep on disk in (k)B, (M)B or (G)B, for example, 500M, or 0 for no limit. For example, maxsize=1G              dumponexit      false      Whether to dump a running recording when the JVM shuts down, for example, dumponexit=true      Configure JFR System LoggingYou can configure the logging for the JFR system with a separate flag -XX:FlightRecorderLogging.The usage is: -XX:FlightRecorderLogging=[tag1[+tag2...][*][=level][,...]].For example:-XX:FlightRecorderLogging=jfr+system=debug-XX:FlightRecorderLogging=all=trace-XX:FlightRecorderLogging=jfr*=error  When this option is not set, logging is enabled at a level of WARNING.  When this option is set to an empty string, logging is enabled at a level of INFO.  When this option is set to “disable”, logging is disabled entirely.Available log levels are: trace, debug, info, warning, error, off.Available log tags are: all, jfr, system, event, setting, bytecode, parser, metadata, dcmd.Otherwise, this option expects a comma-separated list of tag combinations, each with an optional wildcard (*) and level.  A tag combination without a level is given a default level of INFO.  Messages with tags that match a given tag combination will be logged if they meet the tag combination’s level.  If a tag combination does not have a wildcard, then only messages with exactly the same tags are matched. Otherwise, messages whose tags are a subset of the tag combination are matched.  If more than one tag combination matches a message’s tags, the rightmost one will apply.  Messages with tags that do not have any matching tag combinations are set to log at a default level of WARNING.  This option is case insensitive.Features and LimitationsThis section outlines the JFR features that are available in Native Image.Method Profiling and Stack TracesMethod profiling in JFR supports two types of sampling: safepoint and asynchronous sampling.The asynchronous sampler is enabled by default, while the safepoint sampler is used only on demand.Asynchronous sampling offers the advantage of avoiding safepoint bias, which happens if a profiler does not sample all points in the application with equal probability.In this scenario, the sampler can only perform sampling at a safepoint, thereby introducing bias into the profiles.Both samplers periodically produce the event jdk.ExecutionSample at specified frequencies.These samples can be viewed in applications such as JDK Mission Control or VisualVM.In addition, other JFR events that support stacktraces on HotSpot also support stacktraces in Native Image.This means you can do interesting things such as viewing flamegraphs of jdk.ObjectAllocationInNewTLAB to diagnose where object allocations are frequently happening.JFR Event StreamingJFR Event Streaming is available with Native Image.Event streaming enables you to register callbacks for specific events at the application level.This introduces more flexibility and control over how recordings are managed.For example, you may dynamically increase the duration threshold of an event if it is found in the stream beyond a certain number times.Event streaming also enables the application to get continuous periodic JFR updates that are useful for monitoring purposes.Currently, stacktraces are not yet available on streamed events.This means you cannot access the stacktrace of an event inside its callback method.However, this limitation does not affect stacktraces in the JFR snapshot file (.jfr), those will still work as usual.Interaction with FlightRecorderMXBean via Remote JMXYou can interact with Native Image JFR from out of a process via a remote JMX connection to FlightRecorderMXBean.This can be done using applications such as JDK Mission Control or VisualVM.Over JMX you can start, stop, and dump JFR recordings using the FlightRecorderMXBean API as an interface.  Note: Remote JMX connection support needs to be enabled separately at build time and is experimental.FlightRecorderOptionsYou can fine-tune JFR parameters by using -XX:FlightRecorderOptions at runtime.This is primarily for advanced users, and most people should be fine with the default parameters.Leak ProfilingLeak profiling implemented using the jdk.OldObjectSample event is partially available.Specifically, old object tracking is possible, but the path to the GC root information is unavailable.Using JFR with JCMDJFR can be controlled using the Java Diagnostic Command utility (jcmd).To enable this functionality, jcmd support must be configured at build time.The following JFR commands are available with jcmd: JFR.start, JFR.stop, JFR.check, and JFR.dump.Built-In EventsMany of the VM-level built-in events are available in Native Image.Java-level events implemented by bytecode instrumentation on the HotSpot JVM are not yet available in Native Image.Such events include file I/O and exception built-in events.The following table lists JFR Events that can be collected with Native Image.Some of the events are available with Serial GC only, the default garbage collector in Native Image.            Event Name                  jdk.ActiveRecording              jdk.ActiveSetting              jdk.AllocationRequiringGC 1)              jdk.ClassLoadingStatistics              jdk.ContainerCPUThrottling              jdk.ContainerCPUUsage              jdk.ContainerConfiguration              jdk.ContainerIOUsage              jdk.ContainerMemoryUsage              jdk.DataLoss              jdk.ExecutionSample              jdk.ExecuteVMOperation              jdk.GarbageCollection 1)              jdk.GCHeapSummary 1)              jdk.GCPhasePause 1)              jdk.GCPhasePauseLevel1 1)              jdk.GCPhasePauseLevel2 1)              jdk.GCPhasePauseLevel3 1)              jdk.GCPhasePauseLevel4 1)              jdk.InitialEnvironmentVariable              jdk.InitialSystemProperty              jdk.JavaMonitorEnter              jdk.JavaMonitorInflate              jdk.JavaMonitorWait              jdk.JavaThreadStatistics              jdk.JVMInformation              jdk.NativeMemoryUsage 3)              jdk.NativeMemoryUsageTotal 3)              jdk.NativeMemoryUsagePeak 3)              jdk.NativeMemoryUsageTotalPeak 3)              jdk.ObjectAllocationSample 1)              jdk.ObjectAllocationInNewTLAB 1)              jdk.OldObjectSample 2)              jdk.OSInformation              jdk.PhysicalMemory              jdk.SafepointBegin              jdk.SafepointEnd              jdk.SocketRead              jdk.SocketWrite              jdk.SystemGC  1)              jdk.ThreadAllocationStatistics              jdk.ThreadCPULoad              jdk.ThreadEnd              jdk.ThreadPark              jdk.ThreadSleep              jdk.ThreadStart              jdk.VirtualThreadEnd              jdk.VirtualThreadPinned              jdk.VirtualThreadStart      1) Available if Serial GC is used.2) Partially available if Serial GC is used.3) Available if Native Memory Tracking is used.Further Reading  Build and Run Native Executables with JFR  Use remote JMX with Native Image  Java Diagnostic Command (jcmd) with Native Image",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/JFR/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-jni":  {
          "title": "Java Native Interface (JNI) in Native Image",
          "content": "Java Native Interface (JNI) in Native ImageJava Native Interface (JNI) is a native API that enables Java code to interact with native code and vice versa.This page gives an overview of the JNI implementation in Native Image.JNI support is enabled by default and built into Native Image. Individual classes, methods, and fields that should be accessible via JNI must be specified at image build time in a configuration file (read below).Java code can load native code from a shared object with System.loadLibrary().Alternatively, native code can load the JVM’s native library and attach to its Java environment using the Invocation API.The Native Image JNI implementation supports both approaches.Table of Contents  Loading Native Libraries  Reflection Metadata  Object Handles  Java-to-Native Method Calls  Native-to-Java Method Calls  JNI Functions  Object Creation  Field Accesses  Exceptions  MonitorsLoading Native LibrariesWhen loading native libraries using System.loadLibrary() (and related APIs), the native image will search the directory containing the native image before searching the Java library path. So as long as the native libraries to be loaded are in the same directory as the native image, no other settings should be necessary.Reflection MetadataJNI supports looking up classes by their names, and looking up methods and fields by their names and signatures.This requires keeping the necessary metadata for these lookups around.The native-image builder must know beforehand which items will be looked up in case they might not be reachable otherwise and therefore would not be included in a native image.Moreover, native-image must generate wrapper code ahead-of-time for any method that can be called via JNI.Therefore, specifying a concise list of items that need to be accessible via JNI guarantees their availability and allows for a smaller footprint.Such a list should be specified in the reachability-metadata.json file.The JNI configuration can be collected automatically using the Tracing Agent from the GraalVM JDK. The agent tracks all usages of dynamic features during application execution on a regular Java VM. When the application completes and the JVM exits, the agent writes configuration to JSON files in the specified output directory.If you move the generated configuration files from that output directory to META-INF/native-image/ on the class path, they are then automatically used at build time. The native-image builder searches for META-INF/native-image/ and its subdirectories for file named reachability-metadata.json, or legacy files such as reflect-config.json and others.Alternatively, a custom Feature implementation can register program elements before and during the analysis phase of the image build using the JNIRuntimeAccess class. For example:class JNIRegistrationFeature implements Feature {  public void beforeAnalysis(BeforeAnalysisAccess access) {    try {      JNIRuntimeAccess.register(String.class);      JNIRuntimeAccess.register(String.class.getDeclaredField(&quot;value&quot;));      JNIRuntimeAccess.register(String.class.getDeclaredField(&quot;hash&quot;));      JNIRuntimeAccess.register(String.class.getDeclaredConstructor(char[].class));      JNIRuntimeAccess.register(String.class.getDeclaredMethod(&quot;charAt&quot;, int.class));      JNIRuntimeAccess.register(String.class.getDeclaredMethod(&quot;format&quot;, String.class, Object[].class));      JNIRuntimeAccess.register(String.CaseInsensitiveComparator.class);      JNIRuntimeAccess.register(String.CaseInsensitiveComparator.class.getDeclaredMethod(&quot;compare&quot;, String.class, String.class));    } catch (NoSuchMethodException | NoSuchFieldException e) { ... }  }}To activate the custom feature, pass --features=&amp;lt;fully qualified name of JNIRegistrationFeature class&amp;gt; to the native-image builder.Native Image Build Configuration explains how this can be automated with a native-image.properties file in META-INF/native-image.java.lang.reflect SupportThe JNI functions FromReflectedMethod and ToReflectedMethod can be used to obtain the corresponding jmethodID to a java.lang.reflect.Method, or to a java.lang.reflect.Constructor object, and vice versa.The functions FromReflectedField and ToReflectedField convert between jfieldID and java.lang.reflect.Field.In order to use these functions, reflection support must be enabled and the methods and fields in question must be included in the reflection metadata.Object HandlesJNI does not permit direct access to Java objects.Instead, JNI provides word-sized object handles that can be passed to JNI functions to access objects indirectly.Local handles are only valid for the duration of a native call and only in the caller’s thread, while global handles are valid across threads and remain valid until they are destroyed explicitly.The handle 0 represents NULL.Native Image implements local handles with a thread-local, growing array of referenced objects, where the index in the array is the handle value.A “finger” points to where the next handle will be allocated.Native calls can be nested, so before a native method is invoked, the call stub pushes the current finger on a stack, and after it returns, it restores the old finger from the stack and nullifies all object references from the call in the array.Global handles are implemented using a variable number of object arrays in which referenced objects are inserted and nullified using atomic operations.A global handle’s value is a negative integer that is determined from the index of the containing array and the index within the array.Therefore, the JNI code can distinguish local and global handles by only looking at their sign.The analysis is not obstructed by object handles because it can observe the entire flow of object references and the handles that are passed to native code are only numeric values.Java-to-Native Method CallsMethods declared with the native keyword have a JNI-compliant implementation in native code, but can be called like any other Java method. For example:// Java declarationnative int[] sort0(int[] array);// native declaration with JNI name manglingjintArray JNICALL Java_org_example_sorter_IntSorter_sort0(JNIEnv *env, jobject this, jintArray array)When the image build encounters a method that is declared native, it generates a graph with a wrapper that performs the transition to native code and back, adds the JNIEnv* and this arguments, boxes any object arguments in handles, and in case of an object return type, unboxes the returned handle.The actual native call target address can only be determined at run time.Therefore, the native-image builder also creates an extra linkage object in the reflection metadata of native-declared methods.When a native method is called, the call wrapper looks up the matching symbol in all loaded libraries and stores the resolved address in the linkage object for future calls.Alternatively, instead of requiring symbols that conform to JNI name mangling scheme, Native Image also supports the RegisterNatives JNI function to explicitly provide code addresses for native methods.Native-to-Java Method CallsNative code can invoke Java methods by first obtaining a jmethodID for the target method, and then using one of the Call&amp;lt;Type&amp;gt;Method, CallStatic&amp;lt;Type&amp;gt;Method or CallNonvirtual&amp;lt;Type&amp;gt;Method functions for the invocation.Each of these Call... functions is also available in a Call...MethodA and a Call...MethodV variant, which take arguments as an array or as a va_list instead of variadic arguments. For example:jmethodID intcomparator_compare_method = (*env)-&amp;gt;GetMethodID(env, intcomparator_class, &quot;compare&quot;, &quot;(II)I&quot;);jint result = (*env)-&amp;gt;CallIntMethod(env, this, intcomparator_compare_method, a, b);The native-image builder generates call wrappers for each method that can be called via JNI according to the provided JNI configuration.The call wrappers conform to the signature of the JNI Call... functions that are appropriate for the method.The wrappers perform the transition to Java code and back, adapt the argument list to the target Java method’s signature, unbox any passed object handles, and if necessary, box the return type in an object handle.Each method that can be called via JNI has a reflection metadata object.The address of this object is used as the method’s jmethodID.The metadata object contains the addresses of all of the method’s generated call wrappers.Because each call wrapper conforms precisely to the corresponding Call... function signature, the Call... functions themselves are nothing more than an unconditional jump to the appropriate call wrapper based on the passed jmethodID.As another optimization, the call wrappers are able to efficiently restore the current thread’s Java context from the JNIEnv* argument.JNI FunctionsJNI provides a set of functions that native code can use to interact with Java code.Native Image implements these functions using @CEntryPoint, for example:@CEntryPoint(...) private static void DeleteGlobalRef(JNIEnvironment env, JNIObjectHandle globalRef) { /* setup; */ JNIGlobalHandles.singleton().delete(globalRef); }JNI specifies that these functions are provided via function pointers in a C struct that is accessible via the JNIEnv* argument.The automatic initialization of this struct is prepared during the image build.Object CreationJNI provides two ways of creating Java objects, either by calling AllocObject to allocate memory and then using CallVoidMethod to invoke the constructor, or by using NewObject to create and initialize the object in a single step (or variants NewObjectA or NewObjectV). For example:jclass calendarClass = (*env)-&amp;gt;FindClass(env, &quot;java/util/GregorianCalendar&quot;);jmethodID ctor = (*env)-&amp;gt;GetMethodID(env, calendarClass, &quot;&amp;lt;init&amp;gt;&quot;, &quot;(IIIIII)V&quot;);jobject firstObject = (*env)-&amp;gt;AllocObject(env, calendarClass);(*env)-&amp;gt;CallVoidMethod(env, obj, ctor, year, month, dayOfMonth, hourOfDay, minute, second);jobject secondObject = (*env)-&amp;gt;NewObject(env, calendarClass, ctor, year, month, dayOfMonth, hourOfDay, minute, second);Native Image supports both approaches.The constructor must be included in the JNI configuration with a method name of &amp;lt;init&amp;gt;.Instead of generating additional call wrappers for NewObject, the regular CallVoidMethod wrapper is reused and detects when it is called via NewObject because it is passed the Class object of the target class.In that case, the call wrapper allocates a new instance before invoking the actual constructor.Field AccessesNative code can access a Java field by obtaining its jfieldID and then using one of the Get&amp;lt;Type&amp;gt;Field, Set&amp;lt;Type&amp;gt;Field, GetStatic&amp;lt;Type&amp;gt;Field or SetStatic&amp;lt;Type&amp;gt;Field functions. For example:jfieldID intsorter_comparator_field = (*env)-&amp;gt;GetFieldID(env, intsorter_class, &quot;comparator&quot;, &quot;Lorg/example/sorter/IntComparator;&quot;);jobject value = (*env)-&amp;gt;GetObjectField(env, self, intsorter_comparator_field);For a field that is accessible via JNI, its offset within an object (or within the static field area) is stored in the reflection metadata and is used as its jfieldID.The native-image builder generates accessor methods for fields of all primitive types and for object fields.These accessor methods perform the transition to Java code and back, and use unsafe loads or stores to directly manipulate the field value.Because the analysis cannot observe assignments of object fields via JNI, it assumes that any subtype of the field’s declared type can occur in a field that is accessible via JNI.JNI also permits writing fields that are declared final, which must be enabled for individual fields with an allowWrite property in the configuration file.However, code accessing final fields might not observe changes of final field values in the same way as for non-final fields because of optimizations.ExceptionsJNI specifies that exceptions in Java code that are the result of a call from native code must be caught and retained.In Native Image, this is done in the native-to-Java call wrappers and in the implementation of JNI functions.Native code can then query and clear a pending exception with the ExceptionCheck, ExceptionOccurred, ExceptionDescribe, and ExceptionClear functions.Native code can also throw exceptions with Throw, ThrowNew, or FatalError.When an exception remains unhandled in native code or the native code itself throws an exception, the Java-to-native call wrapper rethrows that exception upon reentering Java code.MonitorsJNI declares the functions MonitorEnter and MonitorExit to acquire and release the intrinsic lock of an object.Native Image provides implementations of these functions.However, the native-image builder directly assigns intrinsic locks only to objects of classes which the analysis can observe as being used in Java synchronized statements and with wait(), notify() and notifyAll().For other objects, synchronization falls back on a slower mechanism which uses a map to store lock associations, which itself needs synchronization.For that reason, it can be beneficial to wrap synchronization in Java code.Related Documentation  Interoperability with Native Code  JNI Invocation API  Reachability Metadata: Java Native Interface  Collect Metadata with the Tracing Agent",
          "url": " /latest/reference-manual/native-image/dynamic-features/JNI/"
          },
          
          "latest-reference-manual-native-image-native-code-interoperability-jniinvocationapi":  {
          "title": "JNI Invocation API",
          "content": "JNI Invocation APINative Image can be used to implement low-level system operations in Java and make them available via JNI Invocation API to Java code executing on a standard JVM.As a result one can use the same language to write the application logic as well as the system calls.Note that this document describes the opposite of what is commonly done via JNI: usually low-level system operations are implemented in C and invoked from Java using JNI.If you are interested in how Native Image supports the common use case, see Java Native Interface (JNI) in Native Image.Create a Shared LibraryFirst of all one has to use the native-image builder to generate a shared library with some JNI-compatible entry points.Start with the Java code:package org.pkg.implnative;import org.graalvm.nativeimage.c.function.CEntryPoint;import org.graalvm.word.Pointer;public final class NativeImpl {    @CEntryPoint(name = &quot;Java_org_pkg_apinative_Native_add&quot;)    public static int add(Pointer jniEnv, Pointer clazz, @CEntryPoint.IsolateThreadContext long isolateId, int a, int b) {        return a + b;    }}After being processed by the native-image builder, the code exposes a C function Java_org_pkg_apinative_Native_add (the name follows conventions of JNI that will be handy later) and a Native Image signature typical for JNI methods.The first parameter is a reference to the JNIEnv* value.The second parameter is a reference to the jclass value for the class declaring the method.The third parameter is a portable (for example, long) identifier of the Native Image isolatethread.The rest of the parameters are the actual parameters of the Java Native.add method described in the next section. Compile the code with the --shared option:$JAVA_HOME/bin/native-image --shared -H:Name=libnativeimpl -cp nativeimplThe libnativeimpl.so is generated. We are ready to use it from standard Java code.Bind a Java Native MethodNow we need another Java class to use the native library generated in the previous step:package org.pkg.apinative;public final class Native {    private static native int add(long isolateThreadId, int a, int b);}The package name of the class, as well as the name of the method, has to correspond (after the JNI mangling) to the name of the @CEntryPoint introduced previously.The first argument is a portable (for example, long) identifier of the Native Image isolate thread.The rest of the arguments match the parameters of the entry point.Load the Native LibraryThe next step is to bind the JDK with the generated .so library.For example, make sure the implementation of the native Native.add method is loaded.Simple load or loadLibrary calls will do:public static void main(String[] args) {    System.loadLibrary(&quot;nativeimpl&quot;);    // ...}This is assuming your LD_LIBRARY_PATH environment variable is specified, or the java.library.path Java property is properly set.Initialize a Native Image IsolateBefore making calls to the Native.add method, we need to create a Native Image isolate.Native Image provides a special built-in to allow that: CEntryPoint.Builtin.CREATE_ISOLATE.Define another method along your other existing @CEntryPoint methods.Let it return IsolateThread and take no parameters:public final class NativeImpl {    @CEntryPoint(name = &quot;Java_org_pkg_apinative_Native_createIsolate&quot;, builtin=CEntryPoint.Builtin.CREATE_ISOLATE)    public static native IsolateThread createIsolate();}Native Image then generates default native implementation of the method into the final .so library.The method initializes the Native Image runtime and returns a portable identification (for example, long), to hold an instance of a Native Image isolatethread.The isolate thread can then be used for multiple invocations of the native part of your code:package org.pkg.apinative;public final class Native {    public static void main(String[] args) {        System.loadLibrary(&quot;nativeimpl&quot;);        long isolateThread = createIsolate();        System.out.println(&quot;2 + 40 = &quot; + add(isolateThread, 2, 40));        System.out.println(&quot;12 + 30 = &quot; + add(isolateThread, 12, 30));        System.out.println(&quot;20 + 22 = &quot; + add(isolateThread, 20, 22));    }    private static native int add(long isolateThread, int a, int b);    private static native long createIsolate();}The standard JVM is started. It initializes a Native Image isolate, attaches the current thread to the isolate, and the universal answer 42 is then computed three times inside of the isolate.Call JVM from Native JavaThere is a detailed tutorial on the C interface of Native Image.The following example shows how to make a callback to JVM.In the classical setup, when C needs to call into JVM, it uses a jni.h header file.The file defines essential JVM structures (such as JNIEnv) as well as functions one can invoke to inspect classes, access fields, and call methods in the JVM.In order to call these functions from the NativeImpl class in the above example, you need to define appropriate Java API wrappers of the jni.h concepts:@CContext(JNIHeaderDirectives.class)@CStruct(value = &quot;JNIEnv_&quot;, addStructKeyword = true)interface JNIEnvironment extends PointerBase {    @CField(&quot;functions&quot;)    JNINativeInterface getFunctions();}@CPointerTo(JNIEnvironment.class)interface JNIEnvironmentPointer extends PointerBase {    JNIEnvironment read();    void write(JNIEnvironment value);}@CContext(JNIHeaderDirectives.class)@CStruct(value = &quot;JNINativeInterface_&quot;, addStructKeyword = true)interface JNINativeInterface extends PointerBase {    @CField    GetMethodId getGetStaticMethodID();    @CField    CallStaticVoidMethod getCallStaticVoidMethodA();}interface GetMethodId extends CFunctionPointer {    @InvokeCFunctionPointer    JMethodID find(JNIEnvironment env, JClass clazz, CCharPointer name, CCharPointer sig);}interface JObject extends PointerBase {}interface CallStaticVoidMethod extends CFunctionPointer {    @InvokeCFunctionPointer    void call(JNIEnvironment env, JClass cls, JMethodID methodid, JValue args);}interface JClass extends PointerBase {}interface JMethodID extends PointerBase {}Leaving aside the meaning of JNIHeaderDirectives for now, the rest of the interfaces are type-safe representations of the C pointers found in the jni.h file. JClass, JMethodID, and JObject are all pointers.Thanks to the above definitions, you now have Java interfaces to represent instances of these objects in your native Java code in a type-safe way.The core part of any JNI API is the set of functions one can call when talking to the JVM.There are dozens of them, but in the JNINativeInterface definition, you just define wrappers for those few that are needed in the example.Again, give them proper types, so in your native Java code you can use GetMethodId.find(...), CallStaticVoidMethod.call(...), etc.In addition, there is another important part missing in the puzzle - the jvalue union type wrapping all the possible Java primitive and object types.Here are definitions of its getters and setters:@CContext(JNIHeaderDirectives.class)@CStruct(&quot;jvalue&quot;)interface JValue extends PointerBase {    @CField boolean z();    @CField byte b();    @CField char c();    @CField short s();    @CField int i();    @CField long j();    @CField float f();    @CField double d();    @CField JObject l();    @CField void z(boolean b);    @CField void b(byte b);    @CField void c(char ch);    @CField void s(short s);    @CField void i(int i);    @CField void j(long l);    @CField void f(float f);    @CField void d(double d);    @CField void l(JObject obj);    JValue addressOf(int index);}The addressOf method is a special Native Image construct used to perform C pointer arithmetic.Given a pointer, one can treat it as the initial element of an array, then, for example, use addressOf(1) to access the subsequent element.With this you have all the API needed to make a callback - redefine the previously introduced NativeImpl.add method to accept properly typed pointers, and then use these pointers to invoke a JVM method before computing the sum of a + b:@CEntryPoint(name = &quot;Java_org_pkg_apinative_Native_add&quot;)static int add(JNIEnvironment env, JClass clazz, @CEntryPoint.IsolateThreadContext long isolateThreadId, int a, int b) {    JNINativeInterface fn = env.getFunctions();    try (        CTypeConversion.CCharPointerHolder name = CTypeConversion.toCString(&quot;hello&quot;);        CTypeConversion.CCharPointerHolder sig = CTypeConversion.toCString(&quot;(ZCBSIJFD)V&quot;);    ) {        JMethodID helloId = fn.getGetStaticMethodID().find(env, clazz, name.get(), sig.get());        JValue args = StackValue.get(8, JValue.class);        args.addressOf(0).z(false);        args.addressOf(1).c(&#39;A&#39;);        args.addressOf(2).b((byte)22);        args.addressOf(3).s((short)33);        args.addressOf(4).i(39);        args.addressOf(5).j(Long.MAX_VALUE / 2l);        args.addressOf(6).f((float) Math.PI);        args.addressOf(7).d(Math.PI);        fn.getCallStaticVoidMethodA().call(env, clazz, helloId, args);    }    return a + b;}The above example seeks a static method hello and invokes it with eight JValue parameters in an array reserved by StackValue.get on the stack.Individual parameters are accessed by use of the addressOf operator and filled with appropriate primitive values before the call happens.The method hello is defined in the class Native and prints values of all parameters to verify they are properly propagated from the NativeImpl.add caller:public class Native {    public static void hello(boolean z, char c, byte b, short s, int i, long j, float f, double d) {        System.err.println(&quot;Hi, I have just been called back!&quot;);        System.err.print(&quot;With: &quot; + z + &quot; &quot; + c + &quot; &quot; + b + &quot; &quot; + s);        System.err.println(&quot; and: &quot; + i + &quot; &quot; + j + &quot; &quot; + f + &quot; &quot; + d);    }There is just one final piece to explain: the JNIHeaderDirectives.The Native Image C interface needs to understand the layout of the C structures.It needs to know at which offset of JNINativeInterface structure it can find the pointer to the GetMethodId function.To do so, it needs jni.h and additional files during compilation. One can specify them by @CContext annotation and implementation of its Directives:final class JNIHeaderDirectives implements CContext.Directives {    @Override    public List&amp;lt;String&amp;gt; getOptions() {        File[] jnis = findJNIHeaders();        return Arrays.asList(&quot;-I&quot; + jnis[0].getParent(), &quot;-I&quot; + jnis[1].getParent());    }    @Override    public List&amp;lt;String&amp;gt; getHeaderFiles() {        File[] jnis = findJNIHeaders();        return Arrays.asList(&quot;&amp;lt;&quot; + jnis[0] + &quot;&amp;gt;&quot;, &quot;&amp;lt;&quot; + jnis[1] + &quot;&amp;gt;&quot;);    }    private static File[] findJNIHeaders() throws IllegalStateException {        final File jreHome = new File(System.getProperty(&quot;java.home&quot;));        final File include = new File(jreHome.getParentFile(), &quot;include&quot;);        final File[] jnis = {            new File(include, &quot;jni.h&quot;),            new File(new File(include, &quot;linux&quot;), &quot;jni_md.h&quot;),        };        return jnis;    }}The good thing is that jni.h is inside of every JDK, so one can use the java.home property to locate the necessary header files.The actual logic can, of course, be made more robust and OS-independent.Implementing any JVM native method in Java and/or making callbacks to the JVM with Native Image should now be as easy as expanding upon the given example and invoking native-image.Related Documentation  Interoperability with Native Code  Java Native Interface (JNI) in Native Image",
          "url": " /latest/reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/"
          },
          
          "latest-reference-manual-js-javainteroperability":  {
          "title": "Java Interoperability",
          "content": "Java InteroperabilityThis documentation shows you how to enable interoperability with Java and possible JavaScript-to-Java embedding scenarios.Enabling Java InteroperabilityAs of GraalVM for JDK 21, all necessary artifacts can be downloaded directly from Maven Central.All artifacts relevant to embedders can be found in the Maven dependency group org.graalvm.polyglot.Learn more about the dependency setup in the Getting Started guide.Polyglot ContextThe preferred method of embedding JavaScript in Java is via Context.For that, a new org.graalvm.polyglot.Context is built with the hostAccess option allowing access and a hostClassLookup predicate defining the Java classes you allow access to:Context context = Context.newBuilder(&quot;js&quot;)    .allowHostAccess(HostAccess.ALL)    //allows access to all Java classes    .allowHostClassLookup(className -&amp;gt; true)    .build();context.eval(&quot;js&quot;, jsSourceCode);See the Guide to Embedding Languages on how to interact with a guest language such as JavaScript from a Java host application.ScriptEngine (JSR 223)JavaScript running on a GraalVM JDK is fully compatible with JSR 223 and supports the ScriptEngine API.Internally, the GraalVM’s JavaScript ScriptEngine wraps a polyglot Context instance:ScriptEngine eng = new ScriptEngineManager()    .getEngineByName(&quot;graal.js&quot;);Object fn = eng.eval(&quot;(function() { return this; })&quot;);Invocable inv = (Invocable) eng;Object result = inv.invokeMethod(fn, &quot;call&quot;, fn);See the ScriptEngine guide for more details on how to use it from GraalJS.Access Java from JavaScriptGraalVM provides a set of features to allow interoperability from JavaScript to Java.While Rhino, Nashorn, and GraalJS have a mostly comparable overall feature set, they differ in exact syntax, and, partly, semantics.Class AccessTo access a Java class, GraalJS supports the Java.type(typeName) function:var FileClass = Java.type(&#39;java.io.File&#39;);If the host class lookup is allowed (allowHostClassLookup), the java global property is available by default.Existing code accessing, for example, java.io.File, should be rewritten to use the Java.type(name) function:// GraalJS (and Nashorn) compliant syntaxvar FileClass = Java.type(&quot;java.io.File&quot;);// Backwards-compatible syntaxvar FileClass = java.io.File;GraalJS provides Packages, java, and similar global properties for compatibility.However, explicitly accessing the required class with Java.type is preferred whenever possible for two reasons:  It resolves the class in one step instead of trying to resolve each property as a class.  Java.type immediately throws a TypeError if the class cannot be found or is not accessible, rather than silently treating an unresolved name as a package.The js.java-package-globals flag can be used to deactivate the global fields of Java packages (set to false to avoid creation of the fields; default is true).Constructing Java ObjectsA Java object can be constructed with JavaScript’s new keyword:var FileClass = Java.type(&#39;java.io.File&#39;);var file = new FileClass(&quot;myFile.md&quot;);Field and Method AccessThe static fields of a Java class, or the fields of a Java object, can be accessed like JavaScript properties:var JavaPI = Java.type(&#39;java.lang.Math&#39;).PI;Java methods can be called like JavaScript functions:var file = new (Java.type(&#39;java.io.File&#39;))(&quot;test.md&quot;);var fileName = file.getName();Conversion of Method ArgumentsJavaScript is defined to operate on the double number type.GraalJS might internally use additional Java data types for performance reasons (for example, the int type).When calling Java methods, a value conversion might be required.This happens when the Java method expects a long parameter, and an int is provided from GraalJS (type widening).If this conversion causes a lossy conversion, a TypeError is thrown://Javavoid longArg   (long arg1);void doubleArg (double arg2);void intArg    (int arg3);//JavaScriptjavaObject.longArg(1);     //widening, OKjavaObject.doubleArg(1);   //widening, OKjavaObject.intArg(1);      //match, OKjavaObject.longArg(1.1);   //lossy conversion, TypeError!javaObject.doubleArg(1.1); //match, OKjavaObject.intArg(1.1);    //lossy conversion, TypeError!Note how the argument values have to fit into the parameter types.You can override this behavior using custom target type mappings.Method SelectionJava allows overloading of methods by argument types.When calling from JavaScript to Java, the method with the narrowest available type that the actual argument can be converted to without loss is selected://Javavoid foo(int arg);void foo(short arg);void foo(double arg);void foo(long arg);//JavaScriptjavaObject.foo(1);              // will call foo(short);javaObject.foo(Math.pow(2,16)); // will call foo(int);javaObject.foo(1.1);            // will call foo(double);javaObject.foo(Math.pow(2,32)); // will call foo(long);To override this behavior, an explicit method overload can be selected using the javaObject[&#39;methodName(paramTypes)&#39;] syntax.Parameter types need to be comma-separated without spaces, and object types need to be fully qualified (for example, &#39;get(java.lang.String,java.lang.String[])&#39;).Note that this is different from Nashorn which allows extra spaces and simple names.In the example above, one might always want to call, for example, foo(long), even when foo(short) can be reached with lossless conversion (foo(1)):javaObject[&#39;foo(int)&#39;](1);javaObject[&#39;foo(long)&#39;](1);javaObject[&#39;foo(double)&#39;](1);Note that the argument values still have to fit into the parameter types.You can override this behavior using custom target type mappings.An explicit method selection can also be useful when the method overloads are ambiguous and cannot be automatically resolved as well as when you want to override the default choice://Javavoid sort(List&amp;lt;Object&amp;gt; array, Comparator&amp;lt;Object&amp;gt; callback);void sort(List&amp;lt;Integer&amp;gt; array, IntBinaryOperator callback);void consumeArray(List&amp;lt;Object&amp;gt; array);void consumeArray(Object[] array);//JavaScriptvar array = [3, 13, 3, 7];var compare = (x, y) =&amp;gt; (x &amp;lt; y) ? -1 : ((x == y) ? 0 : 1);// throws TypeError: Multiple applicable overloads foundjavaObject.sort(array, compare);// explicitly select sort(List, Comparator)javaObject[&#39;sort(java.util.List,java.util.Comparator)&#39;](array, compare);// will call consumeArray(List)javaObject.consumeArray(array);// explicitly select consumeArray(Object[])javaObject[&#39;consumeArray(java.lang.Object[])&#39;](array);Note that there is currently no way to explicitly select constructor overloads.Future versions of GraalJS might lift that restriction.Package AccessGraalJS provides a Packages global property:&amp;gt; Packages.java.io.FileJavaClass[java.io.File]Array AccessGraalJS supports the creation of Java arrays from JavaScript code.Both the patterns suggested by Rhino and Nashorn are supported://Rhino patternvar JArray = Java.type(&#39;java.lang.reflect.Array&#39;);var JString = Java.type(&#39;java.lang.String&#39;);var sarr = JArray.newInstance(JString, 5);// Nashorn patternvar IntArray = Java.type(&quot;int[]&quot;);var iarr = new IntArray(5);The arrays created are Java types, but can be used in JavaScript code:iarr[0] = iarr[iarr.length] * 2;Map AccessIn GraalJS you can create and access Java Maps, for example, java.util.HashMap:var HashMap = Java.type(&#39;java.util.HashMap&#39;);var map = new HashMap();map.put(1, &quot;a&quot;);map.get(1);GraalJS supports iterating over such maps similar to Nashorn:for (var key in map) {    print(key);    print(map.get(key));}List AccessIn GraalJS you can create and access Java Lists, for example, java.util.ArrayList:var ArrayList = Java.type(&#39;java.util.ArrayList&#39;);var list = new ArrayList();list.add(42);list.add(&quot;23&quot;);list.add({});for (var idx in list) {    print(idx);    print(list.get(idx));}String AccessGraalJS can create Java strings with Java interoperability.The length of the string can be queried with the length property (note that length is a value property and cannot be called as a function):var javaString = new (Java.type(&#39;java.lang.String&#39;))(&quot;Java&quot;);javaString.length === 4;Note that GraalJS uses Java strings internally to represent JavaScript strings, so the above code and the JavaScript string literal &quot;Java&quot; are actually not distinguishable.Iterating PropertiesProperties (fields and methods) of Java classes and Java objects can be iterated with a JavaScript for..in loop:var m = Java.type(&#39;java.lang.Math&#39;)for (var i in m) { print(i); }&amp;gt; E&amp;gt; PI&amp;gt; abs&amp;gt; sin&amp;gt; ...Access to JavaScript Objects from JavaJavaScript objects are exposed to Java code as instances of com.oracle.truffle.api.interop.java.TruffleMap.This class implements Java’s Map interface.JavaImporterThe JavaImporter feature is available only in Nashorn compatibility mode (with the js.nashorn-compat option).Console Output of Java Classes and Java ObjectsGraalJS provides both print and console.log.GraalJS provides a print built-in function compatible with Nashorn.The console.log is provided by Node.js directly.It does not provide special treatment of interop objects.Note that the default implementation of console.log on GraalJS is just an alias for print, and Node’s implementation is only available when running on Node.js.ExceptionsExceptions thrown in Java code can be caught in JavaScript code.They are represented as Java objects:try {    Java.type(&#39;java.lang.Class&#39;)    .forName(&quot;nonexistent&quot;);} catch (e) {    print(e.getMessage());}PromisesGraalJS provides support for interoperability between JavaScript Promise objects and Java.Java objects can be exposed to JavaScript code as thenable objects, allowing JavaScript code to await Java objects.Moreover, JavaScript Promise objects are regular JavaScript objects, and can be accessed from Java using the mechanisms described in this document.This allows Java code to be called back from JavaScript when a JavaScript promise is resolved or rejected.Creating JavaScript Promise Objects That Can Be Resolved from JavaJavaScript applications can create Promise objects delegating to Java the resolution of the Promise instance.This can be achieved from JavaScript by using a Java object as the “executor” function of the JavaScript Promise.For example, Java objects implementing the following functional interface can be used to create new Promise objects:@FunctionalInterfacepublic interface PromiseExecutor {    void onPromiseCreation(Value onResolve, Value onReject);}Any Java object implementing PromiseExecutor can be used to create a JavaScript Promise:// `javaExecutable` is a Java object implementing the `PromiseExecutor` interfacevar myPromise = new Promise(javaExecutable).then(...);JavaScript Promise objects can be created not only using functional interfaces, but also using any other Java object that can be executed by GraalJS (for example, any Java object implementing the Polyglot ProxyExecutable interface).More detailed example usages are available in the GraalJS unit tests.Using await with Java ObjectsJavaScript applications can use the await expression with Java objects.This can be useful when Java and JavaScript have to interact with asynchronous events.To expose a Java object to GraalJS as a thenable object, the Java object should implement a method called then() having the following signature:void then(Value onResolve, Value onReject);When await is used with a Java object implementing then(), GraalJS will treat the object as a JavaScript Promise.The onResolve and onReject arguments are executable Value objects that should be used by the Java code to resume or abort the JavaScript await expression associated with the corresponding Java object.More detailed example usages are available in the GraalJS unit tests.Using JavaScript Promises from JavaPromise objects created in JavaScript can be exposed to Java code like any other JavaScript object.Java code can access such objects like normal Value objects, with the possibility to register new promise resolution functions using the Promise’s default then() and catch() functions.As an example, the following Java code registers a Java callback to be executed when a JavaScript promise resolves:Value jsPromise = context.eval(ID, &quot;Promise.resolve(42);&quot;);Consumer&amp;lt;Object&amp;gt; javaThen = (value)    -&amp;gt; System.out.println(&quot;Resolved from JavaScript: &quot; + value);jsPromise.invokeMember(&quot;then&quot;, javaThen);More detailed example usages are available in the GraalJS unit tests.MultithreadingGraalJS supports multithreading when used in combination with Java.More details about the GraalJS multithreading model can be found in the Multithreading documentation.Extending Java classesGraalJS provides support for extending Java classes and interfaces using the Java.extend function.Note that host access has to be enabled in a polyglot context for this feature to be available.Java.extendJava.extend(types...) returns a generated adapter Java class object that extends the specified Java class and/or interfaces.For example:var Ext = Java.extend(Java.type(&quot;some.AbstractClass&quot;),                      Java.type(&quot;some.Interface1&quot;),                      Java.type(&quot;some.Interface2&quot;));var impl = new Ext({  superclassMethod: function() {/*...*/},  interface1Method: function() {/*...*/},  interface2Method: function() {/*...*/},  toString() {return &quot;MyClass&quot;;}});impl.superclassMethod();Super methods can be called via Java.super(adapterInstance).See a combined example:var sw = new (Java.type(&quot;java.io.StringWriter&quot;));var FilterWriterAdapter = Java.extend(Java.type(&quot;java.io.FilterWriter&quot;));var fw = new FilterWriterAdapter(sw, {    write: function(s, off, len) {        s = s.toUpperCase();        if (off === undefined) {            fw_super.write(s, 0, s.length)        } else {            fw_super.write(s, off, len)        }    }});var fw_super = Java.super(fw);fw.write(&quot;abcdefg&quot;);fw.write(&quot;h&quot;.charAt(0));fw.write(&quot;**ijk**&quot;, 2, 3);fw.write(&quot;***lmno**&quot;, 3, 4);print(sw); // ABCDEFGHIJKLMNONote that in the nashorn-compat mode, you can also extend interfaces and abstract classes using a new operator on a type object of an interface or an abstract class:// --experimental-options --js.nashorn-compatvar JFunction = Java.type(&#39;java.util.function.Function&#39;); var sqFn = new JFunction({   apply: function(x) { return x * x; }});sqFn.apply(6); // 36Related Documentation  Guide to Embedding Languages  GraalJS Compatibility  Multithreading Support",
          "url": " /latest/reference-manual/js/JavaInteroperability/"
          },
          
          "latest-reference-manual-js-javascriptcompatibility":  {
          "title": "GraalJS Compatibility",
          "content": "GraalJS CompatibilityGraalJS is an ECMAScript-compliant JavaScript language runtime.This document explains the public API it presents for user applications written in JavaScript.  ECMAScript Language Compliance  Compatibility Extensions  GraalJS ExtensionsECMAScript Language ComplianceGraalJS implements the ECMAScript (ECMA-262) specification and is fully compatible with the ECMAScript 2024 specification (sometimes referred to as the 15th edition).New features are frequently added to GraalVM when they are confirmed to be part of ECMAScript 2024, see the CHANGELOG.md for details.Older versions starting from ECMAScript 5 can be enabled with a configuration option (by number: --js.ecmascript-version=5 or by year: --js.ecmascript-version=2024).In a production environment, you might consider specifying a fixed ECMAScript version to be used, as future versions of GraalJS will use newer versions of the specification once available.GraalJS provides the following function objects in the global scope as specified by ECMAScript, representing the JavaScript core library:Array, ArrayBuffer, Boolean, DataView, Date, Error, Function, JSON, Map, Math, Number, Object, Promise, Proxy, Reflect, RegExp, Set, SharedArrayBuffer, String, Symbol, TypedArray, WeakMap, and WeakSet.Additional objects are available under options, for example, --js.temporal.Run js --help for the list of available options.Several of these function objects and some of their members are only available when a certain version of the specification is selected for execution.For a list of methods provided, inspect the ECMAScript specification.Extensions to the specification are specified below.Internationalization API (ECMA-402)GraalJS comes with an implementation of the ECMA-402 Internationalization API, enabled by default (can be disabled using the following option: --js.intl-402=false).This includes the following extensions:  Intl.Collator  Intl.DateTimeFormat  Intl.DisplayNames  Intl.ListFormat  Intl.Locale  Intl.NumberFormat  Intl.PluralRules  Intl.RelativeTimeFormat  Intl.SegmenterThe functionality of a few other built-ins, such as toLocaleString, is also updated according to the ECMA-402 specification.JavaScript ModulesGraalJS supports modules as defined by ECMAScript 6 and later.Be aware that the support for this feature continues to increase. Be sure to use the latest ECMAScript version for the all the latest features.When loading modules via a polyglot Source, you can use the unofficial application/javascript+module MIME type to specify that you are loading a module.When loading with JavaScript code from a file, make sure the module is loaded from a file with the .mjs extension.Loading with the import keyword is not limited by that, and can import from a file of any extension.Compatibility ExtensionsThe following objects and methods are available in GraalJS for compatibility with other JavaScript engines.Note that the behavior of such methods might not strictly match the semantics of those methods in all existing engines.Language FeaturesConditional Catch ClausesGraalJS supports conditional catch clauses if the js.syntax-extensions option is enabled:try {    myMethod(); // can throw} catch (e if e instanceof TypeError) {    print(&quot;TypeError caught&quot;);} catch (e) {    print(&quot;another Error caught&quot;);}Global Propertiesload(source)  loads (parses and executes) the specified JavaScript source codeSource can be of type:  a String: the path of the source file or a URL to execute.  java.lang.URL: the URL is queried for the source code to execute if the js.load-from-url option is set to true.  java.io.File: the file is read for the source code to execute.  a JavaScript object: the object is queried for a name and a script property, which represent the source name and code, respectively.  all other types: the source is converted to a String.load is available by default and can be deactivated by setting the js.load option to false.print(...arg) and printErr(...arg)  prints the arguments on the console (stdout and stderr, respectively)  provides a best-effort human readable outputprint and printErr are available by default and can be deactivated by setting the js.print option to false.Methods of the console Global ObjectA global console object is provided that offers several methods for debugging purposes.These methods strive to provide similar functionality as provided in other engines, but do not guarantee identical results.Note that those methods behave differently when GraalJS is executed in Node.js mode (for example, the node executable is started instead of js).Node.js provides its own implementation that is used instead.  console.log, console.info, and console.debug: an alias for print(...arg)  console.error, and console.warn: similar to print, but using the error IO stream  console.assert(check, message): prints message when check is falsy  console.clear: clears the console window if possible  console.count(), and console.countReset(): counts and prints how many times it has been called, or resets this counter  console.group, and console.groupEnd: increases or decreases the indentation for succeeding outputs to the console  console.time(), console.timeLog(), and console.timeEnd(): starts a timer, prints the duration the timer has been active, or prints the duration and stops the timer, respectivelyThe console object is available by default and can be deactivated by setting the option js.console to false.Additional Global Functions in the js Shellquit(status)  exits the engine and returns the specified status coderead(file)  reads the content of fileThe result is returned as a String.The argument file can be of type:  java.io.File: the file is used directly.  all other types: file is converted to a String and interpreted as a file name.readbuffer(file)  reads the content of file similar to the read functionThe result is returned as a JavaScript ArrayBuffer object.readline()  reads one line of input from the input streamThe result is returned as a String.ObjectObject.prototype.__defineGetter__(prop, func)  defines the prop property of this to be the getter function funcThis functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Object.prototype.__defineSetter__(prop, func)  defines the prop property of this to be the setter function funcThis functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Object.prototype.__lookupGetter__(prop)  returns the getter function for property prop of the object as set by __defineGetter__This functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Object.prototype.__lookupSetter__(prop)  returns the setter function for property prop of the object as set by __defineSetter__This functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Nashorn Scripting ModeGraalJS provides a scripting mode compatible with the one provided by the Nashorn engine.It is enabled with the js.scripting option. Make sure to have --experimental-options set:js --experimental-options --js.scripting=trueIn scripting mode, several properties and functions are added to the global object, including readFully, readLine, $ARG, $ENV, and $EXEC.There are migration guides available for code previously targeted to the Nashorn or Rhino engines.GraalJS ExtensionsGraal ObjectThe Graal object is provided as a property of the global object.It provides Graal-specific information.The existence of the property can be used to identify whether GraalJS is the current language engine:if (typeof Graal != &#39;undefined&#39;) {    print(Graal.versionECMAScript);    print(Graal.versionGraalVM);    print(Graal.isGraalRuntime());}The Graal object is available in GraalJS by default, unless deactivated by an option (js.graal-builtin=false).Graal.versionECMAScript  provides the version number (year value) of the GraalJS ECMAScript compatibility modeGraal.versionGraalVM  provides the version of GraalVM, if the current engine is executed on GraalVMGraal.isGraalRuntime()  indicates if GraalJS is executed on a GraalVM-enabled runtime  If true, hot code is compiled by the Graal compiler, resulting in high peak performance.  If false, GraalJS will not be optimized by the Graal Compiler, typically resulting in lower performance.Graal.setUnhandledPromiseRejectionHandler(handler)  provides the unhandled promise rejection handler when using option (js.unhandled-rejections=handler).  the handler is called with two arguments: (rejectionReason, unhandledPromise).  Graal.setUnhandledPromiseRejectionHandler can be called with null, undefined, or empty arguments to clear the handler.JavaThe Java object is only available when host class lookup is allowed.To access Java host classes and its members, they first need to be allowed by the host access policy, and when running from a native executable, be registered for runtime reflection.Note that some functions require the Nashorn compatibility mode to be set (--js.nashorn-compat=true).Java.type(className)Java.type loads the specified Java class and returns a constructible object that has the static members (for example, methods and fields) of the class and can be used with the new keyword to construct new instances:var BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;);var point1 = new BigDecimal(&quot;0.1&quot;);var two = BigDecimal.TWO;console.log(point1.multiply(two).toString());Note that when used directly with the new operator, Java.type(...) needs to be enclosed in parentheses:console.log(new (Java.type(&#39;java.math.BigDecimal&#39;))(&quot;1.1&quot;).pow(15));Java.from(javaData)Java.from creates a shallow copy of the Java data structure (Array, List) as a JavaScript array.In many cases, this is not necessary; you can typically use the Java data structure directly from JavaScript.Java.to(jsData, javaType)Java.to converts the argument to the Java type.The source object jsData is expected to be a JavaScript array, or an array-like object with a length property.The target javaType can either be a String (for example, an &quot;int[]&quot;) or a type object (such as Java.type(&quot;int[]&quot;)).Valid target types are Java arrays.When the target type is omitted, it defaults to Object[].var jsArray = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var stringArrayType = Java.type(&quot;java.lang.String[]&quot;);var javaArray = Java.to(jsArray, stringArrayType);assertEquals(&#39;class java.lang.String[]&#39;, String(javaArray.getClass()));var javaArray = Java.to(jsArray);assertEquals(&#39;class java.lang.Object[]&#39;, String(javaArray.getClass()));The conversion methods as defined by ECMAScript (for example, ToString and ToDouble) are executed when a JavaScript value has to be converted to a Java type.Lossy conversion is disallowed and results in a TypeError.Java.isJavaObject(obj)  returns true if obj is a Java host object  returns false for native JavaScript objects, as well as for objects of other polyglot languagesJava.isType(obj)  returns true if obj is an object representing the constructor and static members of a Java class, as obtained by Java.type() or package objects.  returns false for all other argumentsJava.typeName(obj)  returns the Java Class name of obj when obj represents a Java type (isType(obj) === true) or Java Class instance  returns undefined otherwiseJava.isJavaFunction(fn)  returns whether fn is an object of the Java language that represents a Java function  returns false for all other types, including native JavaScript function, and functions of other polyglot languages  This function is only available in Nashorn compatibility mode (--js.nashorn-compat=true).Java.isScriptObject(obj)  returns whether obj is an object of the JavaScript language  returns false for all other types, including objects of Java and other polyglot languages  This function is only available in Nashorn compatibility mode (--js.nashorn-compat=true).Java.isScriptFunction(fn)  returns whether fn is a JavaScript function  returns false for all other types, including Java function, and functions of other polyglot languages  This function is only available in Nashorn compatibility mode (--js.nashorn-compat=true).Java.addToClasspath(location)  adds the specified location (a .jar file or directory path string) to Java’s classpathPolyglotThe functions of the Polyglot object allow to interact with values from other polyglot languages.The Polyglot object is available by default, unless deactivated by setting the js.polyglot-builtin option to false.Polyglot.export(key, value)  exports the JavaScript value under the name key (a string) to the polyglot bindings:    function helloWorld() { print(&quot;Hello, JavaScript world&quot;); }Polyglot.export(&quot;helloJSWorld&quot;, helloWorld);  If the polyglot bindings already had a value identified by key, it is overwritten with the new value.The value may be any valid Polyglot value.  throws a TypeError if key is not a String or is missingPolyglot.import(key)  imports the value identified by key (a string) from the polyglot bindings and returns it:    var rubyHelloWorld = Polyglot.import(&quot;helloRubyWorld&quot;);rubyHelloWorld();  If no language has exported a value identified by key, undefined is returned.  throws a TypeError if key is not a string or missingPolyglot.eval(languageId, sourceCode)  parses and evaluates the sourceCode with the interpreter identified by languageIdThe value of sourceCode is expected to be a String (or convertible to one).  returns the evaluation result, depending on the sourceCode and/or the semantics of the language evaluated:    var pyArray = Polyglot.eval(&#39;python&#39;, &#39;import random; [random.uniform(0.0, 1.0) for _ in range(1000)]&#39;);  Exceptions can occur when an invalid languageId is passed, when the sourceCode cannot be evaluated by the language, or when the executed program throws one.Polyglot.evalFile(languageId, sourceFileName)  parses the file sourceFileName with the interpreter identified by languageIdThe value of sourceFileName is expected to be a String (or convertible to one), representing a file reachable by the current path.  returns an executable object, typically a function:    var rFunc = Polyglot.evalFile(&#39;R&#39;, &#39;myExample.r&#39;);var result = rFunc();  Exceptions can occur when an invalid languageId is passed, when the file identified by sourceFileName cannot be found, or when the language throws an exception during parsing (parse time errors, for example, syntax errors).Exceptions thrown by the evaluated program are only thrown once the resulting function is evaluated.The Polyglot.evalFile function is available by default when the Polyglot builtin is available, unless deactivated by setting the js.polyglot-evalfile option to false.It is also available when js.debug-builtin is activated.Debug  requires starting the engine with the js.debug-builtin optionDebug is a GraalJS specific function object that provides functionality for debugging JavaScript code and the JavaScript engine.This API might change without notice. Do not use for production purposes.Global FunctionsprintErr(...arg)  behaves identically to printThe only difference is that the error stream is used to print to, instead of the default output stream.loadWithNewGlobal(source, arguments)  behaves similarly to load functionThe relevant difference is that the code is evaluated in a new global scope (Realm, as defined by ECMAScript).Source can be of type:  java.lang.URL: the URL is queried for the source code to execute.  a JavaScript object: the object is queried for a name and a script property.  all other types: the source is converted to a String.The value of arguments is provided to the loaded code upon execution.Related Documentation  Java Interoperability",
          "url": " /latest/reference-manual/js/JavaScriptCompatibility/"
          },
          
          "latest-security-guide-native-image-jipher":  {
          "title": "docs/security/JipherJCE.md",
          "content": "",
          "url": " /latest/security-guide/native-image/Jipher/"
          },
          
          "latest-reference-manual-native-image-llvmbackend":  {
          "title": "LLVM Backend",
          "content": "",
          "url": " /latest/reference-manual/native-image/LLVMBackend/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-languagetutorial":  {
          "title": "Implementing a New Language with Truffle",
          "content": "Implementing a New Language with TruffleThe Truffle framework enables you to implement a programming language and run it efficiently on GraalVM.We provide extensive Truffle API documentation.A good way to start implementing your language is to:  Look at the TruffleLanguage class, and subclass it for your own language implementation.  Fork the SimpleLanguage project and start hacking. SimpleLanguage is a relatively small language implementation, well-documented, and designed to demonstrate most of the Truffle features.  Examine the GraalVM Polyglot API that enables you to embed your Truffle language in Java.We also recommend to watch this online seminar on Dynamic Metacompilation with Truffle by Christian Humer from Oracle, to better understand Truffle concepts such as dynamic metacompilation, partial evaluation, polymorphic inlining, and so on.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/LanguageTutorial/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-languages":  {
          "title": "Language Implementations",
          "content": "Language ImplementationsThis page is intended to keep track of the growing number of language implementations and experiments on top of Truffle.The following language implementations exist already (in alphabetical order):  Enso, an open source, visual language for data science that lets you design, prototype and develop any application by connecting visual elements together.  Espresso, a meta-circular Java bytecode interpreter. *  FastR, an implementation of GNU R. *  GraalJS, an ECMAScript-compliant JavaScript implementation. *  GraalPy, an early-stage implementation of Python. *  GraalWasm, a compliant WebAssembly implementation. *  grCUDA, a polyglot CUDA integration.  Pkl, a configuration as code language with rich validation and tooling.  SimpleLanguage, a toy language implementation to demonstrate Truffle features.  SOMns, a Newspeak implementation for Concurrency Research.  Sulong, an LLVM bitcode interpreter. *  TRegex, a generic regular expression engine (internal, for use by other languages only). *  TruffleRuby, an implementation of Ruby. *  TruffleSOM, a SOM Smalltalk implementation.  TruffleSqueak, a Squeak/Smalltalk VM implementation and polyglot programming environment.  Yona, the reference implementation of a minimalistic, strongly and dynamically-typed, parallel and non-blocking, polyglot, strict, functional programming language.* Shipped as part of GraalVM.Experiments  BACIL, .NET CIL interpreter.  bf, an experimental Brainfuck programming language implementation.  brainfuck-jvm, another Brainfuck language implementation.  Cover, a Safe Subset of C++.  DynSem, a DSL for declarative specification of dynamic semantics of languages.  Heap Language, a tutorial showing the embedding of Truffle languages via interoperability.  hextruffe, an implementation of Hex.  islisp-truffle, an implementation of the ISLISP 2007 standard.  LuaTruffle, an implementation of the Lua language.  Mozart-Graal, an implementation of the Oz programming language.  Mumbler, an experimental Lisp programming language.  PorcE, an Orc language implementation.  ProloGraal a Prolog language implementation supporting interoperability.  PureScript, a small, strongly-typed programming language.  Reactive Ruby, TruffleRuby meets Reactive Programming.  shen-truffle, a port of the Shen programming language.  TruffleBF, a completed Brainfuck programming language implementation, compiled to native-image.  streamblocks-graalvm, a CAL Actor Language (Dataflow Programming) implementation  TruffleMATE, a Smalltalk with a completely reified runtime system.  TrufflePascal, a Pascal interpreter.  ZipPy, a Python implementation.Submit a pull request to add/remove from this list.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/Languages/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-memorymanagement":  {
          "title": "Memory Management",
          "content": "Memory ManagementA native image, when being executed, does not run on the Java HotSpot VM but on the runtime system provided with GraalVM.That runtime includes all necessary components, and one of them is the memory management.Java objects that a native image allocates at run time reside in the area called “the Java heap”.The Java heap is created when the native image starts up, and may increase or decrease in size while the native image runs.When the heap becomes full, a garbage collection is triggered to reclaim memory of objects that are no longer used.For managing the Java heap, Native Image provides different garbage collector (GC) implementations:  The Serial GC is the default GC in GraalVM Native Image.It is optimized for low memory footprint and small Java heap sizes.  The G1 GC is a multithreaded GC that is optimized to reduce stop-the-world pauses and therefore improve latency, while achieving high throughput.To enable it, pass the option --gc=G1 to the native-image builder.Currently, G1 Garbage Collector can be used with Native Image on the Linux AMD64 and AArch64 architectures. (Not available in GraalVM Community Edition.)  The Epsilon GC (available with GraalVM 21.2 or later) is a no-op garbage collector that does not do any garbage collection and therefore never frees any allocated memory.The primary use case for this GC are very short running applications that only allocate a small amount of memory.To enable the Epsilon GC, specify the option --gc=epsilon at image build time.Performance ConsiderationsThe primary metrics for garbage collection are throughput, latency, and footprint:  Throughput is the percentage of total time not spent in garbage collection considered over long periods of time.  Latency is the responsiveness of an application.Garbage collection pauses negatively affect the responsiveness.  Footprint is the working set of a process, measured in pages and cache lines.Choosing settings for the Java heap is always a trade-off between these metrics.For example, a very large young generation may maximize throughput, but does so at the expense of footprint and latency.Young generation pauses can be minimized by using a small young generation at the expense of throughput.By default, Native Image automatically determines values for the Java heap settings that are listed below.The exact values may depend on the system configuration and the used GC.  The maximum Java heap size defines the upper limit for the size of the whole Java heap.If the Java heap is full and the GC is unable reclaim sufficient memory for a Java object allocation, the allocation will fail with the OutOfMemoryError.Note: The maximum heap size is only the upper limit for the Java heap and not necessarily the upper limit for the total amount of consumed memory, as Native Image places some data such as thread stacks, just-in-time compiled code (for Truffle runtime compilation), and internal data structures in memory that is separate from the Java heap.  The minimum Java heap size defines how much memory the GC may always assume as reserved for the Java heap, no matter how little of that memory is actually used.  The young generation size determines the amount of Java memory that can be allocated without triggering a garbage collection.Serial Garbage CollectorThe Serial GC is optimized for low footprint and small Java heap sizes.If no other GC is specified, the Serial GC will be used implicitly as the default on GraalVM.It is also possible to explicitly enable the Serial GC by passing the option --gc=serial to the native image builder.# Build a native image that uses the serial GC with default settingsnative-image --gc=serial HelloWorldOverviewIn its core, the Serial GC is a simple (non-parallel, non-concurrent) stop and copy GC.It divides the Java heap into a young and an old generation.Each generation consists of a set of equally sized chunks, each a contiguous range of virtual memory.Those chunks are the GC-internal unit for memory allocation and memory reclamation.The young generation contains recently created objects and is divided into the eden and survivor regions.New objects are allocated in the eden region, and when this region is full, a young collection is triggered.Objects that are alive in the eden region will be moved to the survivor region, and alive objects in the survivor region stay in that region until they reach a certain age (have survived a certain number of collections), at which time they are moved to the old generation.When the old generation becomes full, a full collection is triggered that reclaims the space of unused objects in both the young and old generations.Typically, a young collection is much faster than a full collection, however doing full collections is important for keeping the memory footprint low.By default, the Serial GC tries to find a size for the generations that provides good throughput, but to not increase sizes further when doing so gives diminishing returns.It also tries to maintain a ratio between the time spent in young collections and in full collections to keep the footprint small.If no maximum Java heap size is specified, a native image that uses the Serial GC will set its maximum Java heap size to 80% of the physical memory size.For example, on a machine with 4GB of RAM, the maximum Java heap size will be set to 3.2GB.If the same image is executed on a machine that has 32GB of RAM, the maximum Java heap size will be set to 25.6GB.Note that this is just the maximum value.Depending on the application, the amount of actually used Java heap memory can be much lower.To override this default behavior, either specify a value for -XX:MaximumHeapSizePercent or explicitly set the maximum Java heap size.Note that GraalVM releases up to (and including) 21.3 use a different default configuration for the Serial GC with no survivor regions, a young generation that is limited to 256 MB, and a default collection policy that balances the time that is spent in young collections and old collections.This configuration can be enabled with: -H:InitialCollectionPolicy=BySpaceAndTimeBe mindful that the GC needs some extra memory when performing a garbage collection (2x of the maximum heap size is the worst case, usually, it is significantly less).Therefore, the resident set size, RSS, can increase temporarily during a garbage collection which can be an issue in any environment with memory constraints (such as a container).Performance TuningFor tuning the GC performance and the memory footprint, the following options can be used:  -XX:MaximumHeapSizePercent - the percentage of the physical memory size that is used as the maximum Java heap size if the maximum Java heap size is not specified otherwise.  -XX:MaximumYoungGenerationSizePercent - the maximum size of the young generation as a percentage of the maximum Java heap size.  -XX:±CollectYoungGenerationSeparately (since GraalVM 21.0) - determines if a full GC collects the young generation separately or together with the old generation.If enabled, this may reduce the memory footprint during full GCs.However, full GCs may take more time.  -XX:MaxHeapFree (since GraalVM 21.3) - maximum total size (in bytes) of free memory chunks that remain reserved for allocations after a collection and are therefore not returned to the operating system.  -H:AlignedHeapChunkSize (can only be specified at image build time) - the size of a heap chunk in bytes.  -H:MaxSurvivorSpaces (since GraalVM 21.1, can only be specified at image build time) - the number of survivor spaces that are used for the young generation, that is, the maximum age at which an object will be promoted to the old generation.With a value of 0, objects that survive a young collection are directly promoted to the old generation.  -H:LargeArrayThreshold (can only be specified at image build time) - the size at or above which an array will be allocated in its own heap chunk.Arrays that are considered as large are more expensive to allocate but they are never copied by the GC, which can reduce the GC overhead.# Build and execute a native image that uses a maximum heap size of 25% of the physical memorynative-image --gc=serial -R:MaximumHeapSizePercent=25 HelloWorld./helloworld# Execute the native image from above but increase the maximum heap size to 75% of the physical memory./helloworld -XX:MaximumHeapSizePercent=75The following options are available with -H:InitialCollectionPolicy=BySpaceAndTime only:  -XX:PercentTimeInIncrementalCollection - determines how much time the GC should spend doing young collections.With the default value of 50, the GC tries to balance the time spent on young and full collections.Increasing this value will reduce the number of full GCs, which can improve performance but may worsen the memory footprint.Decreasing this value will increase the number of full GCs, which can improve the memory footprint but may decrease performance.G1 Garbage CollectorOracle GraalVM also provides the Garbage-First (G1) garbage collector, which is based on the G1 GC from the Java HotSpot VM.Currently, G1 Garbage Collector can be used with Native Image on the Linux AMD64 and AArch64 architectures. (Not available in GraalVM Community Edition.)To enable it, pass the option --gc=G1 to the native-image builder.# Build a native image that uses the G1 GC with default settingsnative-image --gc=G1 HelloWorldNote: In GraalVM 20.0, 20.1, and 20.2, the G1 GC was called low-latency GC and could be enabled via the experimental option -H:+UseLowLatencyGC.OverviewG1 is a generational, incremental, parallel, mostly concurrent, stop-the-world, and evacuating GC.It aims to provide the best balance between latency and throughput.Some operations are always performed in stop-the-world pauses to improve throughput.Other operations that would take more time with the application stopped, such as whole-heap operations like global marking, are performed in parallel and concurrently with the application.The G1 GC tries to meet set pause-time targets with high probability over a longer time.However, there is no absolute certainty for a given pause.G1 partitions the heap into a set of equally sized heap regions, each a contiguous range of virtual memory.A region is the GC-internal unit for memory allocation and memory reclamation.At any given time, each of these regions can be empty, or assigned to a particular generation.If no maximum Java heap size is specified, a native image that uses the G1 GC will set its maximum Java heap size to 25% of the physical memory size.For example, on a machine with 4GB of RAM, the maximum Java heap size will be set to 1GB.If the same image is executed on a machine that has 32GB of RAM, the maximum Java heap size will be set to 8GB.To override this default behavior, either specify a value for -XX:MaxRAMPercentage or explicitly set the maximum Java heap size.Performance TuningThe G1 GC is an adaptive garbage collector with defaults that enable it to work efficiently without modification.However, it can be tuned to the performance needs of a particular application.Here is a small subset of the options that can be specified when doing performance tuning:  -H:G1HeapRegionSize (can only be specified at image build time) - the size of a G1 region.  -XX:MaxRAMPercentage - the percentage of the physical memory size that is used as the maximum heap size if the maximum heap size is not specified otherwise.  -XX:MaxGCPauseMillis - the goal for the maximum pause time.  -XX:ParallelGCThreads - the maximum number of threads used for parallel work during garbage collection pauses.  -XX:ConcGCThreads - the maximum number of threads used for concurrent work.  -XX:InitiatingHeapOccupancyPercent - the Java heap occupancy threshold that triggers a marking cycle.  -XX:G1HeapWastePercent - the allowed unreclaimed space in the collection set candidates. G1 stops the space-reclamation phase if the free space in the collection set candidates is lower than that.# Build and execute a native image that uses the G1 GC with a region size of 2MB and a maximum pause time goal of 100msnative-image --gc=G1 -H:G1HeapRegionSize=2m -R:MaxGCPauseMillis=100 HelloWorld./helloworld# Execute the native image from above and override the maximum pause time goal./helloworld -XX:MaxGCPauseMillis=50Memory Management OptionsThis section describes the most important memory management command-line options that are independent of the used GC.For all numeric values the suffix k, m, or g can be used for scaling.Further options to the native image builder can be listed using native-image --expert-options-all.Java Heap SizeWhen executing a native image, suitable Java heap settings will be determined automatically based on the system configuration and the used GC.To override this automatic mechanism and to explicitly set the heap size at run time, the following command-line options can be used:  -Xmx - maximum heap size in bytes  -Xms - minimum heap size in bytes  -Xmn - the size of the young generation in bytesIt is also possible to preconfigure default heap settings at image build time.The specified values will then be used as the default values at run time:  -R:MaxHeapSize (since GraalVM 20.0) - maximum heap size in bytes  -R:MinHeapSize (since GraalVM 20.0) - minimum heap size in bytes  -R:MaxNewSize (since GraalVM 20.0) - size of the young generation in bytes# Build a native image with the default heap settings and override the heap settings at run timenative-image HelloWorld./helloworld -Xms2m -Xmx10m -Xmn1m# Build a native image and &quot;bake&quot; heap settings into the image. The specified values will be used at run timenative-image -R:MinHeapSize=2m -R:MaxHeapSize=10m -R:MaxNewSize=1m HelloWorld./helloworldCompressed ReferencesOracle GraalVM supports compressed references to Java objects that use 32-bit instead of 64-bit.Compressed references are enabled by default and can have a large impact on the memory footprint.However, they limit the maximum Java heap size to 32 GB of memory.If more than 32 GB are needed, compressed references need to be disabled.  -H:±UseCompressedReferences (can only be specified at image build time) - determines if 32-bit instead of 64-bit references to Java objects are used.Native MemoryNative Image may also allocate memory that is separate from the Java heap.One common use-case is a java.nio.DirectByteBuffer that directly references native memory.  -XX:MaxDirectMemorySize - the maximum size of direct buffer allocations.Printing Garbage CollectionsWhen executing a native image, the following options can be used to print some information on garbage collection.Which data is printed in detail depends on the used GC.  -XX:+PrintGC - print basic information for every garbage collection  -XX:+VerboseGC - can be added to print further garbage collection details# Execute a native image and print basic garbage collection information./helloworld -XX:+PrintGC# Execute a native image and print detailed garbage collection information./helloworld -XX:+PrintGC -XX:+VerboseGCFurther Reading  Optimize Memory Footprint of a Native Executable  Memory Configuration for Native Image Build",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-migration-to-java-modules":  {
          "title": "Truffle Languages and Instruments Migration to Java Modules",
          "content": "Truffle Languages and Instruments Migration to Java ModulesSince version 23.1 Truffle uses languages and instruments primarily as Java modules loaded from the Java VM module path.Loading languages and tools from language or tool homes is still supported for compatibility reasons. However, it is deprecated and will be removed in future versions. The motivations for this change are:  Truffle should be used the same way on all JDKs.  Truffle is not a part of the Java VM jimage and is used as a regular JVM VM module path library.  Loading languages and tools from the module path is much easier for the embedder and works right out of the box withtools like Apache Maven.  The Java module system guarantees strong encapsulation and reliable configuration.Module MigrationFor general information on migrating to Java modules, please refer to development-with-jdk-9.The Truffle module is distributed in two versions: open Truffle and closed Truffle. The open Truffle exports all APIpackages in its module descriptor. On the other hand, the closed Truffle does not export API packages in the moduledescriptor. Instead, it dynamically exports API packages at runtime to modules that provide the language or instrument,as well as to modules that the language or instrument module reads. While the open Truffle is intended for testing andcompile-time purposes, the closed Truffle must be used in production. To correctly load a language or instrument as amodule, the following migration steps need to be applied:  Define a named Java module that requires the org.graalvm.truffle module.  For each Truffle language provided by this module, register a language provider using the  provides TruffleLanguageProvider with &amp;lt;LanguageClass&amp;gt;Provider directive.  For each Truffle instrument provided by this module, register an instrument provider using the  provides TruffleInstrumentProvider with &amp;lt;InstrumentClass&amp;gt;Provider directive.  If a library is exported with a default export lookup enabled using @GenerateLibrary(defaultExportLookupEnabled = true),the generated implementation of the DefaultExportProvider must be registered in the module descriptor using the providesdirective for the com.oracle.truffle.api.library.provider.DefaultExportProvider service. If you build your language or instrument using mxthe provides directive is generated automatically.  If an AOT library is exported using @ExportLibrary(useForAOT = true), the generated implementation of the EagerExportProvidermust be registered in the module descriptor using the provides directive for the com.oracle.truffle.api.library.provider.EagerExportProviderservice. If you build your language or instrument using mx the provides directive is generated automatically.  If your language or instrument already has a module descriptor, make sure that it does not provide any implementationof a deprecated com.oracle.truffle.api.library.EagerExportProvider or com.oracle.truffle.api.library.DefaultExportProviderinterface in the module descriptor. They must be replaced by the com.oracle.truffle.api.library.provider.EagerExportProvider andcom.oracle.truffle.api.library.provider.DefaultExportProvider. Providing these deprecated interfaces in the module descriptorwill cause an error during  creation of a module layer on the closed Truffle.  Languages or instruments must not provide JDK services or services from third party libraries in the module descriptor.This is needed to avoid languages getting loaded by the JDK or third parties without the necessary dynamic exports.  Language dependencies that might be commonly used by Java applications, like ICU4J, should be shadowed to avoidconflicts with modules used by the embedding.  If the language or instrument does not expose any API, it is recommended to keep the module as encapsulated as possibleand avoid exporting any packages. Otherwise, export the API packages. In the case of internal APIs that are exclusivelyutilized by known modules, it is advised to use qualified exports with the syntax export &amp;lt;package&amp;gt; to &amp;lt;module&amp;gt;.Here is a sample module descriptor for the simple language.module org.graalvm.sl {  requires java.base;  requires java.logging;  requires jdk.unsupported;  requires org.antlr.antlr4.runtime;  requires org.graalvm.truffle;  provides  com.oracle.truffle.api.provider.TruffleLanguageProvider with    com.oracle.truffle.sl.SLLanguageProvider;}",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/migration-to-java-modules/"
          },
          
          "latest-reference-manual-js-modules":  {
          "title": "Using JavaScript Modules and Packages in GraalJS",
          "content": "Using JavaScript Modules and Packages in GraalJSGraalJS is compatible with the latest ECMAScript standard, and can be run in a variety of Java-based embedding scenarios.Depending on the embedding, JavaScript packages and modules may be used in different ways.Java Embedding via Context APIWhen embedded in a Java application (using the Context API), GraalJS can execute JavaScript applications and modules that do not depend on Node.js’ built-in modules such as &#39;fs&#39;, &#39;events&#39;, or &#39;http&#39; or Node.js-specific functions such as setTimeout() or setInterval().On the other hand, modules that depend on such Node.js builtins cannot be loaded in a GraalVM polyglot Context.Supported NPM packages can be used in a JavaScript Context using one of the following approaches:  Using a package bundler.For example, to combine multiple NPM packages in a single JavaScript Source file.  Using ECMAScript (ES) modules on the local FileSystem.Optionally, a custom Truffle FileSystem can be used to configure how files are resolved.By default, a Java Context does not load modules using the CommonJS require() function.This is because require() is a Node.js built-in function, and is not part of the ECMAScript specification.Experimental support for CommonJS modules can be enabled through the js.commonjs-require option as described below.ECMAScript Modules (ESM)GraalJS supports the full ES modules specification, including import statements, dynamic modules import using import(), and advanced features such as top-level await.ECMAScript modules can be loaded in a Context simply by evaluating the module sources. GraalJS loads ECMAScript modules based on their file extension. Therefore, any ECMAScript module should have file name extension .mjs. Alternatively, the module Source should have MIME type &quot;application/javascript+module&quot;.As an example, let’s assume that you have a file named foo.mjs containing the following simple ES module:export class Foo {    square(x) {        return x * x;    }}This ES module can be loaded in a polyglot Context in the following way:public static void main(String[] args) throws IOException {    String src = &quot;import {Foo} from &#39;/path/to/foo.mjs&#39;;&quot; +                 &quot;const foo = new Foo();&quot; +                 &quot;console.log(foo.square(42));&quot;;    Context cx = Context.newBuilder(&quot;js&quot;)                .allowIO(true)                .build();cx.eval(Source.newBuilder(&quot;js&quot;, src, &quot;test.mjs&quot;).build());}Note that the ES module file has .mjs extension.Also note that the allowIO() option is provided to enable IO access.More examples of ES modules usage are available here.Module namespace exportsThe --js.esm-eval-returns-exports option (false by default) can be used to expose the ES module namespace exported object to a Polyglot Context.This can be handy when an ES module is used directly from Java:public static void main(String[] args) throws IOException {    String code = &quot;export const foo = 42;&quot;;    Context cx = Context.newBuilder(&quot;js&quot;)                .allowIO(true)                .option(&quot;js.esm-eval-returns-exports&quot;, &quot;true&quot;)                .build();    Source source = Source.newBuilder(&quot;js&quot;, code)                .mimeType(&quot;application/javascript+module&quot;)                .build();    Value exports = cx.eval(source);    // now the `exports` object contains the ES module exported symbols.    System.out.println(exports.getMember(&quot;foo&quot;).toString()); // prints `42`}Truffle FileSystemBy default, GraalJS uses the built-in FileSystem of the polyglot Context to load and resolve ES modules.A FileSystem can be used to customize the ES modules loading process.For example, a custom FileSystem can be used to resolve ES modules using URLs:Context cx = Context.newBuilder(&quot;js&quot;).fileSystem(new FileSystem() {private final Path TMP = Paths.get(&quot;/some/tmp/path&quot;);    @Override    public Path parsePath(URI uri) {    // If the URL matches, return a custom (internal) Path    if (&quot;http://localhost/foo&quot;.equals(uri.toString())) {        return TMP;} else {        return Paths.get(uri);        }    }@Override    public SeekableByteChannel newByteChannel(Path path, Set&amp;lt;? extends OpenOption&amp;gt; options, FileAttribute&amp;lt;?&amp;gt;... attrs) throws IOException {    if (TMP.equals(path)) {        String moduleBody = &quot;export class Foo {&quot; +                            &quot;        square(x) {&quot; +                            &quot;            return x * x;&quot; +                            &quot;        }&quot; +                            &quot;    }&quot;;            // Return a dynamically-generated file for the ES module.            return createByteChannelFrom(moduleBody);        }    }    /* Other FileSystem methods not shown */}).allowIO(true).build();String src = &quot;import {Foo} from &#39;http://localhost/foo&#39;;&quot; +             &quot;const foo = new Foo();&quot; +             &quot;console.log(foo.square(42));&quot;;cx.eval(Source.newBuilder(&quot;js&quot;, src, &quot;test.mjs&quot;).build());In this simple example, a custom FileSystem is used to load a dynamically-generated ES module when an application attempts to import the http://localhost/foo URL.A complete example of a custom Truffle FileSystem to load ES modules can be found here.CommonJS ModulesBy default, the Context API does not support CommonJS modules, and has no built-in require() function.In order to be loaded and used from a Context in Java, a CommonJS module needs to be bundled into a self-contained JavaScript source file.This can be achieved using one of the many popular open-source bundling tools such as Parcel, Browserify, and Webpack.Experimental support for CommonJS modules can be enabled through the js.commonjs-require option as described below.Experimental support for CommonJS NPM modules in the Context APIThe js.commonjs-require option provides a built-in require() function that can be used to load NPM-compatible CommonJS modules in a JavaScript Context.Currently, this is an experimental feature and not for production usage.To enable CommonJS support, a JavaScript context can be created in the following way:Map&amp;lt;String, String&amp;gt; options = new HashMap&amp;lt;&amp;gt;();// Enable CommonJS experimental support.options.put(&quot;js.commonjs-require&quot;, &quot;true&quot;);// (optional) directory where the NPM modules to be loaded are located.options.put(&quot;js.commonjs-require-cwd&quot;, &quot;/path/to/root/directory&quot;);// (optional) Node.js built-in replacements as a comma separated list.options.put(&quot;js.commonjs-core-modules-replacements&quot;,            &quot;buffer:buffer/,&quot; +            &quot;path:path-browserify&quot;);// Create context with IO support and experimental options.Context cx = Context.newBuilder(&quot;js&quot;)                            .allowExperimentalOptions(true)                            .allowIO(true)                            .options(options)                            .build();// Require a moduleValue module = cx.eval(&quot;js&quot;, &quot;require(&#39;some-module&#39;);&quot;);The &quot;js.commonjs-require-cwd&quot; option can be used to specify the main folder where NPM packages have been installed.As an example, this can be the directory where the npm install command was executed, or the directory containing your main node_modules/ directory.Any NPM module will be resolved relative to that directory, including any built-in replacement specified using &quot;js.commonjs-core-modules-replacements&quot;.Differences with Node.js built-in require() functionThe Context built-in require() function can load regular NPM modules implemented in JavaScript, but cannot load native NPM modules.The built-in require() relies on the FileSystem, therefore I/O access needs to be enabled at context creation time using the allowIO option.The built-in require() aims to be largely compatible with Node.js, and we expect it to work with any NPM module that would work in a browser (for example, created using a package bundler).Installing an NPM module to be used via the Context APITo be used from a JavaScript Context, an NPM module needs to be installed to a local directory, for example, by running the npm install command.At runtime, the option js.commonjs-require-cwd can be used to specify the main installation directory for NPM packages.The require() built-in function resolves packages according to the default Node.js’ package resolution protocol starting from the directory specified via js.commonjs-require-cwd.When no directory is provided with the option, the current working directory of the application will be used.Node.js core modules mockupsSome JavaScript applications or NPM modules might need functionalities that are available in Node.js’ built-in modules (for example, &#39;fs&#39; and &#39;buffer&#39;).Such modules are not available in the Context API.Thankfully, the Node.js community has developed high-quality JavaScript implementations for many Node.js core modules (for example, the ‘buffer’ module for the browser).Such alternative module implementations can be exposed to a JavaScript Context using the js.commonjs-core-modules-replacements option, in the following way:options.put(&quot;js.commonjs-core-modules-replacements&quot;, &quot;buffer:my-buffer-implementation&quot;);As the code suggests, the option instructs GraalJS to load a module called my-buffer-implementation when an application attempts to load the Node.js buffer built-in module using require(&#39;buffer&#39;).Global symbols pre-initializationAn NPM module or a JavaScript application might expect certain global properties to be defined in the global scope.For example, applications or modules might expect the Buffer global symbol to be defined in the JavaScript global object.To this end, the application user code can use globalThis to patch the application’s global scope:// define an empty object called &#39;process&#39;globalThis.process = {};// define the &#39;Buffer&#39; global symbolglobalThis.Buffer = require(&#39;some-buffer-implementation&#39;).Buffer;// import another module that might use &#39;Buffer&#39;require(&#39;another-module&#39;);Related Documentation  GraalJS Compatibility",
          "url": " /latest/reference-manual/js/Modules/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-splitting-monomorphization":  {
          "title": "Monomorphization",
          "content": "MonomorphizationTruffle has an automatic approach to monomorphization (also known as “splitting”). For more information about the benefits of monomorphization, continue reading to Monomorphization Use Cases.It is controlled by the Splitting engine option and is on by default.Adding --engine.Splitting=false to your command line will disable it.The heuristic relies on information from the language implementation to guide the decisions. To find out more about how to use the new approach in your language implementation, refer to the Reporting Polymorphism guide.For more details on how the new approach works, see the Splitting guide.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/splitting/Monomorphization/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-splitting-monomorphizationusecases":  {
          "title": "Monomorphization Use Cases",
          "content": "Monomorphization Use CasesThis guide demonstrates through examples how monomorphization can improve performance of dynamic languages without going into any detail on how monomorphization is implemented (described in the Splitting guide) or how to leverage monomorphization in your language implementation (described in the Reporting Polymorphism guide).MonomorphizationTo better illustrate the benefits of monomorphization, consider a small example written in JavaScript:function add(arg1, arg2) {    return arg1 + arg2;}function callsAdd() {    add(1, 2);    add(&quot;foo&quot;, &quot;bar&quot;);}var i = 0;while (i &amp;lt; 1000) {    callsAdd();    i++;}As you can see in this example, the add function is called from callsAdd once with integer arguments and once with string arguments.Once add is executed enough times to be compiled its execution profile will show that the + operator has been executed with both integers and strings and thus handlers (i.e., type checks and execution) for both types will be compiled which has aperformance impact.This can be avoided by rewriting the example as follows:function addInt(arg1, arg2) {    return arg1 + arg2;}function addString(arg1, arg2) {    return arg1 + arg2;}function callsAdd() {    addInt(1, 2);    addString(&quot;foo&quot;, &quot;bar&quot;);}i = 0;while (i &amp;lt; 1000) {    callsAdd();    i++;}In this example the add has been duplicated (split) in such a way that each type profile is contained in a separate copy of the function (addInt and addString).The result is that, come compilation time, only a single type profile is available for each function avoiding potentially costly type checks in the compiled code.Automating the detection suitable candidates, as well as their duplication, performed at run time is what we call monomorphization.It is, in other words, automated run-time monomorphization of polymorphic nodes through AST duplication.Example 1 - Monomorphization of ArgumentsThis example is an extended version of the illustration example from the previous section.The add function is still the target for monomorphization and is called from the action function 3 times with 3 sets of different arguments (numbers, strings and arrays).Execute the action function for 15 seconds in order to have enough time for warmup, and afterwards execute it for 60 seconds keeping track of how long each execution took, reporting finally the average.Execute this code twice: once with and once without monomorphization enabled and report the output of these two runs as well as the speedup.function add(arg1, arg2) {    return arg1 + arg2;}var global = 0;function action() {    for (var i = 0; i &amp;lt; 10000; i++) {        global = add(1, 2);        global = add(&quot;foo&quot;, &quot;bar&quot;);        global = add([1,2,3], [4,5,6]);    }}// Warm up.var start = Date.now();while ((Date.now() - start) &amp;lt; 15000 /* 15 seconds */) {    action();}// Benchmarkvar iterations = 0;var sum = 0;var start = Date.now();while ((Date.now() - start) &amp;lt; 60000 /* 60 seconds */) {    var thisIterationStart = Date.now();    action();    var thisIterationTime = Date.now() - thisIterationStart;    iterations++;    sum += thisIterationTime;}console.log(sum / iterations);The output without monomorphization is 4.494225288735564.The output with monomorphization is 4.2421633923.The speedup is ~5%.Example 2 - Monomorphization of Indirect CallsThis example is slightly more complicated and illustrates how monomorphization benefits higher order functions. In the example, the insertionSort function is defined, which - given an array of items and a function for comparing these items - sorts the array using insertion sort.Define an array of 1000 random double values between 0 and 1 and sort it four times using 4 different sorting methods (in the action function).Finally, as with the previous example, warm up the action function for 15 second, and report the average execution time ofthis function over the next 60 seconds with and without monomorphization.function insertionSort (items, comparator) {    for (var i = 0; i &amp;lt; items.length; i++) {        let value = items[i];        for (var j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; comparator(items[j], value); j--) {            items[j + 1] = items[j]        }        items[j + 1] = value    }}// Random values in an arrayvar array = new Array(1000);for (i = 0; i &amp;lt; array.length; i++) {    array[i] = Math.random();}function action() {    insertionSort(array, function (a, b) { return a &amp;lt; b                                      });    insertionSort(array, function (a, b) { return a &amp;gt; b                                      });    insertionSort(array, function (a, b) { return a.toString().length &amp;lt; b.toString().length; });    insertionSort(array, function (a, b) { return a.toString().length &amp;gt; b.toString().length; });}// Warm up.var start = Date.now();while ((Date.now() - start) &amp;lt; 15000 /* 15 seconds */) {    action();}// Benchmarkvar iterations = 0;var sum = 0;var start = Date.now();while ((Date.now() - start) &amp;lt; 60000 /* 60 seconds */) {    var thisIterationStart = Date.now();    action();    var thisIterationTime = Date.now() - thisIterationStart;    iterations++;    sum += thisIterationTime;}console.log(sum / iterations);The output without monomorphization is 194.05161290322582.The output with monomorphization is 175.41071428571428.The speedup is ~10%.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/splitting/MonomorphizationUseCases/"
          },
          
          "latest-reference-manual-js-multithreading":  {
          "title": "Multithreading",
          "content": "MultithreadingRunning JavaScript on GraalVM supports multithreading.Depending on the usage scenario, threads can be used to execute parallel JavaScript code using multiple Context objects, or multiple Worker threads.Multithreading with Java and JavaScriptMultithreading is supported when running JavaScript in the context of Java interoperability.The basic model of multithreaded execution supported by GraalVM is a “share-nothing” model that should be familiar to any JavaScript developer:  An arbitrary number of JavaScript Contexts can be created, but they should be used by one thread at a time.  Concurrent access to JavaScript objects is not allowed: any JavaScript object cannot be accessed by more than one thread at a time.  Concurrent access to Java objects is allowed: any Java object can be accessed by any Java or JavaScript thread, concurrently.A JavaScript Context cannot be accessed by two or more threads, concurrently, but it is possible to access the same Context from multiple threads using proper syncronization, to ensure that concurrent access never happens.ExamplesThe GraalJS unit tests contain several examples of multithreaded Java/JavaScript interactions.The most notable ones describe how:  Multiple Context objects can be executed in multiple threads.  JavaScript values created by one thread can be used from another thread when proper synchronization is used.  A Context can be accessed from multiple threads when proper synchronization is used.  Java concurrency can be used from JavaScript.  Java objects can be accessed by multiple JavaScript threads, concurrently.Related Documentation  Java Interoperability",
          "url": " /latest/reference-manual/js/Multithreading/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-nfi":  {
          "title": "Truffle Native Function Interface",
          "content": "Truffle Native Function InterfaceTruffle includes a way to call native functions, called the Native Function Interface (NFI).It is implemented as an internal language on top of Truffle that language implementors can access via the standard polyglot eval interface and Truffle interoperability.NFI is intended to be used, for example, to implement a language’s FFI, or to call native runtime routines that are not available in Java.NFI uses libffi.On a standard JVM it calls it using JNI, and on GraalVM Native Image it uses system Java.In the future it may be optimised by the Graal Compiler in native executables so that native calls are made directly from the compiled code.StabilityThe NFI is an internal language designed for language implementors.It is not considered stable and the interface and behavior may change without warning.It is not intended to be used directly by end-users.Basic ConceptsThe NFI is accessed via the polyglot interface of whatever language you are using.This could be Java, or it could be a Truffle language.This lets you use the NFI from both your Java language implementation code, or from your guest language to reduce the amount of Java that you need to write.The entry point is the polyglot eval interface.This runs a special DSL, and returns Truffle interoperability objects which can then expose more methods.Below are some examples using Ruby’s polyglot interface, but any other JVM or a language implementation could be used instead.Basic ExampleHere is a basic working example, before going into the details:library = Polyglot.eval(&#39;nfi&#39;, &#39;load &quot;libSDL2.dylib&quot;&#39;)  # load a librarysymbol = library[&#39;SDL_GetRevisionNumber&#39;]               # load a symbol from the librarysignature = Polyglot.eval(&#39;nfi&#39;, &#39;():UINT32&#39;)           # prepare a signaturefunction = signature.bind(symbol)                       # bind the symbol to the signature to create a functionputs function.call # =&amp;gt; 12373                           # call the functionLoading librariesTo load a library, a script written in the ‘nfi’ language DSL is evaluated.It returns an object that represents the loaded library.library = Polyglot.eval(&#39;nfi&#39;, &#39;...load command...&#39;)The load command can be any of these forms:  default  load &quot;filename&quot;  load (flag | flag | ...) &quot;filename&quot;The default command returns a pseudo-library that contains all symbols already loaded inthe process, equivalent to RTLD_DEFAULT in the Posix interface.The load &quot;filename&quot; command loads a library from a file.You are responsible for any cross-platform concerns about library naming conventions and load paths.The load (flag | flag | ...) &quot;filename&quot; command allows you to specify flags to load the library.For the default backend (backends will be described later), and when running on a Posix platform, the flags available are RTLD_GLOBAL, RTLD_LOCAL, RTLD_LAZY, and RTLD_NOW, which have the conventional Posix semantics.The default is RTLD_NOW if neither RTLD_LAZY nor RTLD_NOW were specified.Loading Symbols from LibrariesTo load a symbol from a library, read the symbol as a property from the library object that was previously loaded.symbol = library[&#39;symbol_name&#39;]Producing Native Function Objects from SymbolsTo get an executable object that you can call in order to invoke the native function, bind the symbol object that was previously loaded, by creating a signature object and calling the bind method on it.The signature object needs to match the native function’s actual type signature.signature = Polyglot.eval(&#39;nfi&#39;, &#39;...signature...&#39;)function = signature.bind(symbol)The format of the signature is (arg, arg, ...) : return, where arg and return are types.Types can be one of the simple types:  VOID  UINT8  SINT8  UINT16  SINT16  UINT32  SINT32  UINT64  SINT64  FLOAT  DOUBLE  POINTER  STRING  OBJECT  ENVArray types are formed by placing another type in square brackets.For example [UINT8]. These are C-style arrays.Function pointer types are formed by writing a nested signature.For example the signature of qsort would be (POINTER, UINT64, UINT64, (POINTER, POINTER) : SINT32) : VOID.For a function with a signature with variadic arguments, you specify ... where the variadic arguments start, but then you must specify the actual types that you will be calling the function with.You may therefore need to bind the same symbol multiple times in order to call it with different types or a different number of arguments.For example, to call printf with %d %f you would use the type signature (STRING, ...SINT32, DOUBLE) : SINT32.Type expressions can be nested arbitrarily deep.Two additional special types, ENV and OBJECT, are described in the section on the native API, later in this document.Types can be written in any case.You are responsible for any mapping of types from a foreign language such as C into NFI types.Calling Native Function ObjectsTo call a native function, execute it.return_value = function.call(...arguments...)Calling back from Native Code to Managed FunctionsUsing nested signatures, a function call can get function pointers as arguments.The managed caller needs to pass a Polyglot executable object, that will be converted to a native function pointer.When calling this function pointer from the native side, the execute message is sent to the Polyglot object.void native_function(int32_t (*fn)(int32_t)) {  printf(&quot;%dn&quot;, fn(15));}signature = Polyglot.eval(&#39;nfi&#39;, &#39;((SINT32):SINT32):VOID&#39;)native_function = signature.bind(library[&#39;native_function&#39;])native_function.call(-&amp;gt;(x) { x + 1 })The arguments and return values of callback functions are converted the same as for regular function calls, with the conversion in the other direction, i.e., arguments are converted from native to managed, and return values are converted from managed to native.Callback function pointers can themselves have function pointer arguments.That works as you would expect: the function accepts a native function pointer as argument, and it is converted to a Truffle executable object.Sending the execute message to that object calls the native function pointer, same as calling a regular NFI function.Function pointer types are also supported as return types.Combined Loading and BindingYou can optionally combine loading a library with loading symbols and binding them.This is achieved with an extended load command, which then returns an object with the already bound functions as methods.These two examples are equivalent:library = Polyglot.eval(&#39;nfi&#39;, &#39;load libSDL2.dylib&#39;)symbol = library[&#39;SDL_GetRevisionNumber&#39;]signature = Polyglot.eval(&#39;nfi&#39;, &#39;():UINT32&#39;)function = signature.bind(symbol)puts function.call # =&amp;gt; 12373library = Polyglot.eval(&#39;nfi&#39;, &#39;load libSDL2.dylib { SDL_GetRevisionNumber():UINT32; }&#39;)puts library.SDL_GetRevisionNumber # =&amp;gt; 12373The definitions in the curly braces {} can contain multiple function bindings, so that many functions can be loaded from a library at once.BackendsThe load command can be prefixed by with in order to select a specific NFI backend.Multiple NFI backends are available.The default is called native, and will be used if there is no with prefix, or the selected backend is not available.Depending on the configuration of components you are running, available backends may include:  native  llvm, which uses the GraalVM LLVM runtime to run the native code  panamaPanama backendThe Panama backend uses the Foreign Function and Memory APIs introduced by project Panama. This backend only supports a subset of all the types. Specifically, it does not support STRING, OBJECT, ENV, or FP80.Although less feature-complete, the backend is typically more performant.It is available starting from JDK 22.Truffle NFI on Native ImageTo build a native image that contains the Truffle NFI, it is sufficient to use the --language:nfi argument, or specify Requires = language:nfi in native-image.properties.It is possible to select what implementation to use for the native backend using --language:nfi=&amp;lt;backend&amp;gt;.Note that the --language:nfi=&amp;lt;backend&amp;gt; argument must come before any other arguments that might pull in the NFI as dependency via Requires = language:nfi.The first instance of language:nfi wins and determines what backend will be built into the native image.Available arguments for --language:nfi=&amp;lt;backend&amp;gt; are:  libffi (the default)  noneSelecting the none native backend will effectively disable access to native functions using the Truffle NFI.This will break users of the NFI that rely on native access (e.g. the GraalVM LLVM Runtime, unless used with --llvm.managed on EE).Native APIThe NFI can be used with unmodified, already compiled native code, but it can also be used with a Truffle-specific API being used by the native code.The special type ENV adds an additional parameter TruffleEnv *env to the signature.An additional simple type OBJECT translates to an opaque TruffleObject type.The trufflenfi.h header file provides declarations for working with these types, that can then be used by the native code called through the NFI.See trufflenfi.h for more documentation on this API.Type MarshallingThis section describes in detail how argument values and return values are converted for all types in the function signature.The following table shows the possible types in NFI signatures with their corresponding C language types on the native side, and what polyglot values these arguments map to on the managed side:            NFI type      C language type      Polyglot value                  VOID      void      Polyglot object with isNull == true (only valid as return type).              SINT8/16/32/64      int8/16/32/64_t      Polyglot isNumber that fitsIn... the corresponding integer type.              UINT8/16/32/64      uint8/16/32/64_t      Polyglot isNumber that fitsIn... the corresponding integer type.              FLOAT      float      Polyglot isNumber that fitsInFloat.              DOUBLE      double      Polyglot isNumber that fitsInDouble.              POINTER      void *      Polyglot object with isPointer == true or isNull == true.              STRING      char * (zero-terminated UTF-8 string)      Polyglot isString.              OBJECT      TruffleObject      Arbitrary object.              [type]      type * (array of primitive)      Java host primitive array.              (args):ret      ret (*)(args) (function pointer type)      Polyglot function with isExecutable == true.              ENV      TruffleEnv *      nothing (injected argument)      The following sections describe the type conversions in detail.The type conversion behavior with function pointers can be slightly confusing, because the direction of the arguments is reversed.When in doubt, always try to figure out in which direction arguments or return values flow, from managed to native or from native to managed.VOIDThis type is only allowed as return type, and is used to denote functions that do not return a value.Since in the Polyglot API, all executable objects have to return a value, a Polyglot object with isNull == true will be returned from native functions that have a VOID return type.The return value of managed callback functions with return type VOID will be ignored.Primitive NumbersThe primitive number types are converted as you might expect.The argument needs to be a Polyglot number, and its value needs to fit in the value range of the specified numeric type.One thing to note is the handling of the unsigned integer types.Even though the Polyglot API does not specify separate messages for values fitting in unsigned types, the conversion is still using the unsigned value ranges.For example, the value 0xFF passed from native to managed through a return value of type SINT8 will result in a Polyglot number -1, which fitsInByte.But the same value returned as UINT8 results in a Polyglot number 255, which does not fitsInByte.When passing numbers from managed code to native code, the signedness of the number is ignored, only the bits of the number are relevant.So for example, passing -1 to an argument of type UINT8 is allowed, and the result on the native side is 255, since it has the same bits as -1.The other way round, passing 255 to an argument of type SINT8 is also allowed, and the result on the native side is -1.Since in the current Polyglot API it is not possible to represent numbers outside of the signed 64-bit range, the UINT64 type is currently handled with signed semantics.This is a known bug in the API, and will change in a future release.POINTERThis type is a generic pointer argument.On the native side, it does not matter what exact pointer type the argument is.A polyglot object passed to POINTER arguments will be converted to a native pointer if possible (using the isPointer, asPointer and toNative messages as necessary).An object with isNull == true will be passed as a native NULL.POINTER return values will produce a polyglot object with isPointer == true.The native NULL pointer will additionally have isNull == true.STRINGThis is a pointer type with special conversion semantics for strings.Polyglot strings passed from managed to native using the STRING type will be converted to a zero-terminated UTF-8 encoded string.For STRING arguments, the pointer is owned by the caller, and is guaranteed to stay alive for the duration of the call only.The STRING values returned from managed function pointers to a native caller are also owned by the caller.They have to be freed with free after use.Polyglot pointer values or null values can also be passed to STRING arguments.The semantics is the same as for POINTER arguments.The user is responsible for ensuring that the pointer is a valid UTF-8 string.The STRING values passed from native functions to managed code behave like POINTER return values, but in addition they have isString == true.The user is responsible for the ownership of the pointer and it might be necessary to free the return value, depending on the semantics of the called native function.After freeing the returned pointer, the returned polyglot string is invalid and reading it results in undefined behavior.In that sense, the returned polyglot string is not a safe object, similar to a raw pointer.It is recommended that the user of the NFI copies the returned string before passing it along to untrusted managed code.OBJECTThis argument corresponds to the C type TruffleObject.This type is defined in trufflenfi.h, and is an opaque pointer type.A value of type TruffleObject represents a reference to an arbitrary managed object.Native code can do nothing with values of type TruffleObject except pass them back to managed code, either through return values or passing them to callback function pointers.The lifetime of TruffleObject references needs to be managed manually.See the documentation in trufflenfi.h for API functions to manage the lifetime of TruffleObject references.A TruffleObject passed as an argument is owned by the caller, and guaranteed to stay alive for the duration of the call.A TruffleObject reference returned from a callback function pointer is owned by the caller, and needs to be freed after use.Returning a TruffleObject from a native function does not transfer ownership (but there is an API function in trufflenfi.h to do that).[...] (Native Primitive Arrays)This type is only allowed as an argument from managed code to a native function, and only arrays of primitive numeric types are supported.On the managed side, only Java host objects containing a Java primitive array are supported.On the native side, the type is a pointer to the contents of the array.It is the user’s responsibility to pass along the array length as a separate argument.The pointer is valid for the duration of the native call only.Modifications to the contents are propagated back to the Java array after returning from the call.The effects of concurrent access to the Java array during the native call are unspecified.(...):... (Function Pointer)On the native side, a nested signature type corresponds to a function pointer with the given signature, calling back to managed code.Polyglot executable objects passed from managed to native using a function pointer type are converted to a function pointer that can be called by the native code.For function pointer arguments, the function pointer is owned by the caller, and is guaranteed to stay alive for the duration of the call only.Function pointer return values are owned by the caller, and have to be freed manually.See polyglot.h for API functions to manage the lifetime of function pointer values.Polyglot pointer values or null values can also be passed to function pointer arguments.The semantics is the same as for POINTER arguments.The user is responsible for ensuring that the pointer is a valid function pointer.Function pointer return types are the same as regular POINTER return types, but in addition they are already bound to the given signature type.They support the execute message, and behave the same as regular NFI functions.ENVThis type is a special argument of type TruffleEnv *.It is only valid as argument type, not as a return type.It is an injected argument on the native side, there is no corresponding argument on the managed side.When used as argument type of a native function, the native function will get an environment pointer on this position.That environment pointer can be used to call API functions (see trufflenfi.h).The argument is injected, for example, if the signature is (SINT32, ENV, SINT32):VOID.This function object is expected to be called with two integer arguments, and the corresponding native function will be called with three arguments: first the first real argument, then the injected ENV argument, and then the second real argument.When the ENV type is used as an argument type for a function pointer parameter, that function pointer must be called with a valid NFI environment as an argument.If the caller already has an environment, threading it through to callback function pointers is more efficient than calling them without an ENV argument.Calling ConventionNative functions must use the system’s standard ABI.There is currently no support for alternative ABIs.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/NFI/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-nmt":  {
          "title": "Native Memory Tracking (NMT) with Native Image",
          "content": "Native Memory Tracking (NMT) with Native ImageNative Memory Tracking (NMT) is a serviceability feature that records off-heap memory usage of your application.The terminology “off-heap memory” is sometimes used interchangeably with “native memory” or “unmanaged memory”. This essentially means any memory that is not managed by the garbage collector.Unlike the HotSpot JVM, Native Image mostly uses memory on the collected heap managed by its garbage collector.However, there are still many places where native memory is used by Native Image to avoid allocations on the managed heap.Some examples include JFR, the garbage collector, and heap dumping.Native memory can also be directly requested at the application level with Unsafe#allocateMemory(long).Enabling Native Memory TrackingNMT support is disabled by default and must be explicitly enabled at build time.To build a native executable with NMT, use the --enable-monitoring=nmt option.If NMT is included at build time, it will always be enabled at runtime.This is different than on HotSpot which allows for enabling/disabling NMT at runtime.native-image --enable-monitoring=nmt YourApplicationAdding -XX:+PrintNMTStatistics when starting your application from a native executable tells NMT to write a report to standard output when the application completes../yourapplication -XX:+PrintNMTStatisticsPerformanceOn Native Image, both the CPU and memory consumption of NMT are quite minimal. In comparison to other serviceability features such as JFR, NMT has relatively very little overhead.JFR Events for NMTThe OpenJDK JFR events jdk.NativeMemoryUsage and jdk.NativeMemoryUsageTotal are supported in Native Image.There are also two Native Image specific JFR events that you can access: jdk.NativeMemoryUsagePeak and jdk.NativeMemoryUsageTotalPeak.These Native Image specific events have been created to expose peak usage data otherwise not exposed through the JFR events ported over from the OpenJDK.These new events are marked as experimental.You may need to enable experimental events in software like JDK Mission Control to view them.To use these JFR events for NMT, enable the JFR monitoring by passing the --enable-monitoring=jfr,nmt option when invoking the native-image tool, and then start JFR recording at runtime. (Learn more in JDK Flight Recorder (JFR) with Native Image).See below the example of what the new events look like when viewed using the jfr command line tool:jfr print --events jdk.NativeMemoryUsagePeak recording.jfr jdk.NativeMemoryUsagePeak {  startTime = 13:18:50.605 (2024-04-30)  type = &quot;Threading&quot;  peakReserved = 424 bytes  peakCommitted = 424 bytes  countAtPeak = 4  eventThread = &quot;JFR Shutdown Hook&quot; (javaThreadId = 63)}jdk.NativeMemoryUsagePeak {  startTime = 13:18:50.605 (2024-04-30)  type = &quot;Unsafe&quot;  peakReserved = 14.0 kB  peakCommitted = 14.0 kB  countAtPeak = 2  eventThread = &quot;JFR Shutdown Hook&quot; (javaThreadId = 63)}LimitationsOn HotSpot, NMT has two modes: summary and detailed.In Native Image, only NMT summary mode is currently supported.The detailed mode, which enables callsite tracking, is not available.Capturing baselines is also not yet possible.If you are interested in support for these additional features, file a request to the GraalVM project on GitHub.Malloc tracking is the only feature currently available (as of GraalVM for JDK 23).Native Image, same as HotSpot, can only track allocations at the VM-level and those made with Unsafe#allocateMemory(long).For example, if a library code or application code calls malloc directly, that call will bypass the NMT accounting and be untracked.Further Reading  Build and Run Native Executables with JFR  Debugging and Diagnostics",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/NMT/"
          },
          
          "latest-reference-manual-js-nashornmigrationguide":  {
          "title": "Migration Guide from Nashorn to GraalJS",
          "content": "Migration Guide from Nashorn to GraalJSThis guide serves as a migration guide for code previously targeted to the Nashorn engine.See the Java Interoperability guide for an overview of supported Java interoperability features.The Nashorn engine has been deprecated in JDK 11 as part of JEP 335 and has been removed from JDK15 as part of JEP 372.GraalJS can step in as a replacement for JavaScript code previously executed on the Nashorn engine.GraalJS provides all the features for JavaScript previously provided by Nashorn.Many are available by default, some are behind options, and others require minor modifications to your source code.Both Nashorn and GraalJS support a similar set of syntax and semantics for Java interoperability.One notable difference is that GraalJS takes a secure by default approach, meaning some features need to be explicitly enabled that were available by default on Nashorn.The most important differences relevant for migration are listed here.Nashorn features available by default (dependent on security settings):  Java.type, Java.typeName  Java.from, Java.to  Java.extend, Java.super  Java package globals: Packages, java, javafx, javax, com, org, eduNashorn Compatibility ModeGraalJS provides a Nashorn compatibility mode.Some of the functionality necessary for Nashorn compatibility is only available when the js.nashorn-compat option is enabled.This is the case for Nashorn-specific extensions that GraalJS does not want to expose by default.Note that you have to unlock experimental features to use this option.Further note that setting this option defeats the secure by default approach of GraalJS in some cases, for example, when operating on a legacy ScriptEngine.When you use the Nashorn compatibility mode, by default, ECMAScript 5 is set as compatibility level.You can specify a different ECMAScript version using the js.ecmascript-version option. Note that this might conflict with full Nashorn compatibility.A code example how to set the option is given near the end of this section.The js.nashorn-compat option can be set:  By using a command line option:      js --experimental-options --js.nashorn-compat=true    By using the Polyglot API:      import org.graalvm.polyglot.Context;  try (Context context = Context.newBuilder().allowExperimentalOptions(true).option(&quot;js.nashorn-compat&quot;, &quot;true&quot;).build()) {      context.eval(&quot;js&quot;, &quot;print(__LINE__)&quot;);  }    By using a system property when starting a Java application (remember to enable allowExperimentalOptions on the Context.Builder in your application as well):      java -Dpolyglot.js.nashorn-compat=true MyApplication  Functionality only available under the nashorn-compat option includes:  Java.isJavaFunction, Java.isJavaMethod, Java.isScriptObject, Java.isScriptFunction  new Interface|AbstractClass(fn|obj)  JavaImporter  JSAdapter  java.lang.String methods on string values  load(&quot;nashorn:parser.js&quot;), load(&quot;nashorn:mozilla_compat.js&quot;)  exit, quitThe js.ecmascript-version option can be set in similar fashion.As this is a supported option, there is no need to provide the experimental-options option just for setting the ecmascript-version:js --js.ecmascript-version=2020Nashorn Syntax ExtensionsNashorn syntax extensions can be enabled using the js.syntax-extensions experimental option.They are also enabled by default in the Nashorn compatibility mode (js.nashorn-compat).GraalJS vs NashornGraalJS differs from Nashorn in some aspects that were intentional design decisions.Secure by DefaultGraalJS takes a secure by default approach.Unless explicitly permitted by the embedder, JavaScript code cannot access Java classes or access the file system, among other restrictions.Several features of GraalJS, including Nashorn compatibility features, are only available when the relevant security settings are permissive enough.Make sure you understand the security implications of any change that lifts the secure default limits to your application and the host system.For a full list of available settings, see Context.Builder.Those options can be defined when building the context with the Polyglot API.Options frequently required to enable features of GraalJS are:  allowHostAccess(): configure which public constructors, methods or fields of public classes are accessible by a guest application. Use HostAccess.EXPLICIT or a custom HostAccess policy to selectively enable access. Set to HostAccess.ALL to allow unrestricted access.  allowHostClassLookup(): set a filter that specifies the Java host classes that can be looked up by a guest application. Set to the Predicate className -&amp;gt; true to allow lookup of all classes.  allowIO(): allow a guest language to perform unrestricted IO operations on the host system, required, for example, to load() from the file system. Set to true to enable IO.If you run code on the legacy ScriptEngine, see Setting Options via Bindings regarding how to set them there.Finally, note that the nashorn-compat mode enables the relevant options when executing code on the ScriptEngine (but not on Context), to provide better compatibility with Nashorn in that setup.Launcher Name jsGraalJS comes with a binary launcher named js.Note that, depending on the build environment, GraalJS might still ship Nashorn and its jjs launcher.ScriptEngine Name graal.jsGraalJS is shipped with support for ScriptEngine.It registers under several names, including “graal.js”, “JavaScript”, and “js”.Be sure to activate the Nashorn compatibility mode as described above if you need full Nashorn compatibility.Depending on the build setup, GraalJS might still ship Nashorn and provide it via ScriptEngine.For more details, see ScriptEngine Implementation.ClassFilterGraalJS provides a class filter when starting with a polyglot Context.See Context.Builder.hostClassFilter.Fully Qualified NamesGraalJS requires the use of Java.type(typename).It does not support accessing classes just by their fully qualified class name by default. Java.type brings more clarity and avoids the accidental use of Java classes in JavaScript code.For example, look at this pattern:var bd = new java.math.BigDecimal(&#39;10&#39;);It should be expressed as:var BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;);var bd = new BigDecimal(&#39;10&#39;);Lossy ConversionGraalJS does not allow lossy conversions of arguments when calling Java methods.This could lead to bugs with numeric values that are hard to detect.GraalJS always selects the overloaded method with the narrowest possible argument types that can be converted to without loss.If no such overloaded method is available, GraalJS throws a TypeError instead of lossy conversion.In general, this affects which overloaded method is executed.Custom targetTypeMappings can be used to customize behavior. See HostAccess.Builder#targetTypeMapping.ScriptObjectMirror ObjectsGraalJS does not provide objects of the class ScriptObjectMirror.Instead, JavaScript objects are exposed to Java code as objects implementing Java’s Map interface.Code referencing ScriptObjectMirror instances can be rewritten by changing the type to either an interface (Map or List) or the polyglot Value class which provides similar capabilities.MultithreadingRunning JavaScript on GraalVM supports multithreading by creating several Context objects from Java code.Contexts can be shared between threads, but each context must be accessed by a single thread at a time.Multiple JavaScript engines can be created from a Java application, and can be safely executed in parallel on multiple threads:Context polyglot = Context.create();Value array = polyglot.eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);GraalJS does not allow the creation of threads from JavaScript with access to the current Context.Moreover, GraalJS does not allow concurrent threads to access the same Context at the same time.This could lead to unmanageable synchronization problems like data races in a language that is not prepared for multithreading. For example:new Thread(function() {    print(&#39;printed from another thread&#39;); // throws Exception due to potential synchronization problems}).start();JavaScript code can create and start threads with Runnables implemented in Java.The child thread may not access the Context of the parent thread or of any other polyglot thread.In case of violations, an IllegalStateException will be thrown.A child thread may create a new Context instance, though.new Thread(aJavaRunnable).start(); // allowed on GraalJSWith proper synchronization in place, multiple contexts can be shared between different threads. The example Java applications using JavaScript Contexts from multiple threads can be found here.Extensions Only Available in Nashorn Compatibility ModeThe following JavaScript extensions available in Nashorn are deactivated in GraalJS by default.They are provided in the Nashorn compatibility mode.It is highly recommended not to implement new applications based on those features, but only to use it as a means to migrate existing applications to GraalVM.String length PropertyGraalJS does not treat the length property of a String specially.The canonical way of accessing the String length is reading the length property:myJavaString.length;Nashorn enables users to access length as both a property and a function.Existing function calls length() should be expressed as property access.Nashorn behavior is mimicked in the Nashorn compatibility mode.Java Packages in the JavaScript Global ObjectGraalJS requires the use of Java.type instead of fully qualified names.In the Nashorn compatibility mode, the following Java packages are added to the JavaScript global object: java, javafx, javax, com, org, and edu.JavaImporterThe JavaImporter feature is available only in the Nashorn compatibility mode.JSAdapterThe use of the non-standard JSAdapter feature is discouraged and should be replaced with the equivalent standard Proxy feature.For compatibility, JSAdapter is still available in the Nashorn compatibility mode.Java.* MethodsSeveral methods provided by Nashorn on the Java global object are available only in the Nashorn compatibility mode, or currently not supported by GraalJS. Available in the Nashorn compatibility mode are: Java.isJavaFunction, Java.isJavaMethod, Java.isScriptObject, and Java.isScriptFunction. Java.asJSONCompatible is currently not supported.AccessorsIn the Nashorn compatibility mode, GraalJS allows users to access getters and setters just by using the names as properties, while omitting get, set, or is:var Date = Java.type(&#39;java.util.Date&#39;);var date = new Date();var myYear = date.year; // calls date.getYear()date.year = myYear + 1; // calls date.setYear(myYear + 1);GraalJS mimics the behavior of Nashorn regarding the ordering of the access:  In case of a read operation, GraalJS will first try to call a getter with the name get and the property name in camel case. If that is not available, a getter with the name is and the property name in camel case is called. In the second case, unlike Nashorn, the resulting value is returned even if it is not of type boolean. Only if both methods are not available, the property itself will be read.  In case of a write operation, GraalJS will try to call a setter with the name set and the property name in camel case, providing the value as argument to that function. If the setter is not available, the property itself will be written.Note that Nashorn (and thus, GraalJS) makes a clear distinction between property read/writes and function calls.When the Java class has both a field and a method of the same name publicly available, obj.property will always read the field (or the getter as discussed above), while obj.property() will always call the respective method.Additional Aspects to ConsiderFeatures of GraalJSGraalJS supports features of the newest ECMAScript specification and some extensions to it.See JavaScript Compatibility.Note that this example adds objects to the global scope that might interfere with existing source code unaware of those extensions.Console OutputGraalJS provides a print builtin function compatible with Nashorn.Note that GraalJS also provides a console.log function.This is an alias for print in pure JavaScript mode, but uses an implementation provided by Node.js when running in Node mode.The behavior around Java objects differs for console.log in Node mode as Node.js does not implement special treatment for such objects.Related Documentation  Migration Guide from Rhino to GraalJS  Java Interoperability",
          "url": " /latest/reference-manual/js/NashornMigrationGuide/"
          },
          
          "latest-reference-manual-llvm-nativeexecution":  {
          "title": "Interaction of GraalVM with Native Code",
          "content": "Interaction of GraalVM with Native CodeThe GraalVM LLVM runtime allows users to run code written in languages that traditionally compile directly to native code.These languages typically do not require any managed runtime or VM to run.Therefore, special care is needed to consider the interaction of this code with the managed runtime of GraalVM, in particular if the code is using certain low-level features.Limited Access to Low-level System Calls  Signal handling is performed based on the following assumptions:          The managed runtime assumes that it has full control of handling all signals.      Installed signal handlers might behave differently than on native execution.        Process control and threading is done based on the following aspects:          GraalVM assumes it has full control over threading.      Multithreading is supported via the pthreads library (for example, pthread_create).      Directly using process related syscalls such as clone, fork, vfork, etc. is not supported.      The exec function family is not supported.      Memory LayoutThe memory and stack layout of processes running on GraalVM is different than with direct native execution.In particular, no assumptions are possible about the relative positions of globals, stack variables and so on.Walking the stack is only possible using the GraalVM APIs.There is a strict separation between code and data.Self-modifying code will not work.Reads, writes and pointer arithmetic on pointers to code are not supported.Interaction with System Libraries in Native ModeIn the native execution mode (the default mode), code running on the GraalVM LLVM runtime can do calls to real native libraries (for example, system libraries).These calls behave similar to JNI calls in Java: they temporarily leave the managed execution environment.Since the code executed in these libraries is not under the control of GraalVM, that code can essentially do anything.In particular, no multicontext isolation applies, and GraalVM APIs like the virtual filesystem are bypassed.Note that this applies in particular to most of the standard C library.Managed Execution ModeThe managed mode (enabled with the --llvm.managed option) is a special execution mode where the LLVM runtime runs purely in managed mode, similar to all other GraalVM supported languages.  Note: The managed mode is only available in Oracle GraalVM.In this mode, by design, it is not allowed to call native code and access native memory.All memory is managed by the garbage collector, and all code that should be run needs to be compiled to bitcode.Pointer arithmetic is only possible to the extent allowed by the C standard.In particular, overflows are prevented, and it is not possible to access different allocations via out-of-bounds access.All such invalid accesses result in runtime exceptions rather than in undefined behavior.In managed mode, GraalVM simulates a virtual Linux/AMD64 operating system, with musl libc and libc++ as the C/C++ standard libraries.All code needs to be compiled for that system, and can then be used to run on any architecture or operating system supported by GraalVM.Syscalls are virtualized and routed through appropriate GraalVM APIs.Polyglot Interaction Between Native Code and Managed LanguagesWhen using polyglot interoperability between LLVM languages (for example, C/C++) and managed languages (such as JavaScript, Python, or Ruby), some care must be taken with the manual memory management.Note that this section only applies to the native mode of execution (the default).In managed mode (enabled with the --llvm.managed option and only available in Oracle GraalVM), the LLVM runtime itself behaves like a managed language, and the polyglot interaction is the same as between other managed languages.  Garbage collection policies to be considered:          Pointers to objects of managed languages are managed by a garbage collector, therefore they do not need to be freed manually.      On the other hand, pointers to allocations from the LLVM code (for example, malloc) are not under control of the garbage collector, so they need to be deallocated manually.        Unmanaged heap policies to be considered:          Native memory (for example, malloc, data sections, thread locals) is not under the control of a garbage collector.      Pointers to foreign objects controlled by the garbage collector can not be stored in native memory directly.      There are handle functions available to work around this limitation (see graalvm/llvm/handles.h).      ",
          "url": " /latest/reference-manual/llvm/NativeExecution/"
          },
          
          "latest-reference-manual-native-image-basics":  {
          "title": "Native Image Basics",
          "content": "Native Image BasicsNative Image is written in Java and takes Java bytecode as input to produce a standalone binary (an executable, or a shared library).During the process of producing a binary, Native Image can run user code.Finally, Native Image links compiled user code, parts of the Java runtime (for example, the garbage collector, threading support), and the results of code execution into the binary.We refer to this binary as a native executable, or a native image.We refer to the utility that produces the binary as the native-image builder, or the native-image generator.To clearly distinguish between code executed during the native image build, and code executed during the native image execution, we refer to the difference between the two as build time and run time.To produce a minimal image, Native Image employs a process called static analysis.Table of Contents  Build Time vs Run Time  Native Image Heap  Static AnalysisBuild Time vs Run TimeDuring the image build, Native Image may execute user code.This code can have side effects, such as writing a value to a static field of a class.We say that this code is executed at build time.Values written to static fields by this code are saved in the image heap.Run time refers to code and state in the binary when it is executed.The easiest way to see the difference between these two concepts is through configurable class initialization.In Java, a class is initialized when it is first used.Every Java class used at build time is said to be build-time initialized.Note that merely loading a class does not necessarily initialize it.The static class initializer of build-time initialized classes executes on the JVM running the image build.If a class is initialized at build time, its static fields are saved in the produced binary.At run time, using such a class for the first time does not trigger class initialization.Users can trigger class initialization at build time in different ways:  By passing --initialize-at-build-time=&amp;lt;class&amp;gt; to the native-image builder.  By using a class in the static initializer of a build-time initialized class.Native Image will initialize frequently used JDK classes at image build time, for example, java.lang.String, java.util.**, etc.Note that build-time class initialization is an expert feature.Not all classes are suitable for build-time initialization.The following example demonstrates the difference between build-time and run-time executed code:public class HelloWorld {    static class Greeter {        static {            System.out.println(&quot;Greeter is getting ready!&quot;);        }                public static void greet() {          System.out.println(&quot;Hello, World!&quot;);        }    }  public static void main(String[] args) {    Greeter.greet();  }}Having saved the code in a file named HelloWorld.java, we compile and run the application on the JVM:javac HelloWorld.javajava HelloWorld Greeter is getting ready!Hello, World!Now we build a native image of it, and then execute:native-image HelloWorld========================================================================================================================GraalVM Native Image: Generating &#39;helloworld&#39; (executable)...========================================================================================================================...Finished generating &#39;helloworld&#39; in 14.9s../helloworld Greeter is getting ready!Hello, World!HelloWorld started up and invoked Greeter.greet. This caused Greeter to initialize, printing the message Greeter is getting ready!.Here we say the class initializer of Greeter is executed at image run time.What would happen if we tell native-image to initialize Greeter at build time?native-image HelloWorld --initialize-at-build-time=HelloWorld$Greeter========================================================================================================================GraalVM Native Image: Generating &#39;helloworld&#39; (executable)...========================================================================================================================Greeter is getting ready![1/8] Initializing...                                                                                    (3.1s @ 0.15GB) Java version: 24+36, vendor version: Oracle GraalVM 24+36.1 Graal compiler: optimization level: 2, target machine: armv8.1-a, PGO: ML-inferred C compiler: cc (apple, arm64, 16.0.0) Garbage collector: Serial GC (max heap size: 80% of RAM)...Finished generating &#39;helloworld&#39; in 13.6s../helloworld Hello, World!We saw Greeter is getting ready! printed during the image build.We say the class initializer of Greeter executed at image build time.At run time, when HelloWorld invoked Greeter.greet, Greeter was already initialized.The static fields of classes initialized during the image build are stored in the image heap.Native Image HeapThe Native Image heap, also called the image heap, contains:  Objects created during the image build that are reachable from application code.  java.lang.Class objects of classes used in the native image.  Object constants embedded in method code.When native image starts up, it copies the initial image heap from the binary.One way to include objects in the image heap is to initialize classes at build time:class Example {    private static final String message;        static {        message = System.getProperty(&quot;message&quot;);    }    public static void main(String[] args) {        System.out.println(&quot;Hello, World! My message is: &quot; + message);    }}Now we compile and run the application on the JVM:javac Example.javajava -Dmessage=hi ExampleHello, World! My message is: hijava -Dmessage=hello Example Hello, World! My message is: hellojava ExampleHello, World! My message is: nullNow examine what happens when we build a native image in which the Example class is initialized at build time:native-image Example --initialize-at-build-time=Example -Dmessage=native================================================================================GraalVM Native Image: Generating &#39;example&#39; (executable)...================================================================================...Finished generating &#39;example&#39; in 19.0s../example Hello, World! My message is: native./example -Dmessage=aNewMessageHello, World! My message is: nativeThe class initializer of the Example class was executed at image build time.This created a String object for the message field and stored it inside the image heap.Static AnalysisStatic analysis is a process that determines which program elements (classes, methods and fields) are used by an application.These elements are also referred to as reachable code.The analysis itself has two parts:  Scanning the bytecode of a method to determine what other elements are reachable from it.  Scanning the root objects in the native image heap (such as static fields) to determine which classes are reachable from them.It starts from the entry points of the application (the main method).The newly discovered elements are iteratively scanned until further scanning yields no additional changes in element’s reachability.Only reachable elements are included in the final image.Once a native image is built, no new elements can be added at run time, for example, through class loading.We refer to this constraint as the closed-world assumption.Further Reading  Native Image Build Overview  Class Initialization in Native Image",
          "url": " /latest/reference-manual/native-image/basics/"
          },
          
          "latest-reference-manual-js-nodejs":  {
          "title": "Node.js Runtime",
          "content": "Node.js RuntimeGraalVM can run unmodified Node.js applications. GraalVM’s Node.js runtime is based on a recent version of Node.js, and runs the GraalVM JavaScript engine (GraalJS) instead of Google V8. Some internal features (for example, VM-internal statistics, configuration, profiling, debugging, and so on) are unsupported, or supported with potentially different behavior.Applications can freely import and use NPM packages, including native ones.Getting Started with Node.jsAs of GraalVM for JDK 21, the GraalVM Node.js runtime is available as a separate distribution.Two standalone runtime options are available for both Oracle GraalVM and GraalVM Community Edition: a Native Image compiled launcher or a JVM-based runtime.To distinguish between them, the GraalVM Community Edition version has the suffix -community in the name: graaljs-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz, graalnodejs-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz.A standalone that comes with a JVM has a -jvm suffix in a name.To enable the GraalVM Node.js runtime, install the Node.js distribution based on Oracle GraalVM or GraalVM Community Edition for your operating system.      Navigate to GitHub releases and select a desired standalone for your operating system.    Unzip the archive:     tar -xzf &amp;lt;archive&amp;gt;.tar.gz    Alternatively, open the file in the Finder.    Check the version to see if the runtime is active:     ./path/to/bin/node --version  Running Node.js ApplicationsThe Node.js installation provides node and npm launchers:node [options] [filename] [args]The npm command is equivalent to the default Node.js command, and features additional GraalVM-specific functionalities (for example, interoperability with Java). A list of available options can be obtained with node --help.Use the node launcher to execute a Node.js application. For example:  Install the colors and ansispan packages using npm install as follows:     npm install colors ansispan    After the packages are installed, you can use them from your application.    Add the following code snippet to a file named app.js and save it in the same directory where you installed the Node.js packages:     const http = require(&quot;http&quot;); const span = require(&quot;ansispan&quot;); require(&quot;colors&quot;); http.createServer(function (request, response) {     response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});     response.end(span(&quot;Hello Node.js!&quot;.green)); }).listen(8000, function() { console.log(&quot;Node.js server running at http://127.0.0.1:8000/&quot;.red); }); setTimeout(function() { console.log(&quot;DONE!&quot;); process.exit(); }, 2000);    Execute it on the GraalVM Node.js runtime using the node command as follows:     node app.js  The Node.js functionality is available when an application is started from the node binary launcher.Certain limits apply when launching a Node.js application or accessing NPM packages from a Java context, see Node.js vs. Java Script Context.Installing Packages Using npmTo install a Node.js package, use the npm launcher.The npm command is equivalent to the default NPM command, and supports most of its options.An NPM package can be installed with:npm install [package]As the npm command of GraalVM Node.js is largely compatible with NPM, packages are installed in the node_modules/ directory, as expected.Installing npm Packages GloballyNode packages can be installed globally using npm and the -g option.By default, npm installs global packages (links to their executables) in the path where the node executable is installed, typically node/bin/.That directory is where global packages are installed.You might want to add that directory to your $PATH if you regularly use globally installed packages, especially their command line interfaces.Another option is to specify the global installation directory of npm by setting the $PREFIX environment variable, or by specifying the --prefix option when running npm install.For example, the following command will install global packages in the /foo/bar/ directory:npm install --prefix /foo/bar -g &amp;lt;package&amp;gt;More details about prefix can be found in the official NPM documentation.Interoperability with JavaThe Node.js runtime cannot be embedded into a JVM but has to be started as a separate process.  Save the following code in a file named HelloPolyglot.java and compile:     import org.graalvm.polyglot.*; import org.graalvm.polyglot.proxy.*; public class HelloPolyglot {     static String JS_CODE = &quot;(function myFun(param){console.log(&#39;hello &#39;+param);})&quot;;     public static void main(String[] args) {         System.out.println(&quot;Hello Java!&quot;);         try (Context context = Context.create()) {             Value value = context.eval(&quot;js&quot;, JS_CODE);             value.execute(args[0]);         }     } }    Then save this code a file named app.js:     var HelloPolyglot = Java.type(&quot;HelloPolyglot&quot;); HelloPolyglot.main([&quot;from node.js&quot;]); console.log(&quot;done&quot;);    Run it with node:     node --vm.cp=. app.js    You should see the following output:     Hello Java! hello from node.js done  Both Node.js and JVM then run in the same process and the interoperability works using the same Value classes as above.For the differences between running the node launcher and accessing Node.js NPM modules or ECMAScript modules from a Java Context, see NodeJSVSJavaScriptContext.Multithreading with Node.jsThe basic multithreading model of GraalJS applies to Node.js applications as well.In Node.js, a Worker thread can be created to execute JavaScript code in parallel, but JavaScript objects cannot be shared between Workers.On the contrary, a Java object created with GraalVM Java interoperability (for example, using Java.type()) can be shared between Node.js Workers.This allows multithreaded Node.js applications to share Java objects.The GraalVM Node.js unit tests contain several examples of multithreaded Node.js applications.The most notable examples show how:  Node.js worker threads can execute Java code.  Java objects can be shared between Node.js worker threads.  JavaScript Promise objects can be used to await on messages from workers, using Java objects to bind promises to worker messages.Frequently Asked QuestionsIs GraalVM’s Node.js runtime compatible with the original Node implementation?GraalVM’s Node.js runtime is largely compatible with the original Node.js (based on the V8 engine).This leads to a high number of npm-based modules being compatible.In fact, out of the 100k npm modules we test, more than 94% of them pass all tests.Still, several sources of differences have to be considered:      Setup:GraalVM’s Node.js mostly mimicks the original setup of Node, including the node executable, npm, and similar.However, not all command-line options are supported (or behave exactly identically).Modules might require that native modules are (re)compiled against the v8.h file.    As of GraalVM for JDK 21, the GraalVM Node.js runtime is available as a separate distribution.   See Getting Started with Node.js.        Internals:GraalVM’s Node.js is implemented on top of a JVM, and thus has a different internal architecture than Node.js based on V8.This implies that some internal mechanisms behave differently and cannot exactly replicate V8 behavior.This will hardly ever affect user code, but might affect modules implemented natively, depending on V8 internals.        Performance:Due to GraalVM’s Node.js being implemented on top of a JVM, performance characteristics vary from the original native implementation.While GraalVM’s peak performance can match V8 on many benchmarks, it will typically take longer to reach the peak (known as warmup).Be sure to give the Graal compiler some extra time when measuring (peak) performance.        Compatibility:GraalVM’s Node.js runtime uses the following approaches to check and retain compatibility with Node.js code:          node-compat-table: GraalVM’s Node.js is compared against other engines using the node-compat-table module, highlighting incompatibilities that might break Node.js code.      automated mass-testing of modules using mocha: in order to test a large set of modules, GraalVM’s Node.js runtime is tested against 95k modules that use the mocha test framework. Using mocha allows automating the process of executing the test and comprehending the test result.      manual testing of popular modules: a select list of npm modules is tested in a manual test setup. These highly-relevant modules are tested in a more sophisticated manner.      Can NPM packages be installed globally?Node packages can be installed globally using npm and the -g option, both with the GraalVM’s Node.js implementation.While the original Node.js implementation has one main directory (node/bin/) to put binaries and globally installed packages and their command-line tools, GraalVM’s Node.js puts binaries in the /path/to/graaljs/bin/ directory.When installing NPM packages globally on the GraalVM Node.js runtime, links to the executables, for example, for command line interface tools are put to the JavaScript-specific directory.In order for globally installed packages to function properly, you might need to add /path/to/graaljs/bin to your $PATH.Another option is to specify the global installation directory of npm by setting the $PREFIX environment variable, or by specifying the --prefix option when running npm install.For more details, see Installing npm Packages Globally.Related Documentation  Differences Between node Native Launcher and a Java Context",
          "url": " /latest/reference-manual/js/NodeJS/"
          },
          
          "latest-reference-manual-js-nodejsvsjavascriptcontext":  {
          "title": "Differences Between Node.js and Java Embeddings",
          "content": "Differences Between Node.js and Java EmbeddingsGraalVM provides a fully-compliant ECMAScript 2024 JavaScript runtime.As such, it can run JavaScript code in a variety of embedding scenarios, including Oracle Database, any Java-based application, and Node.js.Depending on the embedding scenario, applications have access to different built-in capabilities.For example, Node.js applications executed using GraalVM’s bin/node executable have access to all of Node.js’ APIs, including built-in Node.js modules such as fs, http, and so on.Conversely, JavaScript code embedded in a Java application has access to limited capabilities, as specified through the Context API, and do not have access to Node.js built-in modules.This guide describes the main differences between a Node.js application and JavaScript embedded in a Java application.Context CreationJavaScript code in GraalVM can be executed using an execution context.In a Java application, a new context can be created using the Context API.New contexts can be configured in multiple ways, and configuration options include exposing access to Java classes, allowing access to IO, and so on.A list of context creation options can be found in the API documentation.In this scenario, Java classes can be exposed to JavaScript by using GraalVM’s Polyglot Bindings.In a Node.js application, the GraalVM Context executing the application is pre-initialized by the Node.js runtime, and cannot be configured by the user application.In this scenario, Java classes can be exposed to the Node.js application by using the --vm.cp= command line option of the bin/node command, as described below.Java InteroperabilityJavaScript applications can interact with Java classes using the Java built-in object.This object is available by default in the js and node launchers, but accessing Java classes is only possible in the JVM standalone (that have -jvm in the name).When embedding JavaScript using the Polyglot API, you have to explicitly enable host access in the Context.Builder (allowHostAccess, allowHostClassLookup).More details on the JavaScript-Java interoperability are available in the Java Interoperability guide.MultithreadingA polyglot Context running JavaScript enforces a “share-nothing” model of parallelism: no JavaScript values can be accessed by two concurrent Java threads at the same time.In order to leverage parallel execution, multiple contexts have to be created and executed from multiple threads:  In Node.js mode, multiple contexts can be created using Node.js’ Worker threads API.The Worker threads API ensures that no sharing can happen between two parallel contexts.  In Java, multiple contexts can be executed from multiple threads.As long as a context is not accessed by two threads at the same time, parallel execution happens safely.More details on parallel execution in GraalJS are available in this blog post.Java LibrariesJava libraries can be accessed from GraalJS through the Java built-in object.In order for a Java library to be accessible from a Context, its JAR files need to be added to the class path. This can be done in the following way:  In Node.js mode, the class path can be modified using the --vm.cp option.  In Java, the default Java’s -cp option can be used.Read more in Command-line Options.JavaScript Packages and ModulesMany popular JavaScript modules such as those available on the npm package registry can be used from Node.js as well as from Java:  In Node.js mode, JavaScript modules are handled by the Node.js runtime.Therefore, GraalJS supports all modules supported by Node.js (including ES modules, CommonJS modules, and native modules).  In Java mode, GraalJS can execute any JavaScript module or package that does not depend on native Node.js built-in modules (such as fs, http, and so on).Modules can be loaded using a package bundler, or using the available built-in mechanisms for ES modules.CommonJS modules are supported in Java mode under an experimental option.More details on JavaScript modules are available in Modules.Related Documentation  Getting Started with Node.js  Using JavaScript Modules and Packages in GraalJS",
          "url": " /latest/reference-manual/js/NodeJSvsJavaScriptContext/"
          },
          
          "latest-security-guide-native-image-obfuscation":  {
          "title": "Advanced Obfuscation in Native Image",
          "content": "Advanced Obfuscation in Native ImageNative Image provides strong baseline obfuscation through native compilation by eliminating class files, applying aggressive optimizations, and removing unreachable code.Advanced obfuscation adds an extra layer of protection by applying symbol obfuscation to make reverse engineering of native images more difficult.The feature replaces symbol names (module, package, class, method, field, and source file names) with short, opaque identifiers—for example, a class named MySecretClass might become a.These opaque identifiers replace original names in stack traces, heap dumps, and in code that reads metadata (like Class#getName() and Method#getName()).This helps protect intellectual property by hiding meaningful names from reverse engineering tools like disassemblers, debuggers, and binary string extractors.Symbols in your application code and third-party dependencies are obfuscated, but not the JDK and Substrate VM code.Names registered under &quot;reflection&quot; in reachability metadata JSON are not obfuscated.  Caveat: While obfuscation makes reverse engineering more difficult, it does not provide guaranteed protection and can be bypassed by determined attackers.To enable advanced obfuscation, pass -H:AdvancedObfuscation= to the native-image command.To generate a JSON mapping file from original to obfuscated names, use -H:AdvancedObfuscation=export-mapping.The mapping file is produced as &amp;lt;image-name&amp;gt;.obfuscation-mapping.json in your build artifacts.You can use the mapping file to verify what was obfuscated and to deobfuscate stack traces for debugging.The obfuscation build process involves two phases for accurate obfuscation with minimal manual configuration: an initial phase to identify what can safely be obfuscated, followed by a second phase that applies the symbol obfuscation.This results in more verbose output and longer build times (typically 20–50% longer), but does not affect runtime performance or memory usage.  Advanced obfuscation is an experimental feature and is not available in GraalVM Community Edition.Contents  Building an Obfuscated Image  Deobfuscating Stack Traces  What Gets Obfuscated  Understanding the Mapping File  Obfuscation Statistics in Build Reports  Common Issues and Antipatterns  RecommendationsBuilding an Obfuscated ImageThis section demonstrates symbol obfuscation with a Java application, and includes building, running, viewing obfuscated outputs, and deobfuscating a stack trace for debugging.Building and Running a Non-Obfuscated Application on the JVMConsider the following SecretClass.java which includes a secretAlgorithm that throws a RuntimeException:package com.obfuscation;public class SecretClass {    public static void main(String[] args) {        System.out.println(&quot;Class name: &quot; + SecretClass.class.getName());        String sourceFileName = new Exception().getStackTrace()[0].getFileName();        System.out.println(&quot;File name: &quot; + sourceFileName);        secretAlgorithm();    }    private static void secretAlgorithm() {        // ...        throw new RuntimeException(&quot;Something bad happened!&quot;);        // ...    }}Compile and run it on a JVM to see the original, non-obfuscated symbols:javac -d build src/main/java/com/obfuscation/SecretClass.javajava -cp ./build com.obfuscation.SecretClassClass name: com.obfuscation.SecretClassFile name: SecretClass.javaException in thread &quot;main&quot; java.lang.RuntimeException: Something bad happened!        at com.obfuscation.SecretClass.secretAlgorithm(SecretClass.java:14)        at com.obfuscation.SecretClass.main(SecretClass.java:9)All symbols are visible, exposing sensitive information such as the name of SecretClass and secretAlgorithm.Building and Running an Obfuscated Native ImageBuild the obfuscated native executable and export the mapping file from original to obfuscated names:native-image -cp ./build com.obfuscation.SecretClass -o app -H:+UnlockExperimentalVMOptions -H:AdvancedObfuscation=export-mappingExecute the native image:./appClass name: b.aFile name: cException in thread &quot;main&quot; java.lang.RuntimeException: Something bad happened!        at b.a.g(c:14)        at b.a.f(c:9)The symbols are now obfuscated, making it difficult for a malicious actor to infer meaningful information from stack traces or output.Symbol obfuscation can change the behavior of code that relies on symbol names. For example, SecretClass.class.getName() now returns b.a.Obfuscated names are non-deterministic and may vary between builds.Deobfuscating Stack TracesTo debug an obfuscated stack trace, save the stack trace to a file (for example, obfuscated-stacktrace.log) and use native-image-utils with the mapping file:native-image-utils deobfuscate --map-file=app.obfuscation-mapping.json --input-file=obfuscated-stacktrace.logException in thread &quot;main&quot; java.lang.RuntimeException: Something bad happened!        at com.obfuscation.SecretClass.secretAlgorithm(SecretClass.java:14)        at com.obfuscation.SecretClass.main(SecretClass.java:9)This restores the original names for debugging the issue, while keeping your distributed binary obfuscated.Log file lines not part of the stack trace remain unchanged.You can locate the native-image-utils tool in the same bin directory as native-image.What Gets ObfuscatedSymbols in your application code and third-party dependencies are obfuscated by default. However, certain elements are excluded from obfuscation:  JDK and Substrate VM code is not obfuscated.  Classes are not obfuscated if they are annotations, lambdas, proxies, registered for reflection in JSON, or preserved using -H:Preserve.  If a class loads a resource, its package and module names are retained.The table below summarizes the obfuscation rules. Elements are obfuscated by default unless the conditions in Obfuscated Unless apply. To explicitly prevent symbol obfuscation of an element, use the method in Obfuscation Prevented By.            Element      Obfuscated Unless      Obfuscation Prevented By      Notes                  Class-Level Elements (method, field, source file names)      The class is skipped (annotation, lambda, proxy, registered for reflection in JSON, or preserved)      Register the class for reflection      Applies per class; for example, a method is not obfuscated if its containing class is skipped              Simple Class Name (for example, SecretClass in com.obfuscation.SecretClass)      The class is skipped (annotation, lambda, proxy, registered for reflection in JSON, or preserved)      Register the class for reflection      The simple name can be obfuscated even if its package name is not obfuscated              Fully Qualified Class Name (for example, com.obfuscation.SecretClass)      The simple class name is not obfuscated or the package name is not obfuscated      Register the class for reflection      Partial if only the simple name is obfuscated (for example, com.obfuscation.SecretClass → com.obfuscation.a)              Package Name      Any class in the package is registered for reflection or accesses a resource (for example, getResource(&quot;file.txt&quot;)).      Register a class in the package for reflection      Affects all classes in the package              Module Name      Any class in the module accesses a resource      There is no explicit way (it is tied to resource access)      Unnamed modules are not obfuscated since they lack a defined name to replace      If a class is skipped, all its class-level elements (fields, methods, source file names) remain unobfuscated.JUnit-related code is automatically preserved for testing compatibility.Understanding the Mapping FileWhen you use export-mapping, Native Image generates a JSON file named &amp;lt;image-name&amp;gt;.obfuscation-mapping.json in your build artifacts.This file maps original symbol names to their obfuscated versions, allowing native-image-utils deobfuscate to reverse the process.Mappings can change per build, so associate mapping files with specific build versions or IDs for reliable deobfuscation.The mapping file lists the [original, obfuscated] name pairs of modules, packages, source files, types (classes, records, interfaces, enums), and methods.For example:{  &quot;modules&quot;: [    [       &quot;myModule&quot;, &quot;m&quot;    ]  ],  &quot;packages&quot;: [    [      &quot;com.obfuscation&quot;, &quot;b&quot;    ]  ],  &quot;files&quot;: [    [      &quot;com/obfuscation/SecretClass.java&quot;, &quot;c&quot;    ]  ],  &quot;types&quot;: [    [      &quot;com.obfuscation.SecretClass&quot;, &quot;a&quot;    ],    [      &quot;com.library.LibraryClass&quot;, &quot;h&quot;    ]  ],  &quot;methods&quot;: [    [      &quot;com.obfuscation.SecretClass.main&quot;, &quot;f&quot;    ],    [      &quot;com.obfuscation.SecretClass.secretAlgorithm&quot;, &quot;g&quot;    ]  ]}Full qualifiers may mix original and obfuscated parts in cases of partial symbol obfuscation.For example, com.library.LibraryClass → com.library.h because the simple name LibraryClass was obfuscated (as it is listed under types), but the package name was not (as it is not listed under packages).Mapping file sizes typically range between 1–5MB for medium-to-large projects.For example, the Spring Boot application spring-boot-microservice-jibber produces a 1.7MB mapping file.You can check if a symbol was obfuscated by searching the mapping file.Fields are not included in the mapping file because field names are not part of stack traces.Obfuscation Statistics in Build ReportsTo assess the symbol obfuscation effectiveness, enable build reports with --emit=build-report during your build.This generates an HTML report (in the build output directory) with a dedicated “Obfuscation Summary” section in the Security Report.This is an example report:Common Issues and AntipatternsSymbol obfuscation can break previously functioning native image applications by changing the semantics of code using reflection or name-based logic.Methods such as Class#getName(), Method#getName(), and Field#getName() return obfuscated values for obfuscated elements, which may break existing code.Review and test such code patterns after enabling advanced obfuscation.For example, the following application works without obfuscation but throws a ClassNotFoundException when obfuscation is enabled:package com.obfuscation;public class Pitfalls {    static final String ORIGINAL_NAME = &quot;com.obfuscation.Pitfalls&quot;;    // Pitfalls gets obfuscated so &#39;getName&#39; returns the obfuscated name    static final String OBFUSCATED_NAME = Pitfalls.class.getName();    public static void main(String[] args) throws ClassNotFoundException {        // 1) Lookup with original name works.        System.out.printf(&quot;Class.forName(&quot;%s&quot;) worksn&quot;, ORIGINAL_NAME);        Class.forName(ORIGINAL_NAME);        // 2) Lookup with obfuscated name throws ClassNotFoundException.        System.out.printf(&quot;Class.forName(&quot;%s&quot;) failsn&quot;, OBFUSCATED_NAME);        Class.forName(OBFUSCATED_NAME);    }}When executed, the output is:Class.forName(&quot;com.obfuscation.Pitfalls&quot;) worksClass.forName(&quot;b.a&quot;) failsException in thread &quot;main&quot; java.lang.ClassNotFoundException: b.a. This exception was synthesized during native image building from a call to java.lang.Class.forName(String) with constant arguments.        at b.a.f(c:15)The native image builder sees the original names.Class#forName(String) with constant arguments is folded during the build, so the native image builder resolves com.obfuscation.Pitfalls (1) but not the obfuscated name (2).Resolutions  Do not perform reflective operations with obfuscated names; instead, use original names with constant arguments (like ORIGINAL_NAME). This ensures the Class.forName lookup works while still obfuscating Pitfalls.  If you cannot use constant string literals, explicitly register classes for reflection to avoid obfuscating affected classes. Reflection metadata can be collected automatically with the tracing agent. Registering com.obfuscation.Pitfalls would skip obfuscation for the class and the ClassNotFoundException is not thrown anymore. Note: Registration skips obfuscation for the class, reducing the scope of obfuscation.RecommendationsUse the following best practices to ensure effective and secure use of advanced obfuscation in your native image builds:  Export your SBOM instead of embedding it if confidentiality is required. If you currently embed an SBOM and use it for vulnerability scanning, use --enable-sbom=export to export as JSON. Class-level SBOMs must be exported when advanced obfuscation is enabled to prevent embedding original symbol names in the image. If the SBOM is not needed, disable with --enable-sbom=false.  Archive mapping files with build versions to ensure you can deobfuscate stack traces for specific builds.  Use build reports to monitor symbol obfuscation rates.  Collect reachability metadata automatically to reduce risk of semantic issues from name changes.  Test obfuscated builds to ensure there are no semantic issues from name changes, especially in reflection-heavy code. See Common Issues and Antipatterns for more information.  Avoid enabling advanced obfuscation during local development (due to longer build times). Instead, apply it before deployment in automated workflows.  Advanced obfuscation works with PGO so you can enable it on your optimized builds.  Use specific preserve selectors rather than broad ones to maximize obfuscation scope. For example, use -H:Preserve=package=my.package instead of -H:Preserve=all.Feedback is welcome via GraalVM GitHub issues.Related Documentation  Security Considerations in Native Image  Build Output",
          "url": " /latest/security-guide/native-image/obfuscation/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-objectheadersize":  {
          "title": "Object Header Size in Native Image",
          "content": "Object Header Size in Native ImageThe object header is part of every object in memory, storing metadata about the object, and its size varies depending on the JVM implementation, and specific JVM options such as compressed references.The size of the object header directly affects the memory footprint of a Java application, particularly if a lot of small objects are allocated.In Oracle GraalVM Native Image, the object header is 4 bytes by default, which is smaller than when running on HotSpot.For example, in a 64-bit HotSpot VM with compressed references, an instance of java.lang.Object consumes 16 bytes (12-byte header plus 4-byte padding).Using Oracle GraalVM Native Image, the same object consumes only 8 bytes, offering significant memory savings.However, in case of Native Image, the object size heavily depends on the used garbage collector (GC), the allocated instance type, and the state of compressed references.Compressed references use 32-bit instead of 64-bit, and are enabled by default in Oracle GraalVM.To observe the memory usage differences, consider this example application that measures thread-allocated bytes using the ThreadMXBean API:import com.sun.management.ThreadMXBean;import java.lang.management.ManagementFactory;import java.util.ArrayList;public class ObjectSize {    public static void main(String[] args) {        long threadId = Thread.currentThread().threadId();        ThreadMXBean threadMXBean = (com.sun.management.ThreadMXBean) ManagementFactory.getThreadMXBean();        long initialValue = threadMXBean.getThreadAllocatedBytes(threadId);        int count = 12 * 1024 * 1024;        ArrayList&amp;lt;Object&amp;gt; objects = new ArrayList&amp;lt;&amp;gt;(count);        for (int i = 0; i &amp;lt; count; i++) {            objects.add(new Object());        }        long allocatedBytes = threadMXBean.getThreadAllocatedBytes(threadId) - initialValue;        System.out.println(&quot;Object allocation test completed: &quot; + objects.hashCode());        System.out.println(&quot;Thread allocated &quot; + allocatedBytes + &quot; bytes&quot;);    }}The application creates millions of object instances and calculates the total memory allocated during their creation.The application reports the total allocated bytes, which include both the memory for ArrayList and the individual objects.Running this application on a machine with 16 GB of RAM and Oracle GraalVM for JDK 23, produces the following results.Native Image with compressed references and default Serial GC:Object allocation test completed: -718496536Thread allocated 150995032 bytesBreaking this down translates to:48 MB for the ArrayList96 MB for the Objects (12 * 1024 * 1024 objects × 8 bytes)----------------------------------------------------------Total: 144 MBHotSpot with compressed references and default G1 GC:Object allocation test completed: -1131298887Thread allocated 251658592 bytesBreaking this down translates to:48 MB for the ArrayList192 MB for the Objects (12 * 1024 * 1024 objects × 16 bytes)------------------------------------------------------------Total: 240 MBThe primary difference lies in the object header size (4-byte header vs 12-byte header).Note that the memory footprint for the ArrayList is roughly identical in both VMs.However, the memory for the millions of individual objects diverges due to the larger object headers on HotSpot.To summarize, when it comes to applications dealing with large numbers of small objects, Native Image may offer a smaller memory footprint.For Native Image, the object header size primarily depends on the used GC, the allocated instance type, and the state of compressed references.Further Reading  Memory Management",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/ObjectHeaderSize/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-onstackreplacement":  {
          "title": "On-Stack Replacement (OSR)",
          "content": "On-Stack Replacement (OSR)During execution, Truffle will schedule “hot” call targets for compilation.Once a target is compiled, later invocations of the target can execute the compiled version.However, an ongoing execution of a call target will not benefit from this compilation, since it cannot transfer execution to the compiled code.This means that a long-running target can get “stuck” in the interpreter, harming warmup performance.On-stack replacement (OSR) is a technique used in Truffle to “break out” of the interpreter, transferring execution from interpreted to compiled code.Truffle supports OSR for both AST interpreters (i.e., ASTs with LoopNodes) and bytecode interpreters (i.e., nodes with dispatch loops).In either case, Truffle uses heuristics to detect when a long-running loop is being interpreted and can perform OSR to speed up execution.OSR for AST interpretersLanguages using standard Truffle APIs get OSR for free on Graal.The runtime tracks the number of times a LoopNode (created using TruffleRuntime.createLoopNode(RepeatingNode)) executes in the interpreter.Once the loop iterations exceed a threshold, the runtime considers the loop “hot”, and it will transparently compile the loop, poll for completion, and then call the compiled OSR target.The OSR target uses the same Frame used by the interpreter.When the loop exits in the OSR execution, it returns to the interpreted execution, which forwards the result.See the LoopNode javadoc for more details.OSR for bytecode interpretersOSR for bytecode interpreters requires slightly more cooperation from the language.A bytecode dispatch node typically looks something like the following:class BytecodeDispatchNode extends Node {  @CompilationFinal byte[] bytecode;  ...  @ExplodeLoop(kind = ExplodeLoop.LoopExplosionKind.MERGE_EXPLODE)  Object execute(VirtualFrame frame) {    int bci = 0;    while (true) {      int nextBCI;      switch (bytecode[bci]) {        case OP1:          ...          nextBCI = ...          ...        case OP2:          ...          nextBCI = ...          ...        ...      }      bci = nextBCI;    }  }}Unlike with AST interpreters, loops in a bytecode interpreter are often unstructured (and implicit).Though bytecode languages do not have structured loops, backward jumps in the code (“back-edges”) tend to be a good proxy for loop iterations.Thus, Truffle’s bytecode OSR is designed around back-edges and the destination of those edges (which often correspond to loop headers).To make use of Truffle’s bytecode OSR, a language’s dispatch node should implement the BytecodeOSRNode interface.This interface requires (at minimum) three method implementations:  executeOSR(osrFrame, target, interpreterState): This method dispatches execution to the given target (i.e., bytecode index) using osrFrame as the current program state. The interpreterState object can pass any additional interpreter state needed to resume execution.  getOSRMetadata() and setOSRMetadata(osrMetadata): These methods proxy accesses to a field declared on the class. The runtime will use these accessors to maintain state related to OSR compilation (e.g., back-edge counts). The field should be annotated @CompilationFinal.In the main dispatch loop, when the language hits a back-edge, it should invoke the provided BytecodeOSRNode.pollOSRBackEdge(osrNode) method to notify the runtime of the back-edge.If the runtime deems the node eligible for OSR compilation, this method returns true.If (and only if) pollOSRBackEdge returns true, the language can call BytecodeOSRNode.tryOSR(osrNode, target, interpreterState, beforeTransfer, parentFrame) to attempt OSR.This method will request compilation starting from target, and once compiled code is available, a subsequent call can transparently invoke the compiled code and return the computed result.We will discuss the interpreterState and beforeTransfer parameters shortly.The example above can be refactored to support OSR as follows:class BytecodeDispatchNode extends Node implements BytecodeOSRNode {  @CompilationFinal byte[] bytecode;  @CompilationFinal private Object osrMetadata;  ...  Object execute(VirtualFrame frame) {    return executeFromBCI(frame, 0);  }  Object executeOSR(VirtualFrame osrFrame, int target, Object interpreterState) {    return executeFromBCI(osrFrame, target);  }  Object getOSRMetadata() {    return osrMetadata;  }  void setOSRMetadata(Object osrMetadata) {    this.osrMetadata = osrMetadata;  }  @ExplodeLoop(kind = ExplodeLoop.LoopExplosionKind.MERGE_EXPLODE)  Object executeFromBCI(VirtualFrame frame, int bci) {    while (true) {      int nextBCI;      switch (bytecode[bci]) {        case OP1:          ...          nextBCI = ...          ...        case OP2:          ...          nextBCI = ...          ...        ...      }      if (nextBCI &amp;lt; bci) { // back-edge        if (BytecodeOSRNode.pollOSRBackEdge(this)) { // OSR can be tried          Object result = BytecodeOSRNode.tryOSR(this, nextBCI, null, null, frame);          if (result != null) { // OSR was performed            return result;          }        }      }      bci = nextBCI;    }  }}A subtle difference with bytecode OSR is that the OSR execution continues past the end of the loop until the end of the call target.Thus, execution does not need to continue in the interpreter once execution returns from OSR; the result can simply be forwarded to the caller.The interpreterState parameter to tryOSR can contain any additional interpreter state required for execution.This state is passed to executeOSR and can be used to resume execution.For example, if an interpreter uses a data pointer to manage reads/writes, and it is unique for each target, this pointer can be passed in interpreterState.It will be visible to the compiler and used in partial evaluation.The beforeTransfer parameter to tryOSR is an optional callback which will be invoked before performing OSR.Since tryOSR may or may not perform OSR, this parameter is a way to perform any actions before transferring to OSR code.For example, a language may pass a callback to send an instrumentation event before jumping to OSR code.The BytecodeOSRNode interface also contains a few hook methods whose default implementations can be overridden:  copyIntoOSRFrame(osrFrame, parentFrame, target) and restoreParentFrame(osrFrame, parentFrame): Reusing the interpreted Frame inside OSR code is not optimal, because it escapes the OSR call target and prevents scalar replacement (for background on scalar replacement, see this paper).When possible, Truffle will use copyIntoOSRFrame to copy the interpreted state (parentFrame) into the OSR Frame (osrFrame), and restoreParentFrame to copy state back into the parent Frame afterwards.By default, both hooks copy each slot between the source and destination frames, but this can be overridden for finer control (e.g., to only copy over live variables).If overridden, these methods should be written carefully to support scalar replacement.  prepareOSR(target): This hook gets called before compiling an OSR target.It can be used to force any initialization to happen before compilation.For example, if a field can only be initialized in the interpreter, prepareOSR can ensure it is initialized, so that OSR code does not deoptimize when trying to access it.Bytecode-based OSR can be tricky to implement. Some debugging tips:  Ensure that the metadata field is marked @CompilationFinal.  If a Frame with a given FrameDescriptor has been materialized before, Truffle will reuse the interpreter Frame instead of copying (if copying is used, any existing materialized Frame could get out of sync with the OSR Frame).  It is helpful to trace compilation and deoptimization logs to identify any initialization work which could be done in prepareOSR.  Inspecting the compiled OSR targets in IGV can be useful to ensure the copying hooks interact well with partial evaluation.See the BytecodeOSRNode javadoc for more details.Command-line optionsThere are two (experimental) options which can be used to configure OSR:  engine.OSR: whether to perform OSR (default: true)  engine.OSRCompilationThreshold: the number of loop iterations/back-edges required to trigger OSR compilation (default: 100,352).DebuggingOSR compilation targets are marked with &amp;lt;OSR&amp;gt; (or &amp;lt;OSR@n&amp;gt; where n is the dispatch target, in the case of bytecode OSR).These targets can be seen and debugged using standard debugging tools like the compilation log and IGV.For example, in the compilation log, a bytecode OSR entry may look something like:[engine] opt done     BytecodeNode@2d3ca632&amp;lt;OSR@42&amp;gt;                               |AST    2|Tier 1|Time   21(  14+8   )ms|Inlined   0Y   0N|IR   161/  344|CodeSize   1234|Addr 0x7f3851f45c10|Src n/aSee Debugging for more details on debugging Graal compilations.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/OnStackReplacement/"
          },
          
          "latest-reference-manual-compiler-operations":  {
          "title": "Graal JIT Compiler Operations Manual",
          "content": "Graal JIT Compiler Operations ManualMeasuring PerformanceThe first thing to confirm when measuring performance is that the Java Virtual Machine (JVM) is using the Graal JIT compiler.GraalVM is configured to use the Graal JIT compiler as the top tier compiler by default.To enable the Graal JIT compiler for use in the Java HotSpot Virtual Machine, use the -XX:+UseGraalJIT option.(The -XX:+UseGraalJIT option has to be used together with the -XX:+UnlockExperimentalVMOptions option that unlocks this experimental integration.)The following example runs the Java application com.example.myapp with the Graal JIT compiler enabled:java -XX:+UnlockExperimentalVMOptions -XX:+UseGraalJIT com.example.myappYou can confirm that you are using the Graal JIT compiler by adding the -Djdk.graal.ShowConfiguration=info option to the command line.It produces a line of output similar to the one below when the compiler is initialized:Using &quot;Graal Enterprise compiler with Truffle extensions&quot; loaded from a PGO optimized Native Image shared library  Note: The Graal compiler is only initialized on the first top-tier JIT compilation request so if your application is short-lived, you may not see this output.Optimizing a JVM-based application is a science in itself.Compilation may not even be a factor in the case of poor performance as the problem may lie in any other part of the JVM (I/O, garbage collection, threading, and so on), or in a poorly written application, or third-party library code.For this reason, it is  worth employing the JDK Mission Control toolchain to diagnose your application’s behavior.You can also compare performance against the native top-tier compiler in the JVM by adding -XX:-UseJVMCICompiler to the command line.If you observe a significant performance regression when using the Graal JIT compiler, please open an issue on GitHub.Attach a Java Flight Recorder log and instructions to reproduce the issue—this makes investigation easier and thus increases the chances of a fix.Even better is if you can submit a JMH benchmark that represents the hottest parts of your application (as identified by a profiler).This allows us to quickly pinpoint absent optimization opportunities or to provide suggestions on how to restructure your code to avoid or reduce performance bottlenecks.Troubleshooting the Graal JIT CompilerIf you spot a security vulnerability, please do not report it via GitHub Issues or the public mailing lists, but via the process outlined in the Reporting Vulnerabilities guide.Compilation ExceptionsOne advantage of the compiler being written in Java is that a Java exception during compilation is not a fatal JVM error.Instead, each compilation has an exception handler that takes action based on the graal.CompilationFailureAction property.The default value is Silent. If you specify Diagnose, a failing compilation is retried with extra diagnostics.In this case, just before the JVM exits, all diagnostic output captured during retried compilations is written to a ZIP file and its location is printed on the console, for example:Graal diagnostic output saved in /Users/demo/graal-dumps/1499768882600/graal_diagnostics_64565.zipYou can then attach the ZIP file to an issue on GitHub.As well as Silent and Diagnose, the following values for graal.CompilationFailureAction are available:  Print: prints a message and stack trace to the console but does not perform recompilation.  ExitVM: same as Diagnose but the JVM process exits after recompilation.Code Generation ErrorsThe other type of error you might encounter with a compiler is the production of incorrect machine code.This error can cause a JVM crash, resulting in a file that starts with hs_err_pid in the current working directory of the JVM process.In most cases, there is a section in the file that shows the stack at the time of the crash, including the type of code for each frame in the stack, as in the following example:Stack: [0x00007000020b1000,0x00007000021b1000],  sp=0x00007000021af7a0,  free space=1017kNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)J 761 JVMCI jdk.graal.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)V (299 bytes) @ 0x0000000108a2fc01 [0x0000000108a2fac0+0x141] (null)j  jdk.graal.compiler.core.gen.NodeLIRBuilder.doBlock(Ljdk.graal.compiler/nodes/cfg/Block;Ljdk.graal.compiler/nodes/StructuredGraph;Ljdk.graal.compiler/core/common/cfg/BlockMap;)V+211j  jdk.graal.compiler.core.LIRGenerationPhase.emitBlock(Ljdk.graal.compiler/nodes/spi/NodeLIRBuilderTool;Ljdk.graal.compiler/lir/gen/LIRGenerationResult;Ljdk.graal.compiler/nodes/cfg/Block;Ljdk.graal.compiler/nodes/StructuredGraph;Ljdk.graal.compiler/core/common/cfg/BlockMap;)V+65This example shows that the top frame was compiled (J) by the JVMCI compiler, which is the Graal JIT compiler.The crash occurred at offset 0x141 in the machine code produced for:jdk.graal.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)VThe next two frames in the stack were interpreted (j).The location of the crash is also often indicated near the top of the file with something like this:# Problematic frame:# J 761 JVMCI jdk.graal.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)V (299 bytes) @ 0x0000000108a2fc01 [0x0000000108a2fac0+0x141] (null)In this example, there is probably an error in the code produced by the Graal JIT compiler for NodeLIRBuilder.matchComplexExpressions.When filing an issue on GitHub for such a crash, you should first attempt to reproduce the crash with extra diagnostics enabled for the compilation of the problematic method.In this example, you would add the following options to your command line:-Djdk.graal.MethodFilter=NodeLIRBuilder.matchComplexExpressions, -Djdk.graal.Dump=:2These options are described in more detail in the compiler debugging documentation.In brief, these options tell the Graal JIT compiler to capture snapshots of its state at verbosity level 2 while compiling any method named matchComplexExpressions in a class with a simple name of NodeLIRBuilder.The complete format of the MethodFilter option is described in MethodFilterHelp.txt.Quite often, the crash location does not exist directly in the problematic method mentioned in the crash log but comes from an inlined method.In such a case, simply filtering for the problematic method might not capture an erroneous compilation causing a crash.To improve the likelihood of capturing an erroneous compilation,  broaden the MethodFilter value.To guide this, add the -Djdk.graal.PrintCompilation=true option when trying to reproduce the crash so you can see what was compiled just before the crash.The following shows sample output from the console:HotSpotCompilation-1218        Ljdk.graal.compiler/core/amd64/AMD64NodeLIRBuilder;                  peephole                                      (Ljdk.graal.compiler/nodes/ValueNode;)Z           |   87ms   428B   447B  1834kBHotSpotCompilation-1212        Ljdk.graal.compiler/lir/LIRInstructionClass;                         forEachState                                  (Ljdk.graal.compiler/lir/LIRInstruction;Ljdk.graal.compiler/lir/InstructionValueProcedure;)V  |  359ms    92B   309B  6609kBHotSpotCompilation-1221        Ljdk.graal.compiler/hotspot/amd64/AMD64HotSpotLIRGenerator;          getResult                                     ()Ljdk.graal.compiler/hotspot/HotSpotLIRGenerationResult;  |   54ms    18B   142B  1025kB## A fatal error has been detected by the Java Runtime Environment:##  SIGSEGV (0xb) at pc=0x000000010a6cafb1, pid=89745, tid=0x0000000000004b03## JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-graalvm-olabs-b13)# Java VM: OpenJDK 64-Bit GraalVM (25.71-b01-internal-jvmci-0.30 mixed mode bsd-amd64 compressed oops)# Problematic frame:# J 1221 JVMCI jdk.graal.compiler.hotspot.amd64.AMD64HotSpotLIRGenerator.getResult()Ljdk.graal.compiler/hotspot/HotSpotLIRGenerationResult; (18 bytes) @ 0x000000010a6cafb1 [0x000000010a6caf60+0x51] (null)## Failed to write core dump. Core dumps have been disabled. To enable core dumping, try &quot;ulimit -c unlimited&quot; before starting Java againHere, the crash happened in a different method than the first crash.As such, we expand the filter argument to be -Djdk.graal.MethodFilter=NodeLIRBuilder.matchComplexExpressions,AMD64HotSpotLIRGenerator.getResult and run again.When the JVM crashes in this way, it does not run the shutdown code that archives the Graal compiler diagnostic output or delete the directory in which it was written.This must be done manually after the crash.By default, the directory is $PWD/graal-dumps/&amp;lt;timestamp&amp;gt; (for example, ./graal-dumps/1499938817387).However, you can specify the directory with the -Djdk.graal.DumpPath=&amp;lt;path&amp;gt; option.A message, such as the following, is printed to the console when this directory is first used by the compiler:Dumping debug output in /Users/demo/graal-dumps/1499768882600This directory should contain content related to the method that crashed, such as:ls -l /Users/demo/graal-dumps/1499768882600-rw-r--r--  1 demo  staff    144384 Jul 13 11:46 HotSpotCompilation-1162[AMD64HotSpotLIRGenerator.getResult()].bgv-rw-r--r--  1 demo  staff     96925 Jul 13 11:46 HotSpotCompilation-1162[AMD64HotSpotLIRGenerator.getResult()].cfg-rw-r--r--  1 demo  staff  12600725 Jul 13 11:46 HotSpotCompilation-791[NodeLIRBuilder.matchComplexExpressions(List)].bgv-rw-r--r--  1 demo  staff   1727409 Jul 13 11:46 HotSpotCompilation-791[NodeLIRBuilder.matchComplexExpressions(List)].cfgYou should attach a ZIP file of this directory to an issue on GitHub.Related Documentation  Graal Compiler  Graal JIT Compiler Configuration",
          "url": " /latest/reference-manual/compiler/operations/"
          },
          
          "latest-reference-manual-js-operatoroverloading":  {
          "title": "Operator Overloading",
          "content": "Operator OverloadingGraalJS provides an early implementation of the ECMAScript operator overloading proposal.This lets you overload the behavior of JavaScript’s operators on your JavaScript classes.If you want to experiment with this feature, enable it.Since both the proposal and the GraalJS implementation of it are in early stages, you need to pass the --experimental-options option:js --experimental-options --js.operator-overloadingAfter setting the option, you will see a new builtin in the global namespace, the Operators function.You can call this function, passing it a JavaScript object as an argument.The object should have a property for every operator you wish to overload, with the key being the name of the operator and the value being a function that implements it.The return value of the Operators function is a constructor that you can then subclass when defining your type.By subclassing this constructor, you get a class whose objects inherit the overloaded operator behavior that you defined in your argument to the Operators function.Basic ExampleLook at an example from the original proposal featuring vectors:const VectorOps = Operators({  &quot;+&quot;(a, b) {    return new Vector(a.contents.map((elt, i) =&amp;gt; elt + b.contents[i]));  },  &quot;==&quot;(a, b) {    return a.contents.length === b.contents.length &amp;amp;&amp;amp;           a.contents.every((elt, i) =&amp;gt; elt == b.contents[i]);  },});class Vector extends VectorOps {  contents;  constructor(contents) {    super();    this.contents = contents;  }}Here two operators, + and ==, are overloaded.Calling the Operators function with the table of overloaded operators yields the VectorOps class.Then the Vector class is defined as a subclass of VectorOps.If you create instances of Vector, you can observe that they follow the overloaded operator definitions:&amp;gt; new Vector([1, 2, 3]) + new Vector([4, 5, 6]) == new Vector([5, 7, 9])trueExample with Mixed TypesIt is also possible to overload operators between values of different types, allowing, for example, multiplication of vectors by numbers:const VectorOps = Operators({    &quot;+&quot;(a, b) {        return new Vector(a.contents.map((elt, i) =&amp;gt; elt + b.contents[i]));    },    &quot;==&quot;(a, b) {        return a.contents.length === b.contents.length &amp;amp;&amp;amp;            a.contents.every((elt, i) =&amp;gt; elt == b.contents[i]);    },}, {    left: Number,    &quot;*&quot;(a, b) {        return new Vector(b.contents.map(elt =&amp;gt; elt * a));    }});class Vector extends VectorOps {    contents;    constructor(contents) {        super();        this.contents = contents;    }}To define mixed-type operators, pass additional objects to the Operators function.These extra tables should each have either a left property or a right property, depending on whether you overload the behavior of operators with some other type on the left or on the right side of the operator.In the example, the * operator is overloaded for cases when there is a Number on the left and the type, Vector, on the right.Each extra table can have either a left property or a right property and then any number of operator overloads that will apply to that particular case.Running this example you see:&amp;gt; 2 * new Vector([1, 2, 3]) == new Vector([2, 4, 6])trueUsage DocumentationThe function Operators(table, extraTables...) returns a class with overloaded operators.Users should define their own class which extends that class.The table argument must be an object with one property for every overloaded operator.The property key must be the name of the operator.These are the names of operators which can be overloaded:  binary operators: &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;%&quot;, &quot;**&quot;, &quot;&amp;amp;&quot;, &quot;^&quot;, &quot;|&quot;, &quot;&amp;lt;&amp;lt;&quot;, &quot;&amp;gt;&amp;gt;&quot;, &quot;&amp;gt;&amp;gt;&amp;gt;&quot;, &quot;==&quot;, &quot;&amp;lt;&quot;  unary operators: &quot;pos&quot;, &quot;neg&quot;, &quot;++&quot;, &quot;--&quot;, &quot;~&quot;The &quot;pos&quot; and &quot;neg&quot; operator names correspond to unary + and unary -, respectively.Overloading &quot;++&quot; works both for pre-increments ++x and post-increments x++, the same goes for &quot;--&quot;.The overload for &quot;==&quot; is used both for equality x == y and inequality x != y tests.Similarly, the overload for &quot;&amp;lt;&quot; is used for all comparison operators (x &amp;lt; y, x &amp;lt;= y, x &amp;gt; y, x &amp;gt;= y) by swapping the arguments and/or negating the result.The value assigned to an operator name must be a function of two arguments in the case of binary operators or a function of one argument in the case of unary operators.The table argument can also have an open property.If so, the value of that property must be an array of operator names.These are the operators that future classes will be able to overload on this type (for example, a Vector type might declare &quot;*&quot; to be open so that later a Matrix type might overload the operations Vector * Matrix and Matrix * Vector).If the open property is missing, all operators are considered to be open for future overloading with other types.Following the first argument table are optional arguments extraTables.Each of these must also be an object.Each extra table must have either a left property or a right property, not both.The value of that property must be one of the following JavaScript constructors:  Number  BigInt  String  any class with overloaded operators (i.e. extended from a constructor returned by Operators)The other properties of the extra table should be operator overloads as in the first table argument (operator name as key, function implementing the operator as value).These extra tables define the behavior of operators when one of the operand types is of a type other than the one being defined.If the extra table has a left property, its operator definitions will apply to cases when the left operand is of the type named by the left property and the right operand is of the type whose operators are being defined.Similarly for the right property, if the extra table has a right property, the table’s operator definitions will apply when the right operand has the named type and the left operand has the type whose operators are being defined.Note that you are free to overload any of the binary operators between your custom type and the JavaScript numeric types Number and BigInt.However, the only operators you are allowed to overload between your custom type and the String type are &quot;==&quot; and &quot;&amp;lt;&quot;.The Operators function returns a constructor that you will usually want to extend in your own class.Instances of that class will respect your overloaded operator definitions.Whenever you use an operator on an object with overloaded operators, the following happens:  1) Every operand that does not have overloaded operators is coerced to a primitive.  2) If there is an applicable overload for this pairing of operands, it is called. Otherwise, a TypeError is thrown.Notably, your objects with overloaded operators will not be coerced to primitives when applying operators and you can get TypeErrors when applying undefined operators to them.There are two exceptions to this:  1) If you are using the + operator and one of the arguments is a String (or an object without overloaded operators that coerces to a String via ToPrimitive), then the result will be a concatenation of the ToString values of the two operands.  2) If you are using the == operator and there is no applicable overload found, the two operands are assumed to be different (x == y will return false and x != y will return true).Differences from the ProposalThere a few differences between the proposal (as defined by its specification and prototype implementation) and GraalJS implementation:  You do not have to use the with operators from construction to enable the use of overloaded operators. When you overload operators for a class, those operators can then be used anywhere without using with operators from. Furthermore, the parser will not accept the with operators from clause as valid JavaScript.  You cannot use decorators to define overloaded operators. At the time of implementing this proposal, GraalJS does not support decorators (these are still an in-progress proposal).  You cannot overload the &quot;[]&quot; and &quot;[]=&quot; operators for reading and writing integer-indexed elements. These two operators require more complex treatment and are not currently supported.Related Documentation  ECMAScript operator overloading proposal",
          "url": " /latest/reference-manual/js/OperatorOverloading/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance":  {
          "title": "Optimizations and Performance",
          "content": "Optimizations and PerformanceNative Image provides different mechanisms that enable users to optimize a generated binary in terms of performance, file size, build time, debuggability, and other metrics.Optimization LevelsSimilar to gcc and clang, users can control the optimization level using the -O option.By default, -O2 is used which aims for a good tradeoff between performance, file size, and build time.The following table provides an overview of the different optimization levels and explains when they are useful:            Level      Optimizations      Use Cases                  -Ob      Reduced      Quick build mode: Speeds up builds during development by avoiding time-consuming optimizations. This can also reduce file size sometimes.              -Os      Reduced      Optimize for size: -Os enables all -O2 optimizations except those that can increase code or image size significantly. Typically creates the smallest possible images at the cost of reduced performance.              -O0      None      Typically used together with -g to improve the debugging experience.              -O1      Basic      Trades performance for reduced file size and build time. Oracle GraalVM’s -O1 is somewhat comparable to -O2 in GraalVM Community Edition.              -O2      Advanced      Default: Aims for good performance at a reasonable file size.              -O3      All      Aims for the best performance at the cost of longer build times. Used automatically by Oracle GraalVM for PGO builds (--pgo option). -O3 and -O2 are identical in GraalVM Community Edition.      Profile-Guided Optimization for Improved ThroughputConsider using Profile-Guided Optimization (PGO) to optimize your application for improved throughput.These optimizations allow the Graal compiler to leverage profiling information, similar to when it is running as a JIT compiler, when AOT-compiling your application.For this, perform the following steps:  Build your application with --pgo-instrument.  Run your instrumented application with a representative workload to generate profiling information. Profiles collected from this run are stored by default in the default.iprof file.  Rebuild your application with the --pgo option. You can pass a custom .iprof file with --pgo=&amp;lt;your&amp;gt;.iprof, otherwise default.iprof is used. This will rebuild your image and generate an optimized version of your application.  Note: Not available in GraalVM Community Edition.Find more information on this topic in Basic Usage of Profile-Guided Optimization.ML-Powered Profile Inference for Enhanced PerformanceNative Image supports machine learning-driven static profiling, as a built-in capability.By default, GraalVM runs at the -O2 optimization level, which uses the simple and fast Graal Static Profiler (GraalSP) for profile inference.This model is optimized for a wide range of applications.As of GraalVM for JDK 24, the new Graal Neural Network (GraalNN) static profiler can be used for ML-powered profile inference, offering even better performance.Enable it by passing the -O3 option to Native Image.  Note: Not available in GraalVM Community Edition.Note that if the user provides a PGO profile using the --pgo option, additional ML inference is unnecessary and therefore disabled automatically.Key Points:  GraalSP (simple model) is used with -O2 by default.  GraalNN (advanced model) is used with -O3 by default.Optimizing for Specific MachinesNative Image provides a -march option that works similarly to the ones in gcc and clang: it enables users to control the set of instructions that the Graal compiler can use when compiling code to native.By default, Native Image uses x86-64-v3 on x64 and armv8-a on AArch64.Use -march=list to list all available machine types.If the generated binary is built on the same or similar machine type that it is also deployed on, use -march=native.This option instructs the compiler to use all instructions that it finds available on the machine the binary is generated on.If the generated binary, on the other hand, is distributed to users with many different, and potentially very old machines, use -march=compatibility.This reduces the set of instructions used by the compiler to a minimum and thus improves the compatibility of the generated binary.Additional FeaturesNative Image provides additional features to further optimize a generated binary:  Choosing an appropriate Garbage Collector and tailoring the garbage collection policy can reduce GC times. See Memory Management.  Using compressed references can lead to better memory efficiency. See Object Header Size in Native Image.  Loading application configuration during the image build can speed up application startup. See Class Initialization at Image Build Time.  The build output may provide some other recommendations that help you get the best out of Native Image. See Build Output: Recommendations.",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-optimizing":  {
          "title": "Optimizing Truffle Interpreters",
          "content": "Optimizing Truffle InterpretersThis document discusses tools for optimizing or debugging Truffle interpreters for peak temporal performance.Strategy      Run with a profiler to sample the application and identify responsible compilation units. Use a sampling delay (--cpusampler.Delay=MILLISECONDS) to only profile after warmup. See the Profiling guide.        Understand what is being compiled and look for deoptimizations. Methods that are listed to run mostly in the interpreter likely have a problem with deoptimization.        Simplify the code as much as possible where it still shows the performance problem.        Enable performance warnings and list boundary calls.    Dump the Graal graph of the responsible compilation unit and look at the phase After TruffleTier.          Look at the Graal graphs at the phases After TruffleTier and After PartialEscape and check if it is what you would expect.If there are nodes there that you don’t want to be there, think about how to guard against including them.If there are more complex nodes there than you want, think about how to add specialisations that generate simpler code.If there are nodes you think should be there in a benchmark that are not, think about how to make values dynamic so they are not optimized away.            Search for Invoke nodes in the Graal IR. Invoke nodes that are not representing guest language calls should be specialized away. This may not be always possible, e.g., if the method does I/O.        Search for control flow splits (red lines) and investigate whether they result from control flow caused by the guest application or are just artifacts from the language implementation. The latter should be avoided if possible.    Search for indirections in linear code (Load and LoadIndexed) and try to minimize the code. The less code that is on the hot-path the better.Truffle Compiler OptionsA full list of the latest expert and internal options can be found in the Options guide.Observing CompilationsThis section provides an overview of most of the available command line options to observe compilations.Note: Most options also require the additional --experimental-options flag set.The --engine.TraceCompilation command prints a line each time a method is compiled:[engine] opt done   engine=2  id=213   EqualityConstraint.execute                         |Tier 1|Time    14(  11+3   )ms|AST   31|Inlined   0Y   2N|IR    218/   365|CodeSize    1386|Addr 0x782dd1fb9300|CompId 23519  |UTC 2025-07-08T08:25:20.339|Src octane-deltablue.js:528 0xb0b56c7bHere is a quick overview of the information provided in these logs:  engine - Unique identifier of the engine the compilation is done for.  id - Unique identifier of the call target.  Tier - For which compilation tier was the target scheduled.  Time - How long did the compilation last, with separation between the Truffle tier (mainly partial evaluation) and the Graal Tiers.  AST - The targets non-trivial node count.  Inlined - How many calls were inlined and how many remained calls after inlining.  IR - Graal node count after partial evaluation and after compilation.  CodeSize - The size of the code generated for the call target.  Addr - The address of the compiled code.  CompId - VM specific compilation ID of the compilation.  UTC - The time when the event happened.  Src - Abbreviated source section of the call target and the hash code of the source.The --engine.TraceCompilationDetails command prints a line when compilation is queued, unqueued, started, or completed:[engine] opt queued engine=2  id=206   BinaryConstraint.output                            |Tier 1|Count/Thres         75/      100|Queue: Size    3 Change +1  Load  0,25 Time     0us                                   |UTC 2025-07-08T08:25:19.974|Src octane-deltablue.js:416 0xb0b56c7b[engine] opt queued engine=2  id=208   OrderedCollection.size                             |Tier 1|Count/Thres        100/      125|Queue: Size    4 Change +1  Load  0,31 Time     0us                                   |UTC 2025-07-08T08:25:19.997|Src octane-deltablue.js:71 0xb0b56c7b[engine] opt queued engine=2  id=32    Array.prototype.push                               |Tier 1|Count/Thres        125/      175|Queue: Size    5 Change +1  Load  0,44 Time     0us                                   |UTC 2025-07-08T08:25:20.025|Src &amp;lt;builtin&amp;gt;:1 0xe756ac41[engine] opt start  engine=2  id=206   BinaryConstraint.output                            |Tier 1|Priority     93750|Rate 0,000003|Queue: Size    4 Change -1  Load  0,50 Time   195us                                   |UTC 2025-07-08T08:25:20.039|Src octane-deltablue.js:416 0xb0b56c7b|Bonuses first tier... more log ...[engine] opt done   engine=2  id=206   BinaryConstraint.output                            |Tier 1|Time   126( 122+4   )ms|AST   32|Inlined   0Y   0N|IR    138/   169|CodeSize     608|Addr 0x782dd1ecec00|CompId 22170  |UTC 2025-07-08T08:25:20.170|Src octane-deltablue.js:416 0xb0b56c7b[engine] opt start  engine=2  id=208   OrderedCollection.size                             |Tier 1|Priority    323626|Rate 0,000005|Queue: Size    8 Change -1  Load  0,88 Time    17us                                   |UTC 2025-07-08T08:25:20.173|Src octane-deltablue.js:71 0xb0b56c7b|Bonuses first tier[engine] opt queued engine=2  id=215   OrderedCollection.at                               |Tier 1|Count/Thres        350/      325|Queue: Size    9 Change +1  Load  0,81 Time     0us                                   |UTC 2025-07-08T08:25:20.185|Src octane-deltablue.js:67 0xb0b56c7b... more log ...[engine] opt queued engine=2  id=208   OrderedCollection.size                             |Tier 2|Count/Thres      10000/    10000|Queue: Size   19 Change +1  Load  1,00 Time     0us                                   |UTC 2025-07-08T08:25:20.274|Src octane-deltablue.js:71 0xb0b56c7b[engine] opt queued engine=2  id=206   BinaryConstraint.output                            |Tier 2|Count/Thres      10000/    10000|Queue: Size   20 Change +1  Load  1,00 Time     0us                                   |UTC 2025-07-08T08:25:20.277|Src octane-deltablue.js:416 0xb0b56c7b[engine] opt done   engine=2  id=214   Planner.addConstraintsConsumingTo                  |Tier 1|Time    90(  68+22  )ms|AST   79|Inlined   0Y   5N|IR    467/   841|CodeSize    3515|Addr 0x782dd1f74e80|CompId 23040  |UTC 2025-07-08T08:25:20.293|Src octane-deltablue.js:743 0xb0b56c7b[engine] opt start  engine=2  id=205   BinaryConstraint.input                             |Tier 1|Priority   4087953|Rate 0,000111|Queue: Size   19 Change -1  Load  1,00 Time    25us                                   |UTC 2025-07-08T08:25:20.294|Src octane-deltablue.js:409 0xb0b56c7b|Bonuses first tier... more log ...[engine] opt done   engine=2  id=215   OrderedCollection.at                               |Tier 2|Time     5(   2+2   )ms|AST   23|Inlined   0Y   0N|IR     49/    94|CodeSize     485|Addr 0x782dd23b7980|CompId 26009  |UTC 2025-07-08T08:25:21.228|Src octane-deltablue.js:67 0xb0b56c7b[engine] opt start  engine=2  id=206   BinaryConstraint.output                            |Tier 2|Priority   1723949|Rate 0,003724|Queue: Size   82 Change -1  Load  1,00 Time    25us                                   |UTC 2025-07-08T08:25:21.228|Src octane-deltablue.js:416 0xb0b56c7b|Bonuses[engine] opt done   engine=2  id=206   BinaryConstraint.output                            |Tier 2|Time     6(   3+2   )ms|AST   32|Inlined   0Y   0N|IR    100/   144|CodeSize     639|Addr 0x782dd23b8300|CompId 26014  |UTC 2025-07-08T08:25:21.234|Src octane-deltablue.js:416 0xb0b56c7b[engine] opt start  engine=2  id=240   Plan.size                                          |Tier 2|Priority   1565159|Rate 0,003621|Queue: Size   81 Change -1  Load  1,00 Time    23us                                   |UTC 2025-07-08T08:25:21.234|Src octane-deltablue.js:770 0xb0b56c7b|Bonuses[engine] opt done   engine=2  id=240   Plan.size                                          |Tier 2|Time     6(   4+2   )ms|AST   19|Inlined   1Y   0N|IR     43/   112|CodeSize     463|Addr 0x782dd23bdc00|CompId 26018  |UTC 2025-07-08T08:25:21.240|Src octane-deltablue.js:770 0xb0b56c7b[engine] opt start  engine=2  id=239   Plan.execute                                       |Tier 2|Priority   1591366|Rate 0,004334|Queue: Size   80 Change -1  Load  1,00 Time    27us                                   |UTC 2025-07-08T08:25:21.240|Src octane-deltablue.js:778 0xb0b56c7b|Bonuses[engine] opt done   engine=2  id=239   Plan.execute                                       |Tier 2|Time    45(  28+17  )ms|AST   53|Inlined   9Y   0N|IR    609/   552|CodeSize    1583|Addr 0x782dd23c5d00|CompId 26052  |UTC 2025-07-08T08:25:21.285|Src octane-deltablue.js:778 0xb0b56c7b... more log ...[engine] opt unque. engine=2  id=266   Date.prototype.valueOf                             |Tier 2|Count/Thres     145950/    10000|Queue: Size   15 Change  0  Load  1,00 Time     0us                                   |UTC 2025-07-08T08:25:26.409|Src &amp;lt;builtin&amp;gt;:1 0xe756ac41|Reason Target inlined into only callerHere is a quick overview of the information added in these logs:  Count/Thres - What is the call and loop count of the target and what is the threshold needed to add the compilation to the queue.  Queue: Size - How many compilations are in the compilation queue.  Queue: Change - How did this event impact the compilation queue (e.g. certain events can prune the queue of unneeded compilation tasks).  Queue: Load - A metric of whether the queue is over/under loaded. Normal load is represented with 1, less then 1 is underloaded and greater than 1 is overloaded.  Queue: Time - How long did the event take.  Reason - The runtime reported reason for the event.The --engine.TraceCompilationAST command prints the Truffle AST for each compilation:[engine] opt AST          OrderedCollection.size &amp;lt;split-57429b3a&amp;gt;                     |ASTSize      10/   10 |Calls/Thres   10559/    3 |CallsAndLoop/Thres   10559/ 1000  FunctionRootNode    body = FunctionBodyNode      body = DualNode        left = JSWriteCurrentFrameSlotNodeGen          rhsNode = JSPrepareThisNodeGen            operandNode = AccessThisNode        right = TerminalPositionReturnNode          expression = PropertyNode            target = PropertyNode              target = JSReadCurrentFrameSlotNodeGen              cache = PropertyGetNode                cacheNode = ObjectPropertyGetNode                  receiverCheck = ShapeCheckNode            cache = PropertyGetNode              cacheNode = ArrayLengthPropertyGetNode                receiverCheck = ShapeCheckNode                arrayLengthRead = ArrayLengthReadNodeGenThe --engine.TraceInlining command prints guest-language inlining decisions for each compilation:[engine] inline start     Plan.execute                                                |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.00 |IR Nodes         2704 |Frequency        1.00 |Truffle Callees      5 |Forced          false |Depth               0[engine] Inlined            Plan.size                                                 |call diff     -203.75 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          175 |Frequency      101.88 |Truffle Callees      1 |Forced          false |Depth               1[engine] Inlined              OrderedCollection.size &amp;lt;split-e13c02e&amp;gt;                  |call diff     -101.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          157 |Frequency      101.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            Plan.constraintAt                                         |call diff     -201.75 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          206 |Frequency      100.88 |Truffle Callees      1 |Forced          false |Depth               1[engine] Inlined              OrderedCollection.at                                    |call diff     -100.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          232 |Frequency      100.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            ScaleConstraint.execute                                   |call diff       -0.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          855 |Frequency        0.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Inlined            EqualityConstraint.execute                                |call diff     -299.63 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          295 |Frequency       99.88 |Truffle Callees      2 |Forced          false |Depth               1[engine] Inlined              BinaryConstraint.output &amp;lt;split-1e163df7&amp;gt;                |call diff      -99.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          259 |Frequency       99.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined              BinaryConstraint.input &amp;lt;split-2dfade22&amp;gt;                 |call diff      -99.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          259 |Frequency       99.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            EditConstraint.execute                                    |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes           22 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] inline done      Plan.execute                                                |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.00 |IR Nodes         2704 |Frequency        1.00 |Truffle Callees      5 |Forced          false |Depth               0The --engine.TraceSplitting command prints guest-language splitting decisions:[engine] split   0-4310d43-1     Strength                                                    |ASTSize       6/    6 |Calls/Thres       2/    3 |CallsAndLoop/Thres       2/ 1000 |SourceSection /Users/christianhumer/graal/4dev/js-benchmarks/octane-deltablue.js~139:4062-4089[engine] split   1-4b0d79fc-1     Strength                                                    |ASTSize       6/    6 |Calls/Thres       2/    3 |CallsAndLoop/Thres       2/ 1000 |SourceSection /Users/christianhumer/graal/4dev/js-benchmarks/octane-deltablue.js~140:4119-4150The --engine.TracePerformanceWarnings=(call|instanceof|store|all) command prints code which may not be ideal for performance. The call enables warnings when partial evaluation cannot inline the virtual runtime call. The instanceof enables warnings when partial evaluation cannot resolve virtual instanceof to an exact type.The store enables warnings when the store location argument is not a partial evaluation constant:[engine] perf warn        ScaleConstraint.execute                                     |Partial evaluation could not inline the virtual runtime call Virtual to HotSpotMethod&amp;lt;ConditionProfile.profile(boolean)&amp;gt; (167|MethodCallTarget).  Approximated stack trace for [167 | MethodCallTarget:    at com.oracle.truffle.js.nodes.control.IfNode.execute(IfNode.java:158)    at com.oracle.truffle.js.nodes.binary.DualNode.execute(DualNode.java:125)    at com.oracle.truffle.js.nodes.function.FunctionBodyNode.execute(FunctionBodyNode.java:73)    at com.oracle.truffle.js.nodes.function.FunctionRootNode.executeInRealm(FunctionRootNode.java:147)    at com.oracle.truffle.js.runtime.JavaScriptRealmBoundaryRootNode.execute(JavaScriptRealmBoundaryRootNode.java:93)    at com.oracle.truffle.runtime.OptimizedCallTarget.executeRootNode(OptimizedCallTarget.java:503)    at com.oracle.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:480)The --engine.CompilationStatistics command prints statistics on compilations at the end of the process:[engine] Truffle runtime statistics for engine 1    Compilations                : 2763      Success                   : 2743      Temporary Bailouts        : 17        jdk.graal.compiler.core.common.CancellationBailoutException: Compilation cancelled.: 16        jdk.graal.compiler.core.common.RetryableBailoutException: Assumption invalidated while compiling code: IsolatedObjectConstant[Object]: 1      Permanent Bailouts        : 0      Failed                    : 0      Interrupted               : 3    Invalidated                 : 84        Unknown Reason          : 45        Profiled Argument Types : 22        validRootAssumption Split call node: 12        expression invalidatePropertyAssumption: 1        getTextPos invalidatePropertyAssumption: 1        X_OK invalidateAllPropertyAssumptions: 1        statements invalidatePropertyAssumption: 1        typed object location generalizing object type !class com.oracle.truffle.js.runtime.objects.Nullish =&amp;gt; !class java.lang.Object Object@0[final=false][type=class com.oracle.truffle.js.runtime.objects.Nullish]: 1    Queues                      : 3410    Dequeues                    : 262        Split call node         : 124        Target inlined into only caller: 87        validRootAssumption Split call node: 28        null                    : 17        Profiled Argument Types : 6    Splits                      : 5581    Compilation Accuracy        : 0,969598    Queue Accuracy              : 0,923167    Compilation Utilization     : 2,685016    Remaining Compilation Queue : 409    Time to queue               : count=3410, sum=12895957640, min=       0, average=  3781805,76, max=11311217, maxTarget=Math.floor    Time waiting in queue       : count=2763, sum=1247424699, min=      40, average=   451474,74, max= 4762017, maxTarget=tryGetTypeFromEffectiveTypeNode  ---------------------------   :  AST node statistics           :    Truffle node count          : count=2752, sum=    348085, min=       1, average=      126,48, max=    5404, maxTarget=checkSignatureDeclaration      Trivial                   : count=2752, sum=    124817, min=       0, average=       45,36, max=    2707, maxTarget=visitEachChild      Non Trivial               : count=2752, sum=    223268, min=       1, average=       81,13, max=    3162, maxTarget=checkSignatureDeclaration        Monomorphic             : count=2752, sum=    217660, min=       1, average=       79,09, max=    3042, maxTarget=checkSignatureDeclaration        Polymorphic             : count=2752, sum=      4239, min=       0, average=        1,54, max=      71, maxTarget=checkSignatureDeclaration        Megamorphic             : count=2752, sum=      1369, min=       0, average=        0,50, max=      49, maxTarget=checkSignatureDeclaration    Truffle call count          : count=2752, sum=      7789, min=       0, average=        2,83, max=     110, maxTarget=forEachChild      Indirect                  : count=2752, sum=        29, min=       0, average=        0,01, max=       3, maxTarget=emitLeadingComments      Direct                    : count=2752, sum=      7760, min=       0, average=        2,82, max=     110, maxTarget=forEachChild        Dispatched              : count=2752, sum=      6285, min=       0, average=        2,28, max=     110, maxTarget=forEachChild        Inlined                 : count=2752, sum=      1475, min=       0, average=        0,54, max=      60, maxTarget=parseList &amp;lt;split-8113&amp;gt;        ----------              :        Cloned                  : count=2752, sum=         0, min=       0, average=        0,00, max=       0, maxTarget=Array.prototype.push        Not Cloned              : count=2752, sum=      7747, min=       0, average=        2,82, max=     110, maxTarget=forEachChild    Truffle loops               : count=2752, sum=       723, min=       0, average=        0,26, max=      12, maxTarget=pipelineEmitWithComments  ---------------------------   :  Compilation Tier 1            :    Compilation Rate            :    471075,74 bytes/second    Truffle Tier Rate           :   1273853,94 bytes/second    Graal Tier Rate             :    922948,70 bytes/second    Installation Rate           :   5640071,94 bytes/second    Time for compilation (us)   : count=2637, sum=  20538922, min=     727, average=     7788,75, max= 2154173, maxTarget=createPrinter      Truffle Tier (us)         : count=2623, sum=   7595366, min=     255, average=     2895,68, max=  306107, maxTarget=createPrinter      Graal Tier (us)           : count=2623, sum=  10483126, min=     378, average=     3996,62, max= 1665018, maxTarget=createPrinter      Code Installation (us)    : count=2623, sum=   1715472, min=      39, average=      654,01, max=  183048, maxTarget=createPrinter    Graal node count            :      After Truffle Tier        : count=2627, sum=   1089218, min=      88, average=      414,62, max=   12999, maxTarget=forEachChild      After Graal Tier          : count=2624, sum=   2190826, min=     127, average=      834,92, max=   63837, maxTarget=createPrinter    Graal compilation result    :      Code size                 : count=2623, sum=   9675388, min=     492, average=     3688,67, max=  238448, maxTarget=createPrinter      Total frame size          : count=2623, sum=    350080, min=      64, average=      133,47, max=    5328, maxTarget=createPrinter      Exception handlers        : count=2623, sum=      9316, min=       1, average=        3,55, max=     125, maxTarget=forEachChild      Infopoints                : count=2623, sum=    105619, min=       5, average=       40,27, max=    1837, maxTarget=forEachChild        CALL                    : count=2623, sum=    105619, min=       5, average=       40,27, max=    1837, maxTarget=forEachChild    Marks                       : count=2623, sum=     13115, min=       5, average=        5,00, max=       5, maxTarget=Array.prototype.push    Data references             : count=2623, sum=    185670, min=       9, average=       70,79, max=    4153, maxTarget=createPrinter  ---------------------------   :  Compilation Tier 2            :    Compilation Rate            :    141825,62 bytes/second    Truffle Tier Rate           :    397107,38 bytes/second    Graal Tier Rate             :    243094,58 bytes/second    Installation Rate           :   4122848,22 bytes/second    Time for compilation (us)   : count= 123, sum=  11418247, min=     745, average=    92831,28, max=  456707, maxTarget=checkSignatureDeclaration      Truffle Tier (us)         : count= 120, sum=   4077990, min=     288, average=    33983,25, max=  152158, maxTarget=WhileNode$WhileDoRepeatingNode@72d2eaac typescript-polybench.js:16129~ &#39;utf8ToBytes&#39;&amp;lt;OSR&amp;gt;      Graal Tier (us)           : count= 120, sum=   6661604, min=     310, average=    55513,37, max=  343028, maxTarget=checkSignatureDeclaration      Code Installation (us)    : count= 120, sum=    392786, min=      42, average=     3273,22, max=   68576, maxTarget=JSArrayBufferView.@52bcd02    Graal node count            :      After Truffle Tier        : count= 125, sum=    331695, min=      13, average=     2653,56, max=   11989, maxTarget=checkSignatureDeclaration      After Graal Tier          : count= 120, sum=    432639, min=      46, average=     3605,33, max=   19199, maxTarget=checkSignatureDeclaration    Graal compilation result    :      Code size                 : count= 120, sum=   1619400, min=     192, average=    13495,00, max=   72744, maxTarget=checkSignatureDeclaration      Total frame size          : count= 120, sum=     25728, min=      48, average=      214,40, max=     768, maxTarget=bindEach &amp;lt;split-2459&amp;gt;      Exception handlers        : count= 120, sum=      1080, min=       0, average=        9,00, max=      84, maxTarget=checkSignatureDeclaration      Infopoints                : count= 120, sum=      7236, min=       3, average=       60,30, max=     401, maxTarget=checkSignatureDeclaration        CALL                    : count= 120, sum=      7236, min=       3, average=       60,30, max=     401, maxTarget=checkSignatureDeclaration    Marks                       : count= 120, sum=      1116, min=       5, average=        9,30, max=      35, maxTarget=checkIndexConstraintForProperty    Data references             : count= 120, sum=     25252, min=       4, average=      210,43, max=    1369, maxTarget=checkSignatureDeclarationThe --engine.CompilationStatisticDetails command prints histogram information on individual Graal nodes in addition to the previous compilation statistics:  Graal nodes after Truffle tier                    :      FrameState                                    : count= 168, sum=   35502, min=       1, average=      211.32, max=    2048, maxTarget=deltaBlue      FixedGuardNode                                : count= 168, sum=   18939, min=       0, average=      112.73, max=    1048, maxTarget=change      LoadFieldNode                                 : count= 168, sum=   14432, min=       0, average=       85.90, max=     814, maxTarget=EditConstraint      ...  Graal nodes after Graal tier                      :      BeginNode                                     : count= 166, sum=   33333, min=       0, average=      200.80, max=    2110, maxTarget=change      FrameState                                    : count= 166, sum=   30591, min=       0, average=      184.28, max=    2393, maxTarget=MeasureDefault      AMD64AddressNode                              : count= 166, sum=   20072, min=       0, average=      120.92, max=    1960, maxTarget=MeasureDefault      ...The --engine.TraceSourceCache command prints a line for each source cache miss, eviction, or failure. --engine.TraceSourceCacheDetails additionally prints a line for each source cache hit or uncache miss:[engine] source-cache-miss  0xb0b56c7b octane-deltablue.js                               |ParseTime  294 ms|Engine 2 |Layer 1 |CallTarget 27   |Lang js        |Policy EXCLUSIVE|WEAK    |UTC 2025-07-08T08:25:19.042[engine] source-cache-hit   0xb0b56c7b octane-deltablue.js                               |Hits            1|Engine 2 |Layer 1 |CallTarget 27   |Lang js        |Policy EXCLUSIVE|WEAK    |UTC 2025-07-08T08:25:19.280[engine] source-cache-evict 0xb0b56c7b octane-deltablue.js                               |Hits            7|Engine 2 |Layer 1 |CallTarget 27   |Lang js        |Policy EXCLUSIVE|WEAK    |UTC 2025-07-08T08:25:21.007Repeated source cache evictions of the same sources may lead to repeated parsing and compilation of the same sources under different call target IDs. This usually points at a bug on the embedder size - missing or insufficient caching of sources.The --engine.SourceCacheStatistics command prints statistics on source cache for an engine when the engine is closed:[engine] Polyglot source cache statistics for engine 2--- SHARING LAYER 1; WEAK CACHE -------------------------    Languages                                  :         regex                                 :            Character Based Sources Stats      :                Sources                        : count=             14                    Size (C)                   : count=             14, sum=                     384, min=      20, avg=    27,43, max=         33, maxSource=0xde3bf656 /^--warmup-iterations(?:=(.*))?$/                    Biggest Sources            :                        0xc34c7396             : size=              33, name=/^--show-intermediate(?:=(.*))?$/                        0xde3bf656             : size=              33, name=/^--warmup-iterations(?:=(.*))?$/                        0x58e35256             : size=              30, name=/^--profile-memory(?:=(.*))?$/                        ...                Cache                          : parse time(ms)=   193, parse rate(C/s)=     1989,64, hits=      0, misses=    14, evictions=    0, failures=    0, hit rate= 0%                    Parse Successful           : count=             14                        Time (ms)              : count=             14, sum=                     193, min=       4, avg=    13,79, max=         51, maxSource=0x5618ad36 /^--iterations(?:=(.*))?$/                        Size (C)               : count=             14, sum=                     384, min=      20, avg=    27,43, max=         33, maxSource=0xde3bf656 /^--warmup-iterations(?:=(.*))?$/                    Sources With Most Hits     :                        0xbb7ccb96             : parse time(ms)=     5, parse rate(C/s)=     4600,00, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--buckets(?:=(.*))?$/                        0x8facaf76             : parse time(ms)=    14, parse rate(C/s)=     2071,43, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--deterministic(?:=(.*))?$/                        0x8abc7416             : parse time(ms)=    10, parse rate(C/s)=     2500,00, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--dump-heap(?:=(.*))?$/                        ...                    Sources With Most Misses   :                        0xbb7ccb96             : parse time(ms)=     5, parse rate(C/s)=     4600,00, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--buckets(?:=(.*))?$/                        0x8facaf76             : parse time(ms)=    14, parse rate(C/s)=     2071,43, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--deterministic(?:=(.*))?$/                        0x8abc7416             : parse time(ms)=    10, parse rate(C/s)=     2500,00, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--dump-heap(?:=(.*))?$/                        ...                    Sources With Most Evictions:                        0xbb7ccb96             : parse time(ms)=     5, parse rate(C/s)=     4600,00, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--buckets(?:=(.*))?$/                        0x8facaf76             : parse time(ms)=    14, parse rate(C/s)=     2071,43, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--deterministic(?:=(.*))?$/                        0x8abc7416             : parse time(ms)=    10, parse rate(C/s)=     2500,00, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=/^--dump-heap(?:=(.*))?$/                        ...                    Failures                   : count=              0         js                                    :            Character Based Sources Stats      :                Sources                        : count=              2                    Size (C)                   : count=              2, sum=                   53256, min=   25744, avg= 26628,00, max=      27512, maxSource=0x0e851a37 harness.js                    Biggest Sources            :                        0x0e851a37             : size=           27512, name=harness.js                        0xb0b56c7b             : size=           25744, name=octane-deltablue.js                Cache                          : parse time(ms)=   649, parse rate(C/s)=    82058,55, hits=      0, misses=     2, evictions=    0, failures=    0, hit rate= 0%                    Parse Successful           : count=              2                        Time (ms)              : count=              2, sum=                     649, min=     294, avg=   324,50, max=        355, maxSource=0x0e851a37 harness.js                        Size (C)               : count=              2, sum=                   53256, min=   25744, avg= 26628,00, max=      27512, maxSource=0x0e851a37 harness.js                    Sources With Most Hits     :                        0x0e851a37             : parse time(ms)=   355, parse rate(C/s)=    77498,59, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=harness.js                        0xb0b56c7b             : parse time(ms)=   294, parse rate(C/s)=    87564,63, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=octane-deltablue.js                    Sources With Most Misses   :                        0x0e851a37             : parse time(ms)=   355, parse rate(C/s)=    77498,59, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=harness.js                        0xb0b56c7b             : parse time(ms)=   294, parse rate(C/s)=    87564,63, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=octane-deltablue.js                    Sources With Most Evictions:                        0x0e851a37             : parse time(ms)=   355, parse rate(C/s)=    77498,59, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=harness.js                        0xb0b56c7b             : parse time(ms)=   294, parse rate(C/s)=    87564,63, hits=      0, misses=     1, evictions=    0, failures=    0, hit rate= 0%, name=octane-deltablue.js                    Failures                   : count=              0The --engine.SourceCacheStatisticDetails command prints statistics on source cache for an engine when the engine is closed. Statistics for all individual sources are printed.The --engine.TraceMethodExpansion=truffleTier command prints a tree of all expanded Java methods with statistics after each compilation:[engine] Expansion tree for test after truffleTier:Name                                                                                Frequency | Count    Size  Cycles   Ifs Loops Invokes Allocs | Self Count  Size Cycles   Ifs Loops Invokes Allocs | IRNode ASTNode Lang:File:Line:Chars&amp;lt;root&amp;gt;                                                                                   1.00 |    64      72      42     1     1       0      1 |         34    20      0     0     0       0      0 |  - OptimizedCallTarget.profiledPERoot(Object)                                              1.00 |    30      52      42     1     1       0      1 |          1     2      2     0     0       0      0 |    121  OptimizedCallTarget.injectArgumentsProfile(Object)                                     1.00 |     9      19      16     0     0       0      0 |          4     3      0     0     0       0      0 |      5   OptimizedCallTarget.unsafeCast(Object, Class, Z, Z, Z)                                1.00 |     1       0       0     0     0       0      0 |          1     0      0     0     0       0      0 |     10   OptimizedCallTarget.castArgumentsImpl(Object, Class)                                  1.00 |     4      16      16     0     0       0      0 |          4    16     16     0     0       0      0 |     12  OptimizedCallTarget.executeRootNode(VirtualFrame)                                      1.00 |    20      31      24     1     1       0      1 |          0     0      0     0     0       0      0 |   JavaScriptRealmBoundaryRootNode.execute(VirtualFrame)                                 1.00 |    20      31      24     1     1       0      1 |          1     1      0     0     0       0      0 |     34       0 js:test.js:1:0-100    JavaScriptRealmBoundaryRootNode.getRealm()                                           1.00 |     1       1       0     0     0       0      0 |          0     0      0     0     0       0      0 |              0 js:test.js:1:0-100     JSContext.getRealm()                                                                1.00 |     1       1       0     0     0       0      0 |          0     0      0     0     0       0      0 |      PolyglotReferences$AssumeSingleContext.get()                                       1.00 |     1       1       0     0     0       0      0 |          0     0      0     0     0       0      0 |       PolyglotReferences$WeakSingleContext.get()                                        1.00 |     1       1       0     0     0       0      0 |          1     1      0     0     0       0      0 |     37    FunctionRootNode.executeInRealm(VirtualFrame)                                        1.00 |    18      29      24     1     1       0      1 |          1     1      0     0     0       0      0 |     41       0 js:test.js:1:0-100     FunctionBodyNode.execute(VirtualFrame)                                              1.00 |    17      28      24     1     1       0      1 |          0     0      0     0     0       0      0 |              1 js:test.js:1:0-100      AbstractBlockNode.execute(VirtualFrame)                                            1.00 |    17      28      24     1     1       0      1 |          0     0      0     0     0       0      0 |       AbstractBlockNode.executeVoid(VirtualFrame, JavaScriptNode, I, I)                 1.00 |    16      20      16     1     1       0      0 |          1     1      0     0     0       0      0 |     50       2 js:test.js:1:16-100        WhileNode.executeVoid(VirtualFrame)                                              1.00 |    15      19      16     1     1       0      0 |          0     0      0     0     0       0      0 |              7 js:test.js:3:35-84         OptimizedOSRLoopNode.execute(VirtualFrame)                                    101.00 |    15      19      16     1     1       0      0 |          4     3      2     0     1       0      0 |     46       8 js:test.js:3:35-84          RepeatingNode.executeRepeatingWithValue(VirtualFrame)                          1.00 |    11      16      14     1     0       0      0 |          1     1      0     0     0       0      0 |    100       9 js:test.js:3:35-84           WhileNode$WhileDoRepeatingNode.executeRepeating(VirtualFrame)               101.00 |    10      15      14     1     0       0      0 |          3     2      1     1     0       0      0 |     63       9 js:test.js:3:35-84            AbstractRepeatingNode.executeCondition(VirtualFrame)                       101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |              9 js:test.js:3:35-84             StatementNode.executeConditionAsBoolean(VirtualFrame, JavaScriptNode)     101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |              JSLessThanNodeGen.executeBoolean(VirtualFrame)                           101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |             10 js:test.js:3:51-58               JSLessThanNodeGen.executeBoolean_int_int0(VirtualFrame, J)              101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |                JSLessThanNode.doInt(I, I)                                             101.00 |     1       1       1     0     0       0      0 |          1     1      1     0     0       0      0 |     59      10 js:test.js:3:51-58            AbstractRepeatingNode.executeBody(VirtualFrame)                            101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |              9 js:test.js:3:35-84             AbstractBlockNode.executeVoid(VirtualFrame)                               101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |              AbstractBlockNode.executeVoid(VirtualFrame, JavaScriptNode, I, I)        101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             13 js:test.js:3:35-84               JSWriteCurrentFrameSlotNodeGen.executeVoid(VirtualFrame)                101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             14 js:test.js:4:71-79                JSWriteCurrentFrameSlotNodeGen.executeInt(VirtualFrame)                101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |             14 js:test.js:4:71-79                 JSAddNodeGen.executeInt(VirtualFrame)                                 101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |                  JSAddNode.doInt(I, I)                                                101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |                   Math.addExact(I, I)                                                 100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     75      15 js:test.js:4:71-74                LocalVarPostfixIncNodeGen.executeInt(VirtualFrame)                     101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |             18 js:test.js:3:60-63                 LocalVarPostfixIncNode.doInt(Frame)                                   101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |             18 js:test.js:3:60-63                  LocalVarIncNode$IncOp.doInt(I)                                       101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |                   Math.addExact(I, I)                                                 100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     85       AbstractBlockNode.executeGeneric(VirtualFrame, JavaScriptNode, I, I)              1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |              2 js:test.js:1:16-100        ReturnNode$TerminalPositionReturnNode.execute(VirtualFrame)                      1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |             20 js:test.js:6:87-98         JSReadCurrentFrameSlotNodeGen.execute(VirtualFrame)                             1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |          Integer.valueOf(I)                                                             1.00 |     1       8       8     0     0       0      1 |          1     8      8     0     0       0      1 |    139      21 js:test.js:6:94-97The --engine.TraceNodeExpansion=truffleTier command prints a tree of all expanded Truffle nodes with statistics after each compilation.This view groups the method expansion tree by node id:[engine] Expansion tree for test after truffleTier:Name                                                       Frequency | Count    Size  Cycles   Ifs Loops Invokes Allocs | Self Count  Size Cycles   Ifs Loops Invokes Allocs | IRNode ASTNode Lang:File:Line:Chars&amp;lt;call-root&amp;gt;                                                     1.00 |    64      72      42     1     1       0      1 |         44    41     18     0     0       0      0 |      0 FunctionRootNode                                               1.00 |    20      31      24     1     1       0      1 |          3     3      0     0     0       0      0 |     34       0 js:test.js:1:0-100  FunctionBodyNode                                              1.00 |    17      28      24     1     1       0      1 |          0     0      0     0     0       0      0 |              1 js:test.js:1:0-100   ExprBlockNode                                                1.00 |    17      28      24     1     1       0      1 |          1     1      0     0     0       0      0 |     50       2 js:test.js:1:16-100    WhileNode                                                   1.00 |    15      19      16     1     1       0      0 |          0     0      0     0     0       0      0 |              7 js:test.js:3:35-84     OptimizedOSRLoopNode$OptimizedDefaultOSRLoopNode         101.00 |    15      19      16     1     1       0      0 |          4     3      2     0     1       0      0 |     46       8 js:test.js:3:35-84      WhileNode$WhileDoRepeatingNode                          101.00 |    11      16      14     1     0       0      0 |          4     3      1     1     0       0      0 |    100       9 js:test.js:3:35-84       JSLessThanNodeGen                                      101.00 |     1       1       1     0     0       0      0 |          1     1      1     0     0       0      0 |     59      10 js:test.js:3:51-58       VoidBlockNode                                          101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             13 js:test.js:3:35-84        JSWriteCurrentFrameSlotNodeGen                        101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             14 js:test.js:4:71-79         JSAddNodeGen                                         100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     75      15 js:test.js:4:71-74         LocalVarPostfixIncNodeGen                            100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     85      18 js:test.js:3:60-63    ReturnNode$TerminalPositionReturnNode                       1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |             20 js:test.js:6:87-98     JSReadCurrentFrameSlotNodeGen                              1.00 |     1       8       8     0     0       0      1 |          1     8      8     0     0       0      1 |    139      21 js:test.js:6:94-97The --engine.MethodExpansionStatistics=truffleTier command prints statistics on expanded Java methods during partial evaluation at the end of a run.This can be useful to detect code that produces too many or certain Graal nodes unexpectedly:[engine] Method expansion statistics after truffleTier:Name                                                                       Count IR Nodes (min avg max)        Size (min avg max)      Cycles (min avg max)       Ifs  Loops Invokes Allocs | Max IRNode ASTNode Unit:Lang:File:Line:Chars  &amp;lt;no-source-position&amp;gt;                                                         1      212 (212 212.0 212)       117 (117 117.0 117)         0 (0 0.0 0)             0      0       0      0 |          0         mandelbrot  OptimizedOSRLoopNode.execute(VirtualFrame)                                   4       13 (0 3.3 5)               9 (0 2.3 3)               6 (0 1.5 2)             0      3       0      0 |        172      60 mandelbrot:js:mandelbrot.js:68:2589-2888  Math.addExact(I, I)                                                          4       12 (3 3.0 3)              24 (6 6.0 6)              24 (6 6.0 6)             0      0       0      0 |        485     103 mandelbrot:js:mandelbrot.js:80:2874-2875  WhileNode$WhileDoRepeatingNode.executeRepeating(VirtualFrame)                4        9 (0 2.3 3)               6 (0 1.5 2)               3 (0 0.8 1)             3      0       0      0 |         88      17 mandelbrot:js:mandelbrot.js:57:2374-3431  JSTypes.intToDouble(I)                                                       7        7 (1 1.0 1)               7 (1 1.0 1)              24 (0 3.4 8)             0      0       0      0 |        144      41 mandelbrot:js:mandelbrot.js:62:2478-2486  OptimizedCallTarget.castArgumentsImpl(Object, Class)                         1        7 (7 7.0 7)              25 (25 25.0 25)           24 (24 24.0 24)          0      0       0      0 |         12         mandelbrot  JSWriteCurrentFrameSlotNodeGen.executeVoid(VirtualFrame)                     6        6 (0 1.0 3)               4 (0 0.7 2)               2 (0 0.3 1)             2      0       0      0 |        563      46 mandelbrot:js:mandelbrot.js:64:2519-2544  AbstractBlockNode.executeVoid(VirtualFrame, JavaScriptNode, I, I)            8        6 (0 0.8 4)               6 (0 0.8 4)               0 (0 0.0 0)             0      0       0      0 |        177      39 mandelbrot:js:mandelbrot.js:61:2459-3416  Math.multiplyExact(I, I)                                                     4        6 (1 1.5 2)              12 (2 3.0 4)              20 (4 5.0 6)             0      0       0      0 |        155      49 mandelbrot:js:mandelbrot.js:64:2529-2534  OptimizedCallTarget.injectArgumentsProfile(Object)                           1        4 (4 4.0 4)               3 (3 3.0 3)               0 (0 0.0 0)             0      0       0      0 |          5         mandelbrot  JSMultiplyNode.doDouble(D, D)                                                4        4 (1 1.0 1)               4 (1 1.0 1)               8 (2 2.0 2)             0      0       0      0 |        280      75 mandelbrot:js:mandelbrot.js:70:2657-2663  IfNode.executeVoid(VirtualFrame)                                             3        3 (0 1.0 3)               2 (0 0.7 2)               1 (0 0.3 1)             1      0       0      0 |        606     126 mandelbrot:js:mandelbrot.js:93:3240-3397  Math.subtractExact(I, I)                                                     1        3 (3 3.0 3)               6 (6 6.0 6)               6 (6 6.0 6)             0      0       0      0 |        589     129 mandelbrot:js:mandelbrot.js:93:3249-3257  JSSubtractNode.doDouble(D, D)                                                3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        167      47 mandelbrot:js:mandelbrot.js:64:2528-2544  JSLessThanNode.doInt(I, I)                                                   3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        187      62 mandelbrot:js:mandelbrot.js:68:2596-2602  JSAddNode.doDouble(D, D)                                                     3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        263      67 mandelbrot:js:mandelbrot.js:69:2623-2639  JSDivideNode.doDouble(D, D)                                                  2        2 (1 1.0 1)               2 (1 1.0 1)              64 (32 32.0 32)          0      0       0      0 |        165      48 mandelbrot:js:mandelbrot.js:64:2528-2540  JSBitwiseXorNode.doInteger(I, I)                                             2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        575     119 mandelbrot:js:mandelbrot.js:90:3170-3173  JSEqualNode.doInt(I, I)                                                      2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        592     127 mandelbrot:js:mandelbrot.js:93:3244-3257  RepeatingNode.executeRepeatingWithValue(VirtualFrame)                        4        1 (0 0.3 1)               1 (0 0.3 1)               0 (0 0.0 0)             0      0       0      0 |        499      61 mandelbrot:js:mandelbrot.js:68:2589-2888  FunctionRootNode.executeInRealm(VirtualFrame)                                1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         53       0 mandelbrot:js:mandelbrot.js:50:2279-3447  OptimizedCallTarget.profiledPERoot(Object)                                   1        1 (1 1.0 1)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |        737         mandelbrot  PolyglotReferences$WeakSingleContext.get()                                   1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         41         mandelbrot  JSLeftShiftNode.doInteger(I, I)                                              1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        619     134 mandelbrot:js:mandelbrot.js:94:3269-3277  Integer.intValue()                                                           1        1 (1 1.0 1)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |         50       4 mandelbrot:js:1:0-0  JSSubtractNode.doInt(I, I)                                                   2        1 (0 0.5 1)               1 (0 0.5 1)               1 (0 0.5 1)             0      0       0      0 |        940     136 mandelbrot:js:mandelbrot.js:94:3282-3295  JSLeftShiftConstantNode.doInteger(I)                                         1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        527     107 mandelbrot:js:mandelbrot.js:83:2907-2922  JSSubtractNodeGen.executeDouble(VirtualFrame)                                3        1 (0 0.3 1)               1 (0 0.3 1)               0 (0 0.0 0)             0      0       0      0 |         33      47 mandelbrot:js:mandelbrot.js:64:2528-2544  JSReadCurrentFrameSlotNodeGen.executeInt(VirtualFrame)                       1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         74      19 mandelbrot:js:mandelbrot.js:57:2381-2382  Integer.valueOf(I)                                                           1        1 (1 1.0 1)               8 (8 8.0 8)               8 (8 8.0 8)             0      0       0      1 |        939     154 mandelbrot:js:mandelbrot.js:105:3442-3445  JSBitwiseOrNode.doInteger(I, I)                                              1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        532     106 mandelbrot:js:mandelbrot.js:83:2907-2931  JSGreaterThanNode.doDouble(D, D)                                             1        1 (1 1.0 1)               1 (1 1.0 1)               2 (2 2.0 2)             0      0       0      0 |        461      93 mandelbrot:js:mandelbrot.js:76:2800-2815  OptimizedCallTarget.unsafeCast(Object, Class, Z, Z, Z)                       1        1 (1 1.0 1)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |         10         mandelbrot  JavaScriptRealmBoundaryRootNode.execute(VirtualFrame)                        1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         38         mandelbrot  JSLeftShiftConstantNodeGen.executeInt(VirtualFrame)                          1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         36     107 mandelbrot:js:mandelbrot.js:83:2907-2922  DualNode.execute(VirtualFrame)                                               1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                  2 mandelbrot:js:mandelbrot.js:50:2279-3447  ...The --engine.NodeExpansionStatistics=truffleTier command prints statistics on expanded Truffle nodes during partial evaluation at the end of a run.This can be useful to detect code that produces too many or certain Graal nodes unexpectedly.It also shows individual specialization combinations as they were observed during compilation:[engine] Node expansion statistics after truffleTier:Name                                                    Count IR Nodes (min avg max)        Size (min avg max)      Cycles (min avg max)       Ifs  Loops Invokes Allocs | Max IRNode ASTNode Unit:Lang:File:Line:Chars  &amp;lt;call-root&amp;gt;                                               1      226 (226 226.0 226)       148 (148 148.0 148)        26 (26 26.0 26)          0      0       0      0 |          0         mandelbrot  OptimizedOSRLoopNode$OptimizedDefaultOSRLoopNode          4       13 (0 3.3 5)               9 (0 2.3 3)               6 (0 1.5 2)             0      3       0      0 |        172      60 mandelbrot:js:mandelbrot.js:68:2589-2888  JSAddConstantRightNumberNodeGen                           4       12 (3 3.0 3)              24 (6 6.0 6)              24 (6 6.0 6)             0      0       0      0 |        485     103 mandelbrot:js:mandelbrot.js:80:2874-2875    [doInt(I)]                                              4       12 (3 3.0 3)              24 (6 6.0 6)              24 (6 6.0 6)             0      0       0      0 |        485     103 mandelbrot:js:mandelbrot.js:80:2874-2875  JSMultiplyNodeGen                                         6       11 (1 1.8 3)              17 (1 2.8 6)              28 (2 4.7 10)            0      0       0      0 |        155      49 mandelbrot:js:mandelbrot.js:64:2529-2534    [doIntALargerZero(I, I), doIntBLargerZero(I, I)]        2        6 (3 3.0 3)              12 (6 6.0 6)              20 (10 10.0 10)          0      0       0      0 |        155      49 mandelbrot:js:mandelbrot.js:64:2529-2534    [doDouble(D, D)]                                        4        5 (1 1.3 2)               5 (1 1.3 2)               8 (2 2.0 2)             0      0       0      0 |        275      75 mandelbrot:js:mandelbrot.js:70:2657-2663  WhileNode$WhileDoRepeatingNode                            4       10 (0 2.5 4)               7 (0 1.8 3)               3 (0 0.8 1)             3      0       0      0 |        499      61 mandelbrot:js:mandelbrot.js:68:2589-2888  JSSubtractNodeGen                                         5        9 (1 1.8 3)              12 (1 2.4 6)              10 (1 2.0 6)             0      0       0      0 |        589     129 mandelbrot:js:mandelbrot.js:93:3249-3257    [doDouble(D, D)]                                        3        5 (1 1.7 2)               5 (1 1.7 2)               3 (1 1.0 1)             0      0       0      0 |         33      47 mandelbrot:js:mandelbrot.js:64:2528-2544    [doInt(I, I)]                                           2        4 (1 2.0 3)               7 (1 3.5 6)               7 (1 3.5 6)             0      0       0      0 |        589     129 mandelbrot:js:mandelbrot.js:93:3249-3257  JSWriteCurrentFrameSlotNodeGen                           18        7 (0 0.4 3)               5 (0 0.3 2)               2 (0 0.1 1)             2      0       0      0 |        563      46 mandelbrot:js:mandelbrot.js:64:2519-2544  JSDivideNodeGen                                           2        5 (2 2.5 3)               5 (2 2.5 3)              88 (40 44.0 48)          0      0       0      0 |        158      48 mandelbrot:js:mandelbrot.js:64:2528-2540    [doDouble(D, D)]                                        2        5 (2 2.5 3)               5 (2 2.5 3)              88 (40 44.0 48)          0      0       0      0 |        158      48 mandelbrot:js:mandelbrot.js:64:2528-2540  VoidBlockNode                                             7        5 (0 0.7 4)               5 (0 0.7 4)               0 (0 0.0 0)             0      0       0      0 |        177      39 mandelbrot:js:mandelbrot.js:61:2459-3416  JSAddNodeGen                                              3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        263      67 mandelbrot:js:mandelbrot.js:69:2623-2639    [doDouble(D, D)]                                        3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        263      67 mandelbrot:js:mandelbrot.js:69:2623-2639  JSLessThanNodeGen                                         3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        187      62 mandelbrot:js:mandelbrot.js:68:2596-2602    [doInt(I, I)]                                           3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        187      62 mandelbrot:js:mandelbrot.js:68:2596-2602  IfNode                                                    4        3 (0 0.8 3)               2 (0 0.5 2)               1 (0 0.3 1)             1      0       0      0 |        606     126 mandelbrot:js:mandelbrot.js:93:3240-3397  JSGreaterThanNodeGen                                      1        2 (2 2.0 2)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |        460      93 mandelbrot:js:mandelbrot.js:76:2800-2815    [doDouble(D, D)]                                        1        2 (2 2.0 2)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |        460      93 mandelbrot:js:mandelbrot.js:76:2800-2815  JSBitwiseXorNodeGen                                       2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        575     119 mandelbrot:js:mandelbrot.js:90:3170-3173    [doInteger(I, I)]                                       2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        575     119 mandelbrot:js:mandelbrot.js:90:3170-3173  JSLeftShiftConstantNodeGen                                1        2 (2 2.0 2)               2 (2 2.0 2)               1 (1 1.0 1)             0      0       0      0 |         36     107 mandelbrot:js:mandelbrot.js:83:2907-2922    [doInteger(I)]                                          1        2 (2 2.0 2)               2 (2 2.0 2)               1 (1 1.0 1)             0      0       0      0 |         36     107 mandelbrot:js:mandelbrot.js:83:2907-2922  JSReadCurrentFrameSlotNodeGen                             2        2 (1 1.0 1)               9 (1 4.5 8)               8 (0 4.0 8)             0      0       0      1 |         74      19 mandelbrot:js:mandelbrot.js:57:2381-2382  JSEqualNodeGen                                            2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        592     127 mandelbrot:js:mandelbrot.js:93:3244-3257    [doInt(I, I)]                                           2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        592     127 mandelbrot:js:mandelbrot.js:93:3244-3257  FunctionRootNode                                          1        2 (2 2.0 2)               2 (2 2.0 2)               0 (0 0.0 0)             0      0       0      0 |         53       0 mandelbrot:js:mandelbrot.js:50:2279-3447  ExprBlockNode                                             1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         69       5 mandelbrot:js:mandelbrot.js:50:2305-3447  JSBitwiseOrNodeGen                                        1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        532     106 mandelbrot:js:mandelbrot.js:83:2907-2931    [doInteger(I, I)]                                       1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        532     106 mandelbrot:js:mandelbrot.js:83:2907-2931  AccessIndexedArgumentNode                                 1        1 (1 1.0 1)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |         50       4 mandelbrot:js:1:0-0  JSLeftShiftNodeGen                                        2        1 (0 0.5 1)               1 (0 0.5 1)               1 (0 0.5 1)             0      0       0      0 |        619     134 mandelbrot:js:mandelbrot.js:94:3269-3277    [doInteger(I, I)]                                       1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        619     134 mandelbrot:js:mandelbrot.js:94:3269-3277    &amp;lt;unknown&amp;gt;                                               1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                134 mandelbrot:js:mandelbrot.js:94:3269-3277  FunctionBodyNode                                          1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                  1 mandelbrot:js:mandelbrot.js:50:2279-3447  ReturnNode$TerminalPositionReturnNode                     1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                153 mandelbrot:js:mandelbrot.js:105:3435-3445  DualNode                                                  1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                  2 mandelbrot:js:mandelbrot.js:50:2279-3447  WhileNode                                                 4        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                 15 mandelbrot:js:mandelbrot.js:57:2374-3431  DirectBreakTargetNode                                     2        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                 14 mandelbrot:js:mandelbrot.js:50:2305-3447The --engine.InstrumentBoundaries command prints, at the end of the process, information about runtime calls (@TruffleBoundary) made from compiled code.These cause objects to escape (are black-boxes to further optimization) and should generally be minimized.Also see the Branch Instrumentation guide for more details about instrumenting branches and boundaries.Execution profile (sorted by hotness)=====================================  0: *******************************************************************************  1:com.oracle.truffle.js.nodes.binary.JSAddNode.doStringInt(JSAddNode.java:177) [bci: 2][0] count = 22525269com.oracle.truffle.js.builtins.ConstructorBuiltins$ConstructDateNode.constructDateZero(ConstructorBuiltins.java:837) [bci: 6][1] count = 69510The --engine.InstrumentBranches command prints, at the end of the process, information of branch usage in compiled code:Execution profile (sorted by hotness)=====================================  2: ***************  1: **************  5: *************  4: ************  3: ********* 10: **  8: *  9: * 14: * ...com.oracle.truffle.js.nodes.access.PropertyGetNode.getValueOrDefault(PropertyGetNode.java:301) [bci: 55][2] state = BOTH(if=36486564#, else=44603498#)com.oracle.truffle.js.nodes.control.IfNode.execute(IfNode.java:158) [bci: 12][1] state = BOTH(if=72572593#, else=1305851#)com.oracle.truffle.js.nodes.function.JSFunctionCallNode.executeCall(JSFunctionCallNode.java:233) [bci: 18][5] state = BOTH(if=38703322#, else=32550439#)com.oracle.truffle.js.nodes.access.PropertyCacheNode$PrototypeShapeCheckNode.accept(PropertyCacheNode.java:364) [bci: 4][4] state = ELSE(if=0#, else=64094316#)com.oracle.truffle.js.nodes.control.WhileNode$WhileDoRepeatingNode.executeRepeating(WhileNode.java:230) [bci: 5][3] state = BOTH(if=44392142#, else=7096299#)...The --engine.SpecializationStatistics command prints detailed histograms about Node classes and their usage of Truffle DSL specializations.See Specialization Statistics for a tutorial on how to use it.Note: Specialization statistics require a recompilation of the interpreter. -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSWriteCurrentFrameSlotNodeGen                                               8 (17%)            18 (12%)        Min=         1 Avg=        2.25 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean &amp;lt;boolean&amp;gt;                                                          1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   doInt &amp;lt;int&amp;gt;                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|   doSafeIntegerInt                                                             0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doLong                                                                       0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject                                                                     7 (88%)            16 (89%)        Min=         1 Avg=        2.29 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;DynamicObjectBasic&amp;gt;                                                         6 (86%)            12 (75%)        Min=         1 Avg=        2.00 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;IteratorRecord&amp;gt;                                                             1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~1-8:16-130|     &amp;lt;String&amp;gt;                                                                     2 (29%)             2 (13%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     &amp;lt;Integer&amp;gt;                                                                    1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~6:105-123|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doBoolean]                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   [doInt, doObject]                                                            1 (13%)             4 (22%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5-7:76-128|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5-7:76-128|   [doObject]                                                                   6 (75%)            13 (72%)        Min=         1 Avg=        2.17 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSReadCurrentFrameSlotNodeGen                                                8 (17%)            25 (17%)        Min=         1 Avg=        3.13 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean                                                                    0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doInt &amp;lt;no-args&amp;gt;                                                              1 (13%)             1 (4%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject &amp;lt;no-args&amp;gt;                                                           8 (100%)           24 (96%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doInt, doObject]                                                            1 (13%)             4 (16%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5:81-87|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5:81-87|   [doObject]                                                                   7 (88%)            21 (84%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------Controlling What Is CompiledTo make the best use of the former options, limit what is compiled to the methods that you are interested in.      --engine.CompileOnly=foo restricts compilation to methods with foo in their name. Use this in combination with returning a value or taking parameters to avoid code being compiled away.        --engine.CompileImmediately compiles methods as soon as they are run.        --engine.BackgroundCompilation=false compiles synchronously, which can simplify things.        --compiler.Inlining=false disables inlining which can make code easier to understand.        --engine.OSR=false disables on-stack-replacement (compilation of the bodies of while loops for example) which can make code easier to understand.        --engine.Compilation=false turns off Truffle compilation all together.  Debugging DeoptimizationsSometimes compiled code deoptimizes (goes from Truffle compiled code back to the interpreter) unexpectedly.These are some ways to investigate why the code is deoptimized.It is very important for performance to avoid repeated deoptimizations.The --engine.TraceCompilation option shows deoptimizations with an [engine] opt deopt prefix, which is useful to evaluate if many deoptimizations happen.However, it shows no other details.Materializing a frame with FrameInstance#getFrame(READ_WRITE|MATERIALIZE) from the stack causes deoptimizations (but no invalidation).These deoptimizations can be traced with --engine.TraceDeoptimizeFrame.When using native images, you need to build the native image with -H:+IncludeNodeSourcePositions to enable stack traces for deoptimizations.These are disabled by default to save on image size.On natives images, --engine.TraceTransferToInterpreter prints an accurate stack trace for any deoptimization, it is effectively the same as --vm.XX:+TraceDeoptimization --engine.NodeSourcePositions.This is often the most efficient way to find where a deoptimization comes from thanks to the stracktrace.[Deoptimization initiated    name: String#[]    sp: 0x7ffd7b992710  ip: 0x7f26a8d8079f    reason: TransferToInterpreter  action: InvalidateReprofile    debugId: 25  speculation: jdk.vm.ci.meta.SpeculationLog$NoSpeculationReason@13dbed9e    stack trace that triggered deoptimization:        at org.truffleruby.core.string.StringNodesFactory$StringSubstringPrimitiveNodeFactory$StringSubstringPrimitiveNodeGen.execute(StringNodesFactory.java:12760)        at org.truffleruby.core.string.StringNodes$GetIndexNode.substring(StringNodes.java:836)        at org.truffleruby.core.string.StringNodes$GetIndexNode.getIndex(StringNodes.java:650)        at org.truffleruby.core.string.StringNodesFactory$GetIndexNodeFactory$GetIndexNodeGen.execute(StringNodesFactory.java:1435)        at org.truffleruby.language.RubyCoreMethodRootNode.execute(RubyCoreMethodRootNode.java:53)        at com.oracle.truffle.runtime.OptimizedCallTarget.executeRootNode(OptimizedCallTarget.java:632)        at com.oracle.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:603)[Deoptimization of frame    name: String#[]    sp: 0x7ffd7b992710  ip: 0x7f26a8d8079f    stack trace where execution continues:        at org.truffleruby.core.string.StringNodesFactory$StringSubstringPrimitiveNodeFactory$StringSubstringPrimitiveNodeGen.execute(StringNodesFactory.java:12760) bci 99  return address 0x4199a1d        at org.truffleruby.core.string.StringNodes$GetIndexNode.substring(StringNodes.java:836) bci 32 duringCall  return address 0x41608e0        at org.truffleruby.core.string.StringNodes$GetIndexNode.getIndex(StringNodes.java:650) bci 25 duringCall  return address 0x415f197        at org.truffleruby.core.string.StringNodesFactory$GetIndexNodeFactory$GetIndexNodeGen.execute(StringNodesFactory.java:1435) bci 109 duringCall  return address 0x4182391        at org.truffleruby.language.RubyCoreMethodRootNode.execute(RubyCoreMethodRootNode.java:53) bci 14 duringCall  return address 0x4239a29        at com.oracle.truffle.runtime.OptimizedCallTarget.executeRootNode(OptimizedCallTarget.java:632) bci 9 duringCall  return address 0x3f1c4c9        at com.oracle.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:603) bci 37 duringCall  return address 0x3f1d965]]On HotSpot, --engine.TraceTransferToInterpreter prints a stack trace only for explicit deoptimizations via CompilerDirectives.transferToInterpreterAndInvalidate() or CompilerDirectives.transferToInterpreter().The reported location can be incorrect if the deoptimization was caused by something else.In that case it will report the stracktrace of the next CompilerDirectives.transferToInterpreter* call even though it is not the cause.[engine] transferToInterpreter at  BinaryConstraint.output(../../../../4dev/js-benchmarks/octane-deltablue.js:416)    Constraint.satisfy(../../../../4dev/js-benchmarks/octane-deltablue.js:183)    Planner.incrementalAdd(../../../../4dev/js-benchmarks/octane-deltablue.js:597) &amp;lt;split-609bcfb6&amp;gt;    Constraint.addConstraint(../../../../4dev/js-benchmarks/octane-deltablue.js:165) &amp;lt;split-7d94beb9&amp;gt;    UnaryConstraint(../../../../4dev/js-benchmarks/octane-deltablue.js:219) &amp;lt;split-560348e6&amp;gt;    Function.prototype.call(&amp;lt;builtin&amp;gt;:1) &amp;lt;split-1df8b5b8&amp;gt;    EditConstraint(../../../../4dev/js-benchmarks/octane-deltablue.js:315) &amp;lt;split-23202fce&amp;gt;    ...  com.oracle.truffle.api.CompilerDirectives.transferToInterpreterAndInvalidate(CompilerDirectives.java:90)    com.oracle.truffle.js.nodes.access.PropertyCacheNode.deoptimize(PropertyCacheNode.java:1269)    com.oracle.truffle.js.nodes.access.PropertyGetNode.getValueOrDefault(PropertyGetNode.java:305)    com.oracle.truffle.js.nodes.access.PropertyGetNode.getValueOrUndefined(PropertyGetNode.java:191)    com.oracle.truffle.js.nodes.access.PropertyNode.executeWithTarget(PropertyNode.java:153)    com.oracle.truffle.js.nodes.access.PropertyNode.execute(PropertyNode.java:140)    ...On HotSpot, --vm.XX:+UnlockDiagnosticVMOptions --vm.XX:+DebugNonSafepoints --vm.XX:+TraceDeoptimization prints all deoptimization events (but no stacktraces), whether the code is compiled by Truffle or conventional compilers.The TraceDeoptimization option might require using a fastdebug JDK.Uncommon trap   bci=9 pc=0x00000001097f2235, relative_pc=501, method=com.oracle.truffle.js.nodes.access.PropertyNode.executeInt(Ljava/lang/Object;Ljava/lang/Object;)I, debug_id=0Uncommon trap occurred in com.oracle.truffle.runtime.OptimizedCallTarget::profiledPERoot compiler=JVMCI compile_id=2686 (JVMCI: installed code name=BinaryConstraint.output#2)  (@0x00000001097f2235) thread=5891 reason=transfer_to_interpreter action=reinterpret unloaded_class_index=-1 debug_id=0Finally, on native images, --vm.XX:+TraceDeoptimizationDetails prints additional information:[Deoptimization initiated    name: BinaryConstraint.output    sp: 0x7ffee7324d90  ip: 0x1126c51a8    reason: TransferToInterpreter  action: InvalidateReprofile    debugId: 3  speculation: jdk.vm.ci.meta.SpeculationLog$NoSpeculationReason@10f942aa0[Deoptimization of frame    name: BinaryConstraint.output    sp: 0x7ffee7324d90  ip: 0x1126c51a8    stack trace where execution continues:        at com.oracle.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:475) bci 0  return address 0x10aab9e5e            com.oracle.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:475)            bci: 0  deoptMethodOffset: 35524160  deoptMethod: 0x10aab9e40  return address: 0x10aab9e5e  offset: 0            slot 0  kind: Object  value: com.oracle.svm.truffle.api.SubstrateOptimizedCallTarget@0x112cbbaa0  offset: 64            slot 1  kind: Object  value: [Ljava.lang.Object;@0x1144a7db0  offset: 56]]You might notice the presence of a debugId or debug_id in the output of these options.This id might only be set if you also enable dumping, e.g., via --vm.Djdk.graal.Dump=Truffle:1 (see below).In that case, the debug id will correspond to the id of a node in the IGV graph.First, open the first phase of the relevant compilation.That id can be searched via id=NUMBER in IGV’s Search in Nodes search box,then selecting Open Search for node NUMBER in Node Searches window,and then clicking the Search in following phases button.Automatic Detection of Deoptimization CyclesSince the version 25, Truffle has an automatic deoptimization cycle detection feature. This feature is available and enabled by default when running optimized on JDK 25 and later.Whenever a deoptimization cycle is detected, the compilation fails with a permanent bailout that contains the Java stacktrace of the location, if available.Compilation failures are not printed by default. One way of printing compilation failures is to set the option engine.CompilationFailureAction to Print. This also prints an approximated stack trace of the deoptimization location.  Note: To get the approximated stack trace of the deoptimization location in a native image, the image has to be built with -H:+IncludeNodeSourcePositions.Deoptimization cycle detection can be completely disabled by setting compiler.DeoptCycleDetectionThreshold to -1.Example:The following is a simple program that causes a deoptimization cycle.public class DeoptCycleDetectionTest {    static class InvalidArgumentProfilingNode extends RootNode {        @CompilerDirectives.CompilationFinal        boolean cachedValue;        protected InvalidArgumentProfilingNode() {            super(null);        }        @Override        public Object execute(VirtualFrame frame) {            boolean arg = (boolean) frame.getArguments()[0];            if (this.cachedValue != arg) {                // Bug: repeated non-stabilizing deoptimization                CompilerDirectives.transferToInterpreterAndInvalidate();                this.cachedValue = arg;            }            return this.cachedValue;        }    }    public static void main(String[] args) {        try (Context context = Context.create()) {            context.enter();            CallTarget callTarget = new InvalidArgumentProfilingNode().getCallTarget();            for (int i = 0; i &amp;lt; Integer.MAX_VALUE; i++) {                callTarget.call(i % 2 == 0);            }        }    }}In general, when no new code to compile is introduced, Truffle compilations should eventually stabilize and no new compilations/deoptimizations should be produced. However, the above root nodeInvalidArgumentProfilingNode contains a bug which causes a deoptimization cycle. When the root node is executed repeatedly and the argument keeps changing, the number of deoptimizations/recompilations is unlimited.The following command executes the program with the default deoptimization cycle detection and a deopt stacktrace printing for any detected repeated deoptimization.java -Dpolyglot.engine.CompilationFailureAction=Print DeoptCycleDetectionTestThe expected output is[engine] opt fail     DeoptCycleDetectionTest.InvalidArgumentProfilingNode@761490b0|AST      1jdk.graal.compiler.code.SourceStackTraceBailoutException$1:jdk.graal.compiler.code.SourceStackTraceBailoutException:jdk.graal.compiler.core.common.PermanentBailoutException:jdk.graal.compiler.core.common.GraalBailoutException:jdk.vm.ci.code.BailoutException:java.lang.RuntimeException:java.lang.Exception:jdk.graal.compiler.code.SourceStackTraceBailoutException$1: Deopt taken too many times: 270|Deopt. This could indicate a deopt cycle, which typically hints at a bug in the language implementation or Truffle.at DeoptCycleDetectionTest$InvalidArgumentProfilingNode.execute(DeoptCycleDetectionTest.java:19)at com.oracle.truffle.runtime.OptimizedCallTarget.executeRootNode(OptimizedCallTarget.java:823)at com.oracle.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:747)This tells us that a deopt cycle was detected and the stacktrace points to the if condition testing the argument as the location of the repeated deopt. The information about the precise location of the CompilerDirectives.transferToInterpreterAndInvalidate() is lost, but the compiler knows one branch of the if statement leads to the repeated deopt that causes the deopt cycle and so the if condition is determined as the location of the deopt. If the compilation was dumped, the appropriate compilation graph would show the deoptimization node with id 270 is in the false branch of the if statement:The sensitivity of the deoptimization cycle detection can be fine-tuned by the options compiler.DeoptCycleDetectionThreshold and compiler.DeoptCycleDetectionAllowedRepeats.After the number of successful compilations of a call target reaches compiler.DeoptCycleDetectionThreshold, the subsequent Truffle compilations of the call target execute an extra deoptimization cycle detection phase that adds information to the compilation framework which allows it to later detect that the exactly same compiled code was deoptimized at the exatly same location repeatedly. If that happens the compilation fails with a permanent bailout. If compiler.DeoptCycleDetectionAllowedRepeats is set to a higher value than the default 0, the compilation will only fail after the same deopt is repeated more times than the allowed count.See Deoptimization Cycle Patterns to learn about common patterns that cause deoptimization cycles and thus should be avoided.Debugging InvalidationsInvalidations happen when a compiled CallTarget is thrown away.The most common causes are:  An explicit CompilerDirectives.transferToInterpreterAndInvalidate() (an internal invalidation)  One of the Assumption used by that CallTarget has been invalidated (an external invalidation).Use --engine.TraceAssumptions to trace those with more details.The --engine.TraceCompilation option also shows CallTarget invalidations with an [engine] opt inv. prefix.Uncovering Optimization Barriers: Compiler-Level Insights for Truffle AppsOnce you are comfortable profiling Truffle applications and analyzing results (see Profiling), you may reach a point where you wonder, “Why is this benchmark slower than expected?” After determining that the majority of execution time is spent in compiled code, the next step is a deeper analysis of the generated machine code.Start by identifying “hot” compilation units and addressing any Truffle performance warnings (see Step 4 of this document). However, you may still encounter limitations in performance even after resolving these.In such cases, reviewing compiler-level performance warnings can be insightful. While in-depth knowledge of Graal compiler internals is not required here, some warnings surfaced at the compiler level can be actionable by Truffle developers.The Graal compiler offers a compiler analysis phase that emits performance warnings during code compilation. These are similar to Truffle performance warnings but may surface later in the pipeline and are not always directly actionable.Enabling Compiler-Level MetricsTo enable reporting of these metrics, launch your application with:--vm.Djdk.graal.ReportHotMetrics=&amp;lt;method filter&amp;gt;This prints warnings and hot spots to stdout for all compilation units.To narrow the output to specific methods or functions, use known method names like *wasm-function:5311*:--vm.Djdk.graal.ReportHotMetrics=&#39;*wasm-function:5311*&#39;To improve the quality of the generated data, run with node source position tracking --vm.Djdk.graal.TrackNodeSourcePosition=true.Example OutputReporting hot metrics before HighTierLoweringPhase during compilation of wasm-function:5311[Hot Code Warning] Unknown profile for 704|If with f=241.99984874999717 in hot loop Loop (depth=1) 4951258|LoopBegin, node source position is         at org.graalvm.wasm.nodes.WasmFunctionNode.executeBodyFromOffset(WasmFunctionNode.java:363) [bci: 1654]        at org.graalvm.wasm.nodes.WasmFunctionNode.execute(WasmFunctionNode.java:241) [bci: 15]        [...cut for brevity...]        Potential Action Item: Add profile to the top-of-stack source location.Interpreting Results:  [Hot Code Info] lines highlight the hottest basic blocks and loops.          “Local frequency” is the number of times the block is executed per loop iteration.      “Global frequency” is across the entire method. A value of 1 means the basic block executes once per method invocation.        [Hot Code Warning] denotes locations or IR patterns that may inhibit optimization.          Warnings include, for example, missing profile data in hot paths (for example, unknown profile for 704|If …), which is a common actionable warning.      Some warnings may be actionable, while others are for informational purposes. If you encounter frequent or unexplained compiler warnings in your hottest methods and are unsure how to proceed, please reach out to the Truffle community via our Slack channels for advice.Ideal Graph VisualizerThe Ideal Graph Visualizer (IGV) is a tool to understand Truffle ASTs and the Graal Compiler graphs.A typical usage is to run with --vm.Djdk.graal.Dump=Truffle:1 --vm.Djdk.graal.PrintGraph=Network, which will show you Truffle ASTs, guest-language call graphs, and the Graal graphs as they leave the Truffle phase.If the -Djdk.graal.PrintGraph=Network flag is omitted then the dump files are placed in the graal_dumps directory, which you should then open in IGV.Use --vm.Djdk.graal.Dump=Truffle:2 to dump Graal graphs between each compiler phase.C1 VisualizerThe C1 Visualizer is a tool to understand the Low Level IR (LIR), register allocation, andcode generation stages of GraalVM. It is available here.A typical usage is --vm.Djdk.graal.Dump=:3.Files are put into a graal_dumps directory which you should then open in the C1 Visualizer.DisassemblerTHe --vm.XX:+UnlockDiagnosticVMOptions --vm.XX:+PrintAssembly commands combination prints assembly code.You will need to install hsdis using mx hsdis in graal/compiler, or manually install it into the current directory from here.Typical usage is --vm.Djdk.graal.Dump --vm.Djdk.graal.PrintBackendCFG=true. Files areput into a graal_dumps directory which you should then open in theC1 Visualizer.Combine with --vm.XX:TieredStopAtLevel=0 to disable compilation of runtime routines so that it’s easier to find your guest-language method.Note: You can also look at assembly code in the C1 Visualizer.These have been the most common and powerful ways to optimize or debug Truffle interpreters.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/Optimizing/"
          },
          
          "latest-reference-manual-java-options":  {
          "title": "Graal JIT Compiler Configuration",
          "content": "Graal JIT Compiler ConfigurationThe options to configure the Graal JIT compiler are in three categories: general, performance tuning, and diagnostic.  The Graal JIT compiler is mostly configured by system properties whose names begin with the jdk.graal prefix, set via -Djdk.graal... on the command line.The list of available properties can be printed using the -XX:+JVMCIPrintProperties option.General OptionsThese are general options for setting/getting configuration details.  -XX:-UseJVMCICompiler: Disables use of the Graal compiler as the top-tier JIT compiler.This is useful when you want to compare the performance of the Graal JIT compiler against a native JIT compiler.      -Djdk.graal.CompilerConfiguration=&amp;lt;name&amp;gt;: Selects the Graal JIT compiler configuration to use.If omitted, the compiler configuration with the highest auto-selection priority is selected.To see the available configurations, supply the value help to this option.    The names of the compiler configurations and their semantics are:          enterprise: Produces highly optimized code with a possible trade-off to compilation time (only available in Oracle GraalVM).      community: Produces reasonably optimized code with a faster compilation time.      economy: Compiles as fast as possible with less optimal throughput of the generated code.            -Djdk.graal.ShowConfiguration=&amp;lt;level&amp;gt;: Prints information about the Graal JIT compiler configuration selected.  This option only produces output when the compiler is initialized. By default, the Graal JIT compiler is  initialized on the first top-tier compilation. For this reason, the way to use this option  is as follows: java -XX:+EagerJVMCI -Djdk.graal.ShowConfiguration=info -version.    Accepted arguments are:          none: Shows no information.      info: Prints one line of output describing the compiler configuration in use and from where it is loaded.      verbose: Prints detailed compiler configuration information.            -Djdk.graal.SpectrePHTBarriers=&amp;lt;strategy&amp;gt;: Selects a strategy to mitigate speculative bounds check bypass (also known as Spectre-PHT or Spectre V1).    Accepted arguments are:          None: Uses no mitigations in JIT-compiled code. (Default.)      AllTargets: Uses speculative execution barrier instructions to stop speculative execution on all branch targets.  This option is equivalent to setting SpeculativeExecutionBarriers to true.  (This has a large performance impact.)      GuardTargets: Instruments branch targets relevant to Java memory safety with barrier instructions.  Protects only those branches that preserve Java memory safety.  (This option has a lower performance impact than AllTargets.)      NonDeoptGuardTargets: Same as GuardTargets, except that branches which are deoptimized, are not protected because they cannot be executed repeatedly and are, thus, less likely to be successfully exploited in an attack.        Note that all modes except None also instrument branch target blocks containing UNSAFE memory accesses with barrier instructions.  Performance Tuning Options  -Djdk.graal.Vectorization={ true | false }: To disable the auto vectorization optimization (only available in Oracle GraalVM). (Default: true.)  -Djdk.graal.OptDuplication={ true | false }: To disable the path duplication optimization (only available in Oracle GraalVM). (Default: true.)  -Djdk.graal.TuneInlinerExploration=&amp;lt;value&amp;gt;: To tune for better peak performance or faster warmup.It automatically adjusts values governing the effort spent during inlining. The value of the option is a float clamped between -1 and 1 inclusive. Anything below 0 reduces inlining effort and anything above 0 increases inlining effort. In general, peak performance is improved with more inlining effort while less inlining effort improves warmup (albeit to a lower peak). Note that this option is only a heuristic and the optimal value can differ from application to application (only available in Oracle GraalVM).Diagnostic Options      -Djdk.graal.CompilationFailureAction=&amp;lt;action&amp;gt;: Specifies the action to take when compilation fails by throwing an exception.    Accepted actions:          Silent: Print nothing to the console. (Default.)      Print: Print a stack trace to the console.      Diagnose: Retry the compilation with extra diagnostics enabled. On JVM exit, the collected diagnostics are saved to a ZIP file that can be submitted along with a bug report. A message is printed to the console describing where the diagnostics file is saved:        Graal diagnostic output saved in /Users/graal/graal_dumps/1549459528316/graal_diagnostics_22774.zip            ExitVM: Same as Diagnose except that the JVM process exits after retrying.        For all values except for ExitVM, the JVM continues.        -Djdk.graal.CompilationBailoutAsFailure={ true | false }: The compiler may not complete compilation of a method due to some property or code shape in the method (for example, exotic uses of the jsr and ret bytecodes). In this case the compilation bails out. If you want to be informed of such bailouts, this option makes the Graal JIT compiler treat bailouts as failures and thus be subject to the action specified by the -Djdk.graal.CompilationFailureAction option. (Default: false.)  Setting Compiler Options with Language LaunchersThe Graal JIT compiler properties above are usable with some other GraalVM launchers such as node and js. The prefix for specifying the properties is slightly different.For example:java -XX:+EagerJVMCI -Djdk.graal.ShowConfiguration=info -versionBecomes:js --vm.Djdk.graal.ShowConfiguration=info -version  Note the -D prefix is replaced by --vm.D.Related Documentation  Graal Compiler  Graal JIT Compiler Operations Manual",
          "url": " /latest/reference-manual/java/options/"
          },
          
          "latest-reference-manual-llvm-options":  {
          "title": "LLI Command Options",
          "content": "LLI Command OptionsThe syntax to execute programs in LLVM bitcode format with GraalVM is:lli [LLI options] [GraalVM options] [polyglot options] &amp;lt;bitcode file&amp;gt; [program args]Here, &amp;lt;bitcode file&amp;gt; is a compiled program with embedded LLVM bitcode.The following options to lli are available:      --llvm.managed: enable a managed execution mode for LLVM IR code, which means memoryallocations from LLVM bitcode are done on the managed heap. Learn more from Limitations and Differences to Native Execution. Note: The managed execution mode for LLVM bitcode is not available in GraalVM Community Edition.        --print-toolchain-path: print the path of the LLVM toolchain bundled with GraalVM.This directory contains compilers and tools that can be used to compile C/C++ programsto LLVM bitcode for execution on GraalVM.        --print-toolchain-api-tool &amp;lt;tool&amp;gt;: print the path of a tool from the LLVM toolchain.Valid values for &amp;lt;tool&amp;gt; are CC, CXX, LD, AR, NM, OBJCOPY, OBJDUMP,RANLIB, READELF, READOBJ, or STRIP.        --print-toolchain-api-paths &amp;lt;path&amp;gt;: print a search path for the LLVM toolchain.Valid values for &amp;lt;path&amp;gt; are PATH and LD_LIBRARY_PATH.        --print-toolchain-api-identifier: print a unique identifier of the LLVM toolchain.Different modes of the LLVM runtime (for example, --llvm.managed) might require compilationof bitcode with a different LLVM toolchain. This identifier can be used as a stabledirectory name to store build outputs for different modes.        -L &amp;lt;path&amp;gt;/--llvm.libraryPath=&amp;lt;path&amp;gt;: a list of paths where GraalVM will search forlibrary dependencies. Paths are delimited by :.        --lib &amp;lt;libs&amp;gt;/--llvm.libraries=&amp;lt;libs&amp;gt;: a list of libraries to load in addition tothe dependencies of the main binary. Files with a relative path are looked up relativeto llvm.libraryPath. Entries are delimited by :.        --version: print the version and exit.        --version:graalvm: print the GraalVM version information and exit.  Expert and Diagnostic OptionsUse --help and --help:&amp;lt;topic&amp;gt; to get a full list of options.",
          "url": " /latest/reference-manual/llvm/Options/"
          },
          
          "latest-reference-manual-js-options":  {
          "title": "Options",
          "content": "OptionsRunning JavaScript on GraalVM can be configured with several options.These options are to control the behavior of the js launcher:  -e, --eval &amp;lt;code&amp;gt;: evaluate the JavaScript source code, then exit the engine.     js -e &#39;print(1+2);&#39;    -f, --file &amp;lt;arg&amp;gt;: load and execute the provided script file. Note that the -f option is optional and can be omitted in most cases, as any additional argument to js will be interpreted as a file anyway.     js -f myfile.js    --module &amp;lt;arg&amp;gt;: load and execute the provided module file. Note that .mjs files are treated as modules by default.     js --module myfile.mjs    --version: print the version information of GraalJS, then exit.  --strict: execute the engine in JavaScript’s strict mode.GraalJS Engine OptionsThere are several options to configure the behavior of GraalJS.Depending on how the engine is started, the options can be passed either to the launcher or programmatically.For a full list of options of the JavaScript engine, pass the --help:js flag to the js launcher (available from GraalVM 22.1, for older releases use --help:languages).To include internal options, use --help:js:internal.Note that those lists both include stable, supported, and experimental options.Pass Options on the Command LineTo pass the options to the js launcher, use the  --js.&amp;lt;option-name&amp;gt;=&amp;lt;value&amp;gt; syntax. For example:js --js.ecmascript-version=2015Pass Options Programmatically Using the Context APIWhen embedded in Java using GraalVM’s Polyglot API, the options can be passed programmatically to the Context object:Context context = Context.newBuilder(&quot;js&quot;)                         .option(&quot;js.ecmascript-version&quot;, &quot;2015&quot;)                         .build();context.eval(&quot;js&quot;, &quot;42&quot;);See the Polyglot Programming reference for information on how to set options programmatically.Stable and Experimental OptionsThe available options are distinguished as stable and experimental options.If an experimental option is used, an extra option has to be provided upfront.Using the js launcher, --experimental-options has to be passed before all experimental options.When using a Context, the option allowExperimentalOptions(true) has to be called on a Context.Builder.See ScriptEngine Implementation on how to use experimental options with a ScriptEngine.Frequently Used Stable OptionsThe following stable options are frequently relevant:  --js.ecmascript-version: emulate a specific ECMAScript version. Integer value (5, 6, etc., 2015-2022), &quot;latest&quot; (latest supported version of the spec, including finished proposals), or &quot;staging&quot; (latest version including supported unfinished proposals). Default is &quot;latest&quot;.  --js.foreign-object-prototype: provide JavaScript’s default prototype to foreign objects that mimic JavaScript’s own types (foreign Arrays, Objects, and Functions). Boolean value, default is true.  --js.intl-402: enable ECMAScript Internationalization API. Boolean value, default is true.  --js.regexp-static-result: provide static RegExp properties containing the results of the last successful match, for example, RegExp.$1 (legacy). Boolean value, default is true.  --js.strict: enable strict mode for all scripts. Boolean value, default is false.  --js.console: enable the console global property. Boolean value, default is true.  --js.allow-eval: allow the code generation from strings, for example, using eval() or the Function constructor. Boolean value, default is true.  --js.timer-resolution: sets the resolution of timing functions, such as Date.now() and performance.now(), in nanoseconds. Default: 1000000 (i.e. 1 ms).  --js.unhandled-rejections: configure unhandled promise rejection tracking. Accepted values are none (default, no tracking), warn (print a warning to stderr), throw (throw an exception), and handler (invoke a custom handler).  --js.esm-eval-returns-exports: context.eval of an ES module Source returns its exported symbols.For a complete list, use js --help:js:internalECMAScript VersionThe --js.ecmascript-version option provides compatibility with a specific version of the ECMAScript specification.It expects an integer value, where both the edition numbers (5, 6, …) and the publication years (starting from 2015) are supported.As of GraalVM 21.2, latest, staging are also supported.The default in GraalVM 23.1 is the ECMAScript 2023 specification.GraalJS implements some features of the future draft specification and of open proposals, if you explicitly select that version and/or enable specific experimental options.For production settings, it is recommended to set the ecmascript-version to a released, finalized version of the specification (for example, 2022).Available versions are:  5 for ECMAScript 5.x  2015 (or 6) for ECMAScript 2015  2016 (or 7) for ECMAScript 2016  2017 (or 8) for ECMAScript 2017  2018 (or 9) for ECMAScript 2018  2019 (or 10) for ECMAScript 2019  2020 (or 11) for ECMAScript 2020  2021 (or 12) for ECMAScript 2021 (default in 21.3)  2022 (or 13) for ECMAScript 2022 (default in 22.0+)  2023 (or 14) for ECMAScript 2023 (default in 23.1)  2024 (or 15) for ECMAScript 2024 (default in 24.1)  latest for the latest supported language version (the default version)  staging for the latest supported language features including experimental unstable, unfinished proposals (do not use in production!)intl-402The --js.intl-402 option enables ECMAScript’s Internationalization API.It expects a Boolean value and the default is true.Strict ModeThe --js.strict option enables JavaScript&#39;s strict mode for all scripts.It expects a Boolean value and the default is false`.Frequently Used Experimental OptionsNote that these options are experimental and are not guaranteed to be maintained or available in the future.To use them, the --experimental-options option is required upfront.These are the frequently used experimental options:  --js.nashorn-compat: provide compatibility mode with the Nashorn engine. Sets ECMAScript version to 5 by default. Might conflict with newer ECMAScript versions. Boolean value, default is false.  --js.timezone: set the local time zone. String value, default is the system default.  --js.v8-compat: provide better compatibility with Google’s V8 engine. Boolean value, default is false.  --js.temporal: enable Temporal API.  --js.webassembly: enable WebAssembly API.Related Documentation  Setting Options to ScriptEngine",
          "url": " /latest/reference-manual/js/Options/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-options":  {
          "title": "Truffle Options",
          "content": "Truffle OptionsYou can list options from the command line with any language launcher:language-launcher --help:expertOr, for options only relevant for Truffle language implementers:language-launcher --help:internalIn addition, the Graal Compiler options can be listed with:language-launcher --vm.XX:+JVMCIPrintPropertiesSee graalvm_ce_jdk8_options for a list of Graal Compiler options.Default Language Launcher Options- `--vm.[option]` : Pass options to the host VM. To see available options, use `--help:vm`.- `--log.file=&amp;lt;String&amp;gt;` : Redirect guest languages logging into a given file.- `--log.[logger].level=&amp;lt;String&amp;gt;` : Set language log level to OFF, SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST or ALL.- `--help` : Print this help message.- `--help:vm` : Print options for the host VM.- `--version:graalvm` : Print GraalVM version information and exit.- `--show-version:graalvm` : Print GraalVM version information and continue execution.- `--help:languages` : Print options for all installed languages.- `--help:tools` : Print options for all installed tools.- `--help:expert` : Print additional options for experts.- `--help:internal` : Print internal options for debugging language implementations and tools.Expert Engine OptionsThese are advanced options for controlling the engine.They are useful to users and language and tool implementers.- `--engine.BytecodeHistogram=true|false|&amp;lt;group&amp;gt;[,&amp;lt;group&amp;gt;...]` : Collect and print a histogram of executed bytecode opcodes. Set to &#39;true&#39; to enable basic mode or use a comma separated list to configure grouping (e.g. source,root).Available groupings are root, tier, source, language, thread.This feature adds high overhead, use for profiling in non-production runs only. Supported only by Bytecode DSL interpreters. Prints when the engine is closed by default, or periodically if BytecodeHistogramInterval &amp;gt; 0.- `--engine.BytecodeHistogramInterval` : Print and reset the opcode histogram at a fixed interval while BytecodeHistogram is enabled. Use 0 to disable periodic printing and print only once at shutdown. Examples: 250ms, 2s, 1m.- `--engine.BytecodeLanguageFilter` : Limit tracing and statistics to specific language IDs. Provide a comma-separated list of language IDs, for example: js, python. Empty means that all languages are included. Applies to engine.TraceBytecode and engine.BytecodeHistogram.- `--engine.BytecodeMethodFilter` : Limit tracing and statistics to selected methods. Provide a comma-separated list of includes, or excludes prefixed with &#39;~&#39;. Empty means no restriction. Whitespace around commas is ignored. Applies to engine.TraceBytecode and engine.BytecodeHistogram.- `--engine.PreinitializeContexts` : Preinitialize language contexts for given languages.- `--engine.RelaxStaticObjectSafetyChecks` : On property accesses, the Static Object Model does not perform shape checks and uses unsafe casts- `--engine.SourceCacheStatisticDetails` : Print source cache statistics for an engine when the engine is closed. With the details enabled, statistics for all individual sources are printed.- `--engine.SourceCacheStatistics` : Print source cache statistics for an engine when the engine is closed.- `--engine.SynchronousThreadLocalActionMaxWait=[0, inf)` : How long to wait for other threads to reach a synchronous ThreadLocalAction before cancelling it, in seconds. 0 means no limit.- `--engine.SynchronousThreadLocalActionPrintStackTraces` : Print thread stacktraces when a synchronous ThreadLocalAction is waiting for more than SynchronousThreadLocalActionMaxWait seconds.- `--engine.TraceBytecode` : Trace every executed bytecode instruction. Very high overhead, use only for debugging, never in production. Supported only by Bytecode DSL interpreters. Combine with engine.BytecodeMethodFilter and engine.BytecodeLanguageFilter to limit output.- `--engine.TraceSourceCache` : Print information for source cache misses/evictions/failures.- `--engine.TraceSourceCacheDetails` : Print information for all source cache events including hits and uncached misses.- `--engine.TraceStackTraceInterval=[1, inf)` : Prints the stack trace for all threads for a time interval. By default 0, which disables the output.- `--engine.DebugCacheCompileUseLastTier=true|false` : If true uses the last tier instead of the first tier compiler. By default the last tier compiler is used (default: true).- `--engine.BackgroundCompilation=true|false` : Enable asynchronous truffle compilation in background threads (default: true)- `--engine.Compilation=true|false` : Enable or disable Truffle compilation.- `--engine.CompilationFailureAction=Silent|Print|Throw|Diagnose|ExitVM` : Specifies the action to take when Truffle compilation fails.The accepted values are:    Silent - Print nothing to the console.     Print - Print the exception to the console.     Throw - Throw the exception to caller.  Diagnose - Retry compilation with extra diagnostics enabled.    ExitVM - Exit the VM process.- `--engine.CompilerIdleDelay=&amp;lt;ms&amp;gt;` : Set the time in milliseconds an idle Truffle compiler thread will wait for new tasks before terminating. New compiler threads will be started once new compilation tasks are submitted. Select &#39;0&#39; to never terminate the Truffle compiler thread. The option is not supported by all Truffle runtimes. On the runtime which doesn&#39;t support it the option has no effect. default: 10000- `--engine.CompilerThreads=[1, inf)` : Manually set the number of compiler threads. By default, the number of compiler threads is scaled with the number of available cores on the CPU.- `--engine.EncodedGraphCachePurgeDelay=&amp;lt;ms&amp;gt;` : Delay, in milliseconds, after which the encoded graph cache is dropped when a Truffle compiler thread becomes idle (default: 10000).- `--engine.FirstTierBackedgeCounts=true|false` : Whether to emit look-back-edge counters in the first-tier compilations. (default: true)- `--engine.FirstTierCompilationThreshold=[1, inf)` : Number of invocations or loop iterations needed to compile a guest language root in first tier under normal compilation load.Might be reduced/increased when compilation load is low/high if DynamicCompilationThresholds is enabled. (default: 400).- `--engine.FirstTierMinInvokeThreshold=[1, inf)` : Minimum number of calls before a call target is compiled in the first tier (default: 1)- `--engine.LastTierCompilationThreshold=[1, inf)` : Number of invocations or loop iterations needed to compile a guest language root in first tier under normal compilation load.Might be reduced/increased when compilation load is low/high if DynamicCompilationThresholds is enabled. (default: 10000).- `--engine.MaximumCompilations=(-inf, inf)` : Maximum number of successful compilations for a single call target before a permanent bailout. Exceeding the limit will result in a compilation failure with the appropriate reason and there will be no further attempts to compile the call target. (negative integer means no limit, default: 100)- `--engine.MinInvokeThreshold=[1, inf)` : Minimum number of calls before a call target is compiled (default: 3).- `--engine.Mode=latency|throughput` : Configures the execution mode of the engine. Available modes are &#39;latency&#39; and &#39;throughput&#39;. The default value balances between the two.- `--engine.MultiTier=true|false` : Whether to use multiple Truffle compilation tiers by default. (default: true)- `--engine.OSR=true|false` : Enable automatic on-stack-replacement of loops (default: true).- `--engine.PartialBlockCompilation=true|false` : Enable partial compilation for BlockNode (default: true).- `--engine.PartialBlockCompilationSize=[1, inf)` : Sets the target non-trivial Truffle node size for partial compilation of BlockNode nodes (default: 3000).- `--engine.PartialBlockMaximumSize=[1, inf)` : Sets the maximum non-trivial Truffle node size for partial compilation of BlockNode nodes (default: 10000).- `--engine.SingleTierCompilationThreshold=[1, inf)` : Minimum number of invocations or loop iterations needed to compile a guest language root when not using multi tier (default: 1000).- `--engine.Splitting=true|false` : Enable automatic duplication of compilation profiles (splitting) (default: true).- `--engine.StoppedCompilationRetryDelay=&amp;lt;ms&amp;gt;` : Before the Truffle runtime submits an OptimizedCallTarget for compilation, it checks for the compilation activity mode in the host VM. If the activity mode indicates a full code cache, no new compilation requests are submitted and the compilation queue is flushed. After &#39;StoppedCompilationRetryDelay&#39; milliseconds new compilations will be submitted again (which might trigger a sweep of the code cache and a reset of the compilation activity mode in the host JVM). The option is only supported on the HotSpot Truffle runtime. On runtimes which don&#39;t support it the option has no effect. default: 5000- `--engine.TraceCompilation` : Print information for compilation results.- `--compiler.EncodedGraphCache` : Cache encoded graphs across Truffle compilations to speed up partial evaluation. (default: true).- `--compiler.FirstTierUseEconomy` : Whether to use the economy configuration in the first-tier compilations. (default: true, syntax: true|false)- `--compiler.Inlining` : Enable automatic inlining of guest language call targets (default: true, usage: true|false).- `--compiler.InliningExpansionBudget` : The base expansion budget for language-agnostic inlining (default: 12000). Syntax: [1, inf)- `--compiler.InliningInliningBudget` : The base inlining budget for language-agnostic inlining (default: 12000). Syntax: [1, inf)- `--compiler.InliningRecursionDepth` : Maximum depth for recursive inlining (default: 2, usage: [0, inf)).- `--engine.EncodedGraphCache` : Cache encoded graphs across Truffle compilations to speed up partial evaluation. (default: true).- `--engine.FirstTierUseEconomy` : Whether to use the economy configuration in the first-tier compilations. (default: true, syntax: true|false)- `--engine.Inlining` : Enable automatic inlining of guest language call targets (default: true, usage: true|false).- `--engine.InliningExpansionBudget` : The base expansion budget for language-agnostic inlining (default: 12000). Syntax: [1, inf)- `--engine.InliningInliningBudget` : The base inlining budget for language-agnostic inlining (default: 12000). Syntax: [1, inf)- `--engine.InliningRecursionDepth` : Maximum depth for recursive inlining (default: 2, usage: [0, inf)).- `--engine.HostCallStackHeadRoom=[1, inf)&amp;lt;B&amp;gt;|&amp;lt;KB&amp;gt;|&amp;lt;MB&amp;gt;|&amp;lt;GB&amp;gt;` : Stack space headroom for calls to the host.- `--engine.InterpreterCallStackHeadRoom=[0, inf)&amp;lt;B&amp;gt;|&amp;lt;KB&amp;gt;|&amp;lt;MB&amp;gt;|&amp;lt;GB&amp;gt;` : Stack space headroom for any interpreter call. Supported only in the AOT mode.- `--engine.IsolateMemoryProtection=true|false` : Enable memory protection for the isolate.- `--engine.IsolateOption.&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;` : Isolate VM options.Internal Engine OptionsThese are internal options for debugging language implementations and tools.- `--engine.AssertProbes=true|false` : Asserts that enter and return are always called in pairs on ProbeNode, verifies correct behavior of wrapper nodes. Java asserts need to be turned on for this option to have an effect. (default: false)- `--engine.DisableCodeSharing` : Option to force disable code sharing for this engine, even if the context was created with an explicit engine. This option is intended for testing purposes only.- `--engine.ForceCodeSharing` : Option to force enable code sharing for this engine, even if the context was created with a bound engine. This option is intended for testing purposes only.- `--engine.InstrumentExceptionsAreThrown=true|false` : Propagates exceptions thrown by instruments. (default: true)- `--engine.PrintInternalStackTrace` : Printed PolyglotException stacktrace unconditionally contains the stacktrace of the original internal exception as well as the stacktrace of the creation of the PolyglotException instance.- `--engine.SafepointALot` : Repeadly submits thread local actions and collects statistics about safepoint intervals in the process. Prints event and interval statistics when the context is closed for each thread. This option significantly slows down execution and is therefore intended for testing purposes only.- `--engine.ShowInternalStackFrames` : Show internal frames specific to the language implementation in stack traces.- `--engine.SpecializationStatistics` : Enables specialization statistics for nodes generated with Truffle DSL and prints the result on exit. In order for this flag to be functional -Atruffle.dsl.GenerateSpecializationStatistics=true needs to be set at build time. Enabling this flag and the compiler option has major implications on the performance and footprint of the interpreter. Do not use in production environments.- `--engine.StaticObjectStorageStrategy=default|array-based|field-based` : Set the storage strategy used by the Static Object Model. Accepted values are: [&#39;default&#39;, &#39;array-based&#39;, &#39;field-based&#39;]- `--engine.TraceCodeSharing` : Enables printing of code sharing related information to the logger. This option is intended to support debugging language implementations.- `--engine.TraceMissingSafepointPollInterval=[0, inf)` : Show Java stacktraces for missing polls longer than the supplied number of milliseconds. Implies SafepointALot.- `--engine.TraceThreadLocalActions` : Traces thread local events and when they are processed on the individual threads. Prints messages with the [engine] [tl] prefix.- `--engine.TriggerUncaughtExceptionHandlerForCancel` : Propagates cancel execution exception into UncaughtExceptionHandler. For testing purposes only.- `--engine.UseConservativeContextReferences` : Enables conservative context references. This allows invalid sharing between contexts. For testing purposes only.- `--engine.UsePreInitializedContext=true|false` : Use pre-initialized context when it&#39;s available (default: true).- `--engine.DebugCacheCompile=none|compiled|hot|aot|executed` : Policy to use to to force compilation for executed call targets before persisting the engine. Possible values are:  - &#39;none&#39;:     No compilations will be persisted and existing compilations will be invalidated.  - &#39;compiled&#39;: No compilations will be forced but finished compilations will be persisted.  - &#39;hot&#39;:      (default) All started compilations will be completed and then persisted.  - &#39;aot&#39;:      All started and AOT compilable roots will be forced to compile and persisted.  - &#39;executed&#39;: All executed and all AOT compilable roots will be forced to compile.- `--engine.DebugCacheLoad` : Prepares the engine to take the stored engine from the static field instead of reading it from disk.- `--engine.DebugCachePreinitializeContext=true|false` : Preinitialize a new context with all languages that support it and that were used during the run (default: true).- `--engine.DebugCacheStore` : Prepares the engine for caching and stores it a static field instead of writing it to disk.- `--engine.DebugTraceCache` : Enables tracing for the engine cache debug feature.- `--engine.ArgumentTypeSpeculation=true|false` : Speculate on arguments types at call sites (default: true)- `--engine.CompilationStatisticDetails` : Print additional more verbose Truffle compilation statistics at the end of a run.- `--engine.CompilationStatistics` : Print Truffle compilation statistics at the end of a run.- `--engine.CompileAOTOnCreate` : Compiles created call targets immediately with last tier. Disables background compilation if enabled.- `--engine.CompileImmediately` : Compile immediately to test Truffle compilation- `--engine.CompileOnly=&amp;lt;name&amp;gt;,&amp;lt;name&amp;gt;,...` : Restrict compilation to &#39;,&#39;-separated list of includes (or excludes prefixed with &#39;~&#39;). No restriction by default.- `--engine.DynamicCompilationThresholds=true|false` : Reduce or increase the compilation threshold depending on the size of the compilation queue (default: true).- `--engine.DynamicCompilationThresholdsMaxNormalLoad=[1, inf)` : The desired maximum compilation queue load. When the load rises above this value, the compilation thresholds are increased. The load is scaled by the number of compiler threads.  (default: 10)- `--engine.DynamicCompilationThresholdsMinNormalLoad=[1, inf)` : The desired minimum compilation queue load. When the load falls below this value, the compilation thresholds are decreased. The load is scaled by the number of compiler threads (default: 10).- `--engine.DynamicCompilationThresholdsMinScale=[0.0, inf)` : The minimal scale the compilation thresholds can be reduced to (default: 0.1).- `--engine.OSRCompilationThreshold=[1, inf)` : Number of loop iterations until on-stack-replacement compilation is triggered (default 100352).- `--engine.OSRMaxCompilationReAttempts=[0, inf)` : Number of compilation re-attempts before bailing out of OSR compilation for a given method (default 30). This number is an approximation of the acceptable number of deopts.- `--engine.PriorityQueue=true|false` : Use the priority of compilation jobs in the compilation queue (default: true).- `--engine.Profiling=true|false` : Enable/disable builtin profiles in com.oracle.truffle.api.profiles. (default: true)- `--engine.PropagateLoopCountToLexicalSingleCaller=true|false` : Enables hotness propagation to lexical parent to lexically parent single callers.- `--engine.PropagateLoopCountToLexicalSingleCallerMaxDepth=[0, inf)` : How high to propagate call and loop count (hotness proxy) up a single caller chain to lexical scope parent.- `--engine.ReturnTypeSpeculation=true|false` : Speculate on return types at call sites (default: true)- `--engine.SplittingAllowForcedSplits=true|false` : Should forced splits be allowed (default: true)- `--engine.SplittingDumpDecisions` : Dumps to IGV information on polymorphic events- `--engine.SplittingGrowthLimit=[0.0, inf)` : Disable call target splitting if the number of nodes created by splitting exceeds this factor times node count (default: 1.5).- `--engine.SplittingMaxCalleeSize=[1, inf)` : Disable call target splitting if tree size exceeds this limit (default: 100)- `--engine.SplittingMaxPropagationDepth=[1, inf)` : Propagate info about a polymorphic specialize through maximum this many call targets (default: 5)- `--engine.SplittingTraceEvents` : Trace details of splitting events and decisions.- `--engine.ThrowOnMaxOSRCompilationReAttemptsReached=true|false` : Whether an AssertionError is thrown when the maximum number of OSR compilation attempts is reached for a given method (default &#39;false&#39;). This should only be set to &#39;true&#39; in testing environments.- `--engine.TraceAssumptions` : Print stack trace on assumption invalidation- `--engine.TraceCompilationAST` : Print the entire AST after each compilation- `--engine.TraceCompilationDetails` : Print information for compilation queuing.- `--engine.TraceCompilationPolymorphism` : Print all polymorphic and generic nodes after each compilation- `--engine.TraceDeoptimizeFrame` : Print stack trace when deoptimizing a frame from the stack with `FrameInstance#getFrame(READ_WRITE|MATERIALIZE)`.- `--engine.TraceSplitting` : Print information for splitting decisions.- `--engine.TraceSplittingSummary` : Used for debugging the splitting implementation. Prints splitting summary directly to stdout on shutdown- `--engine.TraceStackTraceLimit=[1, inf)` : Number of stack trace elements printed by TraceTruffleTransferToInterpreter, TraceTruffleAssumptions and TraceDeoptimizeFrame (default: 20).- `--engine.TraceTransferToInterpreter` : Print stack trace on transfer to interpreter.- `--engine.TraversingCompilationQueue=true|false` : Use a traversing compilation queue. (default: true)- `--engine.TraversingQueueFirstTierBonus=[0.0, inf)` : Controls how much of a priority should be given to first tier compilations (default 15.0).- `--engine.TraversingQueueFirstTierPriority` : Traversing queue gives first tier compilations priority.- `--engine.TraversingQueueInvalidatedBonus=[0.0, inf)` : Controls how much of a priority should be given to compilations after invalidations (default: 1.0, no bonus).- `--engine.TraversingQueueOSRBonus=[0.0, inf)` : Controls how much of a priority should be given to OSR compilations (default: 1.0, no bonus).- `--engine.TraversingQueueRateHalfLife=[0, inf)` : Sets the time, in milliseconds, after which the impact of a compilation unit&#39;s observed execution rate is halved. (default: 300 ms)- `--engine.TraversingQueueWeightingBothTiers=true|false` : Traversing queue uses rate as priority for both tier. (default: true)- `--compiler.CompilationTimeout` : Time limit in seconds before a compilation expires and throws a bailout (0 to disable the limit). - `--compiler.DeoptCycleDetectionAllowedRepeats` : Maximum allowed repeats of the same compiled code for the same compilable. Works only if the detection of repeated compilation is enabled after DeoptCycleDetectionThreshold has been reached for the compilable. (negative integer means 0, default: 0)- `--compiler.DeoptCycleDetectionThreshold` : Threshold for enabling deopt cycle detection for a call target. When the number of successful compilation of the call target reaches the threshold, deopt cycle detection is enabled for the call target. (negative integer means the detection is never enabled, default: 15)- `--compiler.DiagnoseFailure` : Forces diagnostics for compilation failures (default: false).- `--compiler.ExcludeAssertions` : Exclude assertion code from Truffle compilations (default: true)- `--compiler.FirstTierInliningPolicy` : Explicitly pick a first tier inlining policy by name (None, TrivialOnly). If empty (default) the lowest priority policy (TrivialOnly) is chosen.- `--compiler.InlineAcrossTruffleBoundary` : Enable inlining across Truffle boundary- `--compiler.InlineOnly` : Restrict inlined methods to &#39;,&#39;-separated list of includes (or excludes prefixed with &#39;~&#39;). No restriction by default. (usage: &amp;lt;name&amp;gt;,&amp;lt;name&amp;gt;,...)- `--compiler.InliningPolicy` : Explicitly pick a inlining policy by name. If empty (default) the highest priority chosen by default.- `--compiler.InliningUseSize` : Use the graph size as a cost model during inlining (default: false).- `--compiler.InstrumentBoundaries` : Instrument Truffle boundaries and output profiling information to the standard output.- `--compiler.InstrumentBoundariesPerInlineSite` : Instrument Truffle boundaries by considering different inlining sites as different branches.- `--compiler.InstrumentBranches` : Instrument branches and output profiling information to the standard output.- `--compiler.InstrumentBranchesPerInlineSite` : Instrument branches by considering different inlining sites as different branches.- `--compiler.InstrumentFilter` : Method filter for host methods in which to add instrumentation (syntax: &amp;lt;method&amp;gt;,&amp;lt;method&amp;gt;,....)- `--compiler.InstrumentationTableSize` : Maximum number of instrumentation counters available (default: 10000, syntax: [1, inf))- `--compiler.IterativePartialEscape` : Run the partial escape analysis iteratively in Truffle compilation.- `--compiler.LogInlinedTargets` : Logs inlined targets for statistical purposes (default: false).- `--compiler.MaximumGraalGraphSize` : Stop partial evaluation when the graph exceeded this size, disabled if &amp;lt; 0. (default: -1, syntax: [-inf, inf))- `--compiler.MethodExpansionStatistics` : Print statistics on expanded Java methods during partial evaluation at the end of a run.(syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--compiler.NodeExpansionStatistics` : Print statistics on expanded Truffle nodes during partial evaluation at the end of a run.(syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--compiler.NodeSourcePositions` : Enable node source positions in truffle partial evaluations.- `--compiler.ParsePEGraphsWithAssumptions` : Allow assumptions during parsing of seed graphs for partial evaluation. Disables the persistent encoded graph cache &#39;engine.EncodedGraphCache&#39;. (default: false).- `--compiler.TraceInlining` : Print information for inlining decisions.- `--compiler.TraceInliningDetails` : Print detailed information for inlining (i.e. the entire explored call tree).- `--compiler.TraceMethodExpansion` : Print a tree of all expanded Java methods with statistics after each compilation. (syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--compiler.TraceNodeExpansion` : Print a tree of all expanded Truffle nodes with statistics after each compilation. (syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--compiler.TracePerformanceWarnings` : Print potential performance problems, Performance warnings are: call, instanceof, store, frame_merge, trivial. (syntax: none|all|&amp;lt;perfWarning&amp;gt;,&amp;lt;perfWarning&amp;gt;,...)- `--compiler.TraceStackTraceLimit` : Number of stack trace elements printed by TraceTruffleTransferToInterpreter, TraceTruffleAssumptions and TraceDeoptimizeFrame (default: 20). Syntax: [1, inf).- `--compiler.TreatPerformanceWarningsAsErrors` : Treat performance warnings as error. Handling of the error depends on the CompilationFailureAction option value. Performance warnings are: call, instanceof, store, frame_merge, trivial. (syntax: none|all|&amp;lt;perfWarning&amp;gt;,&amp;lt;perfWarning&amp;gt;,...)- `--engine.ExcludeAssertions` : Exclude assertion code from Truffle compilations (default: true)- `--engine.FirstTierInliningPolicy` : Explicitly pick a first tier inlining policy by name (None, TrivialOnly). If empty (default) the lowest priority policy (TrivialOnly) is chosen.- `--engine.InlineAcrossTruffleBoundary` : Enable inlining across Truffle boundary- `--engine.InlineOnly` : Restrict inlined methods to &#39;,&#39;-separated list of includes (or excludes prefixed with &#39;~&#39;). No restriction by default. (usage: &amp;lt;name&amp;gt;,&amp;lt;name&amp;gt;,...)- `--engine.InliningPolicy` : Explicitly pick a inlining policy by name. If empty (default) the highest priority chosen by default.- `--engine.InliningUseSize` : Use the graph size as a cost model during inlining (default: false).- `--engine.InstrumentBoundaries` : Instrument Truffle boundaries and output profiling information to the standard output.- `--engine.InstrumentBoundariesPerInlineSite` : Instrument Truffle boundaries by considering different inlining sites as different branches.- `--engine.InstrumentBranches` : Instrument branches and output profiling information to the standard output.- `--engine.InstrumentBranchesPerInlineSite` : Instrument branches by considering different inlining sites as different branches.- `--engine.InstrumentFilter` : Method filter for host methods in which to add instrumentation (syntax: &amp;lt;method&amp;gt;,&amp;lt;method&amp;gt;,....)- `--engine.InstrumentationTableSize` : Maximum number of instrumentation counters available (default: 10000, syntax: [1, inf))- `--engine.IterativePartialEscape` : Run the partial escape analysis iteratively in Truffle compilation.- `--engine.MaximumGraalGraphSize` : Stop partial evaluation when the graph exceeded this size, disabled if &amp;lt; 0. (default: -1, syntax: [-inf, inf))- `--engine.MethodExpansionStatistics` : Print statistics on expanded Java methods during partial evaluation at the end of a run.(syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--engine.NodeExpansionStatistics` : Print statistics on expanded Truffle nodes during partial evaluation at the end of a run.(syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--engine.NodeSourcePositions` : Enable node source positions in truffle partial evaluations.- `--engine.ParsePEGraphsWithAssumptions` : Allow assumptions during parsing of seed graphs for partial evaluation. Disables the persistent encoded graph cache &#39;engine.EncodedGraphCache&#39;. (default: false).- `--engine.TraceInlining` : Print information for inlining decisions.- `--engine.TraceInliningDetails` : Print detailed information for inlining (i.e. the entire explored call tree).- `--engine.TraceMethodExpansion` : Print a tree of all expanded Java methods with statistics after each compilation. (syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--engine.TraceNodeExpansion` : Print a tree of all expanded Truffle nodes with statistics after each compilation. (syntax: true|false|peTier|truffleTier|lowTier|&amp;lt;tier&amp;gt;,&amp;lt;tier&amp;gt;,...)  Accepted values are:      true - Collect data for the default tier &#39;truffleTier&#39;.      false - No data will be collected.  Or one or multiple tiers separated by comma (e.g. truffleTier,lowTier):      peTier - After partial evaluation without additional phases applied.      truffleTier - After partial evaluation with additional phases applied.      lowTier - After low tier phases were applied.- `--engine.TracePerformanceWarnings` : Print potential performance problems, Performance warnings are: call, instanceof, store, frame_merge, trivial. (syntax: none|all|&amp;lt;perfWarning&amp;gt;,&amp;lt;perfWarning&amp;gt;,...)- `--engine.TraceStackTraceLimit` : Number of stack trace elements printed by TraceTruffleTransferToInterpreter, TraceTruffleAssumptions and TraceDeoptimizeFrame (default: 20). Syntax: [1, inf).- `--engine.TreatPerformanceWarningsAsErrors` : Treat performance warnings as error. Handling of the error depends on the CompilationFailureAction option value. Performance warnings are: call, instanceof, store, frame_merge, trivial. (syntax: none|all|&amp;lt;perfWarning&amp;gt;,&amp;lt;perfWarning&amp;gt;,...)- `--engine.IsolateLauncher=&amp;lt;path&amp;gt;` : Path to the external isolate launcher.- `--engine.IsolateLibrary=&amp;lt;path&amp;gt;` : Path to the isolate library.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/Options/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo-basic-usage":  {
          "title": "Basic Usage of Profile-Guided Optimization",
          "content": "Basic Usage of Profile-Guided OptimizationTo explain the usage of PGO in the context of GraalVM Native Image, let’s consider the “Game Of Life” example application.It is an implementation of Conway’s Game of Life simulation on a 4000 by 4000 grid.The application takes as input a file specifying the initial state of the world, a file path to output the final state, and an integer declaring how many iterations of the simulation to run.Note that this is a not-illustrative-of-the-real-world application, but it should serve well as an example.Below is the source code of the application, modified from this resource.import java.io.BufferedReader;import java.io.FileReader;import java.io.FileWriter;public class GameOfLife {    private static final int M = 4000;    private static final int N = 4000;    public static void main(String[] args) {        new GameOfLife().run(args);    }    private void run(String[] args) {        if (args.length &amp;lt; 3) {            System.err.println(&quot;Too few arguments, need input file, output file and number of generations&quot;);            System.exit(1);        }        String input = args[0];        String output = args[1];        int generations = Integer.parseInt(args[2]);        int[][] grid = loadGrid(input);        for (int i = 1; i &amp;lt;= generations; i++) {            grid = nextGeneration(grid);        }        saveGrid(grid, output);    }    static int[][] nextGeneration(int[][] grid) {        int[][] future = new int[M][N];        for (int l = 0; l &amp;lt; M; l++) {            for (int m = 0; m &amp;lt; N; m++) {                applyRules(grid, future, l, m, getAliveNeighbours(grid, l, m));            }        }        return future;    }    private static void applyRules(int[][] grid, int[][] future, int l, int m, int aliveNeighbours) {        if ((grid[l][m] == 1) &amp;amp;&amp;amp; (aliveNeighbours &amp;lt; 2)) {            // Cell is lonely and dies            future[l][m] = 0;        } else if ((grid[l][m] == 1) &amp;amp;&amp;amp; (aliveNeighbours &amp;gt; 3)) {            // Cell dies due to over population            future[l][m] = 0;        } else if ((grid[l][m] == 0) &amp;amp;&amp;amp; (aliveNeighbours == 3)) {            // A new cell is born            future[l][m] = 1;        } else {            // Remains the same            future[l][m] = grid[l][m];        }    }    private static int getAliveNeighbours(int[][] grid, int l, int m) {        int aliveNeighbours = 0;        for (int i = -1; i &amp;lt;= 1; i++) {            for (int j = -1; j &amp;lt;= 1; j++) {                if ((l + i &amp;gt;= 0 &amp;amp;&amp;amp; l + i &amp;lt; M) &amp;amp;&amp;amp; (m + j &amp;gt;= 0 &amp;amp;&amp;amp; m + j &amp;lt; N)) {                    aliveNeighbours += grid[l + i][m + j];                }            }        }        // The cell needs to be subtracted from its neighbors as it was counted before        aliveNeighbours -= grid[l][m];        return aliveNeighbours;    }    private static void saveGrid(int[][] grid, String output) {        try (FileWriter myWriter = new FileWriter(output)) {            for (int i = 0; i &amp;lt; M; i++) {                for (int j = 0; j &amp;lt; N; j++) {                    if (grid[i][j] == 0)                        myWriter.write(&quot;.&quot;);                    else                        myWriter.write(&quot;*&quot;);                }                myWriter.write(System.lineSeparator());            }        } catch (Exception e) {            throw new IllegalStateException();        }    }    private static int[][] loadGrid(String input) {        try (BufferedReader reader = new BufferedReader(new FileReader(input))) {            int[][] grid = new int[M][N];            for (int i = 0; i &amp;lt; M; i++) {                String line = reader.readLine();                for (int j = 0; j &amp;lt; N; j++) {                    if (line.charAt(j) == &#39;*&#39;) {                        grid[i][j] = 1;                    } else {                        grid[i][j] = 0;                    }                }            }            return grid;        } catch (Exception e) {            throw new IllegalStateException(e);        }    }}Application performance is measured in terms of elapsed time.The assumption is that applying better optimizations to the application results in the application taking less time to complete a workload.To see the difference in performance, you can run the application in two different ways: first, without PGO and then with PGO.Building the ApplicationThe prerequisite is to install Oracle GraalVM. The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Note: PGO is not available in GraalVM Community Edition.The first step is to compile GameOfLife.java to a class file:javac GameOfLife.javaNext, build a native image of the application, specifying a unique name with the -o option:native-image -cp . GameOfLife -o gameoflife-defaultNow you can move on to building a PGO-enabled native image. For that, you first need to build an “instrumented binary” that will produce a profile for the runtime behavior of the application by adding the --pgo-instrumented option and specifying a different name, as follows:native-image  --pgo-instrument -cp . GameOfLife -o gameoflife-instrumentedNow run that instrumented binary to gather profiles. By default, just before exiting, it generates a file with the default name default.iprof in the current working directory, but you can specify a different name and path for the profile by passing the -XX:ProfilesDumpFile option when running the instrumented binary.You should also provide the standard expected inputs to the application: the initial state of the world (input.txt), a file to which the application will print the final state of the world (output.txt), and the desired number of iterations you want (in this case 10)../gameoflife-instrumented -XX:ProfilesDumpFile=gameoflife.iprof input.txt output.txt 10Having a runtime profile of the application contained in the gameoflife.iprof file,  you can finally build an optimized native executable by using the --pgo option and providing the gathered profile as shown below.native-image -cp . GameOfLife -o gameoflife-pgo --pgo=gameoflife.iprofWith all this in place, you can move on to the evaluating the runtime performance of the application running in the different modes.Evaluating PerformanceTo evaluate the performance, run both native executables of the application with the same inputs.You can measure the elapsed time of the executable via the time command with a custom output format (--format=&amp;gt;&amp;gt; Elapsed: %es).  Note: The CPU clock is fixed to 2.5GHz during all the measurements to minimize noise and improve reproducibility.Running with a Single IterationRun the application as shown below, so that it iterates only once:time  ./gameoflife-default input.txt output.txt 1    &amp;gt;&amp;gt; Elapsed: 1.67stime  ./gameoflife-pgo input.txt output.txt 1    &amp;gt;&amp;gt; Elapsed: 0.97sLooking at the elapsed time, you can see that running the PGO-optimized native executable is substantially faster in terms of percentage.With that in mind, the half a second of difference does not have a huge impact for a single run of this application,but if this was a serverless application that executes frequently, then the cumulative performance gain would start to add up.Run with 100 IterationsNow move on to running the application with 100 iterations. Same as before, the executed commands and the time output is shown below:time  ./gameoflife-default input.txt output.txt 100    &amp;gt;&amp;gt; Elapsed: 24.02stime  ./gameoflife-pgo input.txt output.txt 100    &amp;gt;&amp;gt; Elapsed: 13.25sIn both evaluation runs, the PGO-optimized native executable significantly outperforms the default native build.The amount of improvement that PGO provides in this case is not representative of the PGO gains for real world applications, since this application is small and does exactly one thing so the profiles provided are based on the exact same workload that is being measured.However, it illustrates the general point: Profile-Guided Optimization enables an AOT compiler to perform similar optimizations as a JIT compiler.Executable SizeAnother advantage of using PGO with GraalVM Native Image is the size of the native executable. To measure the size of the files, you can use the Linux du command as shown below.du -hs gameoflife-default    7.9M    gameoflife-defaultdu -hs gameoflife-pgo    6.7M    gameoflife-pgoAs you can see, the PGO-optimized native executable is approximately 15% smaller than the default native build.This is because the profiles provided for the optimizing build allow the compiler to differentiate between which code is important for performance(“hot code”), and which is not important (“cold code”, such as error handling).With this differentiation available, the compiler can decide to focus more heavily on optimizing the hot code and less, or not at all, on the cold code.This is a similar approach to what a JVM does - identifies the hot parts of the code at run time and compile those parts at run time.The main difference is that  Native Image PGO does the profiling and the optimizing ahead-of-time.Further Reading  Inspecting a Profile in a Build Report  Optimize a Native Executable with Profile-Guided Optimization",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/basic-usage/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo-build-reports":  {
          "title": "Inspecting a Profile in a Build Report",
          "content": "Inspecting a Profile in a Build ReportA profile plays an essential part in efficient AOT compilation by Native Image.It contains the information about a particular execution of the application, and is used to guide additional optimizations that further improve application performance.It is often useful to visualize the information in a profile.This section explains how to inspect parts of a profile using the Native Image Build Report tool.  The Native Image Build Report tool is not available in GraalVM Community Edition.Generating a Profile VisualizationThe Build Report tool displays various data about the generated image and the build process itself.Among other things, the tool can visualize profiling information recorded by the sampler, which is useful for exploring how different methods contribute to overall execution time.The samples are aggregated into a single flame graph. The flame graph is color-coded to show how the inliner made the inlining decisions during the compilation (more on that below).To generate a comprehensive report with the visualization, pass the --emit build-report option at the step when you build a PGO-optimized native executable.For example:native-image -cp . GameOfLife -o gameoflife-pgo --pgo=gameoflife.iprof --emit build-report  Refer to Basic Usage of Profile-Guided Optimization for the step-by-step guide.Inspecting a Profile Using a Build ReportProfiling information recorded by the Native Image sampler is visualized in form of a flame graph - a hierarchical chart that aggregates multiple stack traces.This flame graph is specialized in differentiating “hot” vs. “cold” compilation units.There are three distinct colors:  red: used for marking root methods of hot compilation units;  blue: used for all the methods inlined into a hot compilation root;  gray: represents the “cold” code.  Note: The color descriptions and other useful information are part of a chart legend, and can be toggled by clicking “?”.The graph itself provides a couple of functionalities. A user can hover over a specific method bar to see more information about that method, for example, a number of samples and the percentage related to the total number of samples. Besides that, there is the ability to “zoom” into a particular method (by clicking on it) and see all the subsequent calls in that call chain more clearly. One can reset the view using the Reset Zoom button in top-left corner.Additionally, there is a search button (Search) located in top-right corner of the graph.It can be used to highlight a specific method or a group of methods that match the search criteria (the method(s)will be colored yellow).Also, there is a Matched field that represents the group share in the total number of samples (showed underneath the chart in the right half). Note that this is also a relative share - it will be readjusted when expanding/collapsing the view.One can also use a Reset Search button to cancel the search at any time.The flame graph comes with the additional histogram (below it). It shows the individual methods’ contributions to the total execution time (descending by the number of samples). These bars are also clickable, and the click has the same effect as searching - it highlights that particular method inthe flame graph above. Additional click on that same bar resets the highlighting.Further Reading  Tracking Profile Quality  Merging Profiles from Multiple Sources",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/build-reports/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo-faq":  {
          "title": "Frequently Asked Questions",
          "content": "Frequently Asked QuestionsCan I use unit tests for profiling?Yes, it is possible, but usually not recommended.To use the unit tests to generate the profiles, you should generate an instrumented binary for your test suite, in the same way you generate a native executable for any application.For example, you could have a main() method that starts the test harness.Once the instrumented binary executes, it will dump the file with the profiles, same as any instrumented binary.Note that the quality of Profile-Guided Optimization depends on the quality of the profile that you provide as an input to the optimized native build.You should make sure that your tests accurately represent the workload that will run in production.In general, it is not easy to guarantee that, because:  Unit tests are designed to test all the corner-cases of the components, many of which are uncommon in practice (in other words, while they need to be tested and work correctly, corner-cases in your code usually do not need to be fast).  Different components of your code are not always represented with the same number of unit tests.A profile based on a unit-test suite may over-represent the importance of one component, and under-represent the importance of others.  Unit-test suites evolve over time as more and more tests get added.What might accurately represent your application’s behavior today, might not accurately represent it tomorrow.For example, you are implementing web server that serves static content.Most of the time, the web server will be reading a file from the disk or an in-memory cache, compressing that file, and sending the compressed bytes over the network.However, a good unit-test suite will test all components of the web server, including code for configuration-file parsing, cache invalidation, or remote debugging, which may execute infrequently or not at all during a typical execution of the web server.If you collect the profiles across all the unit tests, they will over-represent parts of the code that execute rarely in practice, and in this way misdirect the compiler optimizations.In conclusion, while this is possible, we do not recommend to use unit tests as profiles, because it is not clear how well they represent what the application does. What we recommend instead is to either:  Identify a subset of end-to-end tests that represent important production workloads.An end-to-end test simulates what your application does in production, and is more likely to correctly portray how and where the time is spent in your code.In the previous web server example, an end-to-end test would start the web server, send thousands of requests to retrieve various URLs, and then shut down the server.  Or, create a benchmark workload that represents what your application does in production.A good benchmark would incorporate characteristics of a typical workload.In the previous web server example, a realistic benchmark would incorporate the distribution of requests that was observed when the web-server was running in production.That is, the benchmark would model how often a file of a particular size was requested in production, as well as the compression ratios of the files.Are PGO profiles sufficiently cross-platform, or should each target be instrumented separately?Yes, in most cases, the PGO profiles are sufficiently cross-platform.You can collect the profiles by running an instrumented binary on one platform, but then use those profiles to build an optimized native executable on a different platform.There are some cases in which Native Image uses different classes and methods depending on the platform for which the binary was built.For example, the PosixProcessPropertiesSupport class contains code that manipulates processes on POSIX-based systems, while the WindowsProcessPropertiesSupport class contains code that manipulates processes on Windows.Similarly, certain parts of the JDK contain platform-specific code.In these cases, the profile will contain entries for one platform, but the optimized native build will not find profile entries for its platform-specific code.These corner-cases are rare and typically do not result in a performance impact, but this is something to be aware of.In conclusion, the best practice is always to collect the profiles on the same platform that is the target for the optimized native executable.However, using the profiles collected on a different platform should typically work well.Can the profiling information be reused after a code change, provided it is limited, or do I need to collect new profiling information for each build?Yes, the profiling information can always be reused, and a native executable has to be correctly generated.It is not necessary to collect new profiling information for each build.Note, however, that the performance impact on the optimized native executable depends on the quality of the profiles.If the new code of the program significantly diverges from the code for which the profiles was collected, the compiler optimizations will be misled about which code is important. If the code changes are sufficiently small, or limited to the cold parts of the program, then using the old profile will usually not compromise the performance of the optimized native binary.Read more on this topic in the Tracking Profile Quality guidelines.Can I also run the benchmark with an instrumented binary?Yes, an instrumented binary can be produced for any program, including a benchmark.In fact, using a representative benchmark to collect the profiles is the recommended way of collecting profiles.Be aware that the instrumentation overhead will typically make the instrumented binary slower than the default (non-instrumented) native executable.While we continually strive to minimize the overhead of instrumentation, you will likely notice that the instrumented binary is slower,and your mileage will vary depending on the code patterns in the application that you are running.Also, note that the benchmark should ideally be representative of the workload that you expect in production.The more the benchmark’s workload corresponds to the production workload, the more likely it is that PGO have a positive performance impacton the optimized native build.In conclusion, if the benchmark accurately represents the workload that you will be running in production, then it is a good idea to collect the profiles on the instrumented benchmark binary, and subsequently use these profiles to build an optimized native executable for your production workload.How does GraalVM generate a workload for profiling a web application?GraalVM itself does not generate a workload for profiling a web application that was compiled with Native Image.Instead, you need to use a load-testing tool to generate the workload.For example, if your web application exposes several HTTP endpoints, then you need to use a load-tester such as wrk to generate a stream of requests to those HTTP endpoints.The setup for this would be as follows: you build an instrumented binary of your web application, start it in one process, and start a load-tester such as wrk in another process.The duration of the load-test needs to be long enough to exercise the endpoints of your web application that will be most frequently accessed by the production users, using request payloads that you expect to encounter in production.For a simple web application, duration of 1 minute is typically sufficient to produce profiles of good quality (but this depends on your particular application).After the load-test completes and the web application exits, it will dump the profiles to a file.Why not collect profile in the production environment for a while? For example, collect it only on one instance of the service on Monday from 8:00 till 12:00.Yes, that is a good way to collect profiles.An instrumented binary has a certain overhead, which depends on the code patterns in a particular application.However, if only one instance uses the instrumented binary during a particular period, and all other instances of your service use a normal or PGO-optimized build, then this is generally acceptable in practice.Find more information on this topic in the Tracking Profile Quality guidelines.",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/faq/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo-iprof-file-format":  {
          "title": "The _iprof_ File Format",
          "content": "The iprof File Format  Note: This document assumes that the reader is familiar with GraalVM Profile-Guided Optimization.To build an optimized native image using Profile-Guided Optimization (PGO),it is necessary to provide the native-image tool with profiling data,gathered by executing workloads on an instrumented image.This profiling information is stored as a JSON object in a file with the .iprof extension.This document outlines the structure and semantics of the iprof file format.StructureThe full schema of the JSON format used for iprof files can be found in the iprof-v1.1.0.schema.json document.This JSON schema fully defines the iprof file format and can be used to validate the structure of an arbitrary iprof file.A minimal valid iprof file consists of a JSON object containing 3 fields: types, methods and version.The following is a minimal valid iprof file for the current version (1.1.0).{  &quot;version&quot;: &quot;1.1.0&quot;,  &quot;types&quot;: [],  &quot;methods&quot;: []}In addition to these fields, the iprof file may optionally contain others that provide information on various run-time profiles.The following is an example of a fully populated iprof file (version 1.1.0) with the actual content of each of the fields replaced with ....{  &quot;version&quot;: &quot;1.1.0&quot;,  &quot;types&quot;: [...],  &quot;methods&quot;: [...],  &quot;monitorProfiles&quot;: [...],  &quot;virtualInvokeProfiles&quot;: [...],  &quot;callCountProfiles&quot;: [...],  &quot;conditionalProfiles&quot;: [...],  &quot;samplingProfiles&quot;: [...],  &quot;instanceofProfiles&quot;: [...],}The subsequent sections of this document provide a motivating example and describe each of the fields of the iprof file in more detail.Motivating ExampleConsider the following Java program that calculates and prints the first 10 Fibonacci numbers.import java.io.*;public class Fib {    private int n;    Fib(int n) {        this.n = n;    }    synchronized void fibonacci() {        int num1 = 0, num2 = 1;        for (int i = 0; i &amp;lt; n; i++) {            try {                Thread.sleep(10);            } catch (Exception e) {                // ignored            }            // Print the number            System.out.print(num1 + &quot; &quot;);            // Swap            int num3 = num2 + num1;            num1 = num2;            num2 = num3;        }    }    public static void main(String args[])    {        new Fib(10).fibonacci();    }}This application will be used as an example to explain the structure and semantics of the iprof file.To generate an iprof file from this application, save it as Fib.java and execute the next commands one by one:javac Fib.javanative-image --pgo-instrument -cp . Fib./fibAfter the termination of fib, there should be a default.iprof file in the working directory.  Note: The exact values shown throughout this document will likely be different in your run,so understanding the semantics of the values is required if you try to confirm the claims made throughout the document.VersionThis section describes the version of the iprof file format.The iprof format uses a semantic versioning scheme (ie. major.minor.patch) to ensure any consumers of the iprof file can know which information to expect and in which format.The major version is updated for breaking changes (for example, a new way of encoding the information),minor for non-breaking ones (for example, adding a new optional field in the top-level JSON object),and the patch version is updated for minor fixes that should not impact any client.The current version of the iprof file format is 1.1.0, which can be seen in the iprof file from the example application....    &quot;version&quot;: &quot;1.1.0&quot;,...TypesThis entry in the iprof file contains information about all the types which are required to understand the profile.This includes, but is not limited to, primitive types, types that declare methods that were profiled,as well as any type mentioned in the signatures of those methods.The types field in an iprof file is a JSON array of objects,where each element of the array represents one type.Each type is uniquely identified with their fully qualified name which is stored in the name field of the type object.The iprof format relies on the user to not use iprof files out of context,for example, gathering profiles on one application and applying them to another that has fully different types that share fully qualified names.Also, each type in this section is identified with a unique ID - an integer value.This ID is specific to one iprof file, meaning that, for example,a type with an ID of 3 in one iprof file can be completely differ to a type with an ID of 3 in another iprof file.These IDs are used throughout the iprof file whenever there is a need to reference a type(for example, the return type of a method, see the Methods section).This is done to reduce the footprint of the iprof file,as referring to the fully qualified name of a type every time would dramatically increase its size.See below a selection of the values from the types array of the Fibonacci example iprof file....    &quot;types&quot;: [        {            &quot;id&quot;: 0,            &quot;name&quot;: &quot;boolean&quot;        },        {            &quot;id&quot;: 1,            &quot;name&quot;: &quot;byte&quot;        },        {            &quot;id&quot;: 2,            &quot;name&quot;: &quot;short&quot;        },...        {            &quot;id&quot;: 8,            &quot;name&quot;: &quot;void&quot;        },        {            &quot;id&quot;: 9,            &quot;name&quot;: &quot;java.lang.Object&quot;        },        {            &quot;id&quot;: 10,            &quot;name&quot;: &quot;Fib&quot;        },...        {            &quot;id&quot;: 629,            &quot;name&quot;: &quot;java.lang.System&quot;        },...        {            &quot;id&quot;: 4823,            &quot;name&quot;: &quot;[Ljava.lang.String;&quot;        },...    ]...Each entry is comprised of two components explained before: id and name.Primitive types (for example, boolean, byte, short,the Fib class declared in the motivating example,as well as any other types used in the example(for example, java.lang.System is used to call the print method)are all present in the list.  Note: Only a selection of types is shown here because, despite our motivating example being very small,the iprof file contains a total of 5927 types, mostly from the JDK.MethodsThis entry in the iprof file encompasses information about all the methods which are required to understand the profile.This includes, but is not limited to, all the methods that were instrumented during the instrumentation build of the application.It can include methods that were not instrumented as well,for example, if profiles are usually gathered through sampling rather than instrumentation.As with types, the methods are (within one iprof file) uniquely identified with an integer ID,and this ID is used throughout the iprof file to refer to the method.Unlike types, they cannot be globally identified by just their name, which is also stored in the iprof file.For this reason, the iprof file also stores the method’s signature information.This information is stored in the signature field of the method object and is modeled as an array of integers.Each of these integer values is an ID of a type that must be present in the types entry of the iprof file.The order of values in this array is significant:the first value is the type that declares the method,the second value is the return type of the method, and the remaining values are in-order parameter types of the method.Note that the receiver type is not a part of the signature.Consider this selection of methods from the example application iprof file:    &quot;methods&quot;: [...        {            &quot;id&quot;: 19547,            &quot;name&quot;: &quot;main&quot;,            &quot;signature&quot;: [                10,                8,                4823            ]        },...        {            &quot;id&quot;: 19551,            &quot;name&quot;: &quot;fibonacci&quot;,            &quot;signature&quot;: [                10,                8            ]        },    ]...Each method object is comprised of three components: id, name and, signature.The method with the name main has an ID of 19547.The values in the signature field are 10, 8, and 4823.This leads to the conclusion that the main method was declared in a type with an ID of 10,and checking the example given in the Types section, you see that it is indeed the Fib class.The second value identifies the return value of the method, which is void (with an ID of 8).The final value (4823) is the ID of the type of main’s single parameter - an array of java.lang.String.Call-Count ProfilesThis section describes arguably the simplest of the profiles in the iprof file - the call-count profiles.These profiles hold information about how many times a method was executed in all inlining contexts.This means that the iprof file contains a separate count not just for each instrumented method,but also for each case where the method in question was inlined into another method.This inlining information is called “partial calling context” or just “context”,and understanding this concept is vital for understanding how much of the data in the iprof file is stored.Partial Calling ContextsThe partial calling context describes several levels of caller methods to a particular location in the code,and a different profile can be assigned to each partial calling context.The length of the partial calling context can be chosen arbitrarily,and it is also possible to always specify a single code location without the callers(i.e. to always use a context-insensitive code location).These contexts identify a particular location in the code so that the related profile can be applied to the correct location.At a high level, a context is just an ordered list of methods and bytecode indexes (BCIs)that signify that the profile is related to method a on BCI x which was inlined into method b and the invoke was on BCI y,and so on.Consider the following example Java program, especially the call graph of the program.public class EvenOrOddLength {    public static void main(String[] args) {        printEvenOrOdd(args[0]);    }    private static void printEvenOrOdd(String s) {        if (s.length() % 2 == 0) {            printEven();        } else {            printOdd();        }    }    private static void printEven() {        print(&quot;even&quot;);    }    private static void printOdd() {        print(&quot;odd&quot;);    }    private static void print(String s) {        System.out.println(s);    }}This program has the following incomplete call graph,where the boxes are methods (with their name and ID as per the iprof file)and they are connected by labeled arrows representing a “calls on BCI” relationship.             BCI 2    +----------+     BCI 9          +-----------| printEven|&amp;lt;-----------+          |           |   ID 3   |            |          V           +----------+            |     +-------+                        +----------------+   BCI 3   +------+     | print |                        | printEvenOrOdd |&amp;lt;----------| main |     | ID 5  |                        |    ID 2        |           | ID 1 |     +-------+                        +----------------+           +------+          ^                                   |          |           +---------+             |          +---------- | printOdd|&amp;lt;------------+             BCI 2    |   ID 4  |    BCI 15                      +---------+The simplest example partial context is the beginning of a method which was not inlined.Note that this does not mean the method was never inlined - only that in this context it serves as a compilation root.This information is stored as a pair of integers separated by a :.The first of these two integers is the method ID (as discussed before) and the second one is the BCI.Since the example is about the very start of the method, the BCI will be 0.In this example application, an example of such beginning-of-single-method partial contexts would be main at BCI 0, or 1:0 in the notation (ID:BCI).If additional locations within a single-method partial context need to be identified,you can have a partial context like 1:3, which indicates the location at BCI 3 of main.The call graph shows that this context corresponds to the invocation of printEvenOrOdd.Now consider a context where a method was inlined into another one.Let’s assume that, during compilation of this example application, the compilation starts at main.Assume also, that the inliner decides to inline the call to printEvenOrOdd into main (at BCI 3).The compilation unit superimposed over the call graph looks as follows.             BCI 2    +----------+     BCI 9          +-----------| printEven|&amp;lt;-----------+          |           |   ID 3   |            |          V           +----------+ +----------|-----------------------------+     +-------+                     |  +----------------+   BCI 3   +------+ |     | print |                     |  | printEvenOrOdd |&amp;lt;----------| main | |     | ID 5  |                     |  |    ID 2        |           | ID 1 | |     +-------+                     |  +----------------+           +------+ |          ^                        +----------|-----------------------------+          |           +---------+             |          +---------- | printOdd|&amp;lt;------------+             BCI 2    |   ID 4  |    BCI 15                      +---------+It is now required to identify the location which can be described as “beginning of printEvenOrOdd when inlined into main at BCI 3”.The context would start the same as in the previous example - the ID of the method (2 for printEvenOrOdd),followed by : and the BCI (which is 0 for the beginning of a method).But, it is also necessary to encode the additional context information - the fact that printEvenOrOdd was inlined into main at BCI 3.To do so, the context appends the &amp;lt; character and then appends the additional context.This resulting context is written down as 2:0&amp;lt;1:3 - method with id 2 at BCI 0, inlined into method with id 1 at BCI 3.Similarly, the call to printEven (which is on BCI 9 in printEvenOrOdd) from this compilation unit can be written down as 2:9&amp;lt;1:3.Let’s extend this compilation unit to also include a few more methods:the print method inlined into printEven at BCI 3, which is inlined into printEvenOrOdd at BCI 9, which is inlined into main on BCI 3.The extended compilation unit is presented in the following graph.   +------------------------------------------------------------------------+   |         BCI 2    +----------+     BCI 9                                |   |      +-----------| printEven|&amp;lt;-----------                              |   |      |           |   ID 3   |            |                             |   |      V           +----------+            |                             |   | +-------+                        +----------------+   BCI 3   +------+ |   | | print |                        | printEvenOrOdd |&amp;lt;----------| main | |   | | ID 5  |                        |    ID 2        |           | ID 1 | |   | +-------+                        +----------------+           +------+ |   +------^-----------------------------------|-----------------------------+          |           +---------+             |          +---------- | printOdd|&amp;lt;------------+             BCI 2    |   ID 4  |    BCI 15                      +---------+Several partial contexts can now be written down rather concisely, which are very cumbersome to write down in natural language.Consider the 5:0&amp;lt;3:2&amp;lt;2:2&amp;lt;1:3 partial context.This is read as “the beginning of print, inlined into printEven on BCI2, which is inlined into printEvenOrOdd at BCI 9,which is inlined into main at BCI 3”.These partial contexts can be arbitrarily long, depending on the inlining decisions that the compiler made during the build of the instrumented image.Note that this compilation unit does not include printOdd.Now assume printOdd is a compilation root and inlined print on BCI 2 into it.Both compilation units superimposed over the call graph look as follows.   +------------------------------------------------------------------------+   |         BCI 2    +----------+     BCI 9                                |   |      +-----------| printEven|&amp;lt;-----------                              |   |      |           |   ID 3   |            |                             |+--|------V------+    +----------+            |                             ||  | +-------+   |                    +----------------+   BCI 3   +------+ ||  | | print |   +-----------------+  | printEvenOrOdd |&amp;lt;----------| main | ||  | | ID 5  |                     |  |    ID 2        |           | ID 1 | ||  | +-------+                     |  +----------------+           +------+ ||  +------^-----------------------------------|-----------------------------+|         |           +---------+  |          ||         +---------- | printOdd|&amp;lt;------------+|            BCI 2    |   ID 4  |  | BCI 15|                     +---------+  |+----------------------------------+This will result in two distinct partial profiles for the “beginning of print”:One with the context  (5:0&amp;lt;3:2&amp;lt;2:2&amp;lt;1:3) shown before, and another with printOdd as the rightmost entry in the partial context (5:0&amp;lt;4:2).Note that, if print was also compiled as a compilation root (for example, if it was called from another point in the code and wasn’t inlined there),there would be yet another partial context for the begging of print which would be simply 5:0.Storing Call Count ProfilesThis entry in the iprof file is an array of objects where each object contains a context (stored in a ctx field of the object)as well as the actual numeric values of the profile (stored in the records field of the object).In the case of call-count profiles the only numeric value stored is the number of times the method (at the start of the context, with BCI 0)was executed in that context.This is modeled as an array of integers with a single value.Consider the following example call-count profiles from the first application example.&quot;callCountProfiles&quot;: [...        {            &quot;ctx&quot;: &quot;19551:0&quot;,            &quot;records&quot;: [                1            ]        },...        {            &quot;ctx&quot;: &quot;4669:0&amp;lt;19551:34&quot;,            &quot;records&quot;: [                10            ]        },...]The first shown object indicates that a method with the ID 19551 was executed only once in that context.Looking up the method with that ID in the methods field of the iprof file shows that it is the fibonacci method of the Fib class.This method was indeed executed only once during the run, and was, by chance, not inlined into its only caller (main).The second object shows that a method with the ID 4669 was inlined into fibonacci and that the call was on BCI 34.That method was executed 10 times in that context.Looking further in the iprof file it can be seen that this is in fact the java.io.PrintStream#print method called throughSystem.out which was indeed executed 10 times in that context.Confirming this is left as an exercise to the reader.Conditional ProfilesConditional profiles contain information about the behavior of conditionals (i.e. branches) in the code.This includes if and switch statements as well as all loops,since they are ultimately bound by a conditional statement.The profile information is essentially how many times each branch of a conditional statement was taken.The conditional profiles are stored in a very similar manner to call-count profiles -an array of objects with a ctx and records field, whose values are a string and an array of integers respectively.It is recommended to understand the information in the Call-Count Profiles section,especially the Partial Calling Contexts subsection.Consider the following selection of the conditional profiles from the Fibonacci example.&quot;conditionalProfiles&quot;: [...        {            &quot;ctx&quot;: &quot;19551:11&quot;,            &quot;records&quot;: [                20,                0,                10,                53,                1,                1            ]        },...]The value in the ctx field of this object shows that the method in question has the ID 19551 which is Fib#fibonacci.The BCI in question is 11.Inspecting the bytecode of the method would show that BCI 11 corresponds to the conditional check of the for loop in the fibonacci method.This means that this profile is about the for loop in the fibonacci method.The records entry of this object is an array of 6 values.This is because the conditional has 2 branches (one to the beginning of the loop, another exiting the loop), and 3 integer values per branch are stored:the BCI to which the branch jumps, an index of the branch, and a count of how many times that branch was taken.This means that the length of the records array in conditional profiles must always be divisible by 3.A switch statement with 100 branches will result in an array of 300 values.The index of the branch is just an ordering of the branches imposed by the compiler.This is necessary as multiple branches could target the same BCI, but the index is unique.Going back to the example values (20, 0, 10, 53, 1, 1)indicate that a jump to BCI 20 (index 0) happened 10 times (first 3 values)and the jump to the BCI 53 (index 1) happened once.Referring back to the source code of fibonacci, the loop is executed n times, which is 10 for the example.This is in line with the collected profile - 10 jumps to the beginning of the loop to repeat the loop 10 times,and 1 jump to the outside of the loop to terminate.Virtual Invoke ProfilesVirtual invoke profiles contain information on the run-time types of a receiver of a virtual invoke.Concretely, it is how many times each recorded type was the type of the receiver of the virtual call.The current implementation of PGO limits the number of types recorded per location to 8,but there is no such limit in the iprof format.The virtual invoke profiles are stored in a very similar manner to call-count profiles -an array of objects with a ctx and records field whose values are a string and an array of integers respectively.It is recommended to understand the information in the Call-Count Profiles section,especially the Partial Calling Contexts subsection.Consider the following selection of virtual invoke profiles from the Fibonacci example....    &quot;virtualInvokeProfiles&quot;: [...        {            &quot;ctx&quot;: &quot;3236:11&amp;lt;4669:2&amp;lt;19551:34&quot;,            &quot;records&quot;: [                2280,                10            ]        },...        {            &quot;ctx&quot;: &quot;6886:9&amp;lt;6882:23&quot;,            &quot;records&quot;: [                1322,                2,                2280,                60,                3660,                56            ]        },...    ]...The method at the end of the context has an ID of 19551 (Fib#fibonacci).In that method, on BCI 34, a method with ID 4669 was inlined into fibonacci.Looking at the methods in the iprof file, you can see that it is java.io.PrintStream#print,which is expected based on the source code.Furthermore, on BCI 2, a method with the ID 3239 was inlined into printand the profile refers to BCI 11 of that method.Looking at the methods in the iprof file again it can be seen that the methodjava.lang.String#valueOf(java.lang.Object) has the ID 3236.This valueOf method has a virtual invoke at BCI 11.The source code of this method follows, and the virtual invoke in question is the call to toString on Object.    public static String valueOf(Object obj) {        return (obj == null) ? &quot;null&quot; : obj.toString();    }The records array has only 2 values.The first number is the ID of the type that was recorded (2280 in this case is java.lang.String).The second number is the count of how many times this type was the receiver for this virtual invoke.Since the example application only ever passes java.lang.String to the print method(note the appending of a space after num1 which implicitly converts the argument to a java.lang.String)and the print method is called 10 times - the count for java.lang.String is 10.The length of the records array for virtual invoke profiles is always a multiple of 2,since the values represent a type ID and count pair.In the second object of the example, the records array has 6 entries,meaning 3 different types were recorded as the receiver type at run time.Monitor ProfilesThis section describes the monitor profiles.In Java, each object has its own monitor,which can be used to ensure exclusive access to a section of code (using the synchronized keyword).The monitor profiles record which types were used to synchronize code(either implicitly by adding synchronized to a method of the type, or explicitly with synchronized(obj) {...}),as well as how many times this happened for each of those types.The monitor profiles are stored in a very similar format as call-count profiles -an array of objects with a ctx and records field whose values are a string and an array of integers respectively.It is recommended to understand the information in the Call-Count Profiles section,especially the Partial Calling Contexts subsection.It is worth noting that, since monitor profiles are global, i.e. not related to a particular context,there is only one object in the array and that object has a dummy 0:0 context in the ctx field.This is done for legacy reasons, to keep the format of all the profiles consistent.See below the entirety of the monitor profiles for the Fibonacci example.    &quot;monitorProfiles&quot;: [        {            &quot;ctx&quot;: &quot;0:0&quot;,            &quot;records&quot;: [                9,                4,                10,                1,                579,                9,                619,                10,                1213,                1,                1972,                1,                2284,                2,                2337,                1,                2612,                2,                3474,                3,                3654,                61,                3807,                3,                3820,                7,                4060,                2,                4127,                3,                4725,                6            ]        }    ],...]As mentioned before, the value of the ctx fields of the single object in the array is a dummy context 0:0.The records on the other hand are similar to the format used for virtual invoke profiles -an array of type ID and count pairs.This means that, as with virtual invoke profiles, the length of records array has to be a multiple of 2.The first two values of the array indicate that the type with ID 9 (java.lang.Object) has been used 4 times for synchronization.Since the example does only one synchronization on the instance of Fib (the fibonacci method is synchronized)the next two values indicate that the type with ID 10 (Fib) has been used once for synchronization(recall that fibonacci method is executed only once).Sampling ProfilesThis section describes the sampling profiles.Unlike all the profiles described so far,which are gathered through instrumentation and only have partial contexts,sampling profiles are gathered by periodically sampling the call stack,with no need for instrumentation.This also means that the contexts contained in the sampling profiles are not partial,but are in fact the entire call stack at the moment of sampling.This means that it is normal and expected to see much longer contexts in the sampling profiles when compared to the other profiles.The sampling profiles are stored in a very similar manner to call-count profiles -an array of objects with a ctx and records field whose values are a string and array of integers respectively.It is recommended to understand the information in the Call-Count Profiles section,especially the Partial Calling Contexts subsection.The Fibonacci example executes rather quickly for the sampler to collect a useful variety of samples,so the entirety of the sampling profiles is shown below....    &quot;samplingProfiles&quot;: [        {            &quot;ctx&quot;: &quot;11823:38&amp;lt;12811:1&amp;lt;12810:33&amp;lt;12855:25&amp;lt;19551:17&amp;lt;19547:9&amp;lt;19529:10&amp;lt;6305:105&amp;lt;5998:67&amp;lt;5941:0&amp;lt;5903:50&amp;lt;2684:23&amp;lt;2685:1&quot;,            &quot;records&quot;: [                10            ]        },        {            &quot;ctx&quot;: &quot;22500:23&amp;lt;22353:65&amp;lt;22210:15&amp;lt;22187:246&amp;lt;22032:20&amp;lt;22030:1&amp;lt;22027:22&amp;lt;11795:68&amp;lt;11793:12&amp;lt;43854:2&quot;,            &quot;records&quot;: [                1            ]        }    ],...]...The length of the ctx values is much longer in the sampling profiles.The first object in the sampling profiles has the method with ID 11823 at the top of the context.Looking at the method entries in the iprof file this is the com.oracle.svm.core.thread.PlatformThreads#sleep method,called from method with ID 12811 (java.lang.Thread#sleepNanos0),called from method with ID 12810 (java.lang.Thread#sleepNanos),called from method with ID 12855 (java.lang.Thread#sleep),called from method with ID 19551 (Fib#fibonacci) and so on down to the entry point of the application.Note again that this is a full context, unlike a partial one that other profiles use.The records array contains a single value which tells us how many times this unique call stack was seen during run-time sampling.In this case, it means that the context described in the previous paragraph was recorded 10 times.The other object in the sampling profiles array contains a different context and this sample was seen only once.Understanding the nature of this sample is left as an exercise to the reader.Instance-of Profiles  Note: Instance-of profiles were added in the iprof file format version 1.1.0. They are not present in version 1.0.0.Instance-of profiles contain information on the run-time types of values that are checked at instanceof operators.Specifically, they record how many times a particular run-time type was encountered at a given instanceof operation.Thus, instance-of profiling information can be stored in the same format as Virtual Invoke Profiles.The only difference is that the resulting type histogram in the records part describes the types seen at instanceof checks, rather than the receiver types of virtual method calls.Consider the following Java code:    public class A {}    public class B extends A {}    public static void doForA(Object obj) {        if(obj instanceof A) {            doSomething(obj);        }    }The records section of the profile will include all types (e.g., A, B, Object, String) encountered at run time for the obj variable, together with their occurrence counts.Thus, the length of the records array for instance-of profiles is always a multiple of 2,since the values represent a type ID and count pair.Related Documentation  PGO  Optimize a Native Executable with Profile-Guided Optimization",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/iprof-file-format/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo-lcov":  {
          "title": "Making Sense of PGO Reports Using LCOV",
          "content": "Making Sense of PGO Reports Using LCOVHere you will learn how to analyze PGO profiles with the aid of LCOV-based tooling.Profile-Guided Optimization (PGO) helps you maximize the performance of your native application.As part of the PGO process, you create an instrumented binary and run a workload on it to generatea PGO profile file that you can then feed back into the build process to generate an optimized binaryof your application.Typically, there’s no need for you to understand the contents of such a PGO profile.In some cases, however, you may want to understand what has been recorded as part of a profile,especially when there is a problem with the performance of your optimized binary.GraalVM Native Image can export profiling information in an additional file in the LCOV format.You can open and visualize such a file in any IDE or tool that supports the LCOV format.This allows you to see what methods of your code are called and how often.The Graal compiler spends more time optimizing hot methods, methods that are called many times, thancold methods, methods that are only called a few times or not at all.Therefore, you can use the additional LCOV export to check what methods have actually been called aspart of the workload that ran on an instrumented binary.This also means that the PGO profile contains appropriate profiling information for the methods.Besides, the coverage visualization helps you identify the hot methods of your application, again forthe workload that ran on the instrumented binary.If you want to maximize performance, these are typically the methods you want to take a closer look at.On the contrary, methods that are not covered at all are potential candidates for cleanups, which inturn can speed up the build time.Creating Coverage ReportTo create a coverage report, you first need to pass the -H:+ProfilingLCOV experimental option alongwith the --pgo-instrument option when building an instrumented binary.For example:native-image -cp . GameOfLife -o gameoflife-instrumented --pgo-instrument -H:+UnlockExperimentalVMOptions -H:+ProfilingLCOV -H:-UnlockExperimentalVMOptionsThe report, in the form of a .info trace file, is then generated along with the profile afterrunning the instrumented application.In the similar fashion to profiling, one can additionally customize the destination of the generatedinfo file via the -XX:ProfilesLCOVFile option.For example:./gameoflife-instrumented -XX:ProfilesLCOVFile=gameoflife-coverage.infoThe generated LCOV trace file provides the coverage information at method-level, i.e., whether aparticular method got executed (and how many times) or not.This information can be easily summarised using the lcov command (seethe official LCOV man page).For example:lcov --summary gameoflife-coverage.infoThis outputs the short summary in the format:Summary coverage rate:  lines......: 17.3% (24873 of 144172 lines)  functions..: 15.6% (2390 of 15285 functions)  branches...: no data foundAdditionally, to visualize the data, one can use the genhtml utilityfor creating HTML reports from LCOV data, or use any third-party LCOV data visualizer (e.g., theLCOV viewer project).To show which methods are instrumented (found) and which are executed (hit), the genhtml additionallyutilises source files (which can also be omitted if unavailable using the --synthesize-missing option).Also, the --source-directory option is useful in the case when the source files are located in aspecific directory.For example:genhtml --source-directory *absolute-path-to-sources* gameoflife-coverage.infoSee below an example source file view from the report for the gameoflife-coverage.info trace filegenerated by the former command:More over, the functions view lists all the methods found in the particular source file along withtheir execution counts:Further Reading  Inspecting a Profile in a Build Report  Frequently Asked Questions",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/LCOV/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo-merging-profiles":  {
          "title": "Merging Profiles from Multiple Sources",
          "content": "Merging Profiles from Multiple SourcesThe PGO infrastructure enables you to combine multiple profiles into a single one using the Native Image Utils Tool.Merging profiles implies that the resulting profile will contain the union of all types, methods, and profile entries from the provided profiles.UsageTo merge two profiles, profile_1.iprof and profile_2.iprof, into a single file named output_profile.iprof, use the following command:native-image-utils merge-pgo-profiles --input-file=profile_1.iprof --input-file=profile_2.iprof --output-file=output_profile.iprofThere is also a way to specify a directory as a source of profiles using the  --input-dir=&amp;lt;path&amp;gt; option.Then it only searches for profiles in the given directory, excluding subdirectories.native-image-utils merge-pgo-profiles --input-dir=my_profiles/ --output-file=output_profile.iprofFurther Reading  Basic Usage of Profile-Guided Optimization  Native Image Utils Tool",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/merging-profiles/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo-profile-quality":  {
          "title": "Tracking Profile Quality",
          "content": "Tracking Profile QualityThe most challenging step when using PGO for Native Image is gathering a profile for a relevant workload.Because your source code evolves, your application is rarely static in time.It is sometimes very time consuming to go through the steps of “build-instrumented-image”, “gather-profile”, and “build-optimized-image” for every change to your source code.This document gives some answers to the question “How long can I continue to use an existing profile as my application’s source code changes over time?”Approach 1: Reuse the Profile IndefinitelyWhen you build an optimized application, Native Image aims to do the best it can with the given profile.This means that providing an out-of-date profile for your application (or even a profile for a completely different application) should not stop Native Image from producing a native executable.  Note: An incorrect profile can result in worse performance than no profile. This is because an incorrect profile can lead the compiler to spend optimization resources on the wrong elements of the application and deprioritize the important elements.All that said, reusing a single profile indefinitely for an evolving application will sooner or later turn counterproductive.Approach 2: Collect Profiles PeriodicallySince your application can periodically change, it is logical to periodically collect a fresh profile.One way to achieve this would be a daily Linux cron job that builds an instrumented version of the application using the tip of the master branch, runs a workload to gather a profile, and uploads the resulting iprof file to an FTP server from which other optimizing builds can download it.This ensures that the difference between the application version that is being built and the profile that is being used is never greater than a fixed time interval (24h in this example).However, gathering a profile periodically extends compute time, so it should be balanced against the frequency at which the application changes.If your application is relatively stable and the source code changes infrequently, then it is fine to re-profile less often.Some things to keep in mind:  Align your profiling schedule with the application-release schedule, to avoid building an application with a stale profile.  Ideally, convert the production workload into a reproducible workload, collect the profiles as part of your build, and then create an optimized native executable with profiles that are always fresh.That way, you do not risk having stale or misaligned profiles as long as your workload executes the same parts of the application that will later execute in production.Approach 3: Track the Profile-Quality Metrics Over TimeTo better understand the quality of a profile, Native Image provides two metrics that you can request when building an optimized executable: profile relevance and profile applicability.These metrics reflect the relationship between a profile and the methods and classes that appear in an optimized executable.A change in the values of these two metrics between builds (that use the same profile) indicates that the set of classes and/or methods in those builds has also changed (between the time the profile was collected and the current build).How to Obtain Profile-Quality MetricsTo calculate and print the profile-quality metrics, pass the -H:+PGOPrintProfileQuality option when building an optimized native executable. (This option is experimental.)Let’s consider the Game Of Life example application which was introduced in Basic Usage of Profile-Guided Optimization:native-image -cp . GameOfLife -o gameoflife-pgo --pgo=gameoflife.iprof -H:+PGOPrintProfileQualityIn the build output, at phase 5, you should see an additional line about profile applicability and profile relevance:GraalVM Native Image: Generating &#39;gameoflife-pgo&#39; (executable)...[5/8] Inlining methods...     [***]                                                                      (0.4s @ 0.28GB)Info: PGO: Profile applicability is 21.74%. Profile relevance is 72.71%....The absolute values of these metrics do not tell you much, and should not be considered in isolation.As mentioned earlier, these metrics describe the relationship between the profile and application’s code.If you change the application and reuse the profile, you should see a change in the values of the metrics.For example, apply a simple “method-rename” refactoring to the applyRules () application method.From the profile’s perspective, the applyRules () method was removed from the set of methods in the application and a new method called applyGameRules was introduced.Rerunning the optimized build with the same profile and the modified application returns the following output:native-image -cp . GameOfLife -o gameoflife-pgo --pgo=gameoflife.iprof -H:+PGOPrintProfileQuality========================================================================================================================GraalVM Native Image: Generating &#39;gameoflife-pgo&#39; (executable)......[5/8] Inlining methods...     [***]                                                                      (0.4s @ 0.28GB)Info: PGO: Profile applicability is 21.67%. Profile relevance is 72.66%.                                                                  (6.8s @ 0.29GB)...Recall that the profile applicability in the first build was 21.74%, and now it is 21.67%.Similarly, the profile relevance in the first build was 72.71%, and now it is 72.66%.The small change to the code resulted in a small metrics value change, informing you that the profile might be slightly out-of-date.  Note: In this example you renamed of a very hot method. This change is likely to cause a performance regression since profiles cannot be applied to a hot method. A similar change made in the cold code of the application would result in a similar reduction in these metrics,but this should not impact performance.Note that these metrics are a measure of the relationship between the provided profile and the set of methods in the application, and are not in any way a measurement or prediction of any performance impact a change of the profile, application source code, or dependencies may have.These numbers also make little sense or have little utility when observed in one single build.Their utility comes from observing the metrics change when re-using profile across builds or providing a different profile for the same build of the application.Profile Quality Metric: ApplicabilityThe applicability metric answers the following question: “How applicable is this profile to the application’s methods?”.During the compilation of individual methods in the application, it keeps track of how many locations N in the code needed a profile,and how many times S a profile was available.The profile applicability metric is the ratio S / N, expressed as a percentage.This means that adding new code to the application (and not to the profile) should result in a reduction in profile applicability.This is because more code means more requests for profiles, and the same number of times that the profile can be applied (S),is divided with a larger number of total requests for profiles (N).  Note: It is wrong to expect a profile applicability of 100%.A good workload will, in almost all cases, differentiate between the hot and the cold parts of the application,and will not execute some of the cold parts of the code.For this reason, the profile will not contain any entries for the cold parts of the application (such as, for example, the exception handlers),which are anyway rarely executed in the real workload.A 100% applicability would mean that all parts of the code in the image were fully profiled, which is almost never the case in practice.Profile Quality Metric: RelevanceThe relevance metric aims answers the question: “To what extent do the profile contents match the application methods?”.When loading a profile, all its data is checked against the set of application methods, and all the entries that do not match those methods are dropped.For example, if you remove a method from a class but use a profile that still has entries for that method, then all those entries will be dropped during profile-loading.Profile relevance is the percentage of data that was not dropped during loading.This means that removing code from the application (and not from the profile) should result in the profile relevance reduction, because the percent of data in the profile which is relevant to the new application version is reduced.On the other hand, adding new code (say a new class or dependency) to the application would not affect this metric since the amount of data you need to drop from the profile does not change.  Note: It is wrong to expect that building an optimized binary of exactly the same application as the one used to gather the profile will result in the profile relevance of 100%.This is not the case because the methods of the instrumented binary and the optimized binary differ in subtle ways.For example, the instrumented binary contains code for gathering the profile data as well as code for serializing that data to a file.This code is unnecessary and thus not present in the optimized binary.Looking at the Game Of Life example, the relevance around 70% is primarily due to the application being very small (a single Java class of less than 120 lines of code). Thus the differences in the set of methods of the instrumented and the optimized binary are rather exaggerated.For larger, real-world applications, this percentage is typically larger, but not 100%.Further Reading  Merging Profiles from Multiple Sources  PGO Frequently Asked Questions",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/profile-quality/"
          },
          
          "latest-reference-manual-native-image-optimizations-and-performance-pgo":  {
          "title": "Profile-Guided Optimization",
          "content": "Profile-Guided OptimizationWhat is Profile-Guided Optimization?One advantage that a just-in-time (JIT) compiler has over an ahead-of-time (AOT) compiler is its ability to analyze the run-time behavior of an application.For example, HotSpot keeps track of how many times each branch of an if statement is executed.This information, called a “profile”, is passed to a tier-2 JIT compiler (such as Graal).The tier-2 JIT compiler then assumes that the if statement will continue to behave in the same manner, and uses the information from the profile to optimize that statement.An AOT compiler typically does not have profiling information, and is usually limited to a static view of the code.This means that, barring heuristics, an AOT compiler sees each branch of every if statement as equally likely to occur at run time; each method is as likely to be invoked as any other; and each loop repeats the same number of times.This puts an AOT compiler at a disadvantage—without profiling information, it is difficult to generate machine code of the same quality as a JIT compiler.Profile-Guided Optimization (PGO) is a technique that brings profile information to an AOT compiler to improve the quality of its output in terms of performance and size.  Note: PGO is not available in GraalVM Community Edition.What Is a Profile?A profile is a summarized log of how many times certain events occurred during an application’s run time.The events are chosen according to which information can be useful for the compiler to make better decisions.Examples include:  How many times was this method called?  How many times did this if statement take the true branch? How many times did it take the false branch?  How many times did this method allocate an object?  How many times was a String value passed to a particular instanceof check?How Do I Obtain a Profile of My Application?When running an application on a JVM with a JIT compiler, the profiling of the application is handled by the runtime environment, with no extra steps needed from a developer.However, creating a profile adds execution time and memory usage overheads to the performance of the application that is being profiled.This causes warmup issues: the application will reach predictable peak performance only after sufficient time has passed for the application code to be profiled and JIT-compiled.For long-running applications, this overhead usually pays for itself, yielding a performance boost later.On the other hand, for short-lived applications and applications that need to start with predictable performance as soon as possible, this is counterproductive.Gathering a profile for an AOT-compiled application is more involved, and requires extra steps by the developer, but introduces no overhead in the final application.A profile must be gathered by observing the application while it is running.This is commonly achieved by compiling the application in a special mode that inserts instrumentation code into the application binary.The instrumentation code increments counters for the events that are of interest to the profile.A binary that includes instrumentation code is then called an instrumented binary, and the process of adding these counters is called instrumentation.Naturally, an instrumented binary of the application is not as performant as a default binary due to the overhead of the instrumentation code, so it is not recommended to run it in production.But, running synthetic representative workloads on the instrumented binary provides a representative profile of the application’s behavior.When building an optimized application, the AOT compiler has both a static view and a dynamic profile of the application.Thus, the optimized application performs better than the default AOT-compiled application.How Does a Profile “Guide” Optimization?During compilation, a compiler has to make decisions about optimizations.For example, in the following method, the function-inlining optimization needs to decide which call sites to inline, and which not.private int run(String[] args) {    if (args.length &amp;lt; 3) {        return handleNotEnoughArguments(args);    } else {        return doActualWork(args);    }}For illustrative purposes, imagine that the inlining optimization has a limit on how much code can be generated, and can hence only inline one of the calls.Looking only at the static view of the code being compiled, both the doActualWork() and handleNotEnoughArguments() invocations look pretty much indistinguishable.Without any heuristics, the phase would have to guess which is the better choice to inline.However, making the incorrect choice can lead to code that is less efficient.Assume that run() is most commonly called with the right number of arguments at run time, then inlining handleNotEnoughArguments would increase the code size of the compilation unit without giving any performance benefit since the call to doActualWork()needs to still be made most of the time.Having a run-time profile of the application can give the compiler data to differentiate between the calls.For example, if the run-time profile recorded the if condition as being false 100 times and true 3 times, then it should inline doActualWork(). This is the essence of PGO - using information from the profile to give the compiler grounding in data when making certain decisions.The actual decisions and the actual events the profile records vary from phase to phase, but the preceding example illustrates the general idea.Notice that PGO expects a representative workload to be run on the instrumented binary of the application.Providing a counter-productive profile (a profile that records the exact opposite of the actual runtime behavior of the application) will be counter-productive.For the above example, this would be running the instrumented binary with a workload that invokes the run() method with too few arguments, while the actual application does not.This would lead to the inlining phase choosing to inline handleNotEnoughArguments reducing the performance of the optimized binary.Hence, the goal is to gather profiles on workload that match the production workloads as much as possible.The gold standard for this is to run the exact same workloads you expect to run in production on the instrumented binary.For a more detailed usage overview, go to Basic Usage of Profile-Guided Optimization documentation.Further Reading  Basic Usage of Profile-Guided Optimization  Inspecting a Profile in a Build Report  Creating LCOV Coverage Reports  Merging Profiles from Multiple Sources  Tracking Profile Quality Over Time  The iprof File Format  The iprof JSON Schema  Frequently Asked Questions",
          "url": " /latest/reference-manual/native-image/optimizations-and-performance/PGO/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-perf-profiler":  {
          "title": "Linux Perf Profiler Support in Native Image",
          "content": "Linux Perf Profiler Support in Native ImageThe perf profiler is a performance analysis tool in Linux that enables you to collect and analyze various performance-related data such as CPU utilization, memory usage, and more.It is particularly useful for profiling and understanding the behavior of applications.InstallationPerf is a profiler tool for Linux systems.Most distributions come with perf pre-installed, but you can install it using your package manager if it is not available.To install perf on Oracle Linux/Red Hat/CentOS, run this command:sudo yum install perfTo install perf on Debian/Ubuntu, run the following commands one by one:sudo apt updatesudo apt install linux-tools-common linux-tools-genericAfter installing perf, backup the default values of the following options:cat /proc/sys/kernel/perf_event_paranoid &amp;gt; perf_event_paranoid.backupcat /proc/sys/kernel/kptr_restrict &amp;gt; kptr_restrict.backupThen set them to the new desired values:echo -1 &amp;gt; /proc/sys/kernel/perf_event_paranoidecho 0 &amp;gt; /proc/sys/kernel/kptr_restrictIn the example above, -1 and 0 are used as values, which are the least restrictive, so it is not recommended to use them in production code.You can customize these values according to your needs.perf_event_paranoid has four different levels (values):  -1: Allow use of (almost) all events by all users.  &amp;gt;=0: Disallow ftrace function tracepoint by users without CAP_SYS_ADMIN.  &amp;gt;=1: Disallow CPU event access by users without CAP_SYS_ADMIN.  &amp;gt;=2: Disallow kernel profiling by users without CAP_SYS_ADMIN.kptr_restrict has three different levels (values):  0: Kernel pointers are readable by all users.  1: Kernel pointers are only accessible to privileged users (those with the CAP_SYS_ADMIN capability).  2: Kernel pointers are hidden from all users.Once finished using perf, restore the original values:cat perf_event_paranoid.backup &amp;gt; /proc/sys/kernel/perf_event_paranoidcat kptr_restrict.backup &amp;gt; /proc/sys/kernel/kptr_restrictBuilding Native ExecutablesThe following command assumes that native-image is on the system path and available.If it is not installed, refer to the Getting Started.native-image -g -H:+PreserveFramePointer &amp;lt;entry_class&amp;gt;The -g option instructs Native Image to produce debug information for the generated binary.perf can use this debug information, for example, to provide proper names for types and methods in traces.The -H:+PreserveFramePointer option instructs Native Image to save frame pointers on the stack.This allows perf to reliably unwind stack frames and reconstruct the call hierarchy.Profiling of Runtime-Compiled MethodsNative Image can generate detailed runtime compilation metadata for perf in the jitdump format.This enables perf profiling of runtime compiled methods, for example for Truffle compilations.jitdumpThe jitdump format stores detailed metadata for runtime compiled code. This requires post-processing of the perf data to inject the runtime compilation metadata.      Build with jitdump support:    native-image -g -H:+PreserveFramePointer -H:+RuntimeDebugInfo -H:RuntimeDebugInfoFormat=jitdump ...    At image-runtime, the jitdump file _/jit-.dump_ is created, and runtime compilation metadata is written to it.The output directory can be configured with `-R:RuntimeJitdumpDir=` (defaults to _./jitdump_).        Record with perf:    When recording profiling data, use the -k 1 option to ensure time-based events are ordered correctly for injection:    perf record -k 1 -o perf.data &amp;lt;your-application&amp;gt;    If the perf data was not recorded with -k 1, injecting runtime compilation metadata from a jitdump file will fail.        Inject jitdump into perf data:    perf inject -j -i perf.data -o perf.jit.data    This step:          Locates the jitdump file.      Generates a .so file for each runtime compilation entry in the jitdump file.      Injects runtime compilation metadata into the profiling data and stores it in perf.jit.data.            Inspect profiling data:    perf report -i perf.jit.data    Symbols from the jitdump file appear as coming from _jitted--.so_, where `code_id` is the index of a compilation entry in the jitdump file.  Basic OperationsCPU Profiling      List all available events:    perf list    This command displays a list of all available events that you can use for profiling.        Record CPU events:    perf record -e &amp;lt;event&amp;gt; -o perf.data &amp;lt;your_executable&amp;gt;    Replace &amp;lt;event&amp;gt; with the desired event from the list.This command profiles your executable and save the data to a file named perf.data.        Generate a report:    perf report    This command generates a report based on the collected data.You can use various options to customize the output.  Memory Profiling      Record memory events:    perf record -e memory:&amp;lt;event&amp;gt; -o perf.data &amp;lt;your_executable&amp;gt;    Replace &amp;lt;event&amp;gt; with a specific memory event.This command profiles memory-related events.        Generate a memory report:    perf report --sort=dso    This command generates a report focused on memory-related events, sorted by dynamic shared object (DSO).  Tracing      Record system-wide traces:    sudo perf record -a -g -o perf.data    This command records system-wide traces, including call-graph information, and saves the data to a file named perf.data. Use sudo for system-wide tracing.        Generate a trace report:    perf script    This command generates a script that can be used for analyzing the recorded trace data.  Generating Flame Graphs from Profiling DataFlameGraph is a tool written in Perl that can be used to produce flame graphs from perf profiling data.Flame graphs generated by this tool visualize stack samples as interactive SVGs, making it easy to identify hot code paths in an application.      Download the tool and record profiling data as described in Basic Operations.    Make sure the profiling data was recorded with -g to capture call graphs, otherwise the flame graph will be flat.    Fold stacks:    perf script -i perf.data | ./stackcollapse-perf.pl &amp;gt; perf.data.folded    Render an SVG:    ./flamegraph.pl perf.data.folded &amp;gt; perf.data.svg        Open the flame graph:    Use an application to view the generated SVG file (for example, firefox, chromium).    firefox perf.data.svg  Highlighting Runtime-Compiled MethodsIf the native image supports profiling of runtime-compiled methods, it is possible to highlight runtime-compiled symbols in the flame graph.      Build the native image with jitdump support, record profiling data and inject the jitdump information as described in jitdump.        Fold stacks:    This involves folding the stacks for the non-jitdump-injected perf.data and the jitdump-injected perf.jit.data.    perf script -i perf.data | ./stackcollapse-perf.pl &amp;gt; perf.data.foldedperf script -i perf.jit.data | ./stackcollapse-perf.pl &amp;gt; perf.jit.data.folded        Generate a consistent color palette map:    Use the non-jitdump-injected perf.data.folded to create a consistent palette map in palette.map for events in perf.data.The first call with --cp will create the map while subsequent calls with --cp reuse the map for consistent coloring of known events.This also produces a flame graph for the non-jitdump-injected data.    ./flamegraph.pl --cp perf.data.folded &amp;gt; perf.data.svg        Reuse the color palette map:    Use the consistent palette for already known events with --cp for the jitdump-injected perf.jit.data.folded.This is, events already seen in the non-jitdump-injected perf.data.folded get a fixed coloring.New events get a random coloring from the palette selected with the --color option (e.g. mem).    ./flamegraph.pl --cp --color mem perf.jit.data.folded &amp;gt; perf.jit.data.svg        Open the flame graph:    firefox perf.jit.data.svg  Generate an Invocation-Time-Ordered Flame GraphGenerate a stack-reversed flame graph with the topmost frames shown at the bottom of the flame graph in order of invocation time.Calls appear left-to-right in chronological order, with stack frames in each call arranged top-to-bottom from oldest to newest.Events from all threads contributing to the profiling data are shown interleaved../flamegraph.pl --reverse perf.data.folded &amp;gt; perf.data.svgfirefox perf.data.svgRelated Documentation  Debug Information  JDK Flight Recorder (JFR)",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/perf-profiler/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-profiling":  {
          "title": "Profiling Truffle Interpreters",
          "content": "Profiling Truffle InterpretersThere is no shortage of tools for profiling interpreters written using Truffle.When running in JVM mode you can use standard JVM tooling such as VisualVM, Java Flight Recorder, and Oracle Developer Studio. When running in Native Image you can use callgrind from the Valgrind tool suite, and other system tools such as strace.As a language running on GraalVM, other GraalVM tools can be used.For a broad enough definition of profiling, you can also use the Ideal Graph Visualizer (IGV) and C1 Visualizer to inspect the compiler output.This guide is less about how to use each tool and more about suggestions for extracting the most useful information from the tools, assuming a basic knowledge of their usage.Profiling with CPU SamplerThe simplest way to profile the application level, for example, to find in which guest-language function(s) most of the time is spent, is to use CPU Sampler, which is part of the /tools suite and part of GraalVM.Simply pass --cpusampler to your language launcher:language-launcher --cpusampler --cpusampler.Delay=MILLISECONDS -e &#39;p :hello&#39;You probably want to use a sampling delay with --cpusampler.Delay=MILLISECONDS to only start profiling after warmup. That way, you can easily identify which functions get compiled and which do not and yet take a significant amount of time to execute.See language-launcher --help:tools for more --cpusampler options.Getting Compilation Data from the CPU SamplerThe CPU sampler does not show information about time spent in compiled code. This was, at least in part, motivated by the introduction of multi-tier compilation where “compiled code” was not descriptive enough.Using the --cpusampler.ShowTiers option allows users to control whether they wish to see compilation data at all, as well as to specify exactly which compilation tiers should be considered in the report.For example, adding --cpusampler.ShowTiers=true will show all the compilation tiers encountered during execution as shown below.-----------------------------------------------------------------------------------------------------------------------------------------------------------Sampling Histogram. Recorded 553 samples with period 10ms.  Self Time: Time spent on the top of the stack.  Total Time: Time spent somewhere on the stack.  T0: Percent of time spent in interpreter.  T1: Percent of time spent in code compiled by tier 1 compiler.  T2: Percent of time spent in code compiled by tier 2 compiler.-----------------------------------------------------------------------------------------------------------------------------------------------------------Thread[main,5,main] Name              ||             Total Time    |   T0   |   T1   |   T2   ||              Self Time    |   T0   |   T1   |   T2   || Location----------------------------------------------------------------------------------------------------------------------------------------------------------- accept            ||             4860ms  87.9% |  31.1% |  18.3% |  50.6% ||             4860ms  87.9% |  31.1% |  18.3% |  50.6% || ../primes.js~13-22:191-419 :program          ||             5530ms 100.0% | 100.0% |   0.0% |   0.0% ||              360ms   6.5% | 100.0% |   0.0% |   0.0% || ../primes.js~1-46:0-982 next              ||             5150ms  93.1% |  41.7% |  39.4% |  18.8% ||              190ms   3.4% | 100.0% |   0.0% |   0.0% || ../primes.js~31-37:537-737 DivisibleByFilter ||              190ms   3.4% |  89.5% |  10.5% |   0.0% ||              100ms   1.8% |  80.0% |  20.0% |   0.0% || ../primes.js~7-23:66-421 AcceptFilter      ||               30ms   0.5% | 100.0% |   0.0% |   0.0% ||               20ms   0.4% | 100.0% |   0.0% |   0.0% || ../primes.js~1-5:0-63 Primes            ||               40ms   0.7% | 100.0% |   0.0% |   0.0% ||                0ms   0.0% |   0.0% |   0.0% |   0.0% || ../primes.js~25-38:424-739-----------------------------------------------------------------------------------------------------------------------------------------------------------Alternatively --cpusampler.ShowTiers=0,2 will only show interpreted time and time spent in tier two compiled code, as shown below.-----------------------------------------------------------------------------------------------------------------------------------------Sampling Histogram. Recorded 620 samples with period 10ms.  Self Time: Time spent on the top of the stack.  Total Time: Time spent somewhere on the stack.  T0: Percent of time spent in interpreter.  T2: Percent of time spent in code compiled by tier 2 compiler.-----------------------------------------------------------------------------------------------------------------------------------------Thread[main,5,main] Name              ||             Total Time    |   T0   |   T2   ||              Self Time    |   T0   |   T2   || Location----------------------------------------------------------------------------------------------------------------------------------------- accept            ||             5510ms  88.9% |  30.9% |  52.3% ||             5510ms  88.9% |  30.9% |  52.3% || ../primes.js~13-22:191-419 :program          ||             6200ms 100.0% | 100.0% |   0.0% ||              320ms   5.2% | 100.0% |   0.0% || ../primes.js~1-46:0-982 next              ||             5870ms  94.7% |  37.3% |  20.6% ||              190ms   3.1% |  89.5% |  10.5% || ../primes.js~31-37:537-737 DivisibleByFilter ||              330ms   5.3% | 100.0% |   0.0% ||              170ms   2.7% | 100.0% |   0.0% || ../primes.js~7-23:66-421 AcceptFilter      ||               20ms   0.3% | 100.0% |   0.0% ||               10ms   0.2% | 100.0% |   0.0% || ../primes.js~1-5:0-63 Primes            ||               20ms   0.3% | 100.0% |   0.0% ||                0ms   0.0% |   0.0% |   0.0% || ../primes.js~25-38:424-739-----------------------------------------------------------------------------------------------------------------------------------------Creating a Flame Graph from CPU SamplerThe histogram output from CPUSampler can be quite large, making it difficult to analyze.Additionally, as a flat format it is nto possible to analyze a call graph as that information simply is not encoded in the output.A flame graph shows the entire call graph.Its structure makes it considerably simpler to see where the application time is being spent.Creating the flame graph is a multi-stage process. First, we need to profile the application with the JSON formatter:language-launcher --cpusampler --cpusampler.SampleInternal --cpusampler.Output=json -e &#39;p :hello&#39; &amp;gt; simple-app.jsonUse the --cpusampler.SampleInternal=true option if you want to profile internal sources, such as standard library functions.The JSON formatter encodes call graph information that isn’t available in the histogram format.To make a flame graph out of this output, however, we need to transform it into a format that folds the call stack samples into single lines.This can be done using stackcollapse-graalvm.rb from Benoit Daloze’s fork of FlameGraph.If you have not yet, you should clone this fork of FlameGraph into the parent directory.Now you can run the script to transform the output and pipe it into the script that will generate the SVG data:../FlameGraph/stackcollapse-graalvm.rb simple-app.json | ../FlameGraph/flamegraph.pl &amp;gt; simple-app.svgAt this point, you should open the SVG file in a Chromium-based web browser.Your system might have a different image manipulation application configured as the default application for SVG files.While loading the file in such an application may render a graph, it likely will not handle the interactive components of the flame graph. Firefox may work as well, but Chromium-based browsers currently seem to have better support and performance for the flame graph files.Profiling with Oracle Developer StudioOracle Developer Studio includes aPerformance Analyzer that can be used with GraalVM.Developer Studio can be downloaded from OTN and the current version at time of writing (12.6) provides a perpetual no-cost license for production use and the development of commercial applications.Using the Developer Studio Performance Analyser is straightforward. Include the path to the Developer Studio binaries in your PATH and then prefix your normal command-line with collect.For example:collect js mybenchmark.jsOn completion an “experiment” (.er) directory will have been created containing the profiling data for the command execution, test.1.er by default.To view the profiling results, use the analyzer tool:analyzer test.1.erThe analyzer GUI allows you to view the captured profiling information in several different ways, e.g., the timeline of your application, a flat function list, the call tree, a flame graph, etc.There is also a command-line tool, er_print, which can be used for outputting the profiling information in textual form, for further analysis.For full details, see the Performance Analyzer documentation.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/Profiling/"
          },
          
          "latest-community-publications":  {
          "title": "Academic Publications",
          "content": "Academic PublicationsThis page describes various presentations and publications related to the Graal compiler and Truffle that were published by Oracle Labs and its academic collaborators.TruffleGraalVM provides the Truffle framework for implementing a managed language in Java, improving language performance while enabling integration with other Truffle languages and providing tooling support – all of that by just implementing an abstract syntax tree (AST) interpreter in Java.Truffle applies AST specialization during interpretation, which enables partial evaluation to create highly optimized native code without the need to write a compiler specifically for a language.The Java VM contributes high-performance garbage collection, threads, and parallelism support.Oracle Labs and external research groups have implemented a variety of programming languages on top of Truffle, including JavaScript, Python, Ruby, R, Smalltalk, and others.Several of them already exceed the best implementation of that language that existed before.We recommend watching a presentation on Dynamic Metacompilation with Truffle by Christian Humer, and checking academic publications on Truffle, of your interest, listed on this page.You can also find the extensive Truffle documentation on the website.Graal CompilerThe Graal compiler is an optimizing dynamic compiler written in Java.Because it is highly configurable and extensible, it delivers excellent peak performance on many benchmarks for a diverse set of managed languages including Java and JavaScript.This brings compiler research to a new level: researchers can evaluate new compiler optimizations immediately on many languages.If you are a language implementer who is curious how modern VMs like the Java HotSpot VM optimizes your code, you can find answers to that in the presentation by Doug Simon Looking at the GraalVM compiler.The presentation covers the following topics:  How to build a GraalVM distribution from the sources  Ways the compiler uses Java language features to simplify the development: annotations, unit tests, and benchmarks for individual compiler optimizations  What main classes one should look at the GraalVM project  Compilation wrappers and so onFind below also the academic publications on the compiler of your interest, or see the Graal compiler documentation on the website.Academic Publications2025      Matteo Oldani, William Blair, Shweta Shinde, Matthias NeugschwandtnerMonocle: Transient Execution Proof Memory Views for Runtime Compiled CodeIn Proceedings of the 20th ACM Asia Conference on Computer and Communications Security        Sebastian Kloibhofer, Lukas Makor, Peter Hofer, David Leopoldseder, Hanspeter MössenböckProfile-Guided Field Externalization in an Ahead-of-Time CompilerIn Proceedings of ECOOP 2024        Andrej Pecimuth, David Leopoldseder, Petr TumaReusing Highly Optimized IR in Dynamic CompilationIn Proceedings of ECOOP 2025        Andrej Pecimuth, David Leopoldseder, Petr TumaA Pragmatic Approach to Replay CompilationIn Proceedings of MoreVMs workshop co-located with Programming 2025        Lukas Makor, Sebastian Kloibhofer, Peter Hofer, David Leopoldseder, Hanspeter MössenböckAutomated Profile-Guided Replacement of Data Structures to Reduce Memory AllocationIn Proceedings of ‹Programming› 2025        Vojin Jovanovic, Milan Cugurovic, Lazar MilikicGraalNN: Context-Sensitive Static Profiling with Graph Neural NetworksIn Proceedings of International Symposium on Code Generation and Optimization (CGO) 2025  2024      David Kozak, Codrut Stancu, Tomas Vojnar, Christian WimmerSkipFlow: Improving the Precision of Points-to Analysis using Primitive Values and Predicate EdgesIn Proceedings of the 23rd ACM/IEEE International Symposium on Code Generation and Optimization        Pichler Christoph, Paley Li, Roland Schatz, Hanspeter MoessenboeckOn Automating Hybrid Execution of Ahead-of-Time and Just-in-Time Compiled CodeIn Proceedings of VMIL ‘24: 16th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages        Milica Karlicic, Ivan Ristovic, Milena Vujosevic JanicicProfiling-Based Adaptive GC Policy for ServerlessIn Proceedings of the fourteenth Symposium “Mathematics and Applications”        Aleksandar Stefanovic, Ivan Ristovic, Milena Vujosevic JanicicConstant Folding of Reflective Calls via Static Analysis of Java BytecodeIn Proceedings of the fourteenth Symposium “Mathematics and Applications”        Milan Cugurovic, Milena Vujosevic JanicicGraalSP Profiles Logger: A Tool for Analyzing and Interpreting Predictions of the ML-Based Static ProfilersIn Proceedings Artificial Intelligence Conference        Andrej Pecimuth, David Leopoldseder, Petr TůmaAn Analysis of Compiled Code Reusability in Dynamic CompilationIn Proceedings of VMIL’24 Workshop        Andrej Pecimuth, David Leopoldseder, Petr TumaAccurate Compilation Replay via Remote JIT CompilationPoster presented at the 21st International Conference on Managed Programming Languages and Runtimes (MPLR 2024)        Matteo Oldani, William Blair, Lukas Stadler, Zbynek Slajchrt, Matthias NeugschwandtnerBinsweep: Reliably Restricting Untrusted Instruction Streams with Static Binary Analysis and Control-Flow IntegrityIn Proceedings of the ACM Cloud Computing Security Workshop (CCSW’24)        Lukas Makor, Sebastian Kloibhofer, Peter Hofer, David Leopoldseder, Hanspeter MoessenboeckAutomated Profile-guided Replacement of Data Structures to Reduce Memory AllocationIn Proceedings of ‹Programming› 2025        Florian Huemer, David Leopoldseder, Aleksandar Prokopec, Raphael Mosaner, Hanspeter MoessenboeckTaking a Closer Look: An Outlier-Driven Approach to Compilation-Time OptimizationIn Proceedings of the ECOOP 2024 Doctoral Symposium        Christoph Blumschein, Fabio Niephaus, Codrut Stancu, Christian Wimmer, Jens Lincke, Robert HirschfeldFinding Cuts in Static Analysis Graphs to Debloat SoftwareIn Proceedings of the ACM SIGSOFT International Symposium on Software Testing and Analysis        Ivan Ristovic, Milan Cugurovic, Strahinja Stanojevic, Marko Spasic, Vesna Marinkovic, Milena Vujosevic JanicicEfficient control-flow graph traversalIn Proceedings of YU INFO 2024s        Christian Wimmer, Codrut Stancu, David Kozak, Thomas WuerthingerScaling Type-Based Points-to Analysis with SaturationIn Proceedings of PLDI 2024        Milan Cugurovic, Milena Vujosevic Janicic, Vojin Jovanovic, Thomas WuerthingerGraalSP: Polyglot, Efficient, and Robust Machine Learning-Based Static ProfilerJournal of Systems and Software  2023      Maja Vukasovic, Aleksandar ProkopecExploiting Partially Context-sensitive Profiles to Improve Performance of Hot CodeIn Proceedings of the ACM Transactions on Programming Languages and Systems        Matt D’Souza, James You, Ondrej Lhoták, Aleksandar ProkopecTASTyTruffle: Just-in-Time Specialization of Parametric PolymorphismIn Proceedings of the ACM on Programming Languages        Matteo Basso, Aleksandar Prokopec, Andrea Rosà, Walter BinderOptimization-Aware Compiler-Level Event ProfilingIn Proceedings of the ACM Transactions on Programming Languages and Systems        Andrej PecimuthRemote Just-in-Time Compilation for Dynamic LanguagesIn Proceedings of the SPLASH 2023 Doctoral Symposium        Andrej Pecimuth, David Leopoldseder, Petr TumaDiagnosing Compiler Performance by Comparing Optimization DecisionsIn Proceedings of the 20st International Conference on Managed Programming Languages and Runtimes (MPLR 2023)        Julian Garn, Florian Angerer, Hanspeter MoessenboeckGenerating Java Interfaces for Accessing Foreign ObjectsIn Proceedings of the 20st International Conference on Managed Programming Languages and Runtimes (MPLR 2023)        David Kozak, Vojin Jovanovic, Codrut Stancu, Tomas Vojnar, Christian WimmerComparing Rapid Type Analysis with Points-To Analysis in GraalVM Native ImageIn Proceedings of the 20st International Conference on Managed Programming Languages and Runtimes (MPLR 2023)  2022      Jacob Kreindl, Daniele Bonetta, Lukas Stadler, David Leopoldseder, Hanspeter MoessenboeckTruffleTaint: Polyglot Dynamic Taint Analysis on GraalVMIn Proceedings of the 19th International Conference on Managed Programming Languages and Runtimes (MPLR’22)        Raphael Mosaner, David Leopoldseder, Wolfgang Kisling, Lukas Stadler, Hanspeter MoessenboeckML-SOCO: Machine Learning-Based Self-Optimizing Compiler OptimizationsIn Proceedings of the 19th International Conference on Managed Programming Languages &amp;amp; Runtimes (MPLR’22)        Lukas Makor, Sebastian Kloibhofer, David Leopoldseder, Daniele Bonetta, Lukas Stadler, Hanspeter MoessenboeckAutomatic Array Transformation to Columnar Storage at Run TimeIn Proceedings of the 19th International Conference on Managed Programming Languages &amp;amp; Runtimes (MPLR’22)        Felix Berlakovich, Gergo Barany, Matthias NeugschwandtnerConstant Blinding on GraalVMIn Proceedings of the 15th EUROPEAN WORKSHOP ON SYSTEMS SECURITY        Stefan Reschke, Toni Mattis, Fabio Niephaus, Robert HirschfeldToward Just-in-time and Language-agnostic Mutation TestingIn Proceedings of the MoreVMs’22 workshop at ‹Programming› 2022  2021      David Justo, Shaoqing Yi, Lukas Stadler, Nadia Polikarpova, Arun KumarTowards a polyglot framework for factorized MLIn Proceedings of the VLDB Endowment 14, Issue 12 (VLDB 2021 Industry Track)        Daniele Bonetta, Filippo Schiavio, Walter BinderLanguage-Agnostic Integrated Queries in a Managed Polyglot RuntimeIn Proceedings of the VLDB Endowment 2021  2020      Fabio Niephaus, Patrick Rein, Jakob Edding, Jonas Hering, Bastian König, Kolya Opahle, Nico Scordialo, Robert HirschfeldExample-based Live Programming for Everyone: Building Language-agnostic Tools for Live Programming With LSP and GraalVMIn Proceedings of the ACM Symposium for New Ideas, New Paradigms, and Reflections on Everything to do with Programming and Software (Onward! 2020)        Jacob Kreindl, Daniele Bonetta, Lukas Stadler, David Leopoldseder, Hanspeter MoessenboeckMulti-language Dynamic Taint Analysis in a Polyglot Virtual MachineIn Proceedings of the 17th International Conference on Managed Programming Languages and Runtimes (MPLR 2020)        Alexander Riese, Fabio Niephaus, Tim Felgentreff, Robert HirschfeldUser-Defined Interface Mappings for the GraalVMIn Proceedings of the Interconnecting Code Workshop (ICW) 2020, companion volume to International Conference on the Art, Science, and Engineering of Programming (‹Programming›)        Jan Ehmueller, Alexander Riese, Hendrik Tjabben, Fabio Niephaus, Robert HirschfeldPolyglot Code FinderIn Proceedings of the Programming Experience 2020 (PX/20) Workshop, companion volume to International Conference on the Art, Science, and Engineering of Programming (‹Programming›)        Johannes Henning, Tim Felgentreff, Fabio Niephaus, Robert HirschfeldToward Presizing and Pretransitioning Strategies for GraalPythonIn Proceedings of the Workshop on Modern Language Runtimes, Ecosystems, and VMs (MoreVMs) 2020, companion volume to International Conference on the Art, Science, and Engineering of Programming (‹Programming›)  2019      Christian Wimmer, Peter Hofer, Codrut Stancu, Vojin Jovanovic, Peter Kessler, Thomas Wuerthinger, Oleg Pliss, Paul WoegererInitialize Once, Start Fast: Application Initialization at Build TimeIn Proceedings of the ACM on Programming Languages        Fabio Niephaus, Tim Felgentreff, Robert HirschfeldGraalSqueak: Toward a Smalltalk-based Tooling Platform for Polyglot ProgrammingIn Proceedings of the International Conference on Managed Programming Languages and Runtimes (MPLR 2019)        Aleksandar Prokopec, Gilles Duboscq, David Leopoldseder, Thomas WuerthingerAn Optimization-Driven Incremental Inline Substitution Algorithm for Just-In-Time CompilersIn Proceedings of the 2019 International Symposium on Code Generation and Optimization (CGO 2019)        Aleksandar Prokopec, Andrea Rosà, David Leopoldseder, Gilles Duboscq, Petr Tůma, Martin Studener, Lubomír Bulej, Yudi Zheng, Alex Villazón, Doug Simon, Thomas Würthinger, Walter BinderRenaissance: benchmarking suite for parallel applications on the JVMIn Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2019)        Christian Humer, Tim Felgentreff, Robert Hirschfeld, Fabio Niephaus, Daniel StolpeLanguage-independent Development Environment Support For Dynamic RuntimesIn Proceedings of the 15th ACM SIGPLAN International Symposium on Dynamic Languages        Florian Latifi, David LeopoldsederPractical Second Futamura ProjectionIn Proceedings Companion of the 2019 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity        Jacob Kreindl, Hanspeter Moessenboeck, Daniele BonettaTowards Efficient, Multi-Language Dynamic Taint AnalysisIn Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes        Raphael Mosaner, Hanspeter Moessenboeck, Manuel Rigger, Roland Schatz, David LeopoldsederSupporting On-Stack Replacement in Unstructured Languages by Loop Reconstruction and ExtractionIn Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes        Robert Hirschfeld, Christian Humer, Fabio Niephaus, Daniel Stolpe, Tim FelgentreffLanguage-independent Development Environment Support For Dynamic RuntimesIn Proceedings of the 15th ACM SIGPLAN International Symposium on Dynamic Languages        Stefan Marr, Manuel Rigger, Bram Adams, Hanspeter MoessenboeckUnderstanding GCC Builtins to Develop Better ToolsIn Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering        Fabio Niephaus, Tim Felgentreff, and Robert Hirschfeld GraalSqueak: Toward a Smalltalk-based Tooling Platform for Polyglot ProgrammingIn Proceedings of the International Conference on Managed Programming Languages and Runtimes (MPLR) 2019        Daniel Stolpe, Tim Felgentreff, Christian Humer, Fabio Niephaus, and Robert Hirschfeld Language-independent Development Environment Support for Dynamic RuntimesIn Proceedings of the Dynamic Languages Symposium (DLS) 2019        Fabio Niephaus, Tim Felgentreff, Tobias Pape, and Robert Hirschfeld Efficient Implementation of Smalltalk Activation Records in Language Implementation FrameworksIn Proceedings of the Workshop on Modern Language Runtimes, Ecosystems, and VMs (MoreVMs) 2019, companion volume to International Conference on the Art, Science, and Engineering of Programming (‹Programming›)        Fabio Niephaus, Eva Krebs, Christian Flach, Jens Lincke, and Robert Hirschfeld PolyJuS: A Squeak/Smalltalk-based Polyglot Notebook System for the GraalVMIn Proceedings of the Programming Experience 2019 (PX/19) Workshop, companion volume to International Conference on the Art, Science, and Engineering of Programming (‹Programming›)        Fabio Niephaus, Tim Felgentreff, and Robert Hirschfeld Towards Polyglot Adapters for the GraalVMIn Proceedings of the Interconnecting Code Workshop (ICW) 2019, companion volume to International Conference on the Art, Science, and Engineering of Programming (‹Programming›)  2018      Kevin Menard, Chris Seaton, Benoit Daloze Specializing Ropes for RubyIn Proceedings of the 15th International Conference on Managed Languages &amp;amp; Runtimes (ManLang’18)        B. Daloze, A. Tal, S. Marr, H. Moessenboeck, E. Petrank Parallelization of Dynamic Languages: Synchronizing Built-in CollectionsIn Proceedings of the Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2018)        David Leopoldseder, Roland Schatz, Lukas Stadler, Manuel Rigger, Thomas Wuerthinger, Hanspeter Moessenboeck Fast-Path Loop Unrolling of Non-Counted Loops to Enable Subsequent Compiler OptimizationsIn Proceedings of the 15th International Conference on Managed Languages &amp;amp; Runtimes, Article No. 2 (ManLang’18)        David Leopoldseder, Lukas Stadler, Thomas Würthinger,Josef Eisl, Doug Simon, Hanspeter Moessenboeck Dominance-based duplication simulation (DBDS): code duplication to enable compiler optimizationsIn Proceedings of the 2018 International Symposium on Code Generation and Optimization (CGO 2018)        Matthias Grimmer, Roland Schatz, Chris Seaton, Thomas Wuerthinger, Mikel Lujan Cross-Language Interoperability in a Multi-Language RuntimeIn ACM Transactions on Programming Languages and Systems (TOPLAS), Vol. 40, No. 2, 2018        Fabio Niephaus, Tim Felgentreff, and Robert Hirschfeld GraalSqueak: A Fast Smalltalk Bytecode Interpreter Written in an AST Interpreter FrameworkIn Proceedings of the Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs, and Systems (ICOOOLPS) 2018        Manuel Rigger, Roland Schatz, Jacob Kreindl, Christian Haeubl, Hanspeter Moessenboeck Sulong, and Thanks for All the FishMoreVMs Workshop on Modern Language Runtimes, Ecosystems, and VMs (MoreVMs 2018)        Michael Van De Vanter, Chris Seaton, Michael Haupt, Christian Humer, and Thomas WürthingerFast, Flexible, Polyglot Instrumentation Support for Debuggers and other ToolsIn The Art, Science, and Engineering of Programming, vol. 2, no. 3, 2018, article 14 (&amp;lt;Programming 2018&amp;gt;, Nice, France, April 12, 2018)DOI  2017      T. Würthinger, C. Wimmer, C. Humer, A. Wöss, L. Stadler, C. Seaton, G. Duboscq, D. Simon, M. GrimmerPractical Partial Evaluation for High-Performance Dynamic Language RuntimesIn Proceedings of the Conference on Programming Language Design and Implementation (PLDI)Video recordingDOI: 10.1145/3062341.3062381        Juan Fumero, Michel Steuwer, Lukas Stadler, Christophe DubachJust-In-Time GPU Compilation for Interpreted Languages with Partial EvaluationIn Proceedings of the 13th ACM International Conference on Virtual Execution Environments (VEE’17)DOI: 10.1145/3050748.3050761        Michael Van De VanterBuilding Flexible, Low-Overhead Tooling Support into a High-Performance Polyglot VM (Extended Abstract)MoreVMs Workshop on Modern Language Runtimes, Ecosystems, and VMs.        Juan Fumero, Michel Steuwer, Lukas Stadler, Christophe Dubach.OpenCL JIT Compilation for Dynamic Programming LanguagesMoreVMs Workshop on Modern Language Runtimes, Ecosystems, and VMs (MoreVMs’17)Video recording  2016      Benoit Daloze, Stefan Marr, Daniele Bonetta, Hanspeter MoessenboeckEfficient and Thread-Safe Objects for Dynamically-Typed LanguagesIn Proceedings of the Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA).        Manuel Rigger, Matthias Grimmer, Christian Wimmer, Thomas Würthinger, Hanspeter MoessenboeckBringing Low-Level Languages to the JVM: Efficient Execution of LLVM IR on TruffleIn Proceedings of the Workshop on Virtual Machines and Intermediate Languages (VMIL).        Manuel Rigger, Matthias Grimmer, Hanspeter MoessenboeckSulong – Execution of LLVM-Based Languages on the JVMIn Proceedings of International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS).        Manuel RiggerSulong: Memory Safe and Efficient Execution of LLVM-Based   LanguagesIn Proceedings of the ECOOP 2016 Doctoral Symposium.  2015      Benoit Daloze, Chris Seaton, Daniele Bonetta, Hanspeter MoessenboeckTechniques and Applications for Guest-Language SafepointsIn Proceedings of the International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS).        Matthias Grimmer, Chris Seaton, Roland Schatz, Würthinger, Hanspeter MoessenboeckHigh-Performance Cross-Language Interoperability in a Multi-Language RuntimeIn Proceedings of the 11th Dynamic Language Symposium (DLS).        Matthias Grimmer, Chris Seaton, Thomas Würthinger, Hanspeter MoessenboeckDynamically Composing Languages in a Modular Way: Supporting C Extensions for Dynamic Languages.In Proceedings of the 14th International Conference on Modularity.        Gülfem Savrun-Yeniçeri, Michael Van De Vanter, Per Larsen, Stefan Brunthaler, and Michael FranzAn Efficient and Generic Event-based Profiler Framework for Dynamic LanguagesIn Proceedings of the International Conference on Principles and Practices of Programming on The Java Platform: virtual machines, languages, and tools (PPPJ).        Michael Van De VanterBuilding Debuggers and Other Tools: We Can “Have it All” (Position Paper)In Proceedings of the 10th Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems Workshop (ICOOOLPS).  2014      Matthias GrimmerHigh-performance language interoperability in multi-language runtimesIn Proceedings of the companion publication of the 2014 ACM SIGPLAN conference on Systems, Programming, and Applications: Software for Humanity (SPLASH Companion).        Matthias Grimmer, Manuel Rigger, Roland Schatz, Lukas Stadler, Hanspeter MoessenboeckTruffle C: Dynamic Execution of C on the Java Virtual MachineIn Proceedings of the International Conference on Principles and Practice of Programming in Java (PPPJ).        Christian Humer, Christian Wimmer, Christian Wirth, Andreas Wöß, Thomas WürthingerA Domain-Specific Language for Building Self-Optimizing AST InterpretersIn Proceedings of the International Conference on Generative Programming: Concepts and Experiences (GPCE).        Andreas Wöß, Christian Wirth, Daniele Bonetta, Chris Seaton, Christian Humer, Hanspeter MoessenboeckAn Object Storage Model for the Truffle Language Implementation FrameworkIn Proceedings of International Conference on Principles and Practice of Programming in Java (PPPJ).        Matthias Grimmer, Thomas Würthinger, Andreas Wöß, Hanspeter MoessenboeckAn Efficient Approach to Access Native Binary Data from JavaScriptIn Proceedings of the 9th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS).        Chris Seaton, Michael Van De Vanter, and Michael HauptDebugging at full speedIn Proceedings of the 8th Workshop on Dynamic Languages and Applications (DYLA).  2013      Thomas Würthinger, Christian Wimmer, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Christian Humer, Gregor Richards, Doug Simon, Mario WolczkoOne VM to Rule Them AllIn Proceedings of Onward!.Describes the vision of the Truffle approach, and the full system stack including the interpreter and dynamic compiler.        Matthias Grimmer, Manuel Rigger, Lukas Stadler, Roland Schatz, Hanspeter MoessenboeckAn efficient native function interface for JavaIn Proceedings of the International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools. (PPPJ).        Matthias GrimmerRuntime Environment for the Truffle/C VMMaster’s thesis, Johannes Kepler University Linz, November 2013.  2012  Thomas Würthinger, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Doug Simon, Christian WimmerSelf-Optimizing AST InterpretersIn Proceedings of the Dynamic Languages Symposium (DLS).Describes the design of self-optimizing and self-specializing interpreter, and the application to JavaScript.GraalVM Compiler Papers2023  David Leopoldseder, Daniele Bonetta, Lukas Stadler, Hanspeter Moessenboeck, Sebastian Kloibhofer, Lukas MakorControl Flow Duplication for Columnar Arrays in a Dynamic CompilerIn _Proceedings of the  2023 Journal and Conference_2022      Felix Berlakovich, Matthias Neugschwandtner, Gergö BaranyLook Ma, no constants: practical constant blinding in GraalVMIn Proceedings of the 15th European Workshop on Systems Security (EuroSec ‘22)        Gergo Barany, David Leopoldseder, Hanspeter Moessenboeck, Raphael MosanerImproving Vectorization Heuristics in a Dynamic Compiler with Learned ModelsIn Proceedings of the Virtual Machines and Language Implementations Workshop Co-located with SPLASH 2022        Stefan Marr, Humphrey Burchell, Fabio NiephausExecution vs. Parse-Based Language Servers: Tradeoffs and Opportunities for Language-Agnostic Tooling for Dynamic LanguagesIn Proceedings of the 18th Dynamic Languages Symposium (DLS) at SPLASH 2022        David Leopoldseder, Daniele Bonetta, Lukas Stadler, Hanspeter Moessenboeck, Lukas Makor, Sebastian KloibhoferAutomatic Array Transformation to Columnar Storage at Run TimeIn Proceedings of the 19th International Conference on Managed Programming Languages and Runtimes (MPLR’22)        David Leopoldseder, Lukas Stadler, Hanspeter Moessenboeck, Raphael Mosaner, Wolfgang KislingMachine-Learning-Based Self-Optimizing Compiler HeuristicsIn Proceedings of the 19th International Conference on Managed Programming Languages and Runtimes (MPLR’22)        Stefan Reschke, Toni Mattis, Fabio Niephaus, Robert HirschfeldToward Just-in-time and Language-agnostic Mutation TestingIn Proceedings of the MoreVMs’22 workshop at ‹Programming› 2022  2021      Rodrigo Bruno, Vojin Jovanovic, Christian Wimmer, Gustavo AlonsoCompiler-Assisted Object Inlining with Value FieldsIn Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI 2021)        Raphael Mosaner, David Leopoldseder, Lukas Stadler, Hanspeter MoessenboeckUsing Machine Learning to Predict the Code Size Impact of Duplication Heuristics in a Dynamic CompilerIn Proceedings of the 18th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes (MPLR 2021)        Jacob Kreindl, Daniele Bonetta, Lukas Stadler, David Leopoldseder, Hanspeter Moessenboeck Low-Overhead Multi-Language Dynamic Taint Analysis through Speculative Optimization and Dynamic CompilationIn Proceedings of the 18th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes (MPLR 2021)        Florian Latifi, David Leopoldseder, Christian Wimmer, Hanspeter Moessenboeck CompGen: Generation of Fast Compilers in a Multi-Language VMIn Proceedings Dynamic Language Symposium, DLS co-located with SPLASH conference 2021        Matt D’Souzam, Gilles Duboscq, Lightweight On-Stack Replacement in Languages with Unstructured LoopsIn Proceedings of the 13th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages (VMIL 2021)        Sebastian Kloibhofer Run-time Data Analysis to Drive Compiler OptimizationsIn Proceedings of SPLASH Companion 2021        Lukas Makor Run-time data analysis in dynamic runtimesIn Proceedings of SPLASH Companion 2021        Hugo Guiroux, Jean-Pierre Lozi, Peterson Yuhala, Jämes Ménétrey, Pascal Felber, Valerio Schiavoni, Alain Tchana, Gaël Thomas Montsalvat: Intel SGX Shielding for GraalVM Native ImagesIn Proceedings of MIDDLEWARE 2021 - 22nd ACM/IFIP International Conference 2021  2020      Sebastian Kloibhofer, Thomas Pointhuber, Maximilian Heisinger, Hanspeter Moessenboeck, Lukas Stadler, David Leopoldseder SymJEx: symbolic execution on the GraalVMIn Proceedings of the 17th International Conference on Managed Programming Languages and Runtimes (MPLR 2020)        Raphael Mosaner Machine Learning to Ease Understanding of Data Driven Compiler OptimizationsIn Proceedings of SPLASH Companion 2020        Aleksandar Prokopec, Andrea Rosà, David Leopoldseder, Gilles Duboscq, Petr Tuma, Martin Studener, Lubomír Bulej, Yudi Zheng, Alex Villazón, Doug Simon, Thomas Würthinger, Walter Binder Renaissance: Benchmarking Suite for Parallel Applications on the JVMIn Proceedings of Software Engineering 2020        Aleksandar Prokopec, François Farquet, Lubomír Bulej, Vojtech Horký, Petr TumaDuet Benchmarking: Improving Measurement Accuracy in the CloudIn Proceedings of the International Conference on Performance Engineering (ICPE 2020)        Aleksandar Prokopec, Trevor Brown, Dan Alistarh Non-blocking interpolation search trees with doubly-logarithmic running timeIn Proceedings of the 25th Symposium on Principles &amp;amp; Practice of Parallel Programming (PPoPP 2020)        Sebastian Kloibhofer, Thomas Pointhuber, Maximilian Heisinger, Hanspeter Moessenboeck, Lukas Stadler, David LeopoldsederSymJEx: Symbolic Execution on the GraalVMIn Proceedings of the 17th International Conference on Managed Programming Languages and Runtimes (MPLR 2020)  2019      Aleksandar Prokopec, Gilles Duboscq, David Leopoldseder, Thomas Wuerthinger An Optimization-Driven Incremental Inline Substitution Algorithm for Just-In-Time CompilersIn Proceedings of the 2019 International Symposium on Code Generation and Optimization (CGO 2019)        Aleksandar Prokopec, Andrea Rosà, David Leopoldseder, Gilles Duboscq, Petr Tůma, Martin Studener, Lubomír Bulej, Yudi Zheng, Alex Villazón, Doug Simon, Thomas Würthinger, Walter Binder Renaissance: benchmarking suite for parallel applications on the JVMIn Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2019)  2018      James Clarkson, Juan Fumero, Michalis Papadimitriou, Foivos S. Zakkak, Maria Xekalaki, Christos Kotselidis, Mikel LujánExploiting High-Performance Heterogeneous Hardware for Java Programs using GraalIn Proceedings of the 15th International Conference on Managed Languages &amp;amp; Runtimes (ManLang’18)        Juan Fumero, Christos Kotselidis.Using Compiler Snippets to Exploit Parallelism on Heterogeneous Hardware: A Java Reduction Case StudyIn Proceedings of the 10th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages (VMIL’18)  2016      Josef Eisl, Matthias Grimmer, Doug Simon, Thomas Würthinger, Hanspeter MoessenboeckTrace-based Register Allocation in a JIT CompilerIn Proceedings of the 13th International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ ‘16)        Stefan Marr, Benoit Daloze, Hanspeter MoessenboeckCross-language compiler benchmarking: are we fast yet?In Proceedings of the 12th Symposium on Dynamic Languages (DLS 2016)        Manuel Rigger, Matthias Grimmer, Christian Wimmer, Thomas Würthinger, Hanspeter MoessenboeckBringing low-level languages to the JVM: efficient execution of LLVM IR on TruffleIn Proceedings of the 8th International Workshop on Virtual Machines and Intermediate Languages (VMIL 2016)        Manuel RiggerSulong: Memory Safe and Efficient Execution of LLVM-Based LanguagesECOOP 2016 Doctoral Symposium        Manuel Rigger, Matthias Grimmer, Hanspeter MoessenboeckSulong - Execution of LLVM-Based Languages on the JVMInt. Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS’16)        Luca Salucci, Daniele Bonetta, Walter BinderEfficient Embedding of Dynamic Languages in Big-Data AnalyticsInternational Conference on Distributed Computing Systems Workshops (ICDCSW 2016)        Lukas Stadler, Adam Welc, Christian Humer, Mick JordanOptimizing R language execution via aggressive speculationIn Proceedings of the 12th Symposium on Dynamic Languages (DLS 2016)        Daniele Bonetta, Luca Salucci, Stefan Marr, Walter BinderGEMs: shared-memory parallel programming for Node.jsIn Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2016)        Benoit Daloze, Stefan Marr, Daniele Bonetta, Hanspeter MoessenboeckEfficient and thread-safe objects for dynamically-typed languagesIn Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2016)        Luca Salucci, Daniele Bonetta, Walter BinderLightweight Multi-language Bindings for Apache SparkEuropean Conference on Parallel Processing (Euro-Par 2016)        Luca Salucci, Daniele Bonetta, Stefan Marr, Walter BinderGeneric messages: capability-based shared memory parallelism for event-loop systemsIn Proceedings of the 21st ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP 2016)        Stefan Marr, Chris Seaton, Stéphane DucasseZero-overhead metaprogramming: reflection and metaobject protocols fast and without compromisesIn Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2016)  2015      Josef EislTrace register allocationIn Companion Proceedings of the 2015 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity (SPLASH Companion 2015)        Matthias Grimmer, Chris Seaton, Roland Schatz, Thomas Würthinger, Hanspeter MoessenboeckHigh-performance cross-language interoperability in a multi-language runtimeIn Proceedings of the 11th Symposium on Dynamic Languages (DLS 2015)        Matthias Grimmer, Roland Schatz, Chris Seaton, Thomas Würthinger, Hanspeter MoessenboeckMemory-safe Execution of C on a Java VMIn Proceedings of the 10th ACM Workshop on Programming Languages and Analysis for Security (PLAS’15)        Matthias Grimmer, Chris Seaton, Thomas Würthinger, Hanspeter MoessenboeckDynamically composing languages in a modular way: supporting C extensions for dynamic languagesIn Proceedings of the 14th International Conference on Modularity (MODULARITY 2015)        Doug Simon, Christian Wimmer, Bernhard Urban, Gilles Duboscq, Lukas Stadler, Thomas WürthingerSnippets: Taking the High Road to a Low LevelACM Transactions on Architecture and Code Optimization (TACO)        David Leopoldseder, Lukas Stadler, Christian Wimmer, Hanspeter MoessenboeckJava-to-JavaScript translation via structured control flow reconstruction of compiler IRIn Proceedings of the 11th Symposium on Dynamic Languages (DLS 2015)        Codruţ Stancu, Christian Wimmer, Stefan Brunthaler, Per Larsen, Michael FranzSafe and efficient hybrid memory management for JavaIn Proceedings of the 2015 International Symposium on Memory Management (ISMM ‘15)        Gülfem Savrun-Yeniçeri, Michael L. Van de Vanter, Per Larsen, Stefan Brunthaler, Michael FranzAn Efficient and Generic Event-based Profiler Framework for Dynamic LanguagesIn Proceedings of the Principles and Practices of Programming on The Java Platform (PPPJ ‘15)        Michael L. Van De VanterBuilding debuggers and other tools: we can “have it all”In Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS ‘15)        Benoit Daloze, Chris Seaton, Daniele Bonetta, Hanspeter MoessenboeckTechniques and applications for guest-language safepointsIn Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS ‘15)        Juan Fumero, Toomas Remmelg, Michel Steuwer and Christophe Dubach.Runtime Code Generation and Data Management for Heterogeneous Computing in JavaIn Proceedings of the Principles and Practices of Programming on The Java Platform (PPPJ ‘15)  2014      Wei Zhang, Per Larsen, Stefan Brunthaler, Michael FranzAccelerating iterators in optimizing AST interpreters In Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages &amp;amp; Applications (OOPSLA ‘14)        Matthias GrimmerHigh-performance language interoperability in multi-language runtimes In Proceedings of the companion publication of the 2014 ACM SIGPLAN conference on Systems, Programming, and Applications: Software for Humanity (SPLASH ‘14)        Matthias Grimmer, Manuel Rigger, Roland Schatz, Lukas Stadler, Hanspeter Moessenboeck TruffleC: dynamic execution of C on a Java virtual machine In Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ ‘14)        Matthias Grimmer, Thomas Würthinger, Andreas Wöß, Hanspeter MoessenboeckAn efficient approach for accessing C data structures from JavaScriptIn Proceedings of the 9th International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems PLE (ICOOOLPS ‘14)        Christian Humer, Christian Wimmer, Christian Wirth, Andreas Wöß, Thomas WürthingerA domain-specific language for building self-optimizing AST interpretersIn Proceedings of the 2014 International Conference on Generative Programming: Concepts and Experiences (GPCE 2014)        Gilles Duboscq, Thomas Würthinger, Hanspeter MoessenboeckSpeculation without regret: reducing deoptimization meta-data in the GraalVM compilerIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ ‘14)        Thomas WürthingerGraal and truffle: modularity and separation of concerns as cornerstones for building a multipurpose runtimeIn Proceedings of the companion publication of the 13th international conference on Modularity (MODULARITY ‘14)        Lukas Stadler, Thomas Würthinger, Hanspeter MoessenboeckPartial Escape Analysis and Scalar Replacement for JavaIn Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO ‘14)        Christian Häubl, Christian Wimmer, Hanspeter MoessenboeckTrace transitioning and exception handling in a trace-based JIT compiler for javaACM Transactions on Architecture and Code Optimization (TACO)        Chris Seaton, Michael L. Van De Vanter, Michael HauptDebugging at Full SpeedIn Proceedings of the Workshop on Dynamic Languages and Applications (Dyla’14)        Andreas Wöß, Christian Wirth, Daniele Bonetta, Chris Seaton, Christian Humer, Hanspeter MoessenboeckAn object storage model for the truffle language implementation frameworkIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ ‘14)        Codruţ Stancu, Christian Wimmer, Stefan Brunthaler, Per Larsen, Michael FranzComparing points-to static analysis with runtime recorded profiling dataIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ ‘14)        Juan Jose Fumero, Michel Steuwer and Christophe Dubach.A Composable Array Function Interface for Heterogeneous Computing in JavaIn Proceedings of ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming (ARRAY’14)  2013      Matthias Grimmer, Manuel Rigger, Lukas Stadler, Roland Schatz, Hanspeter MoessenboeckAn efficient native function interface for JavaIn Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ ‘13)        Thomas Würthinger, Christian Wimmer, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Christian Humer, Gregor Richards, Doug Simon, Mario WolczkoOne VM to rule them allIn Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming &amp;amp; software (Onward! 2013)        Gilles Duboscq, Thomas Würthinger, Lukas Stadler, Christian Wimmer, Doug Simon, Hanspeter MoessenboeckAn intermediate representation for speculative optimizations in a dynamic compilerIn Proceedings of the 7th ACM workshop on Virtual machines and intermediate languages (VMIL ‘13)        Lukas Stadler, Gilles Duboscq, Hanspeter Moessenboeck, Thomas Würthinger, Doug SimonAn experimental study of the influence of dynamic compiler optimizations on Scala performanceIn Proceedings of the 4th Workshop on Scala (SCALA ‘13)        Gilles Duboscq, Lukas Stadler, Thomas Würthinger, Doug Simon, Christian Wimmer, Hanspeter MoessenboeckGraal IR: An Extensible Declarative Intermediate RepresentationIn Proceedings of the Asia-Pacific Programming Languages and Compilers Workshop, 2013        Christian Häubl, Christian Wimmer, Hanspeter MoessenboeckContext-sensitive trace inlining for JavaSpecial issue on the Programming Languages track at the 27th ACM Symposium on Applied Computing, Computer Languages, Systems &amp;amp; Structures        Christian Wimmer, Stefan BrunthalerZipPy on truffle: a fast and simple implementation of pythonIn Proceedings of the 2013 companion publication for conference on Systems, programming, &amp;amp; applications: software for humanity (SPLASH ‘13)        Christian Häubl, Christian Wimmer, Hanspeter MoessenboeckDeriving code coverage information from profiling data recorded for a trace-based just-in-time compilerIn Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ ‘13)  2012      Lukas Stadler, Gilles Duboscq, Hanspeter Moessenboeck, Thomas WürthingerCompilation Queuing and Graph Caching for Dynamic CompilersIn Proceedings of the Workshop on Virtual Machines and Intermediate Languages (VMIL) 2012        Thomas Würthinger, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Doug Simon, Christian WimmerSelf-optimizing AST interpretersIn Proceedings of the 8th symposium on Dynamic languages (DLS ‘12)        Christian Wimmer, Thomas WürthingerTruffle: a self-optimizing runtime systemIn Proceedings of the 3rd annual conference on Systems, programming, and applications: software for humanity (SPLASH ‘12)        Christian Häubl, Christian Wimmer, Hanspeter MoessenboeckEvaluation of trace inlining heuristics for JavaIn Proceedings of the 27th Annual ACM Symposium on Applied Computing (SAC ‘12)  ",
          "url": " /latest/community/publications/"
          },
          
          "latest-reference-manual-espresso":  {
          "title": "Espresso",
          "content": "EspressoUsing GraalVM, you can run Java applications normally on HotSpot, in Native Image, and on Truffle.Espresso, also known as Java on Truffle, is an implementation of the Java Virtual Machine Specification, Java SE 8, Java SE 11, Java SE 17, Java SE 21, and Java SE 25 built upon GraalVM as a Truffle interpreter.It is a minified Java VM that includes all core components of a VM, implements the same API as the Java Runtime Environment library (libjvm.so), and reuses the existing standard library.See the Implementation Details for more information.Espresso is open source with its codebase accessible on GitHub.Espresso runs Java via a Java bytecode interpreter, implemented with the Truffle framework – an open source library for writing interpreters for programming languages.With Espresso, Java can be executed by the same principle as other languages in the GraalVM ecosystem (such as JavaScript, Python, Ruby), directly interoperate with those languages, and pass data back and forth in the same memory space.Besides complete language interoperability, with Espresso you can:  run Java bytecode in a separate context from the host Java VM.  run either a Java 8, Java 11, Java 17, Java 21, or Java 25 guest JVM, allowing to embed, for example, a Java 17 context in a Java 21 application, by using GraalVM’s Polyglot API.  leverage the whole stack of tools provided by the Truffle framework, not previously available for Java.  have an improved isolation of the host Java VM and the Java program running on Truffle, so you can run less trusted guest code.  run in the context of a native executable while still allowing dynamically-loaded bytecode.Espresso passes the Java Compatibility Kit (JCK or TCK for Java SE).Getting StartedEspresso is available as a standalone distribution that provides a Java 21 environment.You can download a standalone based on Oracle GraalVM or GraalVM Community Edition.      Download the Espresso 25.0.2 standalone for your operating system:          Linux x64      Linux AArch64      macOS AArch64      Windows x64            Unzip the archive:          Note: If you are using macOS Catalina and later you may need to remove the quarantine attribute:       sudo xattr -r -d com.apple.quarantine &amp;lt;archive&amp;gt;.tar.gz        Extract:     tar -xzf &amp;lt;archive&amp;gt;.tar.gz        A standalone comes with a JVM in addition to its native launcher. Check the version to see the runtime is active:     # Path to Espresso installation ./path/to/bin/java -version  Run a Java Application on EspressoThe java launcher included in the Espresso standalone works like the standard java launcher:To execute a class file:java [options] classTo execute a JAR file:java [options] -jar jarfileYou can also run a Java application from the main class in a module, or run a single source-file program:java [options] -m module[/&amp;lt;mainclass&amp;gt;]java [options] sourcefileBy default, Espresso runs with the standard library included in the standalone, but it is possible to specify a different Java installation directory (java.home).It will automatically switch versions as long as the new Java home is a supported version (8, 11, 17, 21, or 25).java --java.JavaHome=/path/to/java/home -version  Note: If you use -server option of the java launcher, espresso will not be used and HotSpot will be started instead.You can also use -truffle to explicitly require the use of espresso (the default).Performance ConsiderationsThe startup time will not match the speed offered by the regular GraalVM just-in-time (JIT) execution yet, but having created a fully working Espresso runtime, the development team is now focusing on performance.You can still influence the performance by passing the following option to java:  --engine.Mode=latency to enable Truffle’s latency mode to make JIT compilation faster, in exchange for slower peak performance.The --vm.XX: syntax ensures the option is passed to the underlying Native Image VM.When using the -XX: syntax, the VM first checks if there is such an option in the Espresso runtime.If there is none, it will try to apply this option to the underlying Native Image VM.This might be important for options such as MaxDirectMemorySize which can be set independently at both levels: -XX:MaxDirectMemorySize=256M controls how much native memory can be reserved by the Java program running on Espresso (the guest VM), while --vm.XX:MaxDirectMemorySize=256M controls how much native memory can be reserved by Native Image (the host VM).Start Running ApplicationsFrom Command LineTo ensure you have successfully installed Espresso, verify its version:# Path to Espresso installation./path/to/bin/java -versionTaking this HelloWorld.java example, compile it and run from the command line:public class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}$JAVA_HOME/bin/javac HelloWorld.java$JAVA_HOME/bin/java HelloWorldTaking some real-world applications, try running Spring PetClinic - a sample web application that demonstrates the use of Spring Boot with Spring MVC and Spring Data JPA.  Clone the project and navigate to the project’s directory:    git clone https://github.com/spring-projects/spring-petclinic.gitcd spring-petclinic    Build a JAR file (Spring PetClinic is built with Maven):    ./mvnw package    Then run it from the command line:    java -jar target/spring-petclinic-&amp;lt;version&amp;gt;-SNAPSHOT.jar    When the application starts, access it on localhost:8000.From IDETo run a Java project on Espresso from an IDE, you need to set the Espresso standalone as the project’s default JDK.For example, to run the Spring PetClinic project using Intellij IDEA, you need to:      Navigate to File, then to Project Structure. Click Project, and then click Project SDK. Expand the drop down, press Add JDK, and open the directory where you installed the Espresso standalone. For macOS users, JDK home path will be /Library/Java/JavaVirtualMachines/{espresso-standalone}/Contents/Home. Give it a name, and press Apply.            Generate sources and update folders for the project. In the Maven sidebar, click on the directory with the spinner icon:            Press Run.  DebuggingYou do not have to configure anything special to debug Java applications running Espresso from your favorite IDE debugger.For example, starting a debugger session from IntelliJ IDEA is based on the Run Configurations.What to Read NextEspresso enables a seamless Java interoperability with other languages in the GraalVM ecosystem.Check the Interoperability with Truffle Languages guide to learn how to load code written in other languages, export and import objects between languages, and so on.To learn about the implementation approach, project’s current status, and known limitations proceed to Implementation Details.You can already run some large applications such as the Eclipse IDE, Scala or other languages REPLs in the Espresso execution mode.We recommend having a look at the collection of Demo Applications.If you have a question, check the available FAQs, or reach us directly over the #espresso channel in GraalVM Slack.",
          "url": " /latest/reference-manual/espresso/"
          },
          
          "latest-reference-manual-java":  {
          "title": "GraalVM as a Java Virtual Machine",
          "content": "GraalVM as a Java Virtual MachineGraalVM is based on the Java HotSpot Virtual Machine, so any application that runs on the Java HotSpot Virtual Machine will also on GraalVM.GraalVM includes an advanced compiler written in Java, known as the Graal compiler.At runtime, just like any other Java Virtual Machine (JVM), GraalVM loads an application and analyzes its code to detect performance bottlenecks, or hot spots.GraalVM passes the performance-critical code to the Graal just-in-time (JIT) compiler, which compiles it to machine code and then returns it.The Graal compiler can improve the efficiency and the speed of applications written in Java, Scala, Kotlin, or other JVM languages through its unique approaches to code analysis and optimization.For example, it assures performance advantages for highly-abstracted applications due to its ability to remove costly object allocations.See the CEOptimization enum in the GraalVM Community Edition GitHub repository for more information about platform-independent compiler optimizations.  The Graal (JIT) compiler is now also integrated with the Java HotSpot Virtual Machine.To find out more, see the section Graal Compiler.InteroperabilityGraalVM also includes the Truffle language implementation framework—a library, written in Java—to build interpreters for programming languages, which then run on GraalVM.These “Graal languages” can consequently benefit from the optimization possibilities of the Graal compiler.The pipeline for such compilation is:  The Truffle framework code and data represented by Abstract Syntax Trees (ASTs) are partially evaluated to produce a compilation graph. When such an AST is “hot” (that is, called many times), it is scheduled for compilation by the compiler.  The compilation graph is optimized by the Graal compiler to produce machine code.  JVMCI installs this machine code in the JVM’s code cache.  The AST will automatically redirect execution to the installed machine code once it is available.See the Polyglot Programming and Embedding Languages guides for more information about interoperability with other programming languages.Ahead-of-time CompilationBesides the Truffle framework, GraalVM incorporates its compiler into an advanced ahead-of-time (AOT) compilation technology—Native Image—which translates Java and JVM-based code into a native platform executable.These native executables start nearly instantaneously, are smaller, and consume less resources than their JVM counterparts, making them ideal for cloud deployments and microservices.For more information about AOT compilation, see Native Image.Related Documentation  Graal Compiler  Graal JIT Compiler Configuration  Graal JIT Compiler Operations Manual  Native Image  JDK tool reference",
          "url": " /latest/reference-manual/java/"
          },
          
          "latest-reference-manual-llvm":  {
          "title": "GraalVM LLVM Runtime",
          "content": "GraalVM LLVM RuntimeThe GraalVM LLVM runtime can execute programming languages that can be transformed to LLVM bitcode.This includes languages like C/C++, Fortran and others.In contrast to static compilation that is normally used for LLVM-based languages, GraalVM’s implementation of the lli tool first interprets LLVM bitcode and then dynamically compiles the hot parts of the program using the Graal compiler.This allows seamless interoperability with the dynamic languages supported by GraalVM.Getting StartedThe GraalVM LLVM runtime is available as a standalone distribution.You can download a standalone based on Oracle GraalVM or GraalVM Community Edition.      Download the LLVM standalone for your operating system:          Native standalone                  Linux x64          Linux AArch64          macOS AArch64          Windows x64                    JVM standalone                  Linux x64          Linux AArch64          macOS AArch64          Windows x64                          Unzip the archive:          Note: If you are using macOS Catalina and later you may need to remove the quarantine attribute:       sudo xattr -r -d com.apple.quarantine &amp;lt;archive&amp;gt;.tar.gz        Extract:     tar -xzf &amp;lt;archive&amp;gt;.tar.gz        A standalone comes with a JVM in addition to its native launcher. Check the version to see GraalVM LLVM runtime is active:     ./path/to/bin/lli --version  Now you can execute programs in the LLVM bitcode format.LLVM ToolchainAdditionally, a prebuilt LLVM toolchain is bundled with the GraalVM LLVM runtime.  Get the location of the toolchain, using the --print-toolchain-path argument of lli:     ./path/to/bin/lli --print-toolchain-path    Set the LLVM_TOOLCHAIN environment variable:     export LLVM_TOOLCHAIN=$(./path/to/bin/lli --print-toolchain-path)    Then see the content of the toolchain path for a list of available tools:     ls $LLVM_TOOLCHAIN  Now you can compile C/C++ code to LLVM bitcode using clang from the GraalVM LLVM toolchain.Run LLVM BitcodeTo run LLVM-based languages on the GraalVM LLVM runtime, the binaries need to be compiled with embedded bitcode.The Compiling guide provides information on how to compile a program to LLVM bitcode and what file format is expected.The syntax to execute programs in LLVM bitcode format is:lli [LLI options] [GraalVM options] [polyglot options] &amp;lt;bitcode file&amp;gt; [program args]Here, &amp;lt;bitcode file&amp;gt; is a compiled program with embedded LLVM bitcode.See LLI Command Options or use lli --help for options explanations.For example, put this C code into a file named hello.c:#include &amp;lt;stdio.h&amp;gt;int main() {    printf(&quot;Hello from GraalVM!n&quot;);    return 0;}Then compile hello.c to an executable hello with embedded LLVM bitcode and run it as follows:$LLVM_TOOLCHAIN/clang hello.c -o hellolli helloNote: LLVM bitcode is platform-dependent.The program must be compiled to bitcode for an appropriate platform.Further Reading  LLVM Compatibility  Compiling to LLVM Bitcode  Debugging on the GraalVM LLVM Runtime  Interoperability with Other Languages  Interaction of GraalVM with Native Code  LLI Command Options",
          "url": " /latest/reference-manual/llvm/"
          },
          
          "latest-reference-manual-native-image":  {
          "title": "Native Image",
          "content": "Native ImageNative Image is a technology to compile Java code ahead-of-time to a binary—a native executable. A native executable includes only the code required at run time, that is the application classes, standard-library classes, the language runtime, and statically-linked native code from the JDK.An executable file produced by Native Image has several important advantages, in that it  Uses a fraction of the resources required by the Java Virtual Machine, so is cheaper to run  Starts in milliseconds  Delivers peak performance immediately, with no warmup  Can be packaged into a lightweight container image for fast and efficient deployment  Presents a reduced attack surfaceA native executable is created by the Native Image builder or native-image that processes your application classes and other metadata to create a binary for a specific operating system and architecture.First, the native-image tool performs static analysis of your code to determine the classes and methods that are reachable when your application runs.Second, it compiles classes, methods, and resources into a binary.This entire process is called build time to clearly distinguish it from the compilation of Java source code to bytecode.The native-image tool can be used to build a native executable, which is the default, or a native shared library. This quick start guide focuses on building a native executable; to learn more about native shared libraries, go here.To get used to Native Image terminology and get better understanding of the technology, we recommend you to read the Basics of Native Image.Table of Contents  Build a Native Executable Using Maven or Gradle  Build a Native Executable Using the native-image Tool  Build Configuration  Configuring Native Image with Third-Party Libraries  Further ReadingPrerequisitesThe native-image tool, available in the bin directory of your GraalVM installation, depends on the local toolchain (header files for the C library, glibc-devel, zlib, gcc, and/or libstdc++-static). These dependencies can be installed (if not yet installed) using a package manager on your machine.Choose your operating system to find instructions to meet the prerequisites.LinuxOn Oracle Linux use the yum package manager:sudo yum install gcc glibc-devel zlib-develSome Linux distributions may additionally require libstdc++-static.You can install libstdc++-static if the optional repositories are enabled (ol7_optional_latest on Oracle Linux 7, ol8_codeready_builder on Oracle Linux 8, and ol9_codeready_builder on Oracle Linux 9).On Ubuntu Linux use the apt-get package manager:sudo apt-get install build-essential zlib1g-devOn other Linux distributions use the dnf package manager:sudo dnf install gcc glibc-devel zlib-devel libstdc++-staticMacOSOn macOS use xcode:xcode-select --installWindowsTo use Native Image on Windows, install Visual Studio 2022 version 17.6.0 or later, and Microsoft Visual C++ (MSVC). There are two installation options:  Install the Visual Studio Build Tools with the Windows 11 SDK (or later version)  Install Visual Studio with the Windows 11 SDK (or later version)Native Image runs in both a PowerShell or Command Prompt and will automatically set up build environments on Windows, given that it can find a suitable Visual Studio installation.For more information, see Using GraalVM and Native Image on Windows.Build a Native Executable Using Maven or GradleWe provide Maven and Gradle plugins for Native Image to automate building, testing, and configuring native executables.MavenThe Maven plugin for Native Image adds support for compiling a Java application into a native executable using Apache Maven.  Create a new Maven Java project named “helloworld” in your favorite IDE or from your terminal with the following structure:     ├── pom.xml └── src     ├── main     │   └── java     │       └── com     │           └── example     │               └── App.java    For example, you can run this command to create a new Maven project using the quickstart archetype:     mvn archetype:generate -DgroupId=com.example -DartifactId=helloworld -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false    Add the regular Maven plugins for compiling and assembling the project into an executable JAR file to your pom.xml file:     &amp;lt;build&amp;gt;     &amp;lt;plugins&amp;gt;         &amp;lt;plugin&amp;gt;             &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;             &amp;lt;version&amp;gt;3.12.1&amp;lt;/version&amp;gt;             &amp;lt;configuration&amp;gt;                 &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;             &amp;lt;/configuration&amp;gt;         &amp;lt;/plugin&amp;gt;         &amp;lt;plugin&amp;gt;             &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;             &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt;             &amp;lt;configuration&amp;gt;                 &amp;lt;archive&amp;gt;                     &amp;lt;manifest&amp;gt;                         &amp;lt;mainClass&amp;gt;com.example.App&amp;lt;/mainClass&amp;gt;                         &amp;lt;addClasspath&amp;gt;true&amp;lt;/addClasspath&amp;gt;                     &amp;lt;/manifest&amp;gt;                 &amp;lt;/archive&amp;gt;             &amp;lt;/configuration&amp;gt;         &amp;lt;/plugin&amp;gt;     &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;    Enable the Maven plugin for Native Image by adding the following profile to pom.xml:     &amp;lt;profiles&amp;gt;   &amp;lt;profile&amp;gt;     &amp;lt;id&amp;gt;native&amp;lt;/id&amp;gt;     &amp;lt;build&amp;gt;       &amp;lt;plugins&amp;gt;         &amp;lt;plugin&amp;gt;           &amp;lt;groupId&amp;gt;org.graalvm.buildtools&amp;lt;/groupId&amp;gt;           &amp;lt;artifactId&amp;gt;native-maven-plugin&amp;lt;/artifactId&amp;gt;           &amp;lt;version&amp;gt;${native.maven.plugin.version}&amp;lt;/version&amp;gt;           &amp;lt;extensions&amp;gt;true&amp;lt;/extensions&amp;gt;           &amp;lt;executions&amp;gt;             &amp;lt;execution&amp;gt;             &amp;lt;id&amp;gt;build-native&amp;lt;/id&amp;gt;               &amp;lt;goals&amp;gt;                 &amp;lt;goal&amp;gt;compile-no-fork&amp;lt;/goal&amp;gt;               &amp;lt;/goals&amp;gt;               &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;             &amp;lt;/execution&amp;gt;           &amp;lt;/executions&amp;gt;         &amp;lt;/plugin&amp;gt;       &amp;lt;/plugins&amp;gt;     &amp;lt;/build&amp;gt;   &amp;lt;/profile&amp;gt; &amp;lt;/profiles&amp;gt;    Set the version property to the latest plugin version (for example, by specifying the version via &amp;lt;native.maven.plugin.version&amp;gt; in the &amp;lt;properties&amp;gt; element).    Compile the project and build a native executable at one step:     mvn -Pnative package    The native executable, named helloworld, is created in the target/ directory of the project.    Run the executable:     ./target/helloworld     That is it, you successfully created the native executable for your Java application using Maven.  The Maven plugin for Native Image building offers many other features that may be required for an application with more complexity, such as resources autodetection, generating the required configuration, running JUnit Platform tests on a native executable, and so on, described in the plugin reference documentation.GradleThe Gradle plugin for Native Image adds support for compiling a Java application into a native executable using the Gradle build tool.  Create a new Gradle Java project named “helloworld” in your favorite IDE or from your terminal with the following structure:     ├── app │   ├── build.gradle │   └── src │       ├── main │       │   ├── java │       │   │   └── org │       │   │       └── example │       │   │           └── App.java │       │   └── resources    For example, initialize a new Gradle project with the java plugin:          Create a new directory and enter it:          mkdir helloworld &amp;amp;&amp;amp; cd helloworld            Generate a project:          gradle init --project-name helloworld --type java-application --test-framework junit-jupiter --dsl groovy        Follow the prompts.   This command sets up a new Java application with the necessary directory structure and build files.                  If caching was enabled by the project generator in the gradle.properties file, comment out or remove the org.gradle.configuration-cache=true line.                      Enable the Gradle plugin for Native Image by adding the following to plugins section of your project’s build.gradle file:     plugins { // ... id &#39;org.graalvm.buildtools.native&#39; version &#39;x.x.x&#39; }    Specify the latest plugin version for the &#39;x.x.x&#39; version value.    Build a native executable by running ./gradlew nativeCompile:     ./gradlew nativeCompile    The native executable, named app, is created in the app/build/native/nativeCompile/ directory of the project.    Run the native executable:     ./app/build/native/nativeCompile/app     That is it, you successfully created the native executable for your Java application using Gradle.  The Gradle plugin for Native Image building has many other features that may be required for an application with more complexity, such as resources autodetection, generating the required configuration, running JUnit Platform tests on a native executable, and so on, described in the plugin reference documentation.Build a Native Executable Using the native-image ToolThe native-image tool takes Java bytecode as its input. You can build a native executable from a class file, from a JAR file, or from a module (with Java 9 and higher).From a ClassTo build a native executable from a Java class file in the current working directory, use the following command:native-image [options] class [imagename] [options]For example, build a native executable for a HelloWorld application.  Save this code into file named HelloWorld.java:     public class HelloWorld {     public static void main(String[] args) {         System.out.println(&quot;Hello, Native World!&quot;);     } }    Compile it and build a native executable from the Java class:     javac HelloWorld.java native-image HelloWorld    It will create a native executable, helloworld, in the current working directory.        Run the application:     ./helloworld    You can time it to see the resources used:     time -f &#39;Elapsed Time: %e s Max RSS: %M KB&#39; ./helloworld # Hello, Native World! # Elapsed Time: 0.00 s Max RSS: 7620 KB  From a JAR fileTo build a native executable from a JAR file in the current working directory, use the following command:native-image [options] -jar jarfile [imagename]The default behavior of native-image is aligned with the java command which means you can pass the -jar, -cp, -m  options to build with Native Image as you would normally do with java. For example, java -jar App.jar someArgument becomes native-image -jar App.jar and ./App someArgument.Follow this guide to build a native executable from a JAR file.From a ModuleYou can also convert a modularized Java application into a native executable.The command to build a native executable from a Java module is:native-image [options] --module &amp;lt;module&amp;gt;[/&amp;lt;mainclass&amp;gt;] [options]For more information about how to produce a native executable from a modular Java application, see Building a HelloWorld Java Module into a Native Executable.Build ConfigurationThere many options you can pass to the native-image tool to configure the build process. Run native-image --help to see the full list.The options passed to native-image are evaluated left-to-right.For different build tweaks and to learn more about build time configuration, see Native Image Build Configuration.Native Image will output the progress and various statistics during the build. To learn more about the output and the different build phases, see Build Output.For more detailed insights regarding the contents of a native executable, see Build Reports.Native Image and Third-Party LibrariesFor more complex applications that use external libraries, you must provide the native-image tool with metadata.Building a standalone binary with native-image takes place under a “closed world assumption”. The native-image tool performs an analysis to see which classes, methods, and fields within your application are reachable and must be included in the native executable. The analysis is static: it does not run your application.This means that all the bytecode in your application that can be called at runtime must be known (observed and analyzed) at build time.The analysis can determine some cases of dynamic class loading, but it cannot always exhaustively predict all usages of the Java Native Interface (JNI), Java Reflection, Dynamic Proxy objects, or class path resources. To deal with these dynamic features of Java, you inform the analysis with details of the classes that use Reflection, Proxy, and so on, or what classes to be dynamically loaded.To achieve this, you either provide the native-image tool with JSON-formatted configuration files or pre-compute metadata in the code.To learn more about metadata, ways to provide it, and supported metadata types, see Reachability Metadata.To automatically collect metadata for your application, see Automatic Collection of Metadata.Some applications may need additional configuration to be compiled with Native Image.For more details, see Native Image Compatibility Guide.Native Image can also interop with native languages through a custom API.Using this API, you can specify custom native entry points into your Java application and build it into a native shared library.To learn more, see Interoperability with Native Code.Further ReadingThis getting started guide is intended for new users or those with little experience of using Native Image. We strongly recommend these users to check the Basics of Native Image page to better understand some key aspects before going deeper.Check user guides to become more experienced with Native Image, find demo examples, and learn about potential usage scenarios.For a gradual learning process, check the Native Image Build Overview and Build Configuration documentation.Consider running interactive workshops to get some practical experience: go to Luna Labs and search for “Native Image”.If you have stumbled across a potential bug, please submit an issue in GitHub.If you would like to contribute to Native Image, follow our standard contributing workflow.",
          "url": " /latest/reference-manual/native-image/"
          },
          
          "latest-reference-manual-js":  {
          "title": "GraalJS",
          "content": "GraalJSGraalJS is a fast JavaScript language implementation built on top of GraalVM.It is ECMAScript-compliant, provides interoperability with Java and other Graal languages, common tooling, and, if run on the GraalVM JDK, provides the best performance with the Graal JIT compiler by default.You can also use GraalJS with Oracle JDK or OpenJDK.GraalJS is a suitable replacement for projects wanting to migrate from Nashorn or Rhino to a JavaScript engine that supports new ECMAScript standards and features.You can easily add GraalJS to your Java application as shown below.Getting Started with GraalJS on the JVMTo embed JavaScript in a Java host application, enable GraalJS by adding it as a project dependency.All necessary artifacts can be downloaded directly from Maven Central.All artifacts relevant to embedders can be found in the Maven dependency group org.graalvm.polyglot.Below is the Maven configuration for a JavaScript embedding:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graaljs.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;js&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graaljs.version}&amp;lt;/version&amp;gt;    &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;This enables GraalJS which is built on top of Oracle GraalVM and licensed under the GraalVM Free Terms and Conditions (GFTC).Use artifactId js-community instead of js if you want to use GraalJS built on GraalVM Community Edition.Go step-by-step to create a Maven project, embedding JavaScript in Java, and run it.This example application was tested with GraalVM for JDK 23 and the GraalVM Polyglot API version 24.1.0.See how to install GraalVM on the Downloads page.  Create a new Maven Java project named “helloworld” in your favorite IDE or from your terminal with the following structure:     ├── pom.xml └── src     ├── main     │   └── java     │       └── com     │           └── example     │               └── App.java    For example, you can run this command to create a new Maven project using the quickstart archetype:     mvn archetype:generate -DgroupId=com.example -DartifactId=helloworld -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.5 -DinteractiveMode=false    Replace the contents of App.java with the following code:     package com.example; import org.graalvm.polyglot.*; import org.graalvm.polyglot.proxy.*; public class App {     static String JS_CODE = &quot;(function myFun(param){console.log(&#39;Hello &#39; + param + &#39; from JS&#39;);})&quot;;     public static void main(String[] args) {         String who = args.length == 0 ? &quot;World&quot; : args[0];         System.out.println(&quot;Hello &quot; + who + &quot; from Java&quot;);         try (Context context = Context.create()) {             Value value = context.eval(&quot;js&quot;, JS_CODE);             value.execute(who);         }     } }    This example application uses the Polyglot API and returns a JavaScript function as a Java value.    Add the following dependencies to pom.xml to include the JavaScript engine (GraalJS):     &amp;lt;dependencies&amp;gt;     &amp;lt;dependency&amp;gt;         &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;         &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;         &amp;lt;version&amp;gt;${graaljs.version}&amp;lt;/version&amp;gt;     &amp;lt;/dependency&amp;gt;     &amp;lt;dependency&amp;gt;         &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;         &amp;lt;artifactId&amp;gt;js&amp;lt;/artifactId&amp;gt;         &amp;lt;version&amp;gt;${graaljs.version}&amp;lt;/version&amp;gt;         &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;     &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;    Set the GraalJS and GraalVM Polyglot API versions by adding a graaljs.version property to the &amp;lt;properties&amp;gt; section. Alternatively, you can replace ${graaljs.version} with the version string directly. For this example, use 24.1.0:     &amp;lt;properties&amp;gt;     &amp;lt;graaljs.version&amp;gt;24.1.0&amp;lt;/graaljs.version&amp;gt; &amp;lt;/properties&amp;gt;    Add the Maven plugins for compiling the project into a JAR file and copying all runtime dependencies into a directory to your pom.xml file:     &amp;lt;build&amp;gt;     &amp;lt;plugins&amp;gt;         &amp;lt;plugin&amp;gt;             &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;             &amp;lt;version&amp;gt;3.13.0&amp;lt;/version&amp;gt;             &amp;lt;configuration&amp;gt;                 &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;             &amp;lt;/configuration&amp;gt;         &amp;lt;/plugin&amp;gt;         &amp;lt;plugin&amp;gt;             &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;             &amp;lt;version&amp;gt;3.4.2&amp;lt;/version&amp;gt;             &amp;lt;configuration&amp;gt;                 &amp;lt;archive&amp;gt;                     &amp;lt;manifest&amp;gt;                         &amp;lt;mainClass&amp;gt;com.example.App&amp;lt;/mainClass&amp;gt;                     &amp;lt;/manifest&amp;gt;                 &amp;lt;/archive&amp;gt;             &amp;lt;/configuration&amp;gt;         &amp;lt;/plugin&amp;gt;         &amp;lt;plugin&amp;gt;             &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;             &amp;lt;version&amp;gt;3.8.0&amp;lt;/version&amp;gt;             &amp;lt;executions&amp;gt;                 &amp;lt;execution&amp;gt;                     &amp;lt;id&amp;gt;copy-dependencies&amp;lt;/id&amp;gt;                     &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;                     &amp;lt;goals&amp;gt;                         &amp;lt;goal&amp;gt;copy-dependencies&amp;lt;/goal&amp;gt;                     &amp;lt;/goals&amp;gt;                     &amp;lt;configuration&amp;gt;                         &amp;lt;outputDirectory&amp;gt;${project.build.directory}/modules&amp;lt;/outputDirectory&amp;gt;                         &amp;lt;includeScope&amp;gt;runtime&amp;lt;/includeScope&amp;gt;                         &amp;lt;includeTypes&amp;gt;jar&amp;lt;/includeTypes&amp;gt;                     &amp;lt;/configuration&amp;gt;                 &amp;lt;/execution&amp;gt;             &amp;lt;/executions&amp;gt;         &amp;lt;/plugin&amp;gt;     &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;    (Optional.) Add module-info.java to your application. If you would like to run your application on the module path, create a module-info.java file in src/main/java with the following contents:     module com.example {     requires org.graalvm.polyglot; }    Compile and package the project:     mvn clean package    Run the application using GraalVM or another compatible JDK.If you’ve included module-info.java in your project (step 5), you can now run the application on the module path, using one of the following commands:    java --module-path target/modules:target/helloworld-1.0-SNAPSHOT.jar --module com.example/com.example.App &quot;GraalVM&quot;java -p target/modules:target/helloworld-1.0-SNAPSHOT.jar -m com.example/com.example.App &quot;GraalVM&quot;    Otherwise, you can run with the dependencies on the module path and the application on the class path:    java --module-path target/modules --add-modules=org.graalvm.polyglot -cp target/helloworld-1.0-SNAPSHOT.jar com.example.App &quot;GraalVM&quot;java --module-path target/modules --add-modules=org.graalvm.polyglot -jar target/helloworld-1.0-SNAPSHOT.jar &quot;GraalVM&quot;    Alternatively, you can run with everything on the class path as well (in this case you need to use * or specify all JAR files):    java -cp &quot;target/modules/*:target/helloworld-1.0-SNAPSHOT.jar&quot; com.example.App &quot;GraalVM&quot;# or using shell expansion:java -cp &quot;$(find target/modules -name &#39;*.jar&#39; | tr &#39;n&#39; :)target/helloworld-1.0-SNAPSHOT.jar&quot; com.example.App &quot;GraalVM&quot;java -cp &quot;$(printf %s: target/modules/*.jar)target/helloworld-1.0-SNAPSHOT.jar&quot; com.example.App &quot;GraalVM&quot;          Note: We discourage bundling all dependencies into a single “fat” JAR (for example, using the Maven Assembly plugin) as it can cause issues and prevent ahead-of-time compilation with GraalVM Native Image.Instead, we recommend using the original, separate JAR files for all org.graalvm.* dependencies, preferably on the module path.Learn more in the Guide to Embedding Languages.      The source code unit can be represented with a String, as shown in the example, a file, read from URL, and other means.By wrapping the function definition (()), you return the function immediately:Value f = context.eval(&quot;js&quot;, &quot;(function f(x, y) { return x + y; })&quot;);Value result = f.execute(19, 23);You can also lookup Java types from JavaScript and instantiate them, as demonstrated below:try (Context context = Context.newBuilder()                           .allowHostAccess(HostAccess.newBuilder(HostAccess.ALL).build())                           .allowHostClassLookup(className -&amp;gt; true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;js&quot;,            &quot;var BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;);&quot; +            &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}The Polyglot API offers many other ways to access a guest language code from Java, for example, by directly accessing JavaScript objects, numbers, strings, and arrays.Learn more about JavaScript to Java interoperability and find more examples in the Java Interoperability guide.Related DocumentationGraalJS is also available as a standalone distribution that you can download from GitHub.Learn more here.We provide the following documentation for GraalJS users:  JavaScript Compatibility  Java Interoperability  Options of the JavaScript Engine  Multithreading Support  Execute GraalJS on a Stock JDKMigration GuidesLearn more about migration from legacy environments:  Migration Guide from Nashorn  Migration Guide from Rhino  Work with ScriptEngine",
          "url": " /latest/reference-manual/js/"
          },
          
          "latest-tools-graalvm-insight":  {
          "title": "GraalVM Insight",
          "content": "GraalVM Insight  Get Started  Polyglot Tracing  Inspecting Values  What to Read NextGraalVM Insight is a multipurpose, flexible tool that traces program runtime behavior and gathers insights.The dynamic nature of the tool helps users to selectively apply tracing pointcuts on already running applications with no loss of performance.GraalVM Insight also provides detailed access to runtime behavior of a program, allowing users to inspect values and types at invocation or allocation sites.The tool further permits users to modify computed values, interrupt execution, and quickly experiment with behavioral changes without modifying the application code.The implementation details of the tool can be found in the API specification.This page provides information on GraalVM Insight as of the 20.1 version.To learn about Insight on versions 20.0 and 19.3, proceed here.Get Started  Create a simple source-tracing.js script with the following content:    insight.on(&#39;source&#39;, function(ev) { if (ev.characters) {     print(`Loading ${ev.characters.length} characters from ${ev.name}`); }});    Having installed the Node.js runtime, start the node launcher with the --insight tool and observe what scripts are being loaded and evaluated:    ./bin/node --insight=source-tracing.js --js.print --experimental-options -e &quot;print(&#39;The result: &#39; + 6 * 7)&quot; | tail -n 10Loading 215 characters from internal/modules/esm/transform_source.jsLoading 12107 characters from internal/modules/esm/translators.jsLoading 1756 characters from internal/modules/esm/create_dynamic_module.jsLoading 12930 characters from internal/vm/module.jsLoading 2710 characters from internal/modules/run_main.jsLoading 308 characters from module.jsLoading 10844 characters from internal/source_map/source_map.jsLoading 170 characters from [eval]-wrapperLoading 29 characters from [eval]The result: 42    The source-tracing.js script used the provided insight object to attach a source listener to the runtime.Whenever the script was loaded, the listener got notified of it and could take an action – printing the length and name of the processed script.  The Insight information can be collected to a print statement or a histogram.The following function-hotness-tracing.js script counts all method invocations and dumps the most frequent ones when the execution of a program is over:var map = new Map();function dumpHotness() {    print(&quot;==== Hotness Top 10 ====&quot;);    var count = 10;    var digits = 3;    Array.from(map.entries()).sort((one, two) =&amp;gt; two[1] - one[1]).forEach(function (entry) {        var number = entry[1].toString();        if (number.length &amp;gt;= digits) {            digits = number.length;        } else {            number = Array(digits - number.length + 1).join(&#39; &#39;) + number;        }        if (count-- &amp;gt; 0) print(`${number} calls to ${entry[0]}`);    });    print(&quot;========================&quot;);}insight.on(&#39;enter&#39;, function(ev) {    var cnt = map.get(ev.name);    if (cnt) {        cnt = cnt + 1;    } else {        cnt = 1;    }    map.set(ev.name, cnt);}, {    roots: true});insight.on(&#39;close&#39;, dumpHotness);The map is a global variable shared inside of the Insight script that allows the code to share data between the insight.on(&#39;enter&#39;) function and the dumpHotnessfunction.The latter is executed when the node process execution is over (registered via insight.on(&#39;close&#39;, dumpHotness).A table with names and counts of function invocations is printed out when the node process exits.Invoke it as:./bin/node --insight=function-hotness-tracing.js --js.print --experimental-options -e &quot;print(&#39;The result: &#39; + 6 * 7)&quot;The result: 42==== Hotness Top 10 ====516 calls to isPosixPathSeparator311 calls to :=&amp;gt;269 calls to E263 calls to makeNodeErrorWithCode159 calls to :anonymous157 calls to :program 58 calls to getOptionValue 58 calls to getCLIOptionsFromBinding 48 calls to validateString 43 calls to hideStackFrames========================Polyglot TracingThe previous examples were written in JavaScript, but due to GraalVM’s polyglot nature, you can take the same instrument and use it in a program written in, e.g., the Ruby language.  Create the source-trace.js file:    insight.on(&#39;source&#39;, function(ev) {if (ev.uri.indexOf(&#39;gems&#39;) === -1) {  let n = ev.uri.substring(ev.uri.lastIndexOf(&#39;/&#39;) + 1);  print(&#39;JavaScript instrument observed load of &#39; + n);}});    Prepare the helloworld.rb Ruby file:    puts &#39;Hello from GraalVM Ruby!&#39;    Apply the JavaScript instrument to the Ruby program:    ./bin/ruby --polyglot --insight=source-trace.js helloworld.rbJavaScript instrument observed load of helloworld.rbHello from GraalVM Ruby!    It is necessary to start the Ruby launcher with the --polyglot parameter, as the source-tracing.js script remains written in JavaScript.  A user can instrument any language on top of GraalVM, but also the Insight scripts can be written in any of the GraalVM supported languages (implemented with the Truffle language implementation framework).  Create the source-tracing.rb Ruby file:    puts &quot;Ruby: Initializing GraalVM Insight script&quot;insight.on(&#39;source&#39;, -&amp;gt;(ev) { name = ev[:name] puts &quot;Ruby: observed loading of #{name}&quot;})puts &#39;Ruby: Hooks are ready!&#39;    Launch a Node.js application and instrument it with the Ruby script:    ./bin/node --polyglot --insight=source-tracing.rb -e &quot;console.log(&#39;With Ruby: &#39; + 6 * 7)&quot; | grep RubyRuby: Initializing GraalVM Insight scriptRuby: Hooks are ready!Ruby: observed loading of internal/per_context/primordials.jsRuby: observed loading of internal/per_context/setup.jsRuby: observed loading of internal/per_context/domexception.js....Ruby: observed loading of internal/modules/cjs/loader.jsRuby: observed loading of vm.jsRuby: observed loading of fs.jsRuby: observed loading of internal/fs/utils.jsRuby: observed loading of [eval]-wrapperRuby: observed loading of [eval]With Ruby: 42  Inspecting ValuesGraalVM Insight not only allows one to trace where the program execution is happening, it also offers access to values of local variables and function arguments during program execution.You can, for example, write an instrument that shows the value of argument n in the function fib:insight.on(&#39;enter&#39;, function(ctx, frame) {   print(&#39;fib for &#39; + frame.n);}, {   roots: true,   rootNameFilter: (name) =&amp;gt; &#39;fib&#39; === name});This instrument uses the second function argument, frame, to get access to values of local variables inside every instrumented function.The above script also uses rootNameFilter to apply its hook only to the function named fib:function fib(n) {  if (n &amp;lt; 1) return 0;  if (n &amp;lt; 2) return 1;  else return fib(n - 1) + fib(n - 2);}print(&quot;Two is the result &quot; + fib(3));When the instrument is stored in a fib-trace.js file and the actual code is in fib.js, invoking the following command yields detailed information about the program execution and parameters passed between function invocations:./bin/node --insight=fib-trace.js --js.print --experimental-options fib.jsfib for 3fib for 2fib for 1fib for 0fib for 1Two is the result 2What to Read NextInsight Deep DiveAny moderately skilled developer can easily create own so called “hooks” and dynamically apply them to the actual programs.That provides ultimate insights into execution and behavior of one’s application without compromising the execution speed.To continue learning and deep dive into GraalVM Insight, proceed to the Insight Manual which starts with an obligatory HelloWorld example and then demonstrates more challenging tasks.Embedding GraalVM Insight into ApplicationsGraalVM languages (languages implemented with the Truffle framework) can be embedded into custom applications via Polyglot Context API.GraalVM Insight can also be controlled via the same API.Read the embedding documentation to learn how to integrate GraalVM Insight capabilities into applications in a secure way.Tracing with GraalVM InsightGraalVM Insight dynamically adds tracing capabilities into existing code.Write your application as normally and apply Open Telemetry traces dynamicall when needed.Read more about Insight and Jaeger integration in a dedicated guide.API SpecificationIf you are interested in the implementation details, check the API specification.There you will find the information on the insight object properties, functions, etc.",
          "url": " /latest/tools/graalvm-insight/"
          },
          
          "latest-tools-vscode-graalvm-extension":  {
          "title": "GraalVM Tools for Java",
          "content": "GraalVM Tools for JavaThe GraalVM Tools for Java extension for Visual Studio (VS) Code has been deprecated and removed. You can install GraalVM from within VS Code, the same way as any other JDK: open View &amp;gt; Command Palette &amp;gt; Java: Install New JDK &amp;gt; Others &amp;gt; Select Oracle GraalVM.For more information, check Installing and setting up a Java Development Kit (JDK).",
          "url": " /latest/tools/vscode/graalvm-extension/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework":  {
          "title": "Truffle Language Implementation Framework",
          "content": "Truffle Language Implementation FrameworkThe Truffle language implementation framework (Truffle) is an open source library for building tools and programming languages implementations as interpreters for self-modifying Abstract Syntax Trees.Together with the open source Graal compiler, Truffle represents a significant step forward in programming language implementation technology in the current era of dynamic languages.The Truffle artifacts are uploaded to Maven Central - Sonatype.You can use them from your pom.xml file as:&amp;lt;properties&amp;gt;    &amp;lt;graalvm.version&amp;gt;25.0.2&amp;lt;/graalvm.version&amp;gt; &amp;lt;!-- or any later version --&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.truffle&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;truffle-api&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.version}&amp;lt;/version&amp;gt; &amp;lt;!-- or any later version --&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;build&amp;gt;    &amp;lt;plugins&amp;gt;        &amp;lt;plugin&amp;gt;            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;            &amp;lt;version&amp;gt;3.14.0&amp;lt;/version&amp;gt;            &amp;lt;configuration&amp;gt;                &amp;lt;source&amp;gt;21&amp;lt;/source&amp;gt;                &amp;lt;target&amp;gt;21&amp;lt;/target&amp;gt;                &amp;lt;annotationProcessorPaths&amp;gt;                    &amp;lt;path&amp;gt;                        &amp;lt;groupId&amp;gt;org.graalvm.truffle&amp;lt;/groupId&amp;gt;                        &amp;lt;artifactId&amp;gt;truffle-dsl-processor&amp;lt;/artifactId&amp;gt;                        &amp;lt;version&amp;gt;${graalvm.version}&amp;lt;/version&amp;gt;                    &amp;lt;/path&amp;gt;                &amp;lt;/annotationProcessorPaths&amp;gt;            &amp;lt;/configuration&amp;gt;        &amp;lt;/plugin&amp;gt;    &amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;Implement Your LanguageThe Truffle framework allows you to run programming languages efficiently on GraalVM.It simplifies language implementation by automatically deriving high-performance code from interpreters.Getting StartedWe provide extensive Truffle API documentation.Start by looking at the TruffleLanguage class, which you should subclass to start developing a language.Truffle comes with the Graal Compiler and several language implementations as part of GraalVM.A good way to start implementing your language with Truffle is to fork the SimpleLanguage project and start hacking.SimpleLanguage is a relatively small language implementation, well-documented, and designed to demonstrate most of the Truffle features.You could also try by looking at code in one of the existing open source languages implementations and experiments.Advanced TopicsImplementing a language using Truffle offers a way to interoperate with other “Truffle” languages.To estimate if your language is a valid polyglot citizen, read about using the Polyglot API-based Test Compatibility Kit.Somewhat related topics worth exploring are Truffle Libraries, as well as how to use them to implement a language interoperability.Languages implemented with Truffle can also be embedded in Java host applications using the Polyglot API.To better understand how to improve the performance of your language, see the documentation on Profiling Truffle Interpreters and Optimizing Truffle Interpreters.Also, to better understand how to use Truffle’s automated monomorphization feature (for example, splitting), look at the related documentation.Implement Your ToolWith the Truffle framework, you can develop language-agnostic tools such as debuggers, profilers, and other instrumentations.Start with looking at the TruffleInstrument class, which – similar to TruffleLanguage – one should subclass to start developing a tool.If you want to implement your own “Truffle” tool, a good way to start is to fork the SimpleTool project – like the SimpleLanguage project described above – and start hacking.SimpleTool is a well-documented, minimalistic code-coverage tool designed to be a starting point for understanding the tool development process using Truffle.Since tools, developed with Truffle, instrument the language using the same AST-node-based approach, most of the techniques available to language developers, in terms of improving performance, are available to the tool developers as well.This is why it is recommended that you understand how Truffle works from a language developer’s perspective to get the maximum out of your tool.CompatibilityThe Truffle API is evolved in a backwards-compatible manner from one version to the next.When an API is deprecated, then it will stay deprecated for at least two GraalVM releases before it will be removed.As a best practice it is recommended to upgrade Truffle only one version at a time.This way you can increment the version and fix deprecation warnings before continuing to the next version.The deprecated Javadoc tags on the deprecated APIs are designed to be a guide on how to upgrade.The latest additions and changes can be seen in the changelog.Modifying TruffleTo understand how to modify Truffle, check this file.If you would like to contribute to Truffle, consult the contribution documentation.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/"
          },
          
          "latest-reference-manual-native-image-metadata":  {
          "title": "Reachability Metadata",
          "content": "Reachability MetadataThe dynamic language features of the JVM (for example, reflection and resource handling) compute the dynamically-accessed program elements such as fields, methods, or resource URLs at run time. On HotSpot this is possible because all class files and resources are available at run time and can be loaded by the runtime. Availability of all classes and resources, and their loading at run time, comes with an extra overhead in memory and startup time.To make native binaries small, the native-image builder performs static analysis at build time to determine only the necessary program elements that are needed for the correctness of the application. Small binaries allow fast application startup and low memory footprint, however they come at a cost: determining dynamically-accessed application elements via static analysis is infeasible as reachability of those elements depends on data that is available only at run time.To ensure inclusion of necessary dynamically-accessed elements into the native binary, the native-image builder requires reachability metadata (hereinafter referred to as metadata). Providing the builder with correct and exhaustive reachability metadata guarantees application correctness and ensures compatibility with third-party libraries at runtime.You can provide reachability metadata to the native-image builder using the following methods:  Compute metadata in code when the native binary is built and store the required elements in the initial heap of the native binary.  Place one or more reachability-metadata.json files in the META-INF/native-image/&amp;lt;groupId&amp;gt;/&amp;lt;artifactId&amp;gt;/ directory on the classpath. For more information about how to collect metadata for your application automatically, see Collecting Metadata Automatically.  Use the -H:Preserve=&amp;lt;classpath-selector&amp;gt; flag. For detailed instructions, please refer to the -H:Preserve= documentation.  Use the Feature API for advanced use cases where classpath scanning is necessary to compute correct metadata.  Note: Native Image is migrating to the more user-friendly implementation of reachability metadata that shows problems early on and allows easy debugging.  To enable the new user-friendly reachability-metadata mode for your application, pass the option --exact-reachability-metadata at build time. To enable the user-friendly mode only for concrete packages, pass --exact-reachability-metadata=&amp;lt;comma-separated-list-of-packages&amp;gt;.  To get an overview of all places in your code where missing registrations occur, without committing to the exact behavior, you can pass -XX:MissingRegistrationReportingMode=Warn when starting the application.  To detect places where the application accidentally ignores a missing registration error (with catch (Throwable t) blocks), pass -XX:MissingRegistrationReportingMode=Exit when starting the application. The application will then unconditionally print the error message with the stack trace and exit immediately. This behavior is ideal for running application tests to guarantee all metadata is included.  The user-friendly implementation for reflection will become the default in future releases of GraalVM so the timely adoption is important to avoid project breakage.Table of Contents  Computing Metadata in Code  Specifying Metadata with JSON  Metadata Types  Reflection (Including Dynamic Proxies)  Java Native Interface  Foreign Function and Memory API  Resources  Resource Bundles  Serialization  Sample Reachability Metadata  Defining Classes at Run TimeComputing Metadata in CodeComputing metadata in code can be achieved in two ways:      By providing constant arguments to functions that dynamically access elements of the JVM. See, for example, Class#forName in the following code:     class ReflectiveAccess {     public Class&amp;lt;Foo&amp;gt; fetchFoo() throws ClassNotFoundException {         return Class.forName(&quot;Foo&quot;);     } }    Here, Class.forName(&quot;Foo&quot;) is evaluated into a constant at build time. When the native binary is built, this value is stored in its initial heap. If the class Foo does not exist, the call to Class#forName will be transformed into throw ClassNotFoundException(&quot;Foo&quot;).    The constant is defined as:          A literal (for example, &quot;Foo&quot; or 1).      Access to a static field that is initialized at build time.      Access to an effectively final variable.      Defining an array that whose lenght is constant, and all values are constant.      Simple computations on other constants (for example, &quot;F&quot; + &quot;oo&quot;, or an indexing into an array).        When passing constant arrays, the following approaches to declare and populate an array are equivalent from the point of view of the native-image builder:      Class&amp;lt;?&amp;gt;[] params0 = new Class&amp;lt;?&amp;gt;[]{String.class, int.class};  Integer.class.getMethod(&quot;parseInt&quot;, params0);      Class&amp;lt;?&amp;gt;[] params1 = new Class&amp;lt;?&amp;gt;[2];  params1[0] = Class.forName(&quot;java.lang.String&quot;);  params1[1] = int.class;  Integer.class.getMethod(&quot;parseInt&quot;, params1);      Class&amp;lt;?&amp;gt;[] params2 = {String.class, int.class};  Integer.class.getMethod(&quot;parseInt&quot;, params2);    Note that Native Image currently aggressively computes constants, and therefore it is not possible to specify exactly what is a constant at build time.        By initializing classes at build time and storing dynamically accessed elements into the initial heap of the native executable. This way of providing metadata is suited for cases when specifying metadata with constants or in JSON is not possible. This is necessary in cases when:          The user code needs to generate new class bytecode.      The user code needs to traverse the classpath to compute the dynamically accessed program elements necessary for the application.        In the following example:     class InitializedAtBuildTime {     private static Class&amp;lt;?&amp;gt; aClass;     static {         try {             aClass = Class.forName(readFile(&quot;class.txt&quot;));         } catch (ClassNotFoundException e) {             throw RuntimeException(e);         }     }     public Class&amp;lt;?&amp;gt; fetchFoo() {         return aClass;     } }  The dynamically accessed elements will be included into the native executable’s heap only if that part of the heap is reachable through an enclosing method (for example, InitializedAtBuildTime#fetchFoo) or a static field (for example, InitializedAtBuildTime.aClass).Specifying Metadata with JSONAll metadata specified in the reachability-metadata.json file that is located in any of the classpath entries at META-INF/native-image/&amp;lt;group.Id&amp;gt;/&amp;lt;artifactId&amp;gt;/.The JSON schema for the reachability metadata is defined in reachability-metadata-schema-v1.2.0.json.A sample reachability-metadata.json file can be found in the sample section.The reachability-metadata.json configuration contains a single object with one field for each type of metadata. Each field in the top-level object contains an array of metadata entries:{  &quot;reflection&quot;:[],  &quot;resources&quot;:[]}For example, Java reflection metadata is specified under reflection, and an example entry looks like:{  &quot;reflection&quot;: [    {      &quot;type&quot;: &quot;Foo&quot;    }  ]}Conditional Metadata EntriesEach entry in JSON-based metadata should be conditional to avoid unnecessary growth of the native binary size.A conditional entry is specified by adding a condition field to the entry in the following way:{  &quot;condition&quot;: {    &quot;typeReached&quot;: &quot;&amp;lt;fully-qualified-class-name&amp;gt;&quot;  },  &amp;lt;metadata-entry&amp;gt;}A metadata entry with a typeReached condition is considered available at run time, only when the specified fully-qualified type is reached at run time. Before that, all dynamic accesses to the element represented with the metadata-entry will behave as if the metadata-entry does not exist.This means that those dynamic accesses will throw a missing-registration error.A type is reached at run time, right before the class-initialization routine starts for that type (class or interface), or any of the type’s subtypes are reached.For &quot;typeReached&quot;: &quot;ConditionType&quot; that guards a metadata entry in the following example, the type is considered reached:class SuperType {    static {        // ConditionType reached (subtype reached) =&amp;gt; metadata entry available    }}class ConditionType extends SuperType {    static {        // ConditionType reached (before static initializer) =&amp;gt; metadata entry available    }    static ConditionType singleton() {        // ConditionType reached (already initialized) =&amp;gt; metadata entry available    }}public class App {    public static void main(String[] args) {        // ConditionType not reached =&amp;gt; metadata entry not available        ConditionType.class;        // ConditionType not reached (ConditionType.class doesn&#39;t start class initialization) =&amp;gt; metadata entry not available          ConditionType.singleton();        // ConditionType reached (already initialized) =&amp;gt; metadata entry available    }}A type is also reached, if it is marked as initialize-at-build-time or any of its subtypes are marked as initialize-at-build-time and they exist on the classpath.Array types are never marked as reached and as such cannot be used in conditions.A conditional metadata entry is included into the image when the fully-qualified type is reachable at build time. This entry affects the image size, and it will be available at run time only when the condition is reached at run time.You can find more examples of the metadata files in the GraalVM Reachability Metadata repository.Metadata TypesNative Image accepts the following types of reachability metadata:  Java reflection (the java.lang.reflect.* API) enables Java code to examine its own classes, methods, fields, and their properties at run time.  JNI allows native code to access classes, methods, fields and their properties at run time.  Resources allow arbitrary files present on the classpath to be dynamically accessed in the application.  Resource Bundles Java localization support (java.util.ResourceBundle) that enables Java code to load L10N resources.  Serialization enables writing (and reading) Java objects to (and from) streams.  (Experimental) Predefined Classes provide support for dynamically generated classes.ReflectionFor all methods in this section Native Image will compute reachability at build time given that all the call arguments are constant. Providing constant arguments in code is a preferred way to provide metadata as it requires no duplication of information in external JSON files.Reflection in Java starts with java.lang.Class that allows fetching further reflective elements such as methods and fields. The class can be fetched reflectively via the following static functions on java.lang.Class:  java.lang.Class forName(java.lang.String) throws java.lang.ClassNotFoundException  java.lang.Class forName(java.lang.String, boolean, java.lang.ClassLoader) throws java.lang.ClassNotFoundException  java.lang.Class forName(java.lang.Module, java.lang.String)  java.lang.Class arrayType() - requires metadata for the array type.The classes can be also fetched reflectively loading a class from a name with java.lang.ClassLoader#loadClass(String).To provide metadata for the calls that fetch a Class reflectively, the following entry must be added to the reflection array in reachability-metadata.json:{  &quot;type&quot;: &quot;FullyQualifiedReflectivelyAccessedType&quot;}For proxy classes, the java.lang.Class is fetched with the following methods on java.lang.reflect.Proxy:  java.lang.Class getProxyClass(java.lang.ClassLoader, java.lang.Class[]) throws java.lang.IllegalArgumentException  java.lang.Object newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)Metadata, for proxy classes, is in the form an ordered collection of interfaces that defines a proxy:{  &quot;type&quot;: {    &quot;proxy&quot;: [&quot;FullyQualifiedInterface1&quot;, &quot;...&quot;, &quot;FullyQualifiedInterfaceN&quot;]  }}To provide metadata for a lambda class, the following metadata must be added to the reflection array inreachability-metadata.json{  &quot;type&quot;: {    &quot;lambda&quot;: {      &quot;declaringClass&quot;: &quot;FullyQualifiedLambdaDeclaringType&quot;,      &quot;declaringMethod&quot;: {        &quot;name&quot;: &quot;declaringMethodName&quot;,        &quot;parameterType&quot;: [          &quot;FullyQualifiedParameterType1&quot;,          &quot;...&quot;,          &quot;FullyQualifiedParameterType2&quot;        ]      },      &quot;interfaces&quot;: [        &quot;FullyQualifiedLambdaInterface1&quot;,        &quot;...&quot;,        &quot;FullyQualifiedLamdbaInterface2&quot;      ]    }  }}The &quot;declaringClass&quot; field specifies in which class, and the optional &quot;declaringMethod&quot; field specifies in whichmethod the lambda is defined.If &quot;declaringMethod&quot; is not specified, the lambda class is searched through all methods of the specified declaringclass.The &quot;interfaces&quot; field specifies which interfaces are implemented by the lambda class.Such a definition can match multiple lambda classes. If that is the case, the registration entry applies to all thoseclasses.Invocation of methods above without the provided metadata will result in throwing MissingReflectionRegistrationError which extends java.lang.Error andshould not be handled. Note that even if a type does not exist on the classpath, the methods above will throw a MissingReflectionRegistrationError.The following methods on java.lang.Class will throw a MissingRegistrationError if the metadata is not provided for a given type:  Constructor getConstructor(Class[]) throws NoSuchMethodException,SecurityException  Constructor getDeclaredConstructor(Class[]) throws NoSuchMethodException,SecurityException  Constructor[] getConstructors() throws SecurityException  Constructor[] getDeclaredConstructors() throws SecurityException  Method getMethod(String,Class[]) throws NoSuchMethodException,SecurityException  Method getDeclaredMethod(String,Class[]) throws NoSuchMethodException,SecurityException  Method[] getMethods() throws SecurityException  Method[] getDeclaredMethods() throws SecurityException  Field getField(String) throws NoSuchFieldException,SecurityException  Field getDeclaredField(String) throws NoSuchFieldException,SecurityException  Field[] getFields() throws SecurityException  Field[] getDeclaredFields() throws SecurityException  RecordComponent[] getRecordComponents()  Class[] getPermittedSubclasses()  Object[] getSigners()  Class[] getNestMembers()  Class[] getClasses()  Class[] getDeclaredClasses() throws SecurityExceptionFurthermore, all reflective lookups via java.lang.invoke.MethodHandles.Lookup will also require metadata for the type to be present, or they will throw MissingReflectionRegistrationError.Note that for lambda-proxy classes, metadata can not be provided.This is a known issue that will be addressed in the future releases of GraalVM.Reflective Method InvocationTo reflectively invoke methods, the method signature must be added to the type metadata:{  &quot;type&quot;: &quot;TypeWhoseMethodsAreInvoked&quot;,  &quot;methods&quot;: [    {&quot;name&quot;: &quot;&amp;lt;methodName1&amp;gt;&quot;, &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]},    {&quot;name&quot;: &quot;&amp;lt;methodName2&amp;gt;&quot;, &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]}  ]}As a convenience, one can allow method invocation for groups of methods by adding the following in reachability-metadata.json:{  &quot;type&quot;: &quot;TypeWhoseMethodsAreInvoked&quot;,  &quot;allDeclaredConstructors&quot;: true,  &quot;allPublicConstructors&quot;: true,  &quot;allDeclaredMethods&quot;: true,  &quot;allPublicMethods&quot;: true}allDeclaredConstructors and allDeclaredMethods allow calls invocations of methods declared on a given type. allPublicConstructors and allPublicMethods allow invocations of all public methods defined on a type and all of its supertypes.In case the method-invocation metadata is missing, the following methods will throw a MissingReflectionRegistrationError:  java.lang.reflect.Method#invoke(Object, Object...)  java.lang.reflect.Constructor#newInstance(Object...)  java.lang.invoke.MethodHandle#invokeExact(Object...)  java.lang.invoke.MethodHandle#invokeWithArguments (all overloaded versions)Reflective Field-Value AccessTo reflectively access (get or set) field values, metadata about field names must be added to the type:{  &quot;type&quot;: &quot;TypeWhoseFieldValuesAreAccessed&quot;,  &quot;fields&quot;: [{&quot;name&quot;: &quot;&amp;lt;fieldName1&amp;gt;&quot;}, {&quot;name&quot;: &quot;&amp;lt;fieldNameI&amp;gt;&quot;}, {&quot;name&quot;: &quot;&amp;lt;fieldNameN&amp;gt;&quot;}]}As a convenience one can allow field-value access for all fields by adding the following in reachability-metadata.json:{  &quot;type&quot;: &quot;TypeWhoseFieldValuesAreAccessed&quot;,  &quot;allDeclaredFields&quot;: true,  &quot;allPublicFields&quot;: true}allDeclaredFields allow access to all fields declared on a given type, and allPublicFields allows access to all public fields of the given type and all of its supertypes.In case the field-value-access metadata is missing, the following methods will throw a MissingReflectionRegistrationError:  java.lang.reflect.Field#get(Object)  java.lang.reflect.Field#set(Object, Object)  All accessor methods on java.lang.reflect.VarHandle.Unsafe Allocation of a TypeFor unsafe allocation of a type via sun.misc.Unsafe#allocateInstance(Class&amp;lt;?&amp;gt;), or from native code via AllocObject(jClass), we must provide the following metadata:{  &quot;type&quot;: &quot;FullyQualifiedUnsafeAllocatedType&quot;,  &quot;unsafeAllocated&quot;: true}Otherwise, these methods will throw a MissingReflectionRegistrationError.Reflection Metadata SummaryThe overall definition of a type in JSON can have the following values:{  &quot;condition&quot;: {    &quot;typeReached&quot;: &quot;&amp;lt;condition-class&amp;gt;&quot;  },  &quot;type&quot;: &quot;&amp;lt;class&amp;gt;|&amp;lt;proxy-interface-list&amp;gt;&quot;,  &quot;fields&quot;: [    {&quot;name&quot;: &quot;&amp;lt;fieldName&amp;gt;&quot;}  ],  &quot;methods&quot;: [    {&quot;name&quot;: &quot;&amp;lt;methodName&amp;gt;&quot;, &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type&amp;gt;&quot;]}  ],  &quot;allDeclaredConstructors&quot;: true,  &quot;allPublicConstructors&quot;: true,  &quot;allDeclaredMethods&quot;: true,  &quot;allPublicMethods&quot;: true,  &quot;allDeclaredFields&quot;: true,  &quot;allPublicFields&quot;: true,  &quot;unsafeAllocated&quot;: true}Java Native InterfaceJava Native Interface (JNI) allows native code to access arbitrary Java types and type members.Native Image cannot predict what such native code will lookup, write to or invoke.To build a native binary for a Java application that uses JNI to access Java values, JNI metadata is required.For example, the following C code:jclass clazz = FindClass(env, &quot;jni/accessed/Type&quot;);looks up the jni.accessed.Type class, which can then be used to instantiate jni.accessed.Type, invoke its methods or access its fields.The metadata entry for the above call can only be provided via reachability-metadata.json. Specifythe jniAccessible field in the type entry in the reflection section:{  &quot;reflection&quot;: [    {      &quot;type&quot;: &quot;jni.accessed.Type&quot;,      &quot;jniAccessibleType&quot;: true    }  ]}Adding the metadata for a type does not allow to fetch all of its fields and methods with GetFieldID, GetStaticFieldID, GetStaticMethodID, and GetMethodID.To access field values, we need to provide field names:{  &quot;type&quot;: &quot;jni.accessed.Type&quot;,  &quot;jniAccessible&quot;: true,  &quot;fields&quot;: [{&quot;name&quot;: &quot;value&quot;}]}To access all fields one can use the following attributes:{  &quot;type&quot;: &quot;jni.accessed.Type&quot;,  &quot;jniAccessible&quot;: true,  &quot;allDeclaredFields&quot;: true,  &quot;allPublicFields&quot;: true}allDeclaredFields allow access to all fields declared on a given type, and allPublicFields allows access to all public fields of the given type and all of its supertypes.To call Java methods from JNI, we must provide metadata for the method signatures:{  &quot;type&quot;: &quot;jni.accessed.Type&quot;,  &quot;jniAccessible&quot;: true,  &quot;methods&quot;: [    {&quot;name&quot;: &quot;&amp;lt;methodName1&amp;gt;&quot;, &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]},    {&quot;name&quot;: &quot;&amp;lt;methodName2&amp;gt;&quot;, &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]}  ]}As a convenience, one can allow method invocation for groups of methods by adding the following:{  &quot;type&quot;: &quot;jni.accessed.Type&quot;,  &quot;jniAccessible&quot;: true,  &quot;allDeclaredConstructors&quot;: true,  &quot;allPublicConstructors&quot;: true,  &quot;allDeclaredMethods&quot;: true,  &quot;allPublicMethods&quot;: true}allDeclaredConstructors and allDeclaredMethods allow calls invocations of methods declared on a given type.allPublicConstructors and allPublicMethods allow invocations of all public methods defined on a type and all of its supertypes.To allocate objects of a type with AllocObject, the unsafeAllocated field must be set, but the jniAccessible fieldis not required:{  &quot;reflection&quot;: [    {      &quot;type&quot;: &quot;jni.accessed.Type&quot;,      &quot;unsafeAllocated&quot;: true    }  ]}Failing to provide metadata for an element that is dynamically accessed from native code will result in an exception (MissingJNIRegistrationError).  Note that most libraries that use JNI do not handle exceptions properly, so to see which elements are missing --exact-reachability-metadata in combination with -XX:MissingRegistrationReportingMode=Warn must be used.Foreign Function and Memory APIThe Foreign Function and Memory (FFM) API is an interface that enables Java code to interact with native code and vice versa.In particular, it allows you to create downcall handles and upcall stubs.  A downcall handle is a method handle that refers to a native function. Invoking it results in a call to the native function.  An upcall stub is executable code generated at run time that can be passed as a function pointer to native code. Calling this function pointer results in the execution of a Java method handle.To perform downcalls or upcalls at run time, supporting code must be generated at image build time.Therefore, the native-image builder must be provided with descriptors that characterize the functions with which downcalls or upcalls can be performed at run time.If the necessary metadata is not provided, a MissingForeignRegistrationError will be thrown at run time.ResourcesJava is capable of accessing any resource on the application class path, or the module path for which the requesting code has permission to access.Resource metadata instructs the native-image builder to include specified resources and resource bundles in the produced binary.A consequence of this approach is that some parts of the application that use resources for configuration (such as logging) are effectively configured at build time.Native Image will detect calls to java.lang.Class#getResource and java.lang.Class#getResourceAsStream in which:  The class on which these methods are called is constant  The first argument (name) is a constantand automatically register such resources.The code below will work out of the box, because:  It uses a class literal (Example.class) as the receiver  It uses a string literal as the name parameter    class Example { public void conquerTheWorld() {     InputStream plan = Example.class.getResourceAsStream(&quot;plans/v2/conquer_the_world.txt&quot;); }}  Resource Metadata in JSONResource metadata is specified in the resources field of the reachability-metadata.json file. Here is the example of resource metadata:{  &quot;resources&quot;: [    {      &quot;glob&quot;: &quot;path1/level*/**&quot;    }  ]}The glob field uses a subset of glob-pattern rules for specifying resources. There are several rules to be observed when specifying a resource path:  The native-image tool supports only star (*) and globstar (**) wildcard patterns.          Per definition, star can match any number of any characters on one level while globstar can match any number of characters at any level.      If there is a need to treat a star literally (without special meaning), it can be escaped using  (for example, *).        In the glob, a level represents a part of the pattern separated with /.  When writing glob patterns the following rules must be observed:          Glob cannot be empty (for example, &quot;&quot; )      Glob cannot end with a trailing slash (/) (for example, &quot;foo/bar/&quot;)      Glob cannot contain more than two consecutive (non-escaped) * characters on one level (for example, &quot;foo/***/&quot; )      Glob cannot contain empty levels (for example, &quot;foo//bar&quot;)      Glob cannot contain two consecutive globstar wildcards (example, &quot;foo/**/**&quot;)      Glob cannot have other content on the same level as globstar wildcard (for example, &quot;foo/**bar/x&quot;)      Given the following project structure:app-root└── src    └── main        └── resources            ├── Resource0.txt            └── Resource1.txtYou can:  Include all resources with glob **/Resource*.txt ({ &quot;glob&quot;:})  Include Resource0.txt with glob **/Resource0.txt  Include Resource0.txt and Resource1.txt with globs **/Resource0.txt and **/Resource1.txtResources in Java ModulesFor every resource or resource bundle, it is possible to specify the module from which the resource or resource bundle should be taken.You can specify a module name in the separate module field in each entry.For example:{   &quot;resources&quot;: [      {        &quot;module:&quot;: &quot;library.module&quot;,        &quot;glob&quot;: &quot;resource-file.txt&quot;       }   ]}This will cause the native-image tool to only include resource-file.txt from the Java module library.module.If other modules or the classpath containing resources that match the pattern resource-file.txt, only the one in library-module is registered to be included into a native executable.Native Image will also ensure that the modules are guaranteed to be accessible at runtime.Take the following code pattern:InputStream resource = ModuleLayer.boot().findModule(&quot;library.module&quot;).getResourceAsStream(resourcePath);It will always work as expected for resources registered as described above (even if the module does not contain any code that is considered reachable by static analysis).Embedded Resources InformationThere are two ways to see which resources were included in a native executable:  Use the option --emit build-report to generate a build report for your native executable.There you can find information about all included resources under the Resources tab.  Use the option -H:+GenerateEmbeddedResourcesFile to generate a JSON file  embedded-resources.json, listing all included resources.For each registered resource you get:  Module (or unnamed if a resource does not belong to any module)  Name (resource path)  Origin (location of the resource on the system)  Type (whether the resource is a file, directory, or missing)  Size (actual resource size)  Note: The size of a resource directory represents only the size of the names of all directory entries (not a sum of the content sizes).Resource BundlesJava localization support (java.util.ResourceBundle) enables to load L10N resources and show messages localized for a specific locale.Native Image needs knowledge of the resource bundles that your application uses so that it can include appropriate resources and program elements to the application.A simple bundle can be specified in the resources section of reachability-metadata.json:{  &quot;resources&quot;: [    {      &quot;bundle&quot;: &quot;your.pkg.Bundle&quot;    }  ]}To request a bundle from a specific module:{  &quot;resources&quot;: [    {      &quot;module&quot;: &quot;app.module&quot;      &quot;bundle&quot;: &quot;your.pkg.Bundle&quot;    }  ]}Resource bundles are included for all locales that are included into the image.LocalesIt is also possible to specify which locales should be included in a native executable and which should be the default.For example, to switch the default locale to Swiss German and also include French and English, use the following options:native-image -Duser.country=CH -Duser.language=de -H:IncludeLocales=fr,enThe locales are specified using language tags.You can include all locales via -H:+IncludeAllLocales, but note that it increases the size of the resulting executable.SerializationJava can serialize (or deserialize) any class that implements the Serializable interface.Native Image supports serialization (or deserialization) with proper serialization metadata registration.This is necessary because serialization usually requires reflective accesses to the object that is being serialized.Serialization Metadata Registration In CodeNative Image detects calls to ObjectInputFilter.Config#createFilter(String pattern) and if the pattern argument is constant, the exact classes mentioned in the pattern will be registered for serialization. For example, the following pattern will register the class pkg.SerializableClass for serialization:  var filter = ObjectInputFilter.Config.createFilter(&quot;pkg.SerializableClass;!*;&quot;)  objectInputStream.setObjectInputFilter(proof);Using this pattern has a positive side effect of improving security on the JVM as only pkg.SerializableClass can be received by the objectInputStream.Wildcard patterns do the serialization registration only for lambda-proxy classes of an enclosing class. For example, to register lambda serialization in an enclosing class pkg.LambdaHolder use:  ObjectInputFilter.Config.createFilter(&quot;pkg.LambdaHolder$$Lambda*;&quot;)Patterns like &quot;pkg.**&quot; and &quot;pkg.Prefix*&quot; will not perform serialization registration as they are too general and would increase image size significantly.For calls to the sun.reflect.ReflectionFactory#newConstructorForSerialization(java.lang.Class) and sun.reflect.ReflectionFactory#newConstructorForSerialization(java.lang.Class, ) native image detects calls to these functions when all arguments and the receiver are constant. For example, the following call will register SerializlableClass for serialization:  ReflectionFactory.getReflectionFactory().newConstructorForSerialization(SerializableClass.class);To create a custom constructor for serialization use:  var constructor = SuperSuperClass.class.getDeclaredConstructor();  var newConstructor = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(BaseClass.class, constructor);Proxy classes can only be registered for serialization via the JSON files.Serialization Metadata in JSONSerialization metadata is specified in the reflection section of reachability-metadata.json.To specify a regular serialized.Type use{  &quot;reflection&quot;: [    {      &quot;type&quot;: &quot;serialized.Type&quot;,      &quot;serializable&quot;: true    }  ]}To specify a proxy class for serialization, use the following entry:{  &quot;reflection&quot;: [    {      &quot;type&quot;: {        &quot;proxy&quot;: [&quot;FullyQualifiedInterface1&quot;, &quot;...&quot;, &quot;FullyQualifiedInterfaceN&quot;],        &quot;serializable&quot;: true      }    }  ]}In rare cases an application might explicitly make calls to:    ReflectionFactory.newConstructorForSerialization(Class&amp;lt;?&amp;gt; cl, Constructor&amp;lt;?&amp;gt; constructorToCall);The specified constructorToCall differs from the one that would be automatically used during regular serialization of cl.When a class is registered for run-time serialization, all potential custom constructors are automatically registered.As a result, this use case does not require any additional metadata.Sample Reachability MetadataSee below is a sample reachability metadata configuration that you can use in reachabilty-metadata.json:{  &quot;reflection&quot;: [    {      &quot;type&quot;: &quot;reflectively.accessed.Type&quot;,      &quot;fields&quot;: [        {          &quot;name&quot;: &quot;field1&quot;        }      ],      &quot;methods&quot;: [        {          &quot;name&quot;: &quot;method1&quot;,          &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]         }      ],      &quot;allDeclaredConstructors&quot;: true,      &quot;allPublicConstructors&quot;: true,      &quot;allDeclaredFields&quot;: true,      &quot;allPublicFields&quot;: true,      &quot;allDeclaredMethods&quot;: true,      &quot;allPublicMethods&quot;: true,      &quot;unsafeAllocated&quot;: true,      &quot;serializable&quot;: true    }  ],  &quot;jni&quot;: [    {      &quot;type&quot;: &quot;jni.accessed.Type&quot;,      &quot;fields&quot;: [        {          &quot;name&quot;: &quot;field1&quot;        }      ],      &quot;methods&quot;: [        {          &quot;name&quot;: &quot;method1&quot;,          &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]        }      ],      &quot;allDeclaredConstructors&quot;: true,      &quot;allPublicConstructors&quot;: true,      &quot;allDeclaredFields&quot;: true,      &quot;allPublicFields&quot;: true,      &quot;allDeclaredMethods&quot;: true,      &quot;allPublicMethods&quot;: true    }  ],  &quot;resources&quot;: [    {      &quot;module&quot;: &quot;optional.module.of.a.resource&quot;,      &quot;glob&quot;: &quot;path1/level*/**&quot;    },    {      &quot;bundle&quot;: &quot;fully.qualified.bundle.name&quot;    }  ],  &quot;foreign&quot;: {    &quot;downcalls&quot;: [      {        &quot;returnType&quot;: &quot;&amp;lt;return-type&amp;gt;&quot;,        &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]      }    ],    &quot;upcalls&quot;: [      {        &quot;returnType&quot;: &quot;&amp;lt;return-type&amp;gt;&quot;,        &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]      }    ],    &quot;directUpcalls&quot;: [      {        &quot;class&quot;: &quot;org.example.SomeClass&quot;,        &quot;method&quot;: &quot;method1&quot;,        &quot;returnType&quot;: &quot;&amp;lt;return-type&amp;gt;&quot;,        &quot;parameterTypes&quot;: [&quot;&amp;lt;param-type1&amp;gt;&quot;, &quot;&amp;lt;param-typeI&amp;gt;&quot;, &quot;&amp;lt;param-typeN&amp;gt;&quot;]      }    ]  }}Defining Classes at Run TimeJava has support for loading new classes from bytecode at run time, which is not possible in Native Image as all classes must be known at build time (the “closed-world assumption”).To overcome this issue there are the following options:  Modify or reconfigure your application (or a third-party library) so that it does not generate classes at runtime or load them via non-built-in class loaders.  If the classes must be generated, try to generate them at build time in a static initializer of a dedicated class.The generated java.lang.Class objects should be stored in static fields and the dedicated class initialized by passing --initialize-at-build-time=&amp;lt;class_name&amp;gt; as the build argument.  If none of the above is applicable, use the Native Image Agent to run the application and collect predefined classes withjava -agentlib:native-image-agent=config-output-dir=&amp;lt;config-dir&amp;gt;,experimental-class-define-support &amp;lt;application-arguments&amp;gt;.At runtime, if there is an attempt to load a class with the same name and bytecode as one of the classes encountered during tracing, the predefined class will be supplied to the application.Predefined classes metadata is specified in a predefined-classes-config.json file and conform to the JSON schema defined inpredefined-classes-config-schema-v1.0.0.json.The schema also includes further details and explanations how this configuration works. Here is the example of the predefined-classes-config.json:[  {    &quot;type&quot;: &quot;agent-extracted&quot;,    &quot;classes&quot;: [      {        &quot;hash&quot;: &quot;&amp;lt;class-bytecodes-hash&amp;gt;&quot;,        &quot;nameInfo&quot;: &quot;&amp;lt;class-name&quot;      }    ]  }]  Note: Predefined classes metadata is not meant to be manually written.Note: Predefined classes are the best-effort approach for legacy projects, and they are not guaranteed to work.Further Reading  Metadata Collection with the Tracing Agent  Native Image Compatibility Guide  GraalVM Reachability Metadata Repository",
          "url": " /latest/reference-manual/native-image/metadata/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-splitting-reportingpolymorphism":  {
          "title": "Reporting Polymorphic Specializations to Runtime",
          "content": "Reporting Polymorphic Specializations to RuntimeThis guide gives an overview of what is required of language implementers in order to leverage the monomorphization (splitting) strategy.More information on how it works can be found in the Splitting guide.In simple terms, the monomorphization heuristic relies on the language reporting polymorphic specializations for each node that could potentially be returned to a monomorphic state through splitting.In this context a polymorphic specialization is any node rewriting which results in the node changing “how polymorphic” it is. This includes, but is not limited to, activating another specialization, increasing the number of instances of an active specialization, excluding a specialization, etc..Manual Reporting of Polymorphic SpecializationsTo facilitate reporting of polymorphic specializations, a new API was introducedinto the Node class: Node#reportPolymorphicSpecialize.This method can be used to manually report polymorphic specializations, but only in cases when this cannot be automated by using the DSL.Automated Reporting of Polymorphic SpecializationsSince the Truffle DSL automates much of the transitions between specializations, the @ReportPolymorphism annotation for automated reporting of polymorphic specializations was added.This annotation instructs the DSL to include checks for polymorphism after specializations and to call Node#reportPolymorphicSpecialize if needed.For an example on how to use this annotation, consider the com.oracle.truffle.sl.nodes.SLStatementNode. It is the base class for allSimpleLanguage nodes and, since the ReportPolymorphism annotation is inherited, simply annotating this class will enable reporting of polymorphic specializations for all SimpleLanguage nodes.Below is the diff of the change that adds this annotation to SLStatementNode:diff --gita/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.javab/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.javaindex 788cc20..89448b2 100644---a/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.java+++b/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.java@@ -43,6 +43,7 @@ package com.oracle.truffle.sl.nodes; import java.io.File; import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;+import com.oracle.truffle.api.dsl.ReportPolymorphism; import com.oracle.truffle.api.frame.VirtualFrame; import com.oracle.truffle.api.instrumentation.GenerateWrapper; import com.oracle.truffle.api.instrumentation.InstrumentableNode;@@ -62,6 +63,7 @@ import com.oracle.truffle.api.source.SourceSection;  */ @NodeInfo(language = &quot;SL&quot;, description = &quot;The abstract base node for all SLstatements&quot;) @GenerateWrapper+@ReportPolymorphism public abstract class SLStatementNode extends Node implementsInstrumentableNode {     private static final int NO_SOURCE = -1;Controlling Automated Reporting of Polymorphic SpecializationsExcluding particular nodes and specializationsApplying the ReportPolymorphism annotation to all nodes of a language is the simplest way to facilitate the monomorphization, but it could cause reporting of polymorphic specializations in cases where that does not necessarily make sense.In order to give the language developer more control over which nodes and which specializations are taken into consideration for reporting polymorphism, the @ReportPolymorphism.Exclude annotation was introduced which is applicable to classes (disabling automated reporting for the entire class) or to individual specializations (excluding those specializations from consideration when checking for polymorphism).Reporting only on Megamorphic CasesAs of version 20.3.0 a new annotation was added: ReportPolymorphism.Megamorphic.This annotation can only be applied to specializations, as marks that specialization as megamorphic as it is intended to be used on expensive “generic” specializations that should be fixed by monomorphization.The effect of adding this annotation is that, once the annotated specialisation becomes active, the node will report polymorphism to the runtime independent of the state of other specializations.This annotation can be used separately from @ReportPolymorphism, i.e., a node does not need to be annotated with @ReportPolymorphism for the megamorphic annotation to work.If both annotations are used, then both polymorphic and megamorphic activations will be reported as polymorphism.Tools SupportKnowing which nodes should and should not report polymorphic specializations is for the language developer to conclude.This can be done either through domain knowledge (which nodes of the language are expensive when polymorphic), or through experimentation (measuring the effects of including/excluding particular nodes/specializations).To aid language developers in better understanding the impact of reporting polymorphic specializations some tools support was provided.Tracing individual splitsAdding the --engine.TraceSplitting argument to the command line when executing your guest language code will, in real time, print information about each split the runtime makes.A small part of the output from running one of the JavaScript benchmarks with the flag enabled follows....[engine] split   0-37d4349f-1     multiplyScalar |ASTSize      40/   40 |Calls/Thres       2/    3 |CallsAndLoop/Thres       2/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~441-444:12764-12993[engine] split   1-2ea41516-1     :anonymous |ASTSize       8/    8 |Calls/Thres       3/    3 |CallsAndLoop/Thres       3/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~269:7395-7446[engine] split   2-3a44431a-1     :anonymous |ASTSize      28/   28 |Calls/Thres       4/    5 |CallsAndLoop/Thres       4/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~35-37:1163-1226[engine] split   3-3c7f66c4-1     Function.prototype.apply |ASTSize      18/   18 |Calls/Thres       7/    8 |CallsAndLoop/Thres       7/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~36:1182-1219...Tracing a splitting summaryAdding the --engine.TraceSplittingSummary argument to the command line when executing your guest language code will, after the execution is complete, print out a summary of the gathered data regarding splitting.This includes how many splits there were, how large is the splitting budget and how much of it was used, how many splits were forced, a list of split target names and how many times they were split and a list of nodes that reported polymorphic specializations and how many.A slightly simplified output of running one of the JavaScript benchmarks with the flag enabled follows.[engine] Splitting StatisticsSplit count                             :       9783Split limit                             :      15342Split count                             :          0Split limit                             :        574Splits                                  :        591Forced splits                           :          0Nodes created through splitting         :       9979Nodes created without splitting         :      10700Increase in nodes                       :     93.26%Split nodes wasted                      :        390Percent of split nodes wasted           :      3.91%Targets wasted due to splitting         :         27Total nodes executed                    :       7399--- SPLIT TARGETSinitialize                              :         60Function.prototype.apply                :        117Array.prototype.push                    :          7initialize                              :          2magnitude                               :         17:anonymous                              :        117add                                     :          5...--- NODESclass ANode                             :         42class AnotherNode                       :        198class YetAnotherNode                    :          1...Tracing polymorphic specializationsConsider reading the Splitting guide before this section, as the dumped data is directly related to how splitting works.To better understand how reporting polymorphism impacts which call targets are considered for splitting one can use the --engine.SplittingTraceEvents option.This option will print, in real time, a log detailing which nodes are reporting polymorphism and how that is affecting the call targets.See the following examples.Example 1[engine] [poly-event] Polymorphic event! Source: JSObjectWriteElementTypeCacheNode@e3c0e40   WorkerTask.run[engine] [poly-event] Early return: false callCount: 1, numberOfKnownCallNodes: 1            WorkerTask.runThis log section tells that the JSObjectWriteElementTypeCacheNode in the WorkerTask.run method turned polymorphic and reported it.It also tells that this is the first time that WorkerTask.run is being executed (callCount: 1), thus you do not mark it as “needs split” (Early return: false)Example 2[engine] [poly-event] Polymorphic event! Source: WritePropertyNode@50313382                  Packet.addTo[engine] [poly-event] One caller! Analysing parent.                                          Packet.addTo[engine] [poly-event]   One caller! Analysing parent.                                        HandlerTask.run[engine] [poly-event]     One caller! Analysing parent.                                      TaskControlBlock.run[engine] [poly-event]       Early return: false callCount: 1, numberOfKnownCallNodes: 1      Scheduler.schedule[engine] [poly-event]     Return: false                                                      TaskControlBlock.run[engine] [poly-event]   Return: false                                                        HandlerTask.run[engine] [poly-event] Return: false                                                          Packet.addToIn this example the source of the polymorphic specialization is WritePropertyNode in Packet.addTo.Since this call target has only one known caller, you can analyse its parent in the call tree (i.e., the caller).This is, in the example, HandlerTask.run and the same applies to it as well, leading to TaskControlBlock.run, and by the same token to Scheduler.schedule.Scheduler.schedule has a callCount of 1, i.e., this is its first execution, so you do not mark it as “needs split” (Early return: false).Example 3[engine] [poly-event] Polymorphic event! Source: JSObjectWriteElementTypeCacheNode@3e44f2a5  Scheduler.addTask[engine] [poly-event] Set needs split to true                                                Scheduler.addTask[engine] [poly-event] Return: true                                                           Scheduler.addTaskIn this example the source of the polymorphic specialization is JSObjectWriteElementTypeCacheNode in Scheduler.addTask.This call target is immediately marked as “needs split”, since all the criteria to do so are met.Example 3[engine] [poly-event] Polymorphic event! Source: WritePropertyNode@479cbee5                  TaskControlBlock.checkPriorityAdd[engine] [poly-event] One caller! Analysing parent.                                          TaskControlBlock.checkPriorityAdd[engine] [poly-event]   Set needs split to true                                              Scheduler.queue[engine] [poly-event]   Return: true                                                         Scheduler.queue[engine] [poly-event] Set needs split to true via parent                                     TaskControlBlock.checkPriorityAdd[engine] [poly-event] Return: true                                                           TaskControlBlock.checkPriorityAddIn this example the source of the polymorphic specialization is WritePropertyNode in TaskControlBlock.checkPriorityAdd.Since it has only one caller, you look at that caller (Scheduler.queue), and since all the criteria necessary seem to be met, you mark it as “needs split”.Dumping polymorphic specializations to IGVConsider reading the Splitting guide before this section, as the dumped data is directly related to how splitting works.Adding the --engine.SplittingDumpDecisions argument to the command line when executing your guest language code will, every time a call target is marked “needs split”, dump a graph showing a chain of nodes (linked by child connections as well as direct call node to callee root node links) ending in the node that called Node#reportPolymorphicSpecialize.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/splitting/ReportingPolymorphism/"
          },
          
          "latest-reference-manual-js-rhinomigrationguide":  {
          "title": "Migration Guide from Rhino to GraalJS",
          "content": "Migration Guide from Rhino to GraalJSThis document serves as a migration guide for code previously targeted to the Rhino engine.See the Java Interoperability guide for an overview of supported features.Both Rhino and GraalJS support a similar set of syntax and semantics for Java interoperability.The most important differences relevant for migrations are listed here.Java.type(typename) instead of java.a.b.c.typenameGraalJS does not put available Java classes in the JavaScript scope.You have to explicitly load the classes using Java.type(typename).GraalJS supports the Packages global object, but loading the classes explicitly is still encouraged.The following Java package globals are available in the Nashorn compatibility mode (js.nashorn-compat option): java, javafx, javax, com, org, edu.Console Output of Java Classes and Java ObjectsGraalJS provides the print builtin function.It tries to special-case its behavior on Java classes and Java objects to provide the most useful output.Note that GraalJS also provides a console.log function.This is an alias for print in pure JavaScript mode, but uses an implementation provided by Node.js when in Node mode.The behavior around interop objects differs for console.log in Node mode as it does not implement special treatment for such objects.JavaScript vs Java StringsGraalJS uses Java strings internally to represent JavaScript strings.This makes it impossible to differentiate whether a specific string was created by JavaScript or by Java code.In GraalJS, the JavaScript properties take precedence over Java fields or methods.For instance, you can query the length property (of JavaScript) but you cannot call the length function (of Java) on JavaScript strings - length behaves like a data property, not like a function.JavaImporterThe JavaImporter feature is available only in the Nashorn compatibility mode (js.nashorn-compat).Related Documentation  Migration Guide from Nashorn to GraalJS  Java Interoperability",
          "url": " /latest/reference-manual/js/RhinoMigrationGuide/"
          },
          
          "latest-reference-manual-js-runonjdk":  {
          "title": "Run GraalJS on a Stock JDK",
          "content": "Run GraalJS on a Stock JDKGraalJS is optimized for execution as part of GraalVM, primarily recommended for use in a Java application.This guarantees the best possible performance by using the Graal compiler as the optimizing compiler, and potentially Native Image to compile the engine ahead of time into a native binary.It is, however, possible to execute GraalJS on a standard Java VM such as Oracle JDK or OpenJDK.When executed without the Graal Compiler, JavaScript performance will be significantly worse.While the JIT compiler available on a standard JVM can execute and JIT-compile the GraalJS codebase, it cannot optimize GraalJS to its full performance potential.This document describes how to run GraalJS on a standard Java VM, and shows how you can use the Graal compiler as a JIT compiler to guarantee the best possible performance.GraalJS on Maven CentralGraalJS is open source and regularly pushed to Maven Central Repository by the community.You can find it under org.graalvm.polyglot:js.We provide example projects running GraalJS embedded in Java on JDK 21 (or later) and using the Graal compiler:  Polyglot Embedding Demo.Maven and Gradle projects for a simple JavaScript “Hello World” application.  JS Maven Demo.This example contains a Maven project for a JavaScript benchmark (a prime number generator).It enables a user to compare the performance of GraalJS running with or without the Graal compiler as the optimizing compiler.Running with the Graal compiler significantly improves the execution performance of any relatively large JavaScript codebase.In essence, the example pom.xml file activates the JVM Compiler Interface (JVMCI) and configures the JIT compiler to be the Graal compiler by providing it on --module-path and --upgrade-module-path.ScriptEngine JSR 223GraalJS can be started via ScriptEngine when js-scriptengine.jar is included on the module path.The engine registers under several different names, including Graal.js, js, JavaScript, and javascript.Note that the Nashorn engine might be available under its names as well, if on the module path.To start GraalJS from ScriptEngine, the following code can be used:new ScriptEngineManager().getEngineByName(&quot;Graal.js&quot;);To list all available engines:List&amp;lt;ScriptEngineFactory&amp;gt; engines = new ScriptEngineManager().getEngineFactories();for (ScriptEngineFactory f : engines) {    System.out.println(f.getLanguageName() + &quot; &quot; + f.getEngineName() + &quot; &quot; + f.getNames());}Inspecting the Setup - Is the GraalVM Compiler Used as a JIT Compiler?The --engine.TraceCompilation option enables a debug output whenever a JavaScript method is compiled by the Graal compiler.JavaScript source code with a long-enough run time will trigger the compilation and print a log output:&amp;gt; function add(a,b) { return a+b; }; for (var i=0;i&amp;lt;1000*1000;i++) { add(i,i); }[truffle] opt done         add &amp;lt;opt&amp;gt; &amp;lt;split-c0875dd&amp;gt;                                   |ASTSize       7/    7 |Time    99(  90+9   )ms |DirectCallNodes I    0/D    0 |GraalNodes    22/   71 |CodeSize          274 |CodeAddress 0x7f76e4c1fe10 |Source    &amp;lt;shell&amp;gt;:1:1Related Documentation  Getting Started with GraalJS on the JVM",
          "url": " /latest/reference-manual/js/RunOnJDK/"
          },
          
          "latest-security-guide-native-image-sbom":  {
          "title": "Software Bill of Materials (SBOM) in Native Image",
          "content": "Software Bill of Materials (SBOM) in Native ImageGraalVM Native Image assembles a Software Bill of Materials (SBOM) at build time to detect any libraries that may be susceptible to known security vulnerabilities (only available in Oracle GraalVM).Pass the --enable-sbom option to the native-image command to configure the SBOM feature.The SBOM feature is enabled by default and defaults to the embed option which embeds an SBOM into the native executable.In addition to being embedded, the SBOM can be added to the classpath or exported as a JSON file by using --enable-sbom=classpath,export.The CycloneDX format is supported and is the default.The implementation constructs the SBOM by recovering all version information observable in external library manifests for classes included in a native executable.The SBOM is compressed to limit the SBOM’s impact on the native executable size.The compressed size is typically less than 1/10,000 of the overall image size.The SBOM is stored in the gzip format with the exported sbom symbol referencing its start address and the sbom_length symbol referencing its size.The SBOM feature can be disabled with --enable-sbom=false.Extracting SBOM ContentsAfter embedding the compressed SBOM into the image, there are two possible ways to extract the SBOM contents:  using the Native Image Utils Tool  using SyftNative Image Utils ToolThe Native Image Utils Tool can extract the compressed SBOM using the extract-sbom command from executables and shared libraries.$JAVA_HOME/bin/native-image-utils extract-sbom --image-path=&amp;lt;path_to_binary&amp;gt;It outputs the contents in the JSON format:{  &quot;bomFormat&quot;: &quot;CycloneDX&quot;,  &quot;specVersion&quot;: &quot;1.6&quot;,  &quot;version&quot;: 1,  &quot;serialNumber&quot;: &quot;urn:uuid:51ec305f-616e-4139-a033-a094bb94a17c&quot;,  &quot;metadata&quot;: {    &quot;timestamp&quot;: &quot;2025-10-06T15:46:50.593277+02:00&quot;,    &quot;tools&quot;: {      &quot;components&quot;: [        {          &quot;type&quot;: &quot;library&quot;,          &quot;bom-ref&quot;: &quot;Oracle:org.graalvm.sdk:nativeimage:25.0.2&quot;,          &quot;supplier&quot;: {            &quot;name&quot;: &quot;Oracle&quot;          },          &quot;group&quot;: &quot;org.graalvm.sdk&quot;,          &quot;name&quot;: &quot;nativeimage&quot;,          &quot;version&quot;: &quot;25.0.2&quot;,          &quot;purl&quot;: &quot;pkg:maven/org.graalvm.sdk/nativeimage@25.0.2&quot;        }      ]    },    &quot;component&quot;: {      &quot;type&quot;: &quot;library&quot;,      &quot;bom-ref&quot;: &quot;com.sbom:your-app:1.0.0&quot;,      &quot;group&quot;: &quot;com.sbom&quot;,      &quot;name&quot;: &quot;your-app&quot;,      &quot;version&quot;: &quot;1.0.0&quot;,      &quot;purl&quot;: &quot;pkg:maven/com.sbom/your-app@1.0.0&quot;    }  },  &quot;components&quot;: [    {      &quot;type&quot;: &quot;library&quot;,      &quot;bom-ref&quot;: &quot;org.json:json:20211205&quot;,      &quot;group&quot;: &quot;org.json&quot;,      &quot;name&quot;: &quot;json&quot;,      &quot;version&quot;: &quot;20211205&quot;,      &quot;purl&quot;: &quot;pkg:maven/org.json/json@20211205&quot;    },    ...  ],  &quot;dependencies&quot;: [    {      &quot;ref&quot;: &quot;com.sbom:your-app:1.0.0&quot;,      &quot;dependsOn&quot;: [&quot;org.json:json:20211205&quot;]    },    {      &quot;ref&quot;: &quot;org.json:json:20211205&quot;,      &quot;dependsOn&quot;: []    },    ...  ]}A few notes about the SBOM structure:  The metadata/tools entry indicates that the SBOM was produced by Native Image.  The metadata/component is the component of your application. This is included if the image is not built as a shared library and if the class containing the entry point of the image can be associated with exactly one component.  The components entry lists the inventory of first-party and third-party components of your application.See the CycloneDX specification for more information about specific fields.SyftSyft is an open-source tool developed by Anchore that generates an SBOM for container images and filesystems.Additionally, it can extract an embedded SBOM and present it in both its native Syft format and the CycloneDX format.Thanks to the contribution from the GraalVM team, syft can extract an embedded SBOM from within a native image, built for Linux, macOS, or Windows.Run syft scan on the native executable to extract the entire SBOM contents:syft scan &amp;lt;path_to_binary&amp;gt; -o cyclonedx-jsonTo list only the Java libraries included in it, run:syft &amp;lt;path_to_binary&amp;gt;It outputs the list similar to this:NAME               VERSION       TYPEOracle GraalVM     25+12-LTS     graalvm-native-imagecollections        25+12-LTS     java-archivecommons-validator  1.9.0         java-archivejson               20211205      java-archive...Enabling Security ScanningYou can leverage the generated SBOM to integrate with security scanning solutions.There are a variety of tools to help detect and mitigate security vulnerabilities in your application dependencies.One example is Application Dependency Management (ADM) from Oracle.When submitting your SBOM to the ADM vulnerability scanner, it identifies application dependencies and flags those containing known security vulnerabilities.ADM relies on vulnerability reports from community sources, including the National Vulnerability Database (NVD).It also integrates with GitHub Actions, GitLab, and Jenkins Pipelines.Another popular command-line scanner is grype, part of the Anchore software supply chain management platform.With grype, you can check whether the libraries listed in your SBOMs have known vulnerabilities documented in Anchore’s database.The output of the native-image-utils tool can be fed directly into grype to scan for vulnerable libraries using the following command:native-image-utils extract-sbom --image-path=&amp;lt;path_to_binary&amp;gt; | grypeIt produces the following output:NAME  INSTALLED  FIXED IN  TYPE          VULNERABILITY        SEVERITY  EPSS         RISK  json  20211205   20230227  java-archive  GHSA-3vqj-43w4-2q58  High      0.7% (71st)  0.5   json  20211205   20231013  java-archive  GHSA-4jq9-2xhw-jpx7  High      0.5% (66th)  0.4The generated report can then be used to update any vulnerable dependencies in your executable.Automated ScanningIntegrating security scanning into your CI/CD workflows has never been easier.With SBOM support available in the GraalVM GitHub Action, your generated SBOM can be automatically submitted and analyzed using GitHub’s dependency submission API.It enables:  Vulnerability tracking with GitHub’s Dependabot.  Dependency tracking with GitHub’s Dependency Graph.This integration helps ensure that your application is continuously monitored for vulnerabilities throughout the development lifecycle.Verifying Component Integrity with HashesUse --enable-sbom=hashes to associate each component with SHA-256 and SHA-512 hashes.The hash can be verified against trusted sources such as Maven Central.Verifying the component hashes can detect malicious tampering or substitutions in your native image builds.If a compromised dependency poses as a legitimate library, a hash mismatch against the trusted source would reveal tampering.  Verifying component hashes strengthens integrity verification, but does not provide complete end‑to‑end supply chain security. Use cryptographic signing and SLSA provenances to guarantee authenticity and integrity.Below is an example of a component that includes the hashes field:{  &quot;type&quot;: &quot;library&quot;,  &quot;bom-ref&quot;: &quot;io.micronaut:inject:4.2.3&quot;,  &quot;group&quot;: &quot;io.micronaut&quot;,  &quot;name&quot;: &quot;inject&quot;,  &quot;version&quot;: &quot;4.2.3&quot;,  &quot;hashes&quot;: [    {      &quot;alg&quot;: &quot;SHA-256&quot;,      &quot;content&quot;: &quot;6f39a054d1c589248551c4519e892bf48f65cb9b2e16e8a9079393ecfd27e441&quot;    },    {      &quot;alg&quot;: &quot;SHA-512&quot;,      &quot;content&quot;: &quot;05f1a81ea70e9fd0607b97bc62d8d210fd66fcc4e5aa6471ab5f278d2bfb41ab52ac013864d5d5529f0f365e677c15912c88ca51452f9419e8dbaee64efb0b03&quot;    }  ],  &quot;purl&quot;: &quot;pkg:maven/io.micronaut/inject@4.2.3&quot;}Hashes are computed for applications JARs and GraalVM components, but not for classpath directories.The GraalVM components are associated with the hash of the runtime image file. These GraalVM components include for example org.graalvm.nativeimage/svm, org.graalvm.sdk/nativeimage, and Oracle GraalVM.            Kind      Hashed      How to verify                  Application JARs      Yes      Download the JAR from a trusted source, hash it, and compare with the component hash.              GraalVM components      Yes      Hash $GRAALVM_HOME/lib/modules from the same GraalVM distribution used to build the image and compare with the component hash.              Classpath directories      No      -      If you use a fat (or shaded) JAR, the hash is computed from the fat JAR, which will not match individual component hashes published on Maven Central.Pair this with --enable-sbom=hashes,strict.The strict flag enforces completeness by ensuring every class in the image is mapped to a component.When using strict, the native-image builder will throw an exception if one or more components cannot be associated with a hash.The Security Report in the build output indicates whether any components could not be associated with a hash. Run the following command to find these components:jq &#39;.components[] | select(.hashes == null)&#39; /path/to/app.sbom.jsonDependency TreeThe SBOM provides information about component relationships through its dependencies field.This dependency information is derived from Native Image’s static analysis call graph.Analyzing the dependency graph can help you understand why specific components are included in your application.For example, discovering an unexpected component in the SBOM allows for tracing its inclusion through the dependency graph to identify which parts of the application are using it.With the GraalVM GitHub Action, you get access to GitHub’s Dependency Graph feature.More Accurate SBOMs with MavenTo generate more accurate SBOMs, consider using the Maven plugin for GraalVM Native Image.This plugin integrates with Native Image to improve the SBOM creation.The plugin creates a “baseline” SBOM by using the cyclonedx-maven-plugin.The baseline SBOM defines which package names belong to a component, helping Native Image associate classes with their respective components—a task that can be challenging for the native-image tool when shading or fat JARs are used.In this collaborative approach, Native Image is also able to prune components and dependencies more aggressively to produce a minimal SBOM.These enhancements are available starting with plugin version 0.10.4 and are enabled by default when the --enable-sbom option is used.Including Class-Level Metadata in the SBOMUsing --enable-sbom=class-level adds class-level metadata to the SBOM components.This metadata includes Java modules, classes, interfaces, records, annotations, enums, constructors, fields, and methods that are part of the native executable.This information can be useful for:  Advanced vulnerability scanning: When the affected classes or methods of a vulnerability are published as part of a CVE, the class-level metadata can be checked to determine if a native executable with the affected SBOM component is actually vulnerable, thereby reducing the false positive rate of vulnerability scanning.  Understanding image contents: Quickly browse and search the class-level metadata to examine what is included in the native executable.  Including class-level metadata increases the SBOM size substantially. For this Micronaut Hello World Rest application, the SBOM size is 1.1 MB when embedded, and 13.7 MB when exported. The SBOM without class-level metadata is 3.5 kB when embedded, and 64 kB when exported. The size of the native image without an embedded SBOM is around 52 MB.Note that including class-level metadata is not supported by Syft, as the nested components field containing this metadata is removed from the extracted SBOM.This limitation affects only metadata visibility in extracted SBOMs; it does not impact vulnerability scanning functionality.Data FormatThe CycloneDX specification allows the use of a hierarchical representation by nesting components that have a parent-child relationship.It is used to embed class-level information in SBOM components in the following way:[component] SBOM Component└── [component] Java Modules    └── [component] Java Source Files        ├── [property] Classes        ├── [property] Interfaces        ├── [property] Records        ├── [property] Annotations        ├── [property] Enums        ├── [property] Fields        ├── [property] Constructors        └── [property] MethodsEach SBOM component lists its Java modules in the components field.Each module is identified by its name and lists its Java source files in the components field.Each source file is identified by its path relative to the component’s source directory and lists its classes, interfaces, records, annotations, enums, fields, constructors, and methods in the properties field.Consider an example of a simple component containing one Java source file in mymodule:// src/com/sbom/SBOMTestApplication.javapackage com.sbom;import org.apache.commons.validator.routines.RegexValidator;public class SBOMTestApplication {    private static final boolean IS_EMPTY_OR_BLANK = new RegexValidator(&quot;^[s]*$&quot;).isValid(&quot; &quot;);    public static void main(String[] argv) {        System.out.println(String.valueOf(IS_EMPTY_OR_BLANK));        ClassInSameFile someClass = new ClassInSameFile(&quot;hello &quot;, &quot;world&quot;);        someClass.doSomething();    }}class ClassInSameFile {    private final String value1;    private final String value2;    ClassInSameFile(String value1, String value2) {        this.value1 = value1;        this.value2 = value2;    }    String concatenate() {        System.out.println(value1 + value2);    }    // This method is unreachable and will therefore not be included in the SBOM    String unreachable() {        return value;    }}The class-level SBOM component would look like this:{    &quot;type&quot;: &quot;library&quot;,    &quot;bom-ref&quot;: &quot;com.sbom:your-app:1.0.0&quot;,    &quot;group&quot;: &quot;com.sbom&quot;,    &quot;name&quot;: &quot;your-app&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;hashes&quot;: [...],    &quot;purl&quot;: &quot;pkg:maven/com.sbom/your-app@1.0.0&quot;,    &quot;components&quot;: [        {            &quot;type&quot;: &quot;library&quot;,            &quot;name&quot;: &quot;mymodule&quot;,            &quot;components&quot;: [                {                    &quot;type&quot;: &quot;file&quot;,                    &quot;name&quot;: &quot;com/sbom/SBOMTestApplication.java&quot;,                    &quot;properties&quot;: [                        {                            &quot;name&quot;: &quot;class&quot;,                            &quot;value&quot;: &quot;com.sbom.ClassInSameFile&quot;                        },                        {                            &quot;name&quot;: &quot;class&quot;,                            &quot;value&quot;: &quot;com.sbom.SBOMTestApplication&quot;                        },                        {                            &quot;name&quot;: &quot;field&quot;,                            &quot;value&quot;: &quot;com.sbom.ClassInSameFile.value1:java.lang.String&quot;                        },                        {                            &quot;name&quot;: &quot;field&quot;,                            &quot;value&quot;: &quot;com.sbom.ClassInSameFile.value2:java.lang.String&quot;                        },                        {                            &quot;name&quot;: &quot;field&quot;,                            &quot;value&quot;: &quot;com.sbom.SBOMTestApplication.IS_EMPTY_OR_BLANK:boolean&quot;                        },                        {                            &quot;name&quot;: &quot;constructor&quot;,                            &quot;value&quot;: &quot;com.sbom.ClassInSameFile(java.lang.String, java.lang.String)&quot;                        },                        {                            &quot;name&quot;: &quot;method&quot;,                            &quot;value&quot;: &quot;com.sbom.ClassInSameFile.concatenate():java.lang.String&quot;                        },                        {                            &quot;name&quot;: &quot;method&quot;,                            &quot;value&quot;: &quot;com.sbom.SBOMTestApplication.&amp;lt;clinit&amp;gt;():void&quot;                        },                        {                            &quot;name&quot;: &quot;method&quot;,                            &quot;value&quot;: &quot;com.sbom.SBOMTestApplication.main(java.lang.String[]):void&quot;                        }                    ]                }            ]        }    ],    &quot;properties&quot;: [...]}The following table specifies the format of class-level metadata:            Kind      CycloneDX Object      type      name      value      Notes                  Module      Component      library      module name      -      Unnamed module’s name is unnamed module              Source File      Component      file      path relative to the src directory      -      Ends in .java, / separator, path derived from package name              Class      Property      -      class      fully qualified name      Includes anonymous, inner, and sealed classes              Interface      Property      -      interface      fully qualified name      -              Record      Property      -      record      fully qualified name      -              Annotation      Property      -      annotation      fully qualified name      -              Field      Property      -      field      className.fieldName:fieldType      Field declaration              Constructor      Property      -      constructor      className(paramType1, paramType2)      Parameter types comma-space separated              Method      Property      -      method      className.methodName(paramType1, paramType2):returnType      Method with parameters and return type      Some additional notes:  Array types are suffixed with []. For example, an array of strings becomes java.lang.String[].  Synthetically generated lambda classes are not included.When using shaded or fat JARs, the class-level metadata can sometimes not be accurately associated with a component.When this happens, all unresolved metadata gets collected in a placeholder component:{    &quot;type&quot;: &quot;data&quot;,    &quot;name&quot;: &quot;class-level metadata that could not be associated with a component&quot;,    &quot;components&quot;: [      ...    ]}Related Documentation  Using GraalVM Native Image SBOM Support for Vulnerability Scanning  Embed an SBOM in a Native Executable to Identify Its Dependencies  Security Guide",
          "url": " /latest/security-guide/native-image/sbom/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-safepoint":  {
          "title": "Truffle Language Safepoint Tutorial",
          "content": "Truffle Language Safepoint TutorialAs of 21.1 Truffle has support for guest language safepoints.Truffle safepoints allow to interrupt the guest language execution to perform thread local actions submitted by a language or tool.A safepoint is a location during the guest language execution where the state is consistent and other operations can read its state.This replaces previous instrumentation or assumption-based approaches to safepoints, which required the code to be invalidated for a thread local action to be performed.The new implementation uses fast thread local checks and callee register saved stub calls to optimize for performance and keep the overhead minimal.This means that for every loop back-edge and method exit we perform an additional non-volatile read which can potentially lead to slight slow-downs.Use CasesCommon use-cases of Truffle language safepoints are:  Cancellation, requested exit or interruptions during guest language execution. The stack is unwound by submitting a thread local action.  Reading the current stack trace information for other threads than the currently executing thread.  Enumerating all object references active on the stack.  Running a guest signal handler or guest finalizer on a given thread.  Implement guest languages that expose a safepoint mechanism as part of their development toolkit.  Debuggers evaluating expressions in languages that do not support execution on multiple threads.Language SupportSafepoints are explicitly polled by invoking the TruffleSafepoint.poll(Node) method.A Truffle guest language implementation must ensure that a safepoint is polled repeatedly within a constant time interval.For example, a single arithmetic expression completes within a constant number of CPU cycles.However, a loop that summarizes values over an array uses a non-constant time dependent on the actual array size.This typically means that safepoints are best polled at the end of loops and at the end of function or method calls to cover recursion.In addition, any guest language code that blocks the execution, like guest language locks, need to use the  TruffleSafepoint.setBlocked(Interrupter) API to allow cooperative polling of safepoints while the thread is waiting.Please read more details on what steps language implementations need to take to support thread local actions in the javadoc.Thread Local ActionsLanguages and instruments can submit actions using their environment.Usage example:Env env; // language or instrument environmentenv.submitThreadLocal(null, new ThreadLocalAction(true /*side-effecting*/, true /*synchronous*/) {     @Override     protected void perform(Access access) {         assert access.getThread() == Thread.currentThread();     }    @Override    protected void notifyBlocked(Access access) {        assert access.getThread() == Thread.currentThread();    }    @Override    protected void notifyUnblocked(Access access) {        assert access.getThread() == Thread.currentThread();    }});Read more in the javadoc.Current LimitationsThere is currently no way to run thread local actions while the thread is executing in boundary annotated methods unless the method cooperatively polls safepoints or uses the blocking API.Unfortunately it is not always possible to cooperatively poll safepoints, for example, if the code currently executes third party native code.A future improvement will allow to run code for other threads while they are blocked.This is one of the reasons why it is recommended to use ThreadLocalAction.Access.getThread() instead of directly using Thread.currentThread().When the native call returns it needs to wait for any thread local action that is currently executing for this thread.This will enable to collect guest language stack traces from other threads while they are blocked by uncooperative native code.Currently the action will be performed on the next safepoint location when the native code returns.Tooling for DebuggingThere are several debug options available:Exercise safepoints with SafepointALotSafepointALot is a tool to exercise every safepoint of an application and collect statistics.If enabled with the --engine.SafepointALot option it prints the statistics on the cpu time interval between safepoints at the end of an execution.For example, running:graalvm/bin/js --engine.SafepointALot js-benchmarks/harness.js -- octane-deltablue.jsPrints the following output to the log on context close:DeltaBlue: 3037[engine] Safepoint Statistics   -------------------------------------------------------------------------------------------------------------------------------------------------------    Thread Name         Safepoints | Interval     Avg              Min              Max      | Blocked Intervals   Avg              Min              Max  -------------------------------------------------------------------------------------------------------------------------------------------------------    main                  83187332 |            0,452 us           0,2 us      104938,8 us   |      18            6,536 us           0,9 us          36,8 us  -------------------------------------------------------------------------------------------------------------------------------------------------------    All threads           83187332 |            0,452 us           0,2 us      104938,8 us   |      18            6,536 us           0,9 us          36,8 usIt is recommended for guest language implementations to try to stay below 1ms on average.Note that precise timing can depend on CPU and interruptions by the GC.Since GC times are included in the safepoint interval times, it is expected that the maximum is close to the maximum GC interruption time.Future versions of this tool will be able to exclude GC interruption times from this statistic.The SafepointALot tool also does not interrupt blocking operations that typically wait for some resource to be available (e.g. IO, thread start).These blocked intervals are shown separately in the statistics. Ordinary thread local actions do interrupt blocking operations, and so the blocked intervals do not apply to them.Find missing safepoint pollsThe option TraceMissingSafepointPollInterval helps to find missing safepoint polls, use it like:$ bin/js --experimental-options --engine.TraceMissingSafepointPollInterval=20 -e &#39;print(6*7)&#39;...42[engine] No TruffleSafepoint.poll() for 36ms on main (stacktrace 1ms after the last poll)at java.base/java.lang.StringLatin1.replace(StringLatin1.java:312)at java.base/java.lang.String.replace(String.java:2933)at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:801)at java.base/jdk.internal.loader.BuiltinClassLoader.findClassInModuleOrNull(BuiltinClassLoader.java:741)at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:665)at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639)at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:526)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotValueDispatch.createInteropValue(PolyglotValueDispatch.java:1694)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotLanguageInstance$1.apply(PolyglotLanguageInstance.java:149)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotLanguageInstance$1.apply(PolyglotLanguageInstance.java:147)at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotLanguageInstance.lookupValueCacheImpl(PolyglotLanguageInstance.java:147)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotLanguageInstance.lookupValueCache(PolyglotLanguageInstance.java:137)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotLanguageContext.asValue(PolyglotLanguageContext.java:948)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotContextImpl.eval(PolyglotContextImpl.java:1686)at org.graalvm.truffle/com.oracle.truffle.polyglot.PolyglotContextDispatch.eval(PolyglotContextDispatch.java:60)at org.graalvm.polyglot/org.graalvm.polyglot.Context.eval(Context.java:402)at org.graalvm.js.launcher/com.oracle.truffle.js.shell.JSLauncher.executeScripts(JSLauncher.java:365)at org.graalvm.js.launcher/com.oracle.truffle.js.shell.JSLauncher.launch(JSLauncher.java:93)at org.graalvm.launcher/org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:296)at org.graalvm.launcher/org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:121)at org.graalvm.launcher/org.graalvm.launcher.AbstractLanguageLauncher.runLauncher(AbstractLanguageLauncher.java:168)...It prints host stacktraces when there was not a safepoint poll in the last N milliseconds, N being the argument to TraceMissingSafepointPollInterval.On HotSpot there can be long delays between guest safepoints due to classloading, so it makes sense to run this with a native image or focus on non-classloading stacktraces.Trace thread local actionsThe option --engine.TraceThreadLocalActions allows to trace all thread local actions of any origin.Example output:[engine] [tl] submit                 0  thread[main]                action[SampleAction$8@5672f0d1]     all-threads[alive=4]        side-effecting     asynchronous[engine] [tl]   perform-start        0  thread[pool-1-thread-410]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-start        0  thread[pool-1-thread-413]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-start        0  thread[pool-1-thread-412]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-413]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-410]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-start        0  thread[pool-1-thread-411]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-412]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-411]   action[SampleAction$8@5672f0d1][engine] [tl] done                   0  thread[pool-1-thread-411]   action[SampleAction$8@5672f0d1]Printing guest and host stack frames every time interval.The option --engine.TraceStackTraceInterval=1000 allows to set the time interval in milliseconds to repeatedly print the current stack trace.Note that the stack trace is printed on the next safepoint poll and therefore might not be accurate.graalvm/bin/js --engine.TraceStackTraceInterval=1000 js-benchmarks/harness.js -- octane-deltablue.jsPrints the following output:[engine] Stack Trace Thread main: org.graalvm.polyglot.PolyglotExceptionat &amp;lt;js&amp;gt; BinaryConstraint.chooseMethod(octane-deltablue.js:359-381:9802-10557)at &amp;lt;js&amp;gt; Constraint.satisfy(octane-deltablue.js:176:5253-5275)at &amp;lt;js&amp;gt; Planner.incrementalAdd(octane-deltablue.js:597:16779-16802)at &amp;lt;js&amp;gt; Constraint.addConstraint(octane-deltablue.js:165:4883-4910)at &amp;lt;js&amp;gt; UnaryConstraint(octane-deltablue.js:219:6430-6449)at &amp;lt;js&amp;gt; StayConstraint(octane-deltablue.js:297:8382-8431)at &amp;lt;js&amp;gt; chainTest(octane-deltablue.js:817:23780-23828)at &amp;lt;js&amp;gt; deltaBlue(octane-deltablue.js:883:25703-25716)at &amp;lt;js&amp;gt; MeasureDefault(harness.js:552:20369-20383)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSingleBenchmark(harness.js:614:22538-22550)at &amp;lt;js&amp;gt; RunNextBenchmark(harness.js:340:11560-11614)at &amp;lt;js&amp;gt; RunStep(harness.js:141:5673-5686)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSuites(harness.js:160:6247-6255)at &amp;lt;js&amp;gt; runBenchmarks(harness.js:686-688:24861-25023)at &amp;lt;js&amp;gt; main(harness.js:734:26039-26085)at &amp;lt;js&amp;gt; :program(harness.js:783:27470-27484)at org.graalvm.polyglot.Context.eval(Context.java:348)at com.oracle.truffle.js.shell.JSLauncher.executeScripts(JSLauncher.java:347)at com.oracle.truffle.js.shell.JSLauncher.launch(JSLauncher.java:88)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:124)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:71)at com.oracle.truffle.js.shell.JSLauncher.main(JSLauncher.java:73)[engine] Stack Trace Thread main: org.graalvm.polyglot.PolyglotExceptionat &amp;lt;js&amp;gt; EqualityConstraint.execute(octane-deltablue.js:528-530:14772-14830)at &amp;lt;js&amp;gt; Plan.execute(octane-deltablue.js:781:22638-22648)at &amp;lt;js&amp;gt; chainTest(octane-deltablue.js:824:24064-24077)at &amp;lt;js&amp;gt; deltaBlue(octane-deltablue.js:883:25703-25716)at &amp;lt;js&amp;gt; MeasureDefault(harness.js:552:20369-20383)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSingleBenchmark(harness.js:614:22538-22550)at &amp;lt;js&amp;gt; RunNextBenchmark(harness.js:340:11560-11614)at &amp;lt;js&amp;gt; RunStep(harness.js:141:5673-5686)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSuites(harness.js:160:6247-6255)at &amp;lt;js&amp;gt; runBenchmarks(harness.js:686-688:24861-25023)at &amp;lt;js&amp;gt; main(harness.js:734:26039-26085)at &amp;lt;js&amp;gt; :program(harness.js:783:27470-27484)at org.graalvm.polyglot.Context.eval(Context.java:348)at com.oracle.truffle.js.shell.JSLauncher.executeScripts(JSLauncher.java:347)at com.oracle.truffle.js.shell.JSLauncher.launch(JSLauncher.java:88)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:124)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:71)at com.oracle.truffle.js.shell.JSLauncher.main(JSLauncher.java:73)Further ReadingDaloze, Benoit, Chris Seaton, Daniele Bonetta, and Hanspeter Mössenböck.“Techniques and applications for guest-language safepoints.”In Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems, pp. 1-10. 2015.https://dl.acm.org/doi/abs/10.1145/2843915.2843921",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/Safepoint/"
          },
          
          "latest-reference-manual-js-scriptengine":  {
          "title": "ScriptEngine Implementation",
          "content": "ScriptEngine ImplementationGraalJS provides a JSR-223 compliant javax.script.ScriptEngine implementation for running JavaScript.Note that this feature is provided for legacy reasons to allow easier migration for implementations currently based on a ScriptEngine.We strongly encourage users to use the org.graalvm.polyglot.Context interface to control many of the settings directly and benefit from finer-grained security settings in GraalVM.  Note: As of GraalVM for JDK 21, GraalVM no longer includes ScriptEngine by default. If you relied on that, you will have to migrate your setup to explicitly depend on the script engine module and add it to the module path.To enable the js-scriptengine module, add it as the Maven dependency, as follows:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.js&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;js-scriptengine&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graaljs.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;js&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graaljs.version}&amp;lt;/version&amp;gt;    &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;If you are not using Maven, you will need to add the js-scriptengine.jar file to the module path manually, for example, --module-path=languages/js/graaljs-scriptengine.jar.In some cases you may also need to add --add-modules org.graalvm.js.scriptengine to the command line, to ensure that the ScriptEngine will be found.An explicit dependency on the org.graalvm.js.scriptengine module is only required if you want to use GraalJSScriptEngine directly (see below).Finally, it is also possible to use jlink to generate a custom Java runtime image that contains the GraalJS’s ScriptEngine.An example pom.xml file can be found in the GraalJS repository on GitHub.Recommendation for UseTo avoid unnecessary recompilation of JavaScript sources, it is recommended to use CompiledScript.eval instead of ScriptEngine.eval.This prevents JIT-compiled code from being garbage-collected as long as the corresponding CompiledScript object is alive.Single-threaded example:ScriptEngineManager manager = new ScriptEngineManager();ScriptEngine engine = manager.getEngineByName(&quot;js&quot;);CompiledScript script = ((Compilable) engine).compile(&quot;console.log(&#39;hello world&#39;);&quot;);script.eval();Multi-threaded example:ScriptEngineManager manager = new ScriptEngineManager();ScriptEngine engine = manager.getEngineByName(&quot;js&quot;);CompiledScript script = ((Compilable) engine).compile(&quot;console.log(&#39;start&#39;);var start = Date.now(); while (Date.now()-start &amp;lt; 2000);console.log(&#39;end&#39;);&quot;);new Thread(new Runnable() {    @Override    public void run() {        try {            // Create ScriptEngine for this thread (with a shared polyglot Engine)            ScriptEngine engine = manager.getEngineByName(&quot;js&quot;);            script.eval(engine.getContext());        } catch (ScriptException scriptException) {            scriptException.printStackTrace();        }    }}).start();script.eval();Setting Options via BindingsThe ScriptEngine interface does not provide a default way to set options.As a workaround, GraalJSScriptEngine supports setting some Context options through Bindings.These options are:  polyglot.js.allowHostAccess &amp;lt;boolean&amp;gt;  polyglot.js.allowNativeAccess &amp;lt;boolean&amp;gt;  polyglot.js.allowCreateThread &amp;lt;boolean&amp;gt;  polyglot.js.allowIO &amp;lt;boolean&amp;gt;  polyglot.js.allowHostClassLookup &amp;lt;boolean or Predicate&amp;lt;String&amp;gt;&amp;gt;  polyglot.js.allowHostClassLoading &amp;lt;boolean&amp;gt;  polyglot.js.allowAllAccess &amp;lt;boolean&amp;gt;  polyglot.js.nashorn-compat &amp;lt;boolean&amp;gt;  polyglot.js.ecmascript-version &amp;lt;String&amp;gt;These options control the sandboxing rules applied to evaluated JavaScript code and are set to false by default, unless the application was started in the Nashorn compatibility mode (--js.nashorn-compat=true).Note that using ScriptEngine implies allowing experimental options.This is an exhaustive list of allowed options to be passed via Bindings; in case you need to pass additional options to GraalJS, you need to manually create a Context as shown below.To set an option via Bindings, use Bindings.put(&amp;lt;option name&amp;gt;, true) before the engine’s script context is initialized.Note that even a call to Bindings#get(String) may lead to a context initialization.The following code shows how to enable polyglot.js.allowHostAccess via Bindings:ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;JavaScript&quot;);Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);bindings.put(&quot;polyglot.js.allowHostAccess&quot;, true);bindings.put(&quot;polyglot.js.allowHostClassLookup&quot;, (Predicate&amp;lt;String&amp;gt;) s -&amp;gt; true);bindings.put(&quot;javaObj&quot;, new Object());engine.eval(&quot;(javaObj instanceof Java.type(&#39;java.lang.Object&#39;));&quot;); // it will not work without allowHostAccess and allowHostClassLookupThis example will not work if the user calls, for example, engine.eval(&quot;var x = 1;&quot;), before calling bindings.put(&quot;polyglot.js.allowHostAccess&quot;, true);, since any call to eval forces a context initialization.Setting Options via System PropertiesOptions to the JavaScript engine can be set via system properties before starting the JVM by prepending polyglot.:java -Dpolyglot.js.ecmascript-version=2022 MyApplicationOr, options to the JavaScript engine can be set programmatically from within a Java application before creating ScriptEngine.This, however, only works for the options passed to the JavaScript engine (such as js.ecmascript-version), and not for the options mentioned in the example that can be set via Bindings.Another caveat is that those system properties are shared by all concurrently executed ScriptEngines.Manually Creating Context for More FlexibilityContext options can also be passed to GraalJSScriptEngine directly, via an instance of Context.Builder:ScriptEngine engine = GraalJSScriptEngine.create(null,        Context.newBuilder(&quot;js&quot;)        .allowHostAccess(HostAccess.ALL)        .allowHostClassLookup(s -&amp;gt; true)        .option(&quot;js.ecmascript-version&quot;, &quot;2022&quot;));engine.put(&quot;javaObj&quot;, new Object());engine.eval(&quot;(javaObj instanceof Java.type(&#39;java.lang.Object&#39;));&quot;);This enables setting all options available in GraalJS.It does come at the cost of a hard dependency on GraalJS, for example, the GraalJSScriptEngine and Context classes.Supported File ExtensionsThe GraalJS implementation of javax.script.ScriptEngine supports the js file extension for JavaScript source files, as well as the mjs extension for ES modules.Related Documentation  GraalJS Command-line Options",
          "url": " /latest/reference-manual/js/ScriptEngine/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-specializationhistogram":  {
          "title": "Specialization Histogram",
          "content": "Specialization HistogramThis guide explains how to use the --engine.SpecializationStatistics option.The specialization histogram requires Truffle DSL nodes to be generated in a special way.So if you use the plain specialization histogram option it will just print the following:js --engine.SpecializationStatistics test.js[engine] Specialization histogram:No specialization statistics data was collected. Either no node with @Specialization annotations was executed or the interpreter was not compiled with -Atruffle.dsl.GenerateSpecializationStatistics=true e.g as parameter to the javac tool.Follow the advice of the error and recompile our interpreter.For mx users this is as simple as:mx build -c -A-Atruffle.dsl.GenerateSpecializationStatistics=trueAfter the rebuild, the specialization statistics are ready to be used.Make sure that your IDE does not recompile the sources automatically in the meantime.In this tutorial, a simple test.js script will be used:function test() {  var array = [42, &quot;&quot;, {}, []]  var globalVar = true;  for (element of array) {    globalVar = element;  }}test();Now the specialization statistics need to be enabled, in this example using the JavaScript launcher of GraalVM:js --experimental-options --engine.SpecializationStatistics test.jsAfter the script is executed a histogram for each class will be printed.The histograms will be ordered by the sum of executions of each node, whereas the most frequently used node class will be printed last.These are some of the histograms printed when executing test.js:(Note: The output is likely already outdated.) -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSWriteCurrentFrameSlotNodeGen                                               8 (17%)            18 (12%)        Min=         1 Avg=        2.25 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean &amp;lt;boolean&amp;gt;                                                          1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   doInt &amp;lt;int&amp;gt;                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|   doSafeIntegerInt                                                             0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doLong                                                                       0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject                                                                     7 (88%)            16 (89%)        Min=         1 Avg=        2.29 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;DynamicObjectBasic&amp;gt;                                                         6 (86%)            12 (75%)        Min=         1 Avg=        2.00 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;IteratorRecord&amp;gt;                                                             1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~1-8:16-130|     &amp;lt;String&amp;gt;                                                                     2 (29%)             2 (13%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     &amp;lt;Integer&amp;gt;                                                                    1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~6:105-123|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doBoolean]                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   [doInt, doObject]                                                            1 (13%)             4 (22%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5-7:76-128|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5-7:76-128|   [doObject]                                                                   6 (75%)            13 (72%)        Min=         1 Avg=        2.17 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSReadCurrentFrameSlotNodeGen                                                8 (17%)            25 (17%)        Min=         1 Avg=        3.13 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean                                                                    0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doInt &amp;lt;no-args&amp;gt;                                                              1 (13%)             1 (4%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject &amp;lt;no-args&amp;gt;                                                           8 (100%)           24 (96%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doInt, doObject]                                                            1 (13%)             4 (16%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5:81-87|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5:81-87|   [doObject]                                                                   7 (88%)            21 (84%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------The histogram prints two inner tables for every node class.The first table groups specialization and dynamic type combination.For example, in this histogram the node class JSWriteCurrentFrameSlotNodeGen was instantiated 8 and executed 18 times.This is 20% of the total instances and 11% of all node executions of the run.Three specializations were instantiated in this script, namely doBoolean, doObject, and doInt.The doBoolean specialization was instantiated and executed only once which accounts for 13% of all instances and 6% of all executions of this node class.The doObject specializations was invoked using three different input value combinations: DynamicObjectBasic, IteratorRecord, and String.Similar to specializations, we can see the numbers of times per node they were used and how many times they were executed.For each line you can see minimum, average, and maximum execution numbers per instance.The last column prints the source section of the instance with the maximum executions.The second table groups for each combination of specializations that were used by node class.Here are some questions you would want to ask these specialization statistics:  Is a certain specialization combination used only rarely and can it be removed/consolidated into a single specialization?  Is there a specialization with a very common type combination that could benefit from further specialization?  Which specialization combination is common and could deserve its own specialization? This could indicate common polymorphism in the code that could be investigated.  What are common specializations, and does the order match the number of executions? Specializations that are most commonly used should be ordered first in the node class. This may lead to improvements in interpreter performance.  Are there unexpected specializations instantiated? If yes, investigate further using the printed source section.  Which specializations are instantiated often, and should therefore be optimized for memory footprint?  Were there nodes with the name Uncached in the profile? The use of uncached nodes should be rare. If they were used often, it can be worthwhile to dig deeper to see why.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/SpecializationHistogram/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-specializationtesting":  {
          "title": "Testing Truffle DSL Specializations",
          "content": "Testing Truffle DSL SpecializationsThis document discusses the tools for testing Truffle DSL specializations.Slow Path Specializations in Only Compilation ModeThe following example will be used in this guide:abstract class PowNode extends Node {  public abstract double execute(double a, int exp);  @Specialization(guards = &quot;exp==1&quot;)  double doOne(double a, int exp) {    return a;  }  @Specialization(replaces = &quot;doOne&quot;)  int doGeneric(double a, int exp) {    double res = 1;    for (int i = 0; i &amp;lt; exp; i++)      res *= a;    return res;  }}In order to test that doGeneric produces the correct result for argument exp == 1, you first need to execute this node with a different value.For example, you can use exp == 2 to activate the doGeneric specialization and only then with 1, which will nowbe handled by the doGeneric specialization instead of the doOne specialization.With a real-world code, writing a test that covers specializations that replace other specializations can be much more complicated and it leads to fragile tests.Changes in the production code may cause the test to suddenly cover different specializations.This can easily happen unnoticed.Truffle DSL provides a mode where the “fast-path” specializations (those that are “replaced” by some other specialization, doOne in our example) are ignored.This allows you to simply increase test coverage by running the same tests, which now may cover different code paths.When building a language with mx, pass the additional option:mx build -c -A-Atruffle.dsl.GenerateSlowPathOnly=trueAfter the rebuild, the generated code will call only “slow-path” specializations.Make sure that your IDE does not recompile the sources automatically in the meantime.Note that if you compile your dependencies (e.g., Truffle) from source as part of your build, this option will apply to the code of those dependencies as well.You may choose to apply this option only to some classes by using a filter:mx build -c -A-Atruffle.dsl.GenerateSlowPathOnly=true -A-Atruffle.dsl.GenerateSlowPathOnlyFilter=org.my.truffle.language.package",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/SpecializationTesting/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-splitting-splitting":  {
          "title": "Splitting Algorithm",
          "content": "Splitting AlgorithmThis guide gives an overview of the algorithm used in the implementation of Truffle call target splitting.The new implementation relies on the language implementations providing information on when a particular node turns polymorphic or increases its “degree” of polymorphism by, for example, adding an entry into an inline cache.This event is called a “polymorphic specialize”.This information is provided to the runtime by calling theNode.reportPolymorphicSpecialize method after the specialization is complete.This guide explains what happens after the call to reportPolymorphicSpecialize.You can find more information on how to correctly report polymorphic specializations in the Reporting Polymorphism guide.ApproachDetection of suitable splitting candidates relies on the languages reporting polymorphic specializations.Once the specialization is reported, you can assume that the polymorphism is coming from somewhere in the caller chain of the call target hosting the newly polymorphic node, and that by splitting the right call target (or call targets) you can return this node to a monomorphic state.You then identify the call targets for which the splitting could result in monomorphization and mark them as “needs split”. During further execution, if the interpreter is about to execute a direct call to a call target that is marked as “needs split”, that call target will be split (provided there are no outstanding factors preventing it such as the root node not being allowed to be split,the AST being too big, etc.).This results in a new call target with a clean profile (i.e., all its nodes are returned to an uninitialized state) to bere-profiled specifically for this call site, since it is the only call site calling this new call target.Following recursive algorithm (expressed as pseudo code) is a simplified version of the approach used to decide which call targets need to be marked “needs split”.This algorithm is applied to every call target once one of its nodes reports a polymorphic specialization.The full implementation can be found in com.oracle.truffle.runtime.OptimizedCallTarget#maybeSetNeedsSplit.setNeedsSplit(callTarget)    if callTarget.needsSplit        return false    if sizeof(knownCallers(callTarget)) == 0        return false    if callCount(callTarget) == 1        return false    if sizeof(knownCallers(callTarget)) &amp;gt; 1        callTarget.needsSplit = true    else        callTarget.needsSplit = setNeedsSplit(caller(callTarget))    return callTarget.needsSplitAt the very beginning of the pseudo code you can have early termination conditions.If the call target is already marked as “needs split”, there is no need to continue.Also, if the call target has no known callers (e.g., it is the “main” of the execution) splitting is not applicable since splitting is inherently tied to duplicating ASTs for a particular call site.Finally, if this is happening during the first execution of a call target, splitting is pointless since the polymorphic nature of the node is inevitable (i.e., not coming from the callers, but rather an integral property of that call target).In the second part of the pseudo code two cases are differentiated:1) The call target has multiple known callers - in this case you can assume that the polymorphism is coming from one of these multiple callers. Thus, you mark the call target as “needs split”.2) The call target has only one known caller - in this case you know that marking this call target as “needs split” cannot help remove the polymorphism. But, the polymorphism could be coming into this call target from its sole caller, which could have multiple callers and could be a candidate for splitting. Thus, you recursively apply the algorithm to the caller of our call target.Ignore for now the return value of our algorithm and its usage, and consider the following SimpleLanguage example to illustrate why this distinction between one and multiple callers is needed:function add(arg1, arg2) {    return arg1 + arg2;}function double(arg1) {    return add(arg1, arg1);}function callsDouble() {    double(1);    double(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}In this example, the node representing + in the add function will turn polymorphic once double is called with the string argument &quot;foo&quot; and this will be reported to the runtime and our algorithm will be applied to add.All of the early return checks will fail (add is not marked “needs split”, it has known callers and this is not its first execution).Observe that add has only one caller (double), so you apply the algorithm to double.Early returns all fail, and since double has multiple callers, you mark it as “needs split” and on later iterations calls to double are split resulting in the following code representation of the run time state:function add(arg1, arg2) {    return arg1 + arg2; // + is polymorphic}function double(arg1) {    return add(arg1, arg1);}function doubleSplit1(arg1) {    return add(arg1, arg1);}function doubleSplit2(arg1) {    return add(arg1, arg1);}function callsDouble() {    doubleSplit1(1);    doubleSplit2(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}As you can see, the source of the polymorphism was split, but that did not solve the issue, since both splits still call the same add function and the polymorphism remains.This is where the algorithms return value comes in to play.If the algorithm was successful in finding a target to mark then all the transitive callee’s of that target need to be marked “needs split” as well.With this final step in place, the final run time result of our splitting approach for the previous example can be represented as the following source code:function add(arg1, arg2) {    return arg1 + arg2; // + is polymorphic}function addSplit1(arg1, arg2) {    return arg1 + arg2;}function addSplit2(arg1, arg2) {    return arg1 + arg2;}function double(arg1) {    return add(arg1, arg1);}function doubleSplit1(arg1) {    return addSplit1(arg1, arg1);}function doubleSplit2(arg1) {    return addSplit2(arg1, arg1);}function callsDouble() {    doubleSplit1(1);    doubleSplit2(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}Final note to observe at this point is that the splitting does not remove the original call targets, and that they still have polymorphism in their profiles.Thus, even if new calls to these call targets are created, they will also be split.Consider if the main of the previous example looked as follows.function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }    add(1,2); // this line was added}Once the execution reaches the newly added line you do not want it to call the add function with the polymorphic + since the arguments here do not merit the polymorphism.Luckily, since add was already marked as “needs split”, it will remain so during the entire execution, and this final call to add will cause another split of the add function.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/splitting/Splitting/"
          },
          
          "latest-reference-manual-native-image-debugging-and-diagnostics-staticanalysisreports":  {
          "title": "Points-to Analysis Reports",
          "content": "Points-to Analysis ReportsThe points-to analysis produces two kinds of reports: an analysis call tree and an object tree. This information is produced by an intermediate step in the building process and represents the static analysis view of the call graph and heap object graph. These graphs are further transformed in the building process before they are compiled ahead-of-time into the binary and written into the binary heap, respectively.In addition to the comprehensive report of the whole analysis universe, the points-to analysis can also produce reachability reports on why certain type/method/field is reachable.Call treeThe call tree is a breadth-first tree reduction of the call graph as seen by the points-to analysis.The points-to analysis eliminates calls to methods that it determines cannot be reachable at runtime, based on the analyzed receiver types.It also completely eliminates invocations in unreachable code blocks, such as blocks guarded by a type check that always fails.The call tree report is enabled using the -H:+PrintAnalysisCallTree command-line option and can be formatted either as a TXT file (default) or as a set of CSV files using the -H:PrintAnalysisCallTreeType=CSV option.TXT FormatWhen using the TXT format a file with the following structure is generated:VM Entry Points├── entry &amp;lt;entry-method&amp;gt; id=&amp;lt;entry-method-id&amp;gt;│   ├── directly calls &amp;lt;callee&amp;gt; id=&amp;lt;callee-id&amp;gt; @bci=&amp;lt;invoke-bci&amp;gt;│   │   └── &amp;lt;callee-sub-tree&amp;gt;│   ├── virtually calls &amp;lt;callee&amp;gt; @bci=&amp;lt;invoke-bci&amp;gt;│   │   ├── is overridden by &amp;lt;override-method-i&amp;gt; id=&amp;lt;override-method-i-id&amp;gt;│   │   │   └── &amp;lt;callee-sub-tree&amp;gt;│   │   └── is overridden by &amp;lt;override-method-j&amp;gt; id-ref=&amp;lt;override-method-j-id&amp;gt;│   └── interfacially calls &amp;lt;callee&amp;gt; @bci=&amp;lt;invoke-bci&amp;gt;│       ├── is implemented by &amp;lt;implementation-method-x&amp;gt; id=&amp;lt;implementation-method-x-id&amp;gt;│       │   └── &amp;lt;callee-sub-tree&amp;gt;│       └── is implemented by &amp;lt;implementation-method-y&amp;gt; id-ref=&amp;lt;implementation-method-y-id&amp;gt;├── entry &amp;lt;entry-method&amp;gt; id=&amp;lt;entry-method-id&amp;gt;│   └── &amp;lt;callee-sub-tree&amp;gt;└── ...The tags between &amp;lt;and &amp;gt; are expanded with concrete values, the remainder is printed as illustrated.The methods are formatted using &amp;lt;qualified-holder&amp;gt;.&amp;lt;method-name&amp;gt;(&amp;lt;qualified-parameters&amp;gt;):&amp;lt;qualified-return-type&amp;gt; and are expanded until no more callees can be reached.Since this is a tree reduction of the call graph each concrete method is expanded exactly once.The tree representation inherently omits calls to methods that have already been explored in a different branch or previously on the same branch.This restriction implicitly fixes the recursion problem.To convey the information that is lost through tree reduction each concrete method is given a unique id.Thus when a method is reached for the first time it declares an identifier as id=&amp;lt;method-id&amp;gt;.Subsequent discoveries of the same method use an identifier reference to point to the previously expansion location: id-ref=&amp;lt;method-id&amp;gt;.Each id=&amp;lt;method-id&amp;gt; and id-ref=&amp;lt;method-id&amp;gt; are followed by a blank space to make it easy to search.Each invoke is tagged with the invocation bci: @bci=&amp;lt;invoke-bci&amp;gt;.For invokes of inline methods the &amp;lt;invoke-bci&amp;gt; is a list of bci values, separated with -&amp;gt;, enumerating the inline locations, backwards to the original invocation location.CSV FormatWhen using the CSV format a set of files containing raw data for methods and their relationships is generated.In particular, three files are generated—they represent methods, method invocations, and call targets.The call_tree_methods_*.csv has the following columns:  Id: The unique identifier of this method.  Name: The name of the method.  Type: The declaring type.  Parameters: A space-separated list of parameter types.  Return: The return type.  Display: A shortened version of the qualified name of the method, useful for visualizations.  Flags: Other metadata such as visibility modifiers, synchronization, and so on.  IsEntryPoint: If true, the method is an entry point (root method) in the call graph, false otherwise.The call_tree_invokes_*.csv has the following columns:  Id: The unique identifier of the invocation.  MethodId: The identifier of the method in which the invocation is located.  BytecodeIndexes: The bytecode index of the invocation. It can be a chain of bytecode indexes connected via -&amp;gt; ifthe method was inlined.  TargetId: The id of the target method.  IsDirect: If true, the invocation is direct, false otherwise.The call_tree_targets_*.csv  has two columns: InvokeId and TargetId, connecting invocations with their calltargets.The aim of these files is to enable the raw data to be easily processed by custom scripts or imported into a graphdatabase.A graph database can provide the following functionality:  Sophisticated graphical visualization of the call tree graph that provides a different perspective compared to text-based formats.  Ability to execute complex queries that can (for example) show a subset of the tree that causes certain code path to be included in the call tree analysis.This querying functionality is crucial in making big analysis call trees manageable.The process to import the files into a graph database is specific to each database.Please follow the instructions provided by the graph database provider.Object TreeThe object tree is an exhaustive expansion of the objects included in the native binary heap.The tree is obtained by a depth first walk of the native binary heap object graph.It is enabled using the -H:+PrintImageObjectTree option.The roots are either static fields or method graphs that contain embedded constants.The printed values are concrete constant objects added to the native binary heap.Produces a file with the structure:Heap roots├── root &amp;lt;root-field&amp;gt; value:│   └── &amp;lt;value-type&amp;gt; id=&amp;lt;value-id&amp;gt; toString=&amp;lt;value-as-string&amp;gt; fields:│       ├── &amp;lt;field-1&amp;gt; value=null│       ├── &amp;lt;field-2&amp;gt; toString=&amp;lt;field-2-value-as-string&amp;gt; (expansion suppressed)│       ├── &amp;lt;field-3&amp;gt; value:│       │   └── &amp;lt;field-3-value-type&amp;gt; id=&amp;lt;field-3-value-id&amp;gt; toString=&amp;lt;field-3-value-as-string&amp;gt; fields:│       │       └── &amp;lt;object-tree-rooted-at-field-3&amp;gt;│       ├── &amp;lt;array-field-4&amp;gt; value:│       │   └── &amp;lt;array-field-4-value-type&amp;gt; id=&amp;lt;array-field-4-value-id&amp;gt; toString=&amp;lt;array-field-4-value-as-string&amp;gt; elements (excluding null):│       │       ├── [&amp;lt;index-i&amp;gt;] &amp;lt;element-index-i-value-type&amp;gt; id=&amp;lt;element-index-i-value-id&amp;gt; toString=&amp;lt;element-index-i-value-as-string&amp;gt; fields:│       │       │   └── &amp;lt;object-tree-rooted-at-index-i&amp;gt;│       │       └── [&amp;lt;index-j&amp;gt;] &amp;lt;element-index-j-value-type&amp;gt; id=&amp;lt;element-index-j-value-id&amp;gt; toString=&amp;lt;element-index-j-value-as-string&amp;gt; elements (excluding null):│       │           └── &amp;lt;object-tree-rooted-at-index-j&amp;gt;│       ├── &amp;lt;field-5&amp;gt; value:│       │   └── &amp;lt;field-5-value-type&amp;gt; id-ref=&amp;lt;field-5-value-id&amp;gt; toString=&amp;lt;field-5-value-as-string&amp;gt;│       ├── &amp;lt;field-6&amp;gt; value:│       │   └── &amp;lt;field-6-value-type&amp;gt; id=&amp;lt;field-6-value-id&amp;gt; toString=&amp;lt;field-6-value-as-string&amp;gt; (no fields)│       └── &amp;lt;array-field-7&amp;gt; value:│           └── &amp;lt;array-field-7-value-type&amp;gt; id=&amp;lt;array-field-7-id&amp;gt; toString=&amp;lt;array-field-7-as-string&amp;gt; (no elements)├── root &amp;lt;root-field&amp;gt; id-ref=&amp;lt;value-id&amp;gt; toString=&amp;lt;value-as-string&amp;gt;├── root &amp;lt;root-method&amp;gt; value:│   └── &amp;lt;object-tree-rooted-at-constant-embeded-in-the-method-graph&amp;gt;└── ...The tags between &amp;lt;and &amp;gt; are expanded with concrete values, the remainder is printed as illustrated.The root fields are formatted using &amp;lt;qualified-holder&amp;gt;.&amp;lt;field-name&amp;gt;:&amp;lt;qualified-declared-type&amp;gt;.The non-root fields are formatted using &amp;lt;field-name&amp;gt;:&amp;lt;qualified-declared-type&amp;gt;.The value types are formatted using &amp;lt;qualified-type&amp;gt;.The root methods are formatted using &amp;lt;qualified-holder&amp;gt;.&amp;lt;method-name&amp;gt;(&amp;lt;unqualified-parameters&amp;gt;):&amp;lt;qualified-return-type&amp;gt;No-array objects are expanded for all fields (including null).No-array objects with no fields are tagged with (no fields).Array objects are expanded for all non-null indexes: [&amp;lt;element-index&amp;gt;] &amp;lt;object-tree-rooted-at-array-element&amp;gt;Empty array objects or with all null elements are tagged with (no elements).Each constant value is expanded exactly once to compress the format.When a value is reached from multiple branches it is expanded only the first time and given an identifier: id=&amp;lt;value-id&amp;gt;.Subsequent discoveries of the same value use an identifier reference to point to the previously expansion location: id-ref=&amp;lt;value-id&amp;gt;.Suppressing Expansion of ValuesSome values, such as String, BigInteger and primitive arrays, are not expanded by default and marked with (expansion suppressed).All the other types are expanded by default.To force the suppression of types expanded by default you can use -H:ImageObjectTreeSuppressTypes=&amp;lt;comma-separated-patterns&amp;gt;.To force the expansion of types suppressed by default or through the option you can use -H:ImageObjectTreeExpandTypes=&amp;lt;comma-separated-patterns&amp;gt;.When both -H:ImageObjectTreeSuppressTypes and -H:ImageObjectTreeExpandTypes are specified -H:ImageObjectTreeExpandTypes has precedence.Similarly, some roots, such as java.lang.Character$UnicodeBlock.map&quot; that prints a lot of strings, are not expanded at all and marked with (expansion suppressed) as well.All the other roots are expanded by default.To force the suppression of roots expanded by default you can use -H:ImageObjectTreeSuppressRoots=&amp;lt;comma-separated-patterns&amp;gt;.To force the expansion of roots suppressed by default or through the option you can use -H:ImageObjectTreeExpandRoots=&amp;lt;comma-separated-patterns&amp;gt;.When both -H:ImageObjectTreeSuppressRoots and -H:ImageObjectTreeExpandRoots are specified -H:ImageObjectTreeExpandRoots has precedence.All the suppression/expansion options above accept a comma-separated list of patterns.For types the pattern is based on the fully qualified name of the type and refers to the concrete type of the constants.(For array types it is enough to specify the elemental type; it will match all the arrays of that type, of all dimensions.)For roots the pattern is based on the string format of the root as described above.The pattern accepts the * modifier:  ends-with: *&amp;lt;str&amp;gt; - the pattern exactly matches all entries that end with &amp;lt;str&amp;gt;  starts-with: &amp;lt;str&amp;gt;* - the pattern exactly matches all entries that start with &amp;lt;str&amp;gt;  contains: *&amp;lt;str&amp;gt;* - the pattern exactly matches all entries that contain &amp;lt;str&amp;gt;  equals: &amp;lt;str&amp;gt; - the pattern exactly matches all entries that are equal to &amp;lt;str&amp;gt;  all: * - the pattern matches all entriesExamplesTypes suppression/expansion:  -H:ImageObjectTreeSuppressTypes=java.io.BufferedWriter - suppress the expansion of java.io.BufferedWriter objects  -H:ImageObjectTreeSuppressTypes=java.io.BufferedWriter,java.io.BufferedOutputStream - suppress the expansion of java.io.BufferedWriter and java.io.BufferedOutputStream objects  -H:ImageObjectTreeSuppressTypes=java.io.* - suppress the expansion of all java.io.* objects  -H:ImageObjectTreeExpandTypes=java.lang.String - force the expansion of java.lang.String objects  -H:ImageObjectTreeExpandTypes=java.lang.String,java.math.BigInteger - force the expansion of java.lang.String and java.math.BigInteger objects  -H:ImageObjectTreeExpandTypes=java.lang.* - force the expansion of all java.lang.* objects  -H:ImageObjectTreeSuppressTypes=java.io.* -H:ImageObjectTreeExpandTypes=java.io.PrintStream - suppress the expansion of all java.io.* but not java.io.PrintStream objects  -H:ImageObjectTreeExpandTypes=* - force the expansion of objects of all types, including those suppressed by defaultRoots suppression/expansion:  -H:ImageObjectTreeSuppressRoots=&quot;java.nio.charset.Charset.lookup(String)&quot; - suppress the expansion of all constants embedded in the graph of com.oracle.svm.core.amd64.FrameAccess.wordSize()  -H:ImageObjectTreeSuppressRoots=java.util.* - suppress the expansion of all roots that start with java.util.  -H:ImageObjectTreeExpandRoots=java.lang.Character$UnicodeBlock.map - force the expansion of java.lang.Character$UnicodeBlock.map static field root  -H:ImageObjectTreeSuppressRoots=java.util.* -H:ImageObjectTreeExpandRoots=java.util.Locale - suppress the expansion of all roots that start with java.util. but not java.util.Locale  -H:ImageObjectTreeExpandRoots=* - force the expansion of all roots, including those suppressed by defaultReachability ReportIn diagnosing code size or security problems, the developer often has the need to know why certain code element (type/method/field) is reachable.Reachability reports are designed for the purpose.There are three options for diagnosing the reachability reasons for types, methods, and fields respectively:  -H:AbortOnTypeReachable=&amp;lt;pattern&amp;gt;  -H:AbortOnMethodReachable=&amp;lt;pattern&amp;gt;  -H:AbortOnFieldReachable=&amp;lt;pattern&amp;gt;For each option, the right-hand side specifies the pattern of the code element to be diagnosed.  The syntax for specifying types and fields is the same as that of suppression/expansion (See documentation for -H:ImageObjectTreeSuppressTypes above).  The syntax for specifying methods is the same as that of method filters (See documentation for -Djdk.graal.MethodFilter).When one of the option is enabled and the corresponding code element is reachable, a reachability trace will be dumped to a TXT file and Native Image will stop.Here is an example of the reachability report for -H:AbortOnTypeReachable=java.io.File:Type java.io.File is marked as allocatedat virtual method com.oracle.svm.core.jdk.NativeLibrarySupport.loadLibraryRelative(NativeLibrarySupport.java:105), implementation invoked├── at virtual method com.oracle.svm.core.jdk.JNIPlatformNativeLibrarySupport.loadJavaLibrary(JNIPlatformNativeLibrarySupport.java:44), implementation invoked│       ├── at virtual method com.oracle.svm.core.posix.PosixNativeLibrarySupport.loadJavaLibrary(PosixNativeLibraryFeature.java:117), implementation invoked│       │       ├── at virtual method com.oracle.svm.core.posix.PosixNativeLibrarySupport.initializeBuiltinLibraries(PosixNativeLibraryFeature.java:98), implementation invoked│       │       │       ├── at static method com.oracle.svm.core.graal.snippets.CEntryPointSnippets.initializeIsolate(CEntryPointSnippets.java:346), implementation invoked│       │       │       │       str: static root method│       │       │       └── type com.oracle.svm.core.posix.PosixNativeLibrarySupport is marked as in-heap│       │       │               scanning root com.oracle.svm.core.posix.PosixNativeLibrarySupport@4839bf0d: com.oracle.svm.core.posix.PosixNativeLibrarySupport@4839bf0d embedded in│       │       │                   org.graalvm.nativeimage.ImageSingletons.lookup(ImageSingletons.java)│       │       │                   at static method org.graalvm.nativeimage.ImageSingletons.lookup(Class), intrinsified│       │       │                       at static method com.oracle.svm.core.graal.snippets.CEntryPointSnippets.createIsolate(CEntryPointSnippets.java:209), implementation invoked│       │       └── type com.oracle.svm.core.posix.PosixNativeLibrarySupport is marked as in-heap│       └── type com.oracle.svm.core.jdk.JNIPlatformNativeLibrarySupport is reachable└── type com.oracle.svm.core.jdk.NativeLibrarySupport is marked as in-heap        scanning root com.oracle.svm.core.jdk.NativeLibrarySupport@6e06bbea: com.oracle.svm.core.jdk.NativeLibrarySupport@6e06bbea embedded in            org.graalvm.nativeimage.ImageSingletons.lookup(ImageSingletons.java)            at static method org.graalvm.nativeimage.ImageSingletons.lookup(Class), intrinsifiedReport FilesThe reports are generated in the reports subdirectory, relative to the build directory.When executing the native-image executable the build directory defaults to the working directory and can be modified using the -H:Path=&amp;lt;dir&amp;gt; option.The call tree report name has the structure call_tree_&amp;lt;binary_name&amp;gt;_&amp;lt;date_time&amp;gt;.txt when using the TXT format or, when using the CSV format, the call tree reports’ names have the structure call_tree_*_&amp;lt;binary_name&amp;gt;_&amp;lt;date_time&amp;gt;.csv.When producing CSV formatted call tree reports, symbolic links following the structure call_tree_*.csv pointing to the latest call tree CSV reports are also generated.The object tree report name has the structure: object_tree_&amp;lt;binary_name&amp;gt;_&amp;lt;date_time&amp;gt;.txt.The binary name is the name of the generated binary, which can be set with the -H:Name=&amp;lt;name&amp;gt; option.The &amp;lt;date_time&amp;gt; is in the yyyyMMdd_HHmmss format.The reachability reports are also located in the reports directory.They follow the same naming convention:  Type reachability report: trace_types_&amp;lt;binary_name&amp;gt;_&amp;lt;date_time&amp;gt;.txt  Method reachability report: trace_methods_&amp;lt;binary_name&amp;gt;_&amp;lt;date_time&amp;gt;.txt  Field reachability report: trace_fields_&amp;lt;binary_name&amp;gt;_&amp;lt;date_time&amp;gt;.txtFurther Reading  Command-line Options",
          "url": " /latest/reference-manual/native-image/debugging-and-diagnostics/StaticAnalysisReports/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-staticobjectmodel":  {
          "title": "Static Object Model",
          "content": "Static Object ModelThis guide demonstrates how to get started with using the StaticShape and StaticProperty APIs introduced with GraalVM 21.3.0.The full documentation can be found in the Javadoc.MotivationThe Static Object Model provides abstractions to represent the layout of objects that, once defined, do not change the number and the type of their properties.It is particularly well suited for, but not limited to, the implementation of the object model of static programming languages.Its APIs define the object layout (StaticShape), execute property accesses (StaticProperty), and allocate static objects (DefaultStaticObjectFactory).The implementation is efficient and executes safety checks on property accesses that can be disabled if they are already executed by the language implementation, for example by a verifier.The Static Object Model does not provide constructs to model the visibility of properties and does not distinguish between static and instance properties.Its APIs are not compatible with those of the Dynamic Object Model, which is more suited for dynamic languages.Getting StartedIn this first example, let’s assume that:  language is an instance of the TruffleLanguage that we are implementing.  We want to represent an object with the following static layout:          An int property named property1.      An Object property named property2 which can be stored as a final field. Later we will see in detail what this implies.      Here is how to use the Static Object Model to represent this layout:public class GettingStarted {    public void simpleShape(TruffleLanguage&amp;lt;?&amp;gt; language) {        StaticShape.Builder builder = StaticShape.newBuilder(language);        StaticProperty p1 = new DefaultStaticProperty(&quot;property1&quot;);        StaticProperty p2 = new DefaultStaticProperty(&quot;property2&quot;);        builder.property(p1, int.class, false);        builder.property(p2, Object.class, true);        StaticShape&amp;lt;DefaultStaticObjectFactory&amp;gt; shape = builder.build();        Object staticObject = shape.getFactory().create();        ...    }}We start by creating a StaticShape.Builder instance, passing a reference to the language that we are implementing.Then, we create DefaultStaticProperty instances that represent the properties that we want to add to the static object layout.The String id passed as argument must be unique within a builder.After creating the properties we register them to the builder instance:  The first argument is the StaticProperty that we register.  The second argument is the type of the property. It can be a primitive class or Object.class.  The third argument is a boolean value that defines if the property can be stored as a final field.This gives the compiler the opportunity to perform additional optimizations.For example, reads to this property might be constant-folded.It’s important to note that the Static Object Model does not check if a property stored as final is not assigned more than once and that it is assigned before it is read.Doing so might lead to wrong behavior of the program, and it is up to the user to enforce that this cannot happen.We then create a new static shape calling builder.build().To allocate the static object, we retrieve the DefaultStaticObjectFactory from the shape, and we invoke its create() method.Now that we have our static object instance, let’s see how to use the static properties to perform property accesses.Expanding the example above:public class GettingStarted {    public void simpleShape(TruffleLanguage&amp;lt;?&amp;gt; language) {        ...        p1.setInt(staticObject, 42);        p2.setObject(staticObject, &quot;42&quot;);        assert p1.getInt(staticObject) == 42;        assert p2.getObject(staticObject).equals(&quot;42&quot;);    }}Shape HierarchiesIt is possible to create a shape hierarchy by declaring that a new shape should extend an existing one.This is done by passing the parent shape as argument to StaticShape.Builder.build(StaticShape) when creating the child shape.Properties of the parent shape can then be used to access values stored in static objects of the child shape.In the following example we create a parent shape identical to the one discussed in the previous section, then we extend it with a child shape that hides one of the properties of the parent shape.Finally, we demonstrate how the various properties can be accessed.public class Subshapes {    public void simpleSubShape(TruffleLanguage&amp;lt;?&amp;gt; language) {        // Create a shape        StaticShape.Builder b1 = StaticShape.newBuilder(language);        StaticProperty s1p1 = new DefaultStaticProperty(&quot;property1&quot;);        StaticProperty s1p2 = new DefaultStaticProperty(&quot;property2&quot;);        b1.property(s1p1, int.class, false).property(s1p2, Object.class, true);        StaticShape&amp;lt;DefaultStaticObjectFactory&amp;gt; s1 = b1.build();        // Create a sub-shape        StaticShape.Builder b2 = StaticShape.newBuilder(language);        StaticProperty s2p1 = new DefaultStaticProperty(&quot;property1&quot;);        b2.property(s2p1, int.class, false);        StaticShape&amp;lt;DefaultStaticObjectFactory&amp;gt; s2 = b2.build(s1); // passing a shape as argument builds a sub-shape        // Create a static object for the sub-shape        Object o2 = s2.getFactory().create();        // Perform property accesses        s1p1.setInt(o2, 42);        s1p2.setObject(o2, &quot;42&quot;);        s2p1.setInt(o2, 24);        assert s1p1.getInt(o2) == 42;        assert s1p2.getObject(o2).equals(&quot;42&quot;);        assert s2p1.getInt(o2) == 24;    }}Extending custom base classesTo reduce memory footprint, the language implementor might want static objects to extend the class that represents guest-level objects.This is complicated by the fact that StaticShape.getFactory() must return an instance of the factory class that allocates static objects.To achieve this, we first need to declare an interface that:  Defines a method for each visible constructor of the static object super class that we want to invoke.  The arguments of each method must match those of the corresponding constructor.  The return type of each method must be assignable from the static object super class.For example, if the static objects should extend this class:public abstract class MyStaticObject {    final String arg1;    final Object arg2;    public MyStaticObject(String arg1) {        this(arg1, null);    }    public MyStaticObject(String arg1, Object arg2) {        this.arg1 = arg1;        this.arg2 = arg2;    }}We need to declare the following factory interface:public interface MyStaticObjectFactory {    MyStaticObject create(String arg1);    MyStaticObject create(String arg1, Object arg2);}Finally, this is how to allocate the custom static objects:public void customStaticObject(TruffleLanguage&amp;lt;?&amp;gt; language) {    StaticProperty property = new DefaultStaticProperty(&quot;arg1&quot;);    StaticShape&amp;lt;MyStaticObjectFactory&amp;gt; shape = StaticShape.newBuilder(language).property(property, Object.class, false).build(MyStaticObject.class, MyStaticObjectFactory.class);    MyStaticObject staticObject = shape.getFactory().create(&quot;arg1&quot;);    property.setObject(staticObject, &quot;42&quot;);    assert staticObject.arg1.equals(&quot;arg1&quot;); // fields of the custom super class are directly accessible    assert property.getObject(staticObject).equals(&quot;42&quot;); // static properties are accessible as usual}As you can see from the example above, fields and methods of the custom parent class are directly accessible and are not hidden by the static properties of the static object.Reducing memory footprintReading the Javadoc, you might have noticed that StaticShape does not provide an API to access the associated static properties.This reduces memory footprint in case the language implementation already has a way to store this information.For example, an implementation of the Java language might want to store the static shape in the class that represents a Java class, and a static property in the class that represents a Java field.In this case, the class representing a Java class should already have a way to retrieve the Java fields associated to it, hence the static properties associated to the shape.To further reduce memory footprint, the language implementor might want the class representing a Java field to extend StaticProperty.Instead of storing the static property in the class that represents fields:class MyField {    final StaticProperty p;    MyField(StaticProperty p) {        this.p = p;    }}new MyField(new DefaultStaticProperty(&quot;property1&quot;));The class that represents fields can extend StaticProperty:class MyField extends StaticProperty {    final Object name;    MyField(Object name) {        this.name = name;    }    @Override    public String getId() {        return name.toString(); // this string must be a unique identifier within a Builder    }}new MyField(&quot;property1&quot;);Safety ChecksOn property access, the Static Object Model performs two types of safety checks:  That the StaticProperty method matches the type of the static property.Example of wrong access:public void wrongMethod(TruffleLanguage&amp;lt;?&amp;gt; language) {    StaticShape.Builder builder = StaticShape.newBuilder(language);    StaticProperty property = new DefaultStaticProperty(&quot;property&quot;);    Object staticObject = builder.property(property, int.class, false).build().getFactory().create();    property.setObject(staticObject, &quot;wrong access type&quot;); // throws IllegalArgumentException  That the object passed to the accessor method matches the shape generated by the builder to which the property is associated, or one of its child shapes.Example of wrong access:public void wrongShape(TruffleLanguage&amp;lt;?&amp;gt; language) {    StaticShape.Builder builder = StaticShape.newBuilder(language);    StaticProperty property = new DefaultStaticProperty(&quot;property&quot;);;    Object staticObject1 = builder.property(property, Object.class, false).build().getFactory().create();    Object staticObject2 = StaticShape.newBuilder(language).build().getFactory().create();    property.setObject(staticObject2, &quot;wrong shape&quot;); // throws IllegalArgumentException}While these checks are often useful, they might be redundant if the language implementation already performs them, for example using a verifier.While the first type of checks (on property type) is very efficient and cannot be disabled, the second type of checks (on the shape) is computationally expensive and can be disabled via a command line argument:--experimental-options --engine.RelaxStaticObjectSafetyChecks=trueor when creating the Context:Context context = Context.newBuilder() //                         .allowExperimentalOptions(true) //                         .option(&quot;engine.RelaxStaticObjectSafetyChecks&quot;, &quot;true&quot;) //                         .build();It is highly discouraged to relax safety checks in absence of other equivalent checks.If the assumption on the correctness of the shape of the static objects is wrong, the VM is likely to crash.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/StaticObjectModel/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-tck":  {
          "title": "Polyglot API-based Test Compatibility Kit",
          "content": "Polyglot API-based Test Compatibility KitThe Test Compatibility Kit (TCK) is a collection of tests verifying the TruffleLanguage inter-operability and instrumentation.The TCK is based on the org.graalvm.polyglot API.Adding a LanguageTo test your language, implement the LanguageProvider.The LanguageProviders are loaded using the java.util.ServiceLoader, so you need to register your implementation in the META-INF/services/org.graalvm.polyglot.tck.LanguageProvider file.The LanguageProvider should provide the language data types, language expressions (operators), and language control flow statements represented as functions returning the data type or executing the operator (statement).To allow composition of the returned functions, the parameter and return types have to be assigned to them usingthe Snippet.Builder.The LanguageProvider should also provide simple but representative scripts which the TCK can use to test instrumentation.Running TCK Tests with mxThe tests are executed using mx unitest. When running the tests, all LanguageProviders in the primary suite and dependent suites are used. The truffle suite provides the java-host LanguageProvider, creating Java data types and Proxies to test Java inter-operability.To run just the TCK tests use:mx unittest com.oracle.truffle.tck.testsOr, simply use:mx tckTo restrict the TCK tests to test a certain language, use the tck.language property.The following example tests JavaScript with data types from all available languages:mx tck -Dtck.language=jsTo restrict the data types to a certain language, use the tck.values property.The following example tests JavaScript with Java types:mx tck -Dtck.values=java-host -Dtck.language=jsTo run a single test, specify the full test name.For example, to run a test for SimpleLanguage + operator with SimpleLanguage number and big number use:mx tck &#39;ExpressionTest#testExpression[sl::+(sl::number, sl::number)]&#39;To run the TCK tests on GraalVM it is enough to set the mx --java-home to point to GraalVM:mx --java-home=&amp;lt;path_to_graalvm&amp;gt; tckTo disable output and error output use the tck.verbose property:mx tck -Dtck.verbose=falseTo disable output and error output only for a certain test, use the tck.{TestSimpleName}.verbose property:mx tck -Dtck.ErrorTypeTest.verbose=falseYou can also disable output and error output for all tests but one:mx tck -Dtck.verbose=false -Dtck.ErrorTypeTest.verbose=trueRunning TCK Tests with Apache MavenThe Apache Maven can be used to execute Truffle TCK tests. First, create a Maven module (project) containing the languageTCK provider. Ensure that this module has a test dependency on the language being tested and TCK tests org.graalvm.truffle:truffle-tck-tests.Configure the maven-surefire-plugin to identify tests in the org.graalvm.truffle:truffle-tck-tests artifact.This can be achieved using the following snippet within the  section of your project&#39;s pom.xml:&amp;lt;build&amp;gt;    &amp;lt;plugins&amp;gt;        [...]        &amp;lt;plugin&amp;gt;            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;            &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;            &amp;lt;version&amp;gt;3.1.2&amp;lt;/version&amp;gt;            &amp;lt;configuration&amp;gt;                &amp;lt;dependenciesToScan&amp;gt;                    &amp;lt;dependency&amp;gt;org.graalvm.truffle:truffle-tck-tests&amp;lt;/dependency&amp;gt;                &amp;lt;/dependenciesToScan&amp;gt;            &amp;lt;/configuration&amp;gt;        &amp;lt;/plugin&amp;gt;        [...]    &amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;To include additional languages in the TCK execution add their TCK providers as test dependencies. For example, adding org.graalvm.js:js-truffle-tck will include JavaScript in the testing process.You can utilize the SimpleLanguage TCK provider pom.xml as a template to get started.To test the runtime optimizations set the JAVA_HOME environment variable to the GraalVM location before running mvn package.Customize TCK TestsTo restrict the TCK tests to test a certain language, use the tck.language property.The following example tests JavaScript with data types from all available languages.&amp;lt;build&amp;gt;    &amp;lt;plugins&amp;gt;        [...]        &amp;lt;plugin&amp;gt;            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;            &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;            &amp;lt;version&amp;gt;3.1.2&amp;lt;/version&amp;gt;            &amp;lt;configuration&amp;gt;                &amp;lt;argLine&amp;gt;                    -Dtck.language=js                &amp;lt;/argLine&amp;gt;                [...]            &amp;lt;/configuration&amp;gt;        &amp;lt;/plugin&amp;gt;        [...]    &amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;To restrict the data types to a certain language, use the tck.values property.The following example tests JavaScript with Java types.&amp;lt;build&amp;gt;    &amp;lt;plugins&amp;gt;        [...]        &amp;lt;plugin&amp;gt;            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;            &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;            &amp;lt;version&amp;gt;3.1.2&amp;lt;/version&amp;gt;            &amp;lt;configuration&amp;gt;                &amp;lt;argLine&amp;gt;                    -Dtck.values=java-host                    -Dtck.language=js                &amp;lt;/argLine&amp;gt;                [...]            &amp;lt;/configuration&amp;gt;        &amp;lt;/plugin&amp;gt;        [...]    &amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;To execute a specific TCK test you can use the test parameter along with the -Dtest option.For example: mvn test -Dtest=ScriptTest",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/TCK/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-traversingcompilationqueue":  {
          "title": "Truffle Approach to the Compilation Queue",
          "content": "Truffle Approach to the Compilation QueueAs of version 21.2.0 Truffle has a new approach to compilation queueing.This document gives motivation and an overview of this approach.What is a Compilation queue?During execution of guest code each Truffle call target counts how many times it was executed as well as how many loop iterations happened during those executions (i.e. the target’s “call and loop count”).Once this counter reaches a certain threshold the call target is deemed “hot” and scheduled for compilation.In order to minimize the impact this has on the execution of the guest code the notion that the target should be compiled is made concrete as a compilation task and placed into a compilation queue to await compilation.The Truffle runtime spawns several compiler threads (--engine.CompilerThreads) that take tasks from the queue and compile the specified call targets.The initial implementation of the compilation queue in Truffle was a straightforward FIFO queue.This approach has important limitations with respect to warmup characteristics of the guest code execution.Namely, not all call targets are equally important to compile.The aim is to identify targets which account for more execution time and compile them first, thus reaching better performance sooner.Since call targets are queued for compilation when a counter reaches a certain threshold a FIFO queue would compile targets in order of reaching that threshold, which in practise does not correlate to actual execution time.Consider the following toy JavaScript example:function lowUsage() {    for (i = 0; i &amp;lt; COMPILATION_THRESHOLD; i++) {        // Do something    }}function highUsage() {    for (i = 0; i &amp;lt; 100 * COMPILATION_THRESHOLD; i++) {        // Do something    }}while(true) {    lowUsage();    highUsage();}Both the lowUsage and the highUsage function will reach a high enough call and loop count threshold even on the first execution, but the lowUsage function will reach it first.Using a FIFO queue, we would compile the lowUsage function first, even though this example illustrates that the highUsage function should be compiled first in order to reach better performance sooner.Traversing Compilation QueueThe new compilation queue in Truffle, colloquially called “Traversing Compilation Queue”, takes a more dynamic approach to selecting the order in which targets are compiled.Every time a compiler thread requests the next compilation task the queue will traverse all the entries in the queue and pick the one with the highest priority.A task’s priority is determined based on several factors.For starters, targets scheduled for first-tier compilation (i.e. first-tier tasks) always have higher priority than second-tier tasks.The rational behind this is that performance difference between executing code in the interpreter and executing it in first-tier compiled code is much greater then the difference between tier-one and tier-two compiled code, meaning that we get more benefit from compiling these targets sooner.Also, first-tier compilations are usually take less time, thus one compiler thread can finish multiple first-tier compilations in the same time it takes to complete one second-tier compilation.This approach has been shown to underperform in certain scenarios and might be improved upon in the coming versions.When comparing two tasks of the same tier, we first consider their compilation history and give priority to tasks which were previously compiled with a higher compiler tier.For example, if a call target get first-tier compiled, then gets invalidated for some reason and then gets queued for a first-tier compilation again, it takes priority over all other first tier targets that have never before been compiled.The reasoning is that if it was previously compiled, it is obviously important and should not be penalized more than necessary by its invalidation.Finally, if the two previous conditions can’t differentiate the priority between two tasks we give priority to the task with the higher “weight”.The weight is a function of the target’s call and loop count and time.It is defined as a product of the target’s call and loop count with the rate at which that call and loop count has grown in the past 1ms.Using the target’s call and loop count as a proxy for amount of time spent executing that call target, this metric aims to balance total time spent executing that call target with the recent growth of that time.This gives a priority boost to targets that are currently “very hot” when comparing to targets that were “hot” but are not being executed a lot currently.For performance reasons the weight for tasks is cached and reused for a period of 1ms. If the cached value is older than 1ms, it is recalculated.The traversing compilation queue is on by default as of version 21.2.0 and can be disabled using --engine.TraversingCompilationQueue=false.Dynamic Compilation ThresholdsOne problem of the traversing compilation queue is that it needs to traverse all the entries in the queue to get up-to-date weights and choose the highest priority task.This does not have a significant performance impact as long as the size of the queue remains reasonable.This means that in order to always choose the highest priority task in a reasonable about of time we need to ensure that the queue does not grow indefinitely.This is achieved by an approach we call “dynamic compilation thresholds”.Simply put, dynamic compilation thresholds means that the compilation threshold (the one each call target’s call and loop count is compared against when determining whether to compile it) may change over time depending on the state of the queue.If the queue is overloaded we aim to increase the compilation thresholds to reduce the number of incoming compilation tasks, i.e. targets need to be “more hot” to get scheduled for compilation.On the other hand, if the queue is close to empty, we can reduce the compilation thresholds to allow more targets to get scheduled for compilation, i.e. the compilation threads are in danger of idling so let’s give them even “less hot” targets to compile.We call this changing of the thresholds “scaling” as the thresholds are in practice just multiple by a “scale factor” determined by a scale function.The scale function takes as input the “load” of the queue, which is the number of tasks in the queue divided by the number of compiler threads.We intentionally control for the number of compiler threads since the raw number of tasks in the queue is not a good proxy of how much compilation pressure there is.For example, let’s assume that an average compilation takes 100ms and that there are 160 tasks in the queue.A runtime with 16 threads will finish all the tasks in approximately 10 * 100ms i.e. 1 second.On the other hand, a runtime with 2 compiler thread will take approximately 80 * 100ms, i.e. 8 seconds.The scale function is defined by 3 parameters: --engine.DynamicCompilationThresholdsMinScale, --engine.DynamicCompilationThresholdsMinNormalLoad and DynamicCompilationThresholdsMaxNormalLoad.The --engine.DynamicCompilationThresholdsMinScale option defines how low we are willing to scale the thresholds.It has a default value of 0.1, meaning that the compilation thresholds will never be scaled below 10% of their default value.This in practice means that, by definition, scale(0) = DynamicCompilationThresholdsMinScale or for default values scale(0) = 0.1The --engine.DynamicCompilationThresholdsMinNormalLoad option defines the minimal load at which compilation thresholds will not be scaled.This means that as long as the load of the queue is above this value the runtime will not scale down the compilation thresholds.This in practice means that, by definition, scale(DynamicCompilationThresholdsMinScale) = 1 or for default values scale(10) = 1The --engine.DynamicCompilationThresholdsMaxNormalLoad option defines the maximal load at which compilation thresholds will not be scaled.This means that as long as the load of the queue is below this value the runtime will not scale up the compilation thresholds.This in practice means that, by definition, scale(DynamicCompilationThresholdsMaxScale) = 1 or for default values scale(90) = 1So far we’ve defined the scale function at 3 points.For all values between those points the scale function is a straight line connecting those two points.This means that for all values between the minimal and maximal normal load the scale function is 1 by definition.For values between 0 and the minimal normal load the scale function grows linearly between the minimal scale and 1.Let’s define the slope of this function as s.Now, for the remainder of the functions domain, i.e. the values greater than the maximum normal load, we define scale to be a linear function with slope s passing through the point (DynamicCompilationThresholdsMaxNormalLoad, 1).The following is an ASCII art plot of the scale function which should illustrate how it’s defined.          ^ scale          |          |                                            /          |                                           /          |                                          /          |                                         /          |                                        /          |                                       /        1 |..... ________________________________/          |     /.                               .          |    / .                               .          |   /  .                               .          |  /   .                               .          | /    .                               .MinScale &amp;gt;|/     .                               .          |      .                               .          |_______________________________________________________&amp;gt; load         0       ^                               ^              MinNormalLoad                   MaxNormalLoadThe dynamic thresholds only work with the traversing compilation queue and are on by default as of version 21.2.0.They can be disabled with --engine.DynamicCompilationThresholds=false.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/TraversingCompilationQueue/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-trufflelibraries":  {
          "title": "Truffle Library Guide",
          "content": "Truffle Library GuideTruffle Libraries allow language implementations to use polymorphic dispatch for receiver types with support for implementation-specific caching/profiling and automatic support for uncached dispatch.Truffle Libraries enable modularity and encapsulation for representation types language implementations on top of Truffle.Read this guide first before using them.Getting StartedThis tutorial provides a trace through a use-case on how to use Truffle Libraries.The full API documentation can be found in the Javadoc.This document assumes prior knowledge of Truffle APIs and the use of @Specialization with the @Cached annotation.Motivating ExampleWhen implementing arrays in Truffle Languages it is often necessary to use multiple representations for efficiency.For example, if the array is constructed from an arithmetic sequence of integers (e.g., range(from: 1, step: 2, length: 3)), then it is best represented using the start, stride, and length instead of materializing the full array.Of course, when an array element is written, then the array needs to be materialized.In this example we are going to implement an array implementation with two representations:  Buffer: represents a materialized array representation backed by a Java array.  Sequence: represents an arithmetic sequence of numbers represented by start, stride and length: [start, start + 1 * stride, ..., start + (length - 1) * stride].To keep the example simple we will only support int values and we will ignore index bounds error handling.We will also just implement the read operation and not the typically more complicated write operation.To make the example more interesting, we will implement an optimization that will let the compiler allow constant fold sequenced array accesses even if the array receiver value is not constant.Assume we have the following code snippet range(start, stride, length)[2].In this snippet, the variables start and stride are not known to be constant values, therefore, equivalent code to start + stride * 2 gets compiled.However, if the start and stride values are known to always be the same then the compiler could constant-fold the entire operation.This optimization requires the use of caching.We will later show how this works.In the dynamic array implementation of GraalVM’s JavaScript runtime, we use 20 different representations.There are representations for constant, zero-based, contiguous, holes, and sparse arrays.Some representations are further specialized for the types byte, int, double, JSObject, and Object.The source code can be found here. Note: Currently, JavaScript arrays do not use Truffle Libraries yet.In the following sections, we discuss multiple implementation strategies for the array representations, ultimately describing how Truffle Libraries can be used to achieve this.Strategy 1: Specialization per RepresentationFor this strategy, we will start by declaring classes for the two representations BufferArray and SequenceArray.final class BufferArray {    int length;    int[] buffer;    /*...*/}final class SequenceArray {    final int start;    final int stride;    final int length;    /*...*/}The BufferArray implementation has a mutable buffer and length and is used as the materialized array representation.The sequence array is represented by the final fields start, stride, and length.Now, we specify the basic read operations like this:abstract class ExpressionNode extends Node {    abstract Object execute(VirtualFrame frame);}@NodeChild @NodeChildabstract class ArrayReadNode extends ExpressionNode {    @Specialization    int doBuffer(BufferArray array, int index) {        return array.buffer[index];    }    @Specialization    int doSequence(SequenceArray seq, int index) {        return seq.start + seq.stride * index;    }}The array read node specifies two specializations for the buffer version and the sequence.As mentioned before we are going to ignore error bounds checks for simplicity.Now we try to make the array read specialize on the constant-ness of values of the sequence in order to allow the range(start, stride, length)[2] example to fold if start and stride are constant.To find out whether start and stride are constants we need to profile their value.To profile these values we need to add another specialization to the array read operation like this:@NodeChild @NodeChildclass ArrayReadNode extends ExpressionNode {    /* doBuffer() */    @Specialization(guards = {&quot;seq.stride == cachedStride&quot;,                              &quot;seq.start  == cachedStart&quot;}, limit = &quot;1&quot;)    int doSequenceCached(SequenceArray seq, int index,             @Cached(&quot;seq.start&quot;)  int cachedStart,             @Cached(&quot;seq.stride&quot;) int cachedStride) {        return cachedStart + cachedStride * index;    }    /* doSequence() */}If the speculation guards of this specialization succeed then the start and stride are effectively constant.For example, with the values 3 and 2, the compiler would see 3 + 2 * 2 which is 7.The limit is set to 1 to only try this speculation once.It would likely be inefficient to increase the limit as this would introduce additional control flow to the compiled code.If the speculation does not succeed, i.e., if the operation observes multiple start and stride values, we want to fall back to the normal sequence specialization.To achieve this we change the doSequence specialization by adding replaces = &quot;doSequenceCached&quot; like this:@NodeChild @NodeChildclass ArrayReadNode extends ExpressionNode {    /* doSequenceCached() */    @Specialization(replaces = &quot;doSequenceCached&quot;)    int doSequence(SequenceArray seq, int index) {        return seq.start + seq.stride * index;    }}Now we have achieved the goal of implementing our array representations including additional profiling.The runnable source code for Strategy 1 can be found here.This strategy has some nice properties:  The operation is easy to read and all cases are fully enumerated.  The generated code of the read node only requires a single bit per specialization to remember which representation type was observed at runtime.We would already be done with this tutorial if there would not be some problems with this:  New representations cannot be loaded dynamically; they need to be statically known, making the separation of representation types from operations impossible.  Changing or adding representation types often requires the modification of many operations.  Representation classes need to expose most implementation details to operations (no encapsulation).These problems are the primary motivations for Truffle Libraries.Strategy 2: Java InterfacesNow we will try to address these problems by using Java interfaces.We start by defining an array interface:interface Array {    int read(int index);}The implementations can now implement the Array interface and implement the read method in the representation class.final class BufferArray implements Array {    private int length;    private int[] buffer;    /*...*/    @Override public int read(int index) {        return buffer[index];    }}final class SequenceArray implements Array {    private final int start;    private final int stride;    private final int length;    /*...*/    @Override public int read(int index) {        return start + (stride * index);    }}Finally, we specify the operation node:@NodeChild @NodeChildabstract class ArrayReadNode extends ExpressionNode {    @Specialization   int doDefault(Array array, int index) {        return array.read(index);    }}The problem with this operation implementation is that the partial evaluator does not know which concrete type the array receiver has.Therefore, it needs to stop partial evaluation and emit a slow interface call for the read method call.This is not what we want, but we can introduce a polymorphic type cache to resolve it like this:class ArrayReadNode extends ExpressionNode {    @Specialization(guards = &quot;array.getClass() == arrayClass&quot;, limit = &quot;2&quot;)    int doCached(Array array, int index,           @Cached(&quot;array.getClass()&quot;) Class&amp;lt;? extends Array&amp;gt; arrayClass) {        return arrayClass.cast(array).read(index);    }    @Specialization(replaces = &quot;doCached&quot;)    int doDefault(Array array, int index) {        return array.read(index);    }}We solved the problem of partially evaluating the implementation, but there is no way to express the extra specialization for the constant stride and start index optimization in this solution.This is what we discovered/ solved so far:  Interfaces are existing well-known concept for polymorphism in Java.  New interface implementations can be loaded enabling modularity.  We found a convenient way to use the operations from slow-paths.  Representation types can encapsulate implementation details.But we have introduced new problems:  No representation specific profiling / caching can be performed.  Every interface call requires a polymorphic class cache on the call-site.The runnable source code for Strategy 2 can be found here.Strategy 3: Truffle LibrariesTruffle Libraries work similar to the Java interfaces.Instead of a Java interface, we create an abstract class extending the Library class and annotate it with @GenerateLibrary. We create abstract methods like with the interface, but we insert a receiver argument in the beginning, in our case of type Object.Instead of performing interface type checks we use an explicit abstract method in the library typically named is${Type}.We do this for our example:@GenerateLibrarypublic abstract class ArrayLibrary extends Library {    public boolean isArray(Object receiver) {        return false;    }    public abstract int read(Object receiver, int index);}This ArrayLibrary specifies two messages: isArray and read.At compile time, the annotation processor generates a package protected class ArrayLibraryGen.Unlike generated nodes classes, you never need to refer to this class.Instead of implementing a Java interface, we export the library using the @ExportLibrary annotation on the representation type.Message exports are specified using instance methods on the representation and can, therefore, omit the receiver argument of the library.The first representation we implement this way is the BufferArray representation:@ExportLibrary(ArrayLibrary.class)final class BufferArray {    private int length;    private int[] buffer;    /*...*/    @ExportMessage boolean isArray() {      return true;    }    @ExportMessage int read(int index) {      return buffer[index];    }}This implementation is very similar to the interface version, but in addition, we specify the isArray message.Again, the annotation processor generates the boilerplate code that implements the library abstract class.Next, we implement the sequence representation.We start by implementing it without the optimization for the start and stride value.@ExportLibrary(ArrayLibrary.class)final class SequenceArray {    private final int start;    private final int stride;    private final int length;    /*...*/    @ExportMessage int read(int index) {        return start + stride * index;    }}So far this was equivalent to the interface implementation, but with Truffle Libraries we can now also use specializations in our representations by exporting a message using a class instead of a method.The convention is that the class is named exactly like the exported message, but with the first letter upper-case.Now we implement our stride and start specialization using this mechanism:@ExportLibrary(ArrayLibrary.class)final class SequenceArray {    final int start;    final int stride;    final int length;    /*...*/    @ExportMessage static class Read {        @Specialization(guards = {&quot;seq.stride == cachedStride&quot;,                                  &quot;seq.start  == cachedStart&quot;}, limit = &quot;1&quot;)        static int doSequenceCached(SequenceArray seq, int index,                 @Cached(&quot;seq.start&quot;)  int cachedStart,                 @Cached(&quot;seq.stride&quot;) int cachedStride) {            return cachedStart + cachedStride * index;        }        @Specialization(replaces = &quot;doSequenceCached&quot;)        static int doSequence(SequenceArray seq, int index) {            return doSequenceCached(seq, index, seq.start, seq.stride);        }    }}Since the message is declared using an inner class we need to specify the receiver type.Compared to normal nodes, this class must not extend Node and its methods must be static to allow the annotation processor to generate efficient code for the library subclass.Last, we need to use the array library in our read operation.The Library API provides an annotation called @CachedLibrary that is responsible for dispatching to libraries.The array read operation now looks like this:@NodeChild @NodeChildclass ArrayReadNode extends ExpressionNode {    @Specialization(guards = &quot;arrays.isArray(array)&quot;, limit = &quot;2&quot;)    int doDefault(Object array, int index,                  @CachedLibrary(&quot;array&quot;) ArrayLibrary arrays) {        return arrays.read(array, index);    }}Similar to the type cache we have seen in Strategy 2 we specialize the library to a particular value.The first attribute of @CachedLibrary, &quot;array&quot; specifies the value the library is specialized for.A specialized library can only be used for values they were specialized for.If they are used with other values then the framework will fail with an assertion error.Instead of using the Array type as the parameter type, we use the isArray message in the guard.Using a specialized library requires us to specify the limit on the specialization.The limit specifies how many specializations of a library can be instantiated until the operation should rewrite itself to use an uncached version of the library.In the array example we have only implemented two array representations.Therefore it is impossible that the limit is exceeded.In real array implementations, we are likely to use many more representations.The limit should be set to a value that is unlikely to be exceeded in representative applications, but at the same time does not produce too much code.The uncached or slow-path version of a library can be reached by exceeding the limit of the specialization, but it can also be used manually, e.g., if the array operation needs to be invoked when no node is available.This is usually the case for parts of the language implementation that are invoked infrequently.With the interface strategy (Strategy 2), the array read operation could be used by just invoking the interface method.With Truffle libraries, we need to lookup an uncached version of the library first.Every use of @ExportLibrary generates a cached but also an uncached / slow-path library subclass.The uncached version of the exported library uses the same semantics as @GenerateUncached.Typically, as with our example, the uncached version can be derived automatically.The DSL shows an error if it needs further details on how to generate the uncached version.The uncached version of the library can be invoked like this:ArrayLibrary arrays = LibraryFactory.resolve(ArrayLibrary.class).getUncached();arrays.read(array, index);In order to decrease the verbosity of this example, it is recommended that the library class provides the following optional static utilities:@GenerateLibrarypublic abstract class ArrayLibrary extends Library {    /*...*/    public static LibraryFactory&amp;lt;ArrayLibrary&amp;gt; getFactory() {        return FACTORY;    }    public static ArrayLibrary getUncached() {        return FACTORY.getUncached();    }    private static final LibraryFactory&amp;lt;ArrayLibrary&amp;gt; FACTORY =               LibraryFactory.resolve(ArrayLibrary.class);}The verbose example from above can now be simplified as:ArrayLibrary.getUncached().readArray(array, index);The runnable source code for Strategy 3 can be found here.ConclusionIn this tutorial, we have learned that with Truffle Libraries we no longer need to compromise the modularity of representation types by creating a specialization per representation (Strategy 1) and the profiling is no longer blocked by interface calls (Strategy 2).With Truffle Libraries we now support polymorphic dispatch with type encapsulation but don’t lose the capability of using profiling/caching techniques in representation types.What to do next?      Run and debug all the examples here.        Read the interoperability migration guide, as an example of Truffle Libraries usage here.        Read the Truffle Library reference documentation here.  FAQAre there any known limitations?  Library exports currently cannot explicitly invoke their super implementation. This makes reflective implementations currently infeasible. See the example here.  Boxing elimination for return values is currently not supported. A message can only have one generic return type. Support for this is planned.  Reflection without static dependencies on the Library class is currently not supported. Support for full dynamic reflection is planned.When should I use Truffle Libraries?When to use?  If the representations are modular and cannot be enumerated for an operation (e.g., Truffle Interoperability).  If there is more than one representation of a type and one of the representations needs profiling/caching (e.g., see the motivating example).  If there is a need for a way to proxy all values of a language (e.g., for dynamic taint tracking).When not to use?  For basic types that only have one representation.  For primitive representations that require boxing elimination to speed up the interpreter. Boxing elimination is not supported with Truffle Libraries at the moment.I decided to use a Truffle Library to abstract the language specific types of my language. Should those be exposed to other languages and tools?All libraries are accessible to other languages and tools via the ReflectionLibrary.It is recommended that the language implementation documentation specifies which libraries and messages are intended for external use, and which ones may be subject to breaking changes.What happens when a new method is added to a library but a dynamically loaded implementation hasn’t been updated for it?If the library method was specified abstract then an AbstractMethodError will be thrown.Otherwise the default implementation specified by the library method body will be called.This allows to customize the error in case an abstract method is used.For example, for Truffle interoperability we often throw an UnsupportedMessageException instead of an AbstractMethodError.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/TruffleLibraries/"
          },
          
          "latest-graalvm-as-a-platform-language-implementation-framework-trufflestrings":  {
          "title": "Truffle Strings Guide",
          "content": "Truffle Strings GuideTruffle Strings is Truffle’s primitive String type, which can be shared between languages.Language implementers are encouraged to use Truffle Strings as their language’s string type for easier interoperability and better performance.TruffleString supports a plethora of string encodings, but is especially optimized for the most commonly used:  UTF-8  UTF-16  UTF-32  US-ASCII  ISO-8859-1  BYTESTruffleString APIAll operations exposed by TruffleString are provided as an inner Node, and as static or instance methods.Users should use the provided nodes where possible, as the static/instance methods are just shorthands for executing their respective node’s uncached version.All nodes are named {NameOfOperation}Node, and all convenience methods are named {nameOfOperation}Uncached.Some operations support lazy evaluation, such as lazy concatenation or lazy evaluation of certain string properties.Most of these operations provide a parameter boolean lazy, which allows the user to enable or disable lazy evaluation on a per-callsite basis.Operations dealing with index values, such as CodePointAtIndex, are available in two variants: codepoint-based indexing and byte-based indexing.Byte-based indexing is indicated by the ByteIndex-suffix or prefix in an operation’s name, otherwise indices are based on codepoints.For example, the index parameter ofCodePointAtIndex is codepoint-based, whereas CodePointAtByteIndex uses a byte-based index.The list of currently available operations is listed below and grouped by category.Creating a new TruffleString:  FromCodePoint:Create a new TruffleString from a given codepoint.  FromLong:Create a new TruffleString from a given long value.  FromByteArray:Create a new TruffleString from a given byte array.  FromCharArrayUTF16:Create a UTF-16 TruffleString from a given char array.  FromIntArrayUTF32:Create a UTF-32 TruffleString from a given int array.  FromJavaString:Create a TruffleString from a given java.lang.String.  FromNativePointer:Create a new TruffleString from a given native pointer.  Encoding#getEmpty:Get an empty TruffleString in that encoding.Query string properties:  isEmpty:Check if a string is empty.  CodePointLength:Get a string’s length in codepoints.  byteLength:Get a string’s length in bytes.  IsValid:Check whether a string is encoded correctly.  GetCodeRange:Get coarse information about the string’s content (are all codepoints in this string from the ASCII/LATIN-1/BMPrange?).  GetByteCodeRange:Get coarse information about the string’s content, without taking 16/32-bit based encodings into account.  CodeRangeEquals:Check whether a string’s code range equals the given code range.  isCompatibleTo:Check if a string is compatible to / can be viewed in a given encoding.  isManaged:Check if a string is not backed by a native pointer.  isNative:Check if a string is backed by a native pointer.  isImmutable:Check if a string is an instance of TruffleString.  isMutable:Check if a string is an instance of MutableTruffleString.Comparison:  Equal:Check if two strings are equal. Note that this operation is encoding-sensitive!  RegionEqual:Check if two strings are equal in a given region defined by a codepoint-based offset and length.  RegionEqualByteIndex:Check if two strings are equal in a given region defined by a byte-based offset and length.  CompareBytes:Compare two strings byte-by-byte.  CompareCharsUTF16:Compare two UTF-16 strings char-by-char.  CompareIntsUTF32:Compare two UTF-32 strings int-by-int.  HashCode:Get a string’s hash code. The hash code is based on the string’s bytes, so strings with the same codepoints butdifferent encodings may have different hash codes.Conversion:  SwitchEncoding:Convert a string to a given encoding.  ForceEncoding:Create a string containing the same bytes as the given string, but assigned to the given encoding.  AsTruffleString:Convert a MutableTruffleString to an immutable TruffleString.  AsManaged:Convert a TruffleString backed by a native pointer to one backed by a java byte array.  ToValidString:Convert a TruffleString to a version that is encoded correctly.  CopyToByteArray:Copy a string’s content into a byte array.  GetInternalByteArray:Get a string’s internal byte array.  CopyToNativeMemory:Copy a string’s content into a native pointer.  GetInternalNativePointer:Get a native string’s pointer object.  ToJavaString:Convert a string to a java.lang.String.  ParseInt:Parse a string’s content as an int value.  ParseLong:Parse a string’s content as a long value.  ParseDouble:Parse a string’s content as a double value.Accessing codepoints and bytes:  Materialize:Use this node to avoid materialization code inside loops iterating over a string’s code points or bytes.  ReadByte:Read a single byte from a string.  ReadCharUTF16:Read a single char from a UTF-16 string.  CodePointAtIndex:Read a single codepoint from a string at a given codepoint-based index.  CodePointAtByteIndex:Read a single codepoint from a string at a given byte-based index.  CreateCodePointIterator:Return a TruffleStringIterator object suitable for iterating the string’s codepoints.  CreateBackwardCodePointIterator:Return a TruffleStringIterator object suitable for iterating the string’s codepoints, starting from the end of thestring.  ByteLengthOfCodePoint:Return the number of bytes occupied by the codepoint starting at a given byte index.  CodePointIndexToByteIndex:Convert a given codepoint index to a byte index on a given string.  ByteIndexToCodePointIndex:Convert a given byte index to a codepoint index on a given string.Search:  ByteIndexOfAnyByte:Find the first occurrence of any of a set of given bytes in a string and return its byte-based index.  CharIndexOfAnyCharUTF16:Find the first occurrence of any of a set of given chars in a UTF-16 string and return its char-based index.  IntIndexOfAnyIntUTF32:Find the first occurrence of any of a set of given ints in a UTF-32 string and return its int-based index.  IndexOfCodePoint:Find the first occurrence of a given codepoint in a string and return its codepoint-based index.  ByteIndexOfCodePoint:Find the first occurrence of a given codepoint in a string and return its byte-based index.  ByteIndexOfCodePointSet:Find the first occurrence of a codepoint contained in a given set in a string and return its byte-based index.  LastIndexOfCodePoint:Find the last occurrence of a given codepoint in a string and return its codepoint-based index.  LastByteIndexOfCodePoint:Find the last occurrence of a given codepoint in a string and return its byte-based index.  IndexOfString:Find the first occurrence of a given substring in a string and return its codepoint-based index.  ByteIndexOfString:Find the first occurrence of a given substring in a string and return its byte-based index.  LastIndexOfString:Find the last occurrence of a given substring in a string and return its codepoint-based index.  LastByteIndexOfString:Find the last occurrence of a given substring in a string and return its byte-based index.Combining:  Concat:Concatenate two strings.  Substring:Create a substring from a given string, bounded by a codepoint-based offset and length.  SubstringByteIndex:Create a substring from a given string, bounded by a byte-based offset and length.  Repeat:Repeat a given string n times.InstantiationA TruffleString can be created from a codepoint, a number, a primitive array or a java.lang.String.Strings of any encoding can be created with TruffleString.FromByteArrayNode, which expects a byte array containing the already encoded string.This operation can be non-copying, by setting the copy parameter to false.Important: TruffleStrings will assume the array content to be immutable, do not modify the array after passing it to the non-copying variant of this operation.import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;abstract static class SomeNode extends Node {    @Specialization    static TruffleString someSpecialization(            @Cached TruffleString.FromByteArrayNode fromByteArrayNode) {        byte[] array = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};        return fromByteArrayNode.execute(array, 0, array.length, TruffleString.Encoding.UTF_8, false);    }}For easier creation of UTF-16 and UTF-32 strings independent of the system’s endianness, TruffleString provides TruffleString.FromCharArrayUTF16Node and TruffleString.FromIntArrayUTF32Node.TruffleString may also be created via TruffleStringBuilder, which is TruffleString’s equivalent to java.lang.StringBuilder.TruffleStringBuilder provides the following operations:  AppendByte:Append a single byte to a string builder.  AppendCharUTF16:Append a single char to a UTF-16 string builder.  AppendCodePoint:Append a single codepoint to string builder.  AppendIntNumber:Append an integer number to a string builder.  AppendLongNumber:Append a long number to a string builder.  AppendString:Append a TruffleString to a string builder.  AppendSubstringByteIndex:Append a substring, defined by a byte-based offset and length, to a string builder.  AppendJavaStringUTF16:Append a Java String substring, defined by a char-based offset and length, to a string builder.  ToString:Create a new TruffleString from a string builder.See the below example:import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;import com.oracle.truffle.api.strings.TruffleStringBuilder;abstract static class SomeNode extends Node {    @Specialization    static TruffleString someSpecialization(            @Cached TruffleStringBuilder.AppendCharUTF16Node appendCharNode,            @Cached TruffleStringBuilder.AppendJavaStringUTF16Node appendJavaStringNode,            @Cached TruffleStringBuilder.AppendIntNumberNode appendIntNumberNode,            @Cached TruffleStringBuilder.AppendStringNode appendStringNode,            @Cached TruffleString.FromCharArrayUTF16Node fromCharArrayUTF16Node,            @Cached TruffleStringBuilder.AppendCodePointNode appendCodePointNode,            @Cached TruffleStringBuilder.ToStringNode toStringNode) {        TruffleStringBuilder sb = TruffleStringBuilder.create(TruffleString.Encoding.UTF_16);        sb = appendCharNode.execute(sb, &#39;a&#39;);        sb = appendJavaStringNode.execute(sb, &quot;abc&quot;, /* fromIndex: */ 1, /* length: */ 2);        sb = appendIntNumberNode.execute(sb, 123);        TruffleString string = fromCharArrayUTF16Node.execute(new char[]{&#39;x&#39;, &#39;y&#39;}, /* fromIndex: */ 0, /* length: */ 2);        sb = appendStringNode.execute(sb, string);        sb = appendCodePointNode.execute(sb, &#39;z&#39;);        return toStringNode.execute(sb); // string content: &quot;abc123xyz&quot;    }}EncodingsEvery TruffleString is encoded in a specific internal encoding, which is set during instantiation.TruffleString is fully optimized for the following encodings:  UTF-8  UTF-16LE  UTF-16BE  UTF-32LE  UTF-32BE  US-ASCII  ISO-8859-1  BYTESMany other encodings are supported, but not fully optimized.To use them, they must be enabled by setting needsAllEncodings = true in the Truffle language registration.A TruffleString’s internal encoding is not exposed.Instead of querying a string’s encoding, languages should pass an expectedEncoding parameter to all methods where the string’s encoding matters (which is almost all operations).This allows re-using string objects when converting between encodings, if a string is byte-equivalent in both encodings.A string can be converted to a different encoding using SwitchEncodingNode, as shown in the following example:import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;import com.oracle.truffle.api.strings.TruffleStringBuilder;abstract static class SomeNode extends Node {    @Specialization    static void someSpecialization(            @Cached TruffleString.FromJavaStringNode fromJavaStringNode,            @Cached TruffleString.ReadByteNode readByteNode,            @Cached TruffleString.SwitchEncodingNode switchEncodingNode,            @Cached TruffleString.ReadByteNode utf8ReadByteNode) {        // instantiate a new UTF-16 string        TruffleString utf16String = fromJavaStringNode.execute(&quot;foo&quot;, TruffleString.Encoding.UTF_16);        // read a byte with expectedEncoding = UTF-16.        // if the string is not byte-compatible with UTF-16, this method will throw an IllegalArgumentException        System.out.printf(&quot;%x%n&quot;, readByteNode.execute(utf16String, /* byteIndex */ 0, TruffleString.Encoding.UTF_16));        // convert to UTF-8.        // note that utf8String may be reference-equal to utf16String!        TruffleString utf8String = switchEncodingNode.execute(utf16String, TruffleString.Encoding.UTF_8);        // read a byte with expectedEncoding = UTF-8        // if the string is not byte-compatible with UTF-8, this method will throw an IllegalArgumentException        System.out.printf(&quot;%x%n&quot;, utf8ReadByteNode.execute(utf8String, /* byteIndex */ 0, TruffleString.Encoding.UTF_8));    }}Byte-equivalency between encodings is determined with string compaction on UTF-16 and UTF-32, so e.g. a compacted UTF-16 String is byte-equivalent to ISO-8859-1, and if all of its characters are in the ASCII range (see CodeRange), it is also byte-equivalent to UTF-8.To check if your code is switching encodings properly, run your unit tests with the system property truffle.strings.debug-strict-encoding-checks=true.This disables re-using string objects when switching encodings, and makes encoding checks more strict: all operations working on a single string will enforce an exact match,whereas operations working on two strings will still allow byte-equivalent re-interpretations.All TruffleString operations with more than one string parameter require the strings to be in an encoding compatible with the result encoding.So either the strings need to be in the same encoding, or the caller must ensure that both Strings are compatible with the resulting encoding.This enable callers which already know the SwitchEncodingNodes would be noops to just skip them for footprint reasons.import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;import com.oracle.truffle.api.strings.TruffleStringBuilder;abstract static class SomeNode extends Node {    @Specialization    static boolean someSpecialization(            TruffleString a,            TruffleString b,            @Cached TruffleString.SwitchEncodingNode switchEncodingNodeA,            @Cached TruffleString.SwitchEncodingNode switchEncodingNodeB,            @Cached TruffleString.EqualNode equalNode) {        TruffleString utf8A = switchEncodingNodeA.execute(a, TruffleString.Encoding.UTF_8);        TruffleString utf8B = switchEncodingNodeB.execute(b, TruffleString.Encoding.UTF_8);        return equalNode.execute(utf8A, utf8B, TruffleString.Encoding.UTF_8);    }}For optimal performance, the expectedEncoding parameter of TruffleString nodes should be partial-evaluation-constant whenever possible. TruffleString nodes don’t profile this parameter, since most languages use a single constant encoding.String PropertiesTruffleString exposes the following properties:  byteLength: The string’s length in bytes, exposed via the byteLength method.  codePointLength: The string’s length in codepoints, exposed via CodePointLengthNode.  isValid: Can be queried via IsValidNode to check whether the string is encoded correctly.  codeRange: Provides coarse information about the string’s content, exposed via GetCodeRangeNode. This property canhave the following values:          ASCII: All codepoints in this string are part of the Basic Latin Unicode block, also known as ASCII (0x00 -0x7f).      LATIN-1: All codepoints in this string are part of the ISO-8859-1 character set (0x00 - 0xff), which isequivalent to the union of the Basic Latin and the Latin-1 Supplement Unicode block. At least one codepoint in thestring is greater than 0x7f. Only applicable to ISO-8859-1, UTF-16 and UTF-32.      BMP: All codepoints in this string are part of the Unicode Basic Multilingual Plane (BMP) (0x0000 - 0xffff). Atleast one codepoint in the string is greater than 0xff. Only applicable to UTF-16 and UTF-32.      VALID: This string is encoded correctly, and contains at least one codepoint outside the other applicable coderanges (e.g. for UTF-8, this means there is one codepoint outside the ASCII range, and for UTF-16 this means thatthere is one codepoint outside the BMP range).      BROKEN: This string is not encoded correctly. No further information about its contents can be determined.        hashCode: The string’s hash code, exposed via HashCodeNode. The hash code is dependent on the string’s encoding;strings must always be converted to a common encoding before comparing their hash codes!See the below example how to query all properties exposed by TruffleString:import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;abstract static class SomeNode extends Node {    @Specialization    static TruffleString someSpecialization(            TruffleString string,            @Cached TruffleString.CodePointLengthNode codePointLengthNode,            @Cached TruffleString.IsValidNode isValidNode,            @Cached TruffleString.GetCodeRangeNode getCodeRangeNode,            @Cached TruffleString.HashCodeNode hashCodeNode) {        System.out.println(&quot;byte length: &quot; + string.byteLength(TruffleString.Encoding.UTF_8));        System.out.println(&quot;codepoint length: &quot; + codePointLengthNode.execute(string, TruffleString.Encoding.UTF_8));        System.out.println(&quot;is valid: &quot; + isValidNode.execute(string));        System.out.println(&quot;code range: &quot; + getCodeRangeNode.execute(string));        System.out.println(&quot;hash code: &quot; + hashCodeNode.execute(string, TruffleString.Encoding.UTF_8));    }}String Equality and ComparisonTruffleString objects should be checked for equality using EqualNode.Just like HashCodeNode, the equality comparison is sensitive to the string’s encoding, so before any comparison, strings should always be converted to a common encoding. Object#equals(Object) behaves analogous to EqualNode, but since this method does not have an expectedEncoding parameter, it will determine the string’s common encoding automatically.If the string’s encodings are not equal, TruffleString will check whether one string is binary-compatible to the other string’s encoding, and if so, match their content. Otherwise, the strings are deemed not equal, no automatic conversion is applied.Note that since TruffleString’s hashCode and equals methods are sensitive to string encoding, TruffleString objects must always be converted to a common encoding before, e.g., using them as keys in a HashMap.TruffleString also provides three comparison nodes CompareBytesNode, CompareCharsUTF16Node, and CompareIntsUTF32Node, to compare strings respectively byte-by-byte, char-by-char, and int-by-int.ConcatenationConcatenation is done via ConcatNode.This operation requires both strings to be in expectedEncoding, which is also the encoding of the resulting string. Lazy concatenation is supported via the lazy parameter.When two strings are concatenated lazily, the allocation and initialization of the new string’s internal array is delayed until another operation requires direct access to that array.Materialization of such “lazy concatenation strings” can be triggered explicitly with a MaterializeNode.This is useful to do before accessing a string in a loop, such as in the following example:import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;abstract static class SomeNode extends Node {    @Specialization    static TruffleString someSpecialization(            TruffleString utf8StringA,            TruffleString utf8StringB,            @Cached TruffleString.ConcatNode concatNode,            @Cached TruffleString.MaterializeNode materializeNode,            @Cached TruffleString.ReadByteNode readByteNode) {        // lazy concatenation        TruffleString lazyConcatenated = concatNode.execute(utf8StringA, utf8StringB, TruffleString.Encoding.UTF_8, /* lazy */ true);        // explicit materialization        TruffleString materialized = materializeNode.execute(lazyConcatenated, TruffleString.Encoding.UTF_8);        int byteLength = materialized.byteLength(TruffleString.Encoding.UTF_8);        for (int i = 0; i &amp;lt; byteLength; i++) {            // string is guaranteed to be materialized here, so no slow materialization code can end up in this loop            System.out.printf(&quot;%x%n&quot;, readByteNode.execute(materialized, i, TruffleString.Encoding.UTF_8));        }    }}SubstringsSubstrings can be created via SubstringNode and SubstringByteIndexNode, which use codepoint-based and byte-based indices, respectively.Substrings can also be lazy, meaning that no new array is created for the resulting string, but instead the parent string’s array is re-used and just accessed with the offset and length passed to the substring node.Currently, a lazy substring’s internal array is never trimmed (i.e. replaced by a new array of the string’s exact length).Note that this behavior effectively creates a memory leak whenever a lazy substring is created.An extreme example where this could be problematic: given a string that is 100 megabyte in size, any lazy substring created from this string will keep the 100 megabyte array alive, even when the original string is freed by the garbage collector.Use lazy substrings with caution.Interoperability with java.lang.StringTruffleString provides FromJavaStringNode for converting a java.lang.String to TruffleString.To convert from TruffleString to java.lang.String, use a ToJavaStringNode.This node will internally convert the string to UTF-16, if necessary, and create a java.lang.String from that representation.Object#toString() is implemented using the uncached version of ToJavaStringNode and should be avoided on fast paths.import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;abstract static class SomeNode extends Node {    @Specialization    static void someSpecialization(            @Cached TruffleString.FromJavaStringNode fromJavaStringNode,            @Cached TruffleString.SwitchEncodingNode switchEncodingNode,            @Cached TruffleString.ToJavaStringNode toJavaStringNode,            @Cached TruffleString.ReadByteNode readByteNode) {        TruffleString utf16String = fromJavaStringNode.execute(&quot;foo&quot;, TruffleString.Encoding.UTF_16);        TruffleString utf8String = switchEncodingNode.execute(utf16String, TruffleString.Encoding.UTF_8);        System.out.println(toJavaStringNode.execute(utf8String));    }}TruffleString also exposes #toStringDebug() for debugging purposes.Do not use this method for anything other than debugging, as its return value is unspecified and may change at any time.Differences to java.lang.StringThe following items should be considered when switching from java.lang.String to TruffleString:  The static overhead of TruffleString instances is larger than that of java.lang.String objects. A TruffleString objectcontains 2 pointers fields, 4 int fields and 4 byte fields, which will usually result in a total object size of 40bytes (object header of 12 bytes, 4 bytes per pointer with compressed oops, 8-byte memory alignment). Ajava.lang.String object contains one pointer field, one int field and one byte field, which in the same conditionsresults in a total object size of 24 bytes. This difference in memory footprint may negatively impact some cases wherelots of small strings are generated.  TruffleString does string compaction just like java.lang.String.  If your language needs to convert strings to other encodings, e.g. UTF-8, which is very common in web applications,TruffleString can turn this operation into a no-op if the string does now contain special characters. For example,ASCII-only strings can be re-interpreted as almost any encoding, and converting an ASCII-only UTF-16 string to UTF-8is a no-op.In cases where transcoding a string is unavoidable, TruffleStrings will cache the transcoded string in the originalstring, so transcoding is only done once per string and encoding.  In order to use 3rd party libraries, TruffleString object will have to be converted to java.lang.String and back. Inorder to make this as cheap as possible, TruffleString re-uses Java String’s internal byte arrays when converting fromjava.lang.String to TruffleString, and caches Java Strings created from TruffleString objects in the object itself.  TruffleString offers additional features not present in java.lang.String:          Lazy concatenation and string views, which can significantly decrease the amount of array-copy operations yourlanguage may have to do.      String views into native memory, completely avoiding the need to copy native memory into Java arrays before usingit.      String content classification via the codeRange property, which allows specializations on strings that areASCII-only et cetera. This can reduce the complexity of some string operations significantly.        The performance of all TruffleString operations should be on par with or better than their java.lang.String-counterparts.Codepoint IteratorsTruffleString provides TruffleStringIterator as a means of iterating over a string’s codepoints.This method should be preferred over using CodePointAtIndexNode in a loop, especially on variable-width encodings such as UTF-8, since CodePointAtIndexNode may have to re-calculate the byte index equivalent of the given codepoint index on every call.See the example:import com.oracle.truffle.api.dsl.Cached;import com.oracle.truffle.api.strings.TruffleString;import com.oracle.truffle.api.strings.TruffleStringIterator;abstract static class SomeNode extends Node {    @Specialization    static void someSpecialization(            TruffleString string,            @Cached TruffleString.CreateCodePointIteratorNode createCodePointIteratorNode,            @Cached TruffleStringIterator.NextNode nextNode,            @Cached TruffleString.CodePointLengthNode codePointLengthNode,            @Cached TruffleString.CodePointAtIndexNode codePointAtIndexNode) {        // iterating over a string&#39;s codepoints using TruffleStringIterator        TruffleStringIterator iterator = createCodePointIteratorNode.execute(string, TruffleString.Encoding.UTF_8);        while (iterator.hasNext()) {            System.out.printf(&quot;%x%n&quot;, nextNode.execute(iterator));        }        // suboptimal variant: using CodePointAtIndexNode in a loop        int codePointLength = codePointLengthNode.execute(string, TruffleString.Encoding.UTF_8);        for (int i = 0; i &amp;lt; codePointLength; i++) {            // performance problem: codePointAtIndexNode may have to calculate the byte index corresponding            // to codepoint index i for every loop iteration            System.out.printf(&quot;%x%n&quot;, codePointAtIndexNode.execute(string, i, TruffleString.Encoding.UTF_8));        }    }}Mutable StringsTruffleString also provides a mutable string variant called MutableTruffleString, which is also accepted in all nodes of TruffleString. MutableTruffleString is not thread-safe and allows overwriting bytes in its internal byte array or native pointer via WriteByteNode.The internal array or native pointer’s content may also be modified externally, but the corresponding MutableTruffleString must be notified of this via notifyExternalMutation().MutableTruffleString is not a Truffle interop type, and must be converted to an immutable TruffleString via TruffleString.AsTruffleString before passing a language boundary.",
          "url": " /latest/graalvm-as-a-platform/language-implementation-framework/TruffleStrings/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-urlprotocols":  {
          "title": "URL Protocols in Native Image",
          "content": "URL Protocols in Native ImageURL Protocols in Native Image can be divided into three classes:  supported and enabled by default  supported and disabled by default  HTTPS supportURL Protocols that are supported and enabled by default will be included into every generated native binary.Currently, file and resource are the only supported URL protocols enabled by default.There are URL Protocols that are supported but not enabled by default when building a native binary.They must be enabled during build time by using the --enable-url-protocols=&amp;lt;protocols&amp;gt; option on the command line.The option accepts a list of comma-separated protocols.The rationale behind enabling protocols on-demand is that you can start with a minimal binary and add features as you need them.This way your binary will only include the features you use, which helps keep the overall size small.Currently http and https are the only URL protocols that are supported and can be enabled on demand.They can be enabled using the --enable-http and --enable-https command-line options.HTTPS SupportSupport for the https URL protocol relies on the Java Cryptography Architecture (JCA) framework.Thus enabling https will add the code required by the JCA to the generated binary, including statically linked native libraries that the JCA may depend on.See the documentation on security services for more details.No other URL protocols are currently tested.They can still be enabled using --enable-url-protocols=&amp;lt;protocols&amp;gt;, however they might not work as expected.Related Documentation  Native Image Build Configuration",
          "url": " /latest/reference-manual/native-image/dynamic-features/URLProtocols/"
          },
          
          "latest-reference-manual-native-image-workshops":  {
          "title": "Interactive Labs and Workshops",
          "content": "Interactive Labs and WorkshopsInteractive LabsConsider running interactive workshops in Oracle Cloud Infrastructure to get some practical experience. The interactive cloud platform provides you with a temporary account for the time you run a lab with required cloud resources (a virtual machine, Oracle Linux, storage, and so on).This means you can try Native Image without downloading any additional software to your computer.Go to Luna Labs and search for “Native Image”. The following labs are available:  GraalVM Native Image Quick Start: This lab is for developers new to Native Image who are keen to start building cloud native Java applications.  GraalVM, Reflection and Native Image: This lab shows how to preconfigure the native-image builder when reflection is used, and make your Java application compatible with ahead-of-time compilation using Native Image.  GraalVM Native Image, Spring and Containerisation: This lab shows you how to package a Spring Boot application into a native executable; containerise it; shrink the footprint even more by creating small a Distroless container Image.  Optimize Cloud Native Java Apps with Oracle GraalVM PGO: This lab shows how to run a Java Microbenchmark Harness (JMH) benchmark as a native executable, built with GraalVM Native Image, and then optimize it for higher throughput using Profile-Guided Optimization (PGO).  GraalVM Native Build Tools, for Maven: This lab shows you how to use the GraalVM Native Build Tools to easily build a native executable of your application using Maven. It is aimed at developers with the knowledge of Java.WorkshopsHave a look at GraalVM Workshops and Tutorials collection on GitHub. There you can find the workshops intended to work on your own device (laptop, server). Each workshop begins with prerequisites that you need to have installed.This repository is continually updated with new workshops. Check-in regularly to keep up to date.",
          "url": " /latest/reference-manual/native-image/workshops/"
          },
          
          "latest-reference-manual-native-image-guides-access-environment-variables":  {
          "title": "Access Environment Variables in a Native Executable at Runtime",
          "content": "Access Environment Variables in a Native Executable at RuntimeA native executable accesses environment variables in the same way as a regular Java application.Run a DemoFor example, run a Java application that iterates over your environment variables and prints out the ones that contain the String of characters passed as a command-line argument.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Save the following source code in a file named EnvMap.java:     import java.util.Map; public class EnvMap {     public static void main (String[] args) {         var filter = args.length &amp;gt; 0 ? args[0] : &quot;&quot;;         Map&amp;lt;String, String&amp;gt; env = System.getenv();         for (String envName : env.keySet()) {             if(envName.contains(filter)) {                 System.out.format(&quot;%s=%s%n&quot;,                                 envName,                                 env.get(envName));             }         }     } }    Compile the file and build a native executable, as follows:     javac EnvMap.java     native-image EnvMap    Run the native application and pass a command-line argument, such as “HELLO”. There should be no output, because there is no environment variable with a matching name.     ./envmap HELLO &amp;lt;no output&amp;gt;    Create a new environment variable named “HELLOWORLD” and give it the value “Hello World!”. (If you are using a bash shell, follow the example below.) Now, run the native executable again—it will correctly print out the name and value of the matching environment variable(s).     export HELLOWORLD=&#39;Hello World!&#39;     ./envmap HELLO    You should receive the expected output:     HELLOWORLD=Hello World!  Related Documentation  Native Image Build Configuration",
          "url": " /latest/reference-manual/native-image/guides/access-environment-variables/"
          },
          
          "latest-reference-manual-native-image-guides-add-logging-to-native-executable":  {
          "title": "Add Logging to a Native Executable",
          "content": "Add Logging to a Native ExecutableBy default, a native executable produced by Native Image supports logging via the java.util.logging.* API.Default Logging ConfigurationThe default logging configuration in a native executable is based on the logging.properties file found in the JDK.This file configures a java.util.logging.ConsoleHandler which will only show messages at the INFO level and above.Custom logging configuration can be loaded either at build time or at run time as described below.If you require additional logging handlers, you must register the corresponding classes for reflection.For example, if you use java.util.logging.FileHandler, then provide the following reflection configuration in the META-INF/native-image/reachability-metadata.json file:{    &quot;name&quot; : &quot;java.util.logging.FileHandler&quot;,    &quot;methods&quot; : [      { &quot;name&quot; : &quot;&amp;lt;init&amp;gt;&quot;, &quot;parameterTypes&quot; : [] }    ]  }For more details, see Reflection Support.The usage of the logger is shown in the following example:      Save the following Java code into a file named LoggerRunTimeInit.java, and compile it:     import java.io.IOException; import java.util.logging.Level; import java.util.logging.LogManager; import java.util.logging.Logger;     public class LoggerRunTimeInit {     public static void main(String[] args) throws IOException {         LogManager.getLogManager().readConfiguration(LoggerRunTimeInit.class.getResourceAsStream(&quot;/logging.properties&quot;));         Logger logger = Logger.getLogger(LoggerRunTimeInit.class.getName());         logger.log(Level.WARNING, &quot;Danger, Will Robinson!&quot;);     } }     javac LoggerRunTimeInit.java        Download the logging.properties resource file and save it in the same directory as LoggerRunTimeInit.java.        Build and run the native executable     native-image LoggerRunTimeInit -H:IncludeResources=&quot;logging.properties&quot;     ./loggerruntimeinit    It should produce output that looks similar to:     WARNING: Danger, Will Robinson! [Wed May 18 17:22:40 BST 2022]    In this case, the logging.properties file must be available for runtime processing and therefore needs to be registered in the META-INF/native-image/reachability-metadata.json file. For more details on how to do this, see Use of Resources in a Native Executable.  Related Documentation  Reachability Metadata: Reflection  Native Image Build Configuration",
          "url": " /latest/reference-manual/native-image/guides/add-logging-to-native-executable/"
          },
          
          "java-advantages":  {
          "title": "Advantages for Java",
          "content": "◀BackAccelerating Java performanceGraalVM’s high-performance JIT compiler generates optimized native machine code that runs faster, produces less garbage, and uses less CPU thanks to a battery of advanced compiler optimizations and aggressive and sophisticated inlining techniques.The end results are applications that run faster and consume fewer resources—reducing cloud and infrastructure costs.Figure 1. Speedup vs OpenJDK 11The size of the speedup depends on the type of workload.On the Renaissance benchmark suite, which “contains a range of modern workloads, comprising of various popular systems, frameworks and applications made for the JVM”, Oracle GraalVM achieves a geomean speedup of 1.55x over OpenJDK 8 and similar results for OpenJDK 11.Oracle Cloud InfrastructureBy running the Oracle Cloud Infrastructure (OCI) Monitoring (telemetry) service on Oracle GraalVM, a 10% transaction processing rate increase was achieved along with a 25% reduction in garbage collection times, a 17% reduction in GC pause times, and a 5% reduction CPU utilization.These improvements have significant benefits for a memory intensive service that routinely processes tens of millions of data points, ingests billions of metrics, and serves millions of requests coming from an ever growing collection of OCI service offerings.Figure 2. OCI Monitoring Service Throughput (transaction per second)Quick startLower infrastructure costsHigher application performance and lower CPU and memory usage are goals every developer strives for.These goals are definitely laudable, and achieving them is easier with GraalVM, but the real value of these improvements is a reduction in the cost to run an application in production.Faster applications with lower resource requirements translate into fewer servers required to deliver a given service, and fewer servers means lower monthly cloud bills and lower capital and operating costs for on premises deployments.The math is straightforward.Even with no reduction in resource requirements, with just a ~11% improvement in throughput, 9 servers can do what required 10 before.That is one less cloud server to pay for or one less datacenter server to buy and maintain.Oracle GraalVM was the performance choice for our Dell EMC Servers. Java workload analysis and SPECjbb®2015 benchmark improving max-jOPS results by almost 8%.— Kurtis Bowman, Director of Architecture, Server Office of the CTO, Dell EMCSomething to Tweet AboutTwitter is one of the most popular social media services in the world running a platform used by millions of users around the globe daily.To keep costs down and performance up, Twitter relies on GraalVM to run core services like Tweet, Social, and News. With the efficiency of the GraalVM JIT compiler, Twitter is able to meet their throughput targets with fewer servers, resulting in significant savings.Being able to see 8–11 percent performance improvements on the same hardware without having to change the underlying code is a once-in-a-lifetime event, leading to substantial cost savings and future flexibility for Twitter.— Chris Thalinger, Staff Software Engineer, TwitterQuick startBetter performance with no code changesWhile the OpenJDK project moves forward with the 6-month release cadence, which offers time-based release model where features get in whenever they are ready, a large part of the Java ecosystem is still using Java 8 and Java 11 in production.GraalVM’s dedication to improving the Java ecosystem comes with support for those major versions which are the most popular.GraalVM includes a compatible JDK and currently offers downloads based on Java 8 or Java 11.To use GraalVM to speed up Java applications, build native executables with the Native Image feature, or incorporate libraries from other languages, you do not have to undergo complex migrations to the latest OpenJDK release.Migrating services to GraalVM mostly consists of replacing the JDK downloads or base container images with the GraalVM based ones without code changes or needing to leverage new language features!Quick startEqually excellent developer productivityOne of the best features of GraalVM is its compatibility with all the tools in the Java ecosystem.GraalVM can run Java applications offering better performance without code changes or any learning curve for developers.GraalVM fits into your workflow, being a compatible JDK it not only runs the applications you are working on, but the Java tools that help you! GraalVM works in your debugger, works with your build tools, it works within your favourite IDE, you can migrate your continuous integration environment to it, run your issue tracker on it and all other Java services you are using.You do not even have to be a Java developer! If other JVM languages are your cup of productivity, that is okay. From Kotlin, to Clojure, to Scala, GraalVM can help you run them all with excellent performance too.GraalVM merges the power of the Java ecosystem and community with a more powerful JDK distribution for the best of all worlds.Quick startSupported by industry-leading Java application frameworksSupported by industry-leading Java application frameworks, GraalVM is often cited as the most exciting innovation in the Java ecosystem.For example, the ability to compile applications into native executables with the Native Image technology revolutionises cloud deployments for Java applications.It is especially important for microservices where individual services are either neatly packed in environments constrained by memory or quickly become a major part of the cloud cost.Luckily, with GraalVM you do not have to rewrite your applications in Go to succeed in the cloud.Most major Java application and microservice frameworks are designed with GraalVM Native Image in mind or are working on adding first-class support.Micronaut, Helidon, Quarkus, or Spring Boot for microservices, PicoCLI for command line applications – whichever task you are facing, there’s a GraalVM Native Image compatible framework available to make your job easier.Quick startExpanding the Java ecosystemThe Java Virtual Machine (JVM) makes it possible to run Java programs on everything from small embedded devices to mainframes.It is a high-performance runtime that abstracts away the details of underlying hardware and operating system platforms to enable code portability.But it turns out the JVM does not actually know anything about the Java language itself as it executes programs compiled to the intermediate Java bytecode format.This means that any language that can be compiled to Java bytecode can be run on the JVM, for example, Scala, Kotlin, and Clojure.However, there are many popular languages that do not compile to Java bytecodes and cannot take advantage of the benefits provided by the JVM and the performance benefits of just-in-time compilation.But thanks to the innovative Truffle framework, GraalVM does support the execution of a number of popular programming languages including JavaScript, Python, and WebAssembly on the JVM.GraalVM and Truffle do not just make it possible to run non-Java bytecode programs on the JVM, Truffle also makes it possible for these languages to benefit from GraalVM’s advanced optimizing compiler technology to run faster and leaner — just like Java applications running on GraalVM.In all cases GraalVM Truffle languages perform as fast as, and typically many times faster, on the JVM than they do when running on their original runtimes.Breaking Down WallsIn addition to GraalVM being able to run programs written in a number of languages, it is also possible to run programs that use more than one!There are thousands of useful Node.js packages, Python libraries, and Java libraries that can be used by any of the languages supported by GraalVM.This enables use cases like Java microservices that incorporate Python machine learning capabilities or JavaScript programs that use R for statistical data analysis.GraalVM’s multilingual support makes it possible for developers with different language and domain expertise to collaborate.For example, the Dutch National Police used GraalVM to integrate R code into Spring Boot web services written in Java and Scala.This allowed their data scientists to write code in R to perform data analysis while their Java and Scala developers built out services that interacted with Apache Kafka.Embedding R code in a Scala/JVM project can be an excellent way to use the powerful data processing packages accessible in R… This means you (or your Data Scientist) can use a specialized editor (e.g. RStudio) to create the R side of your functionality, while you can use your own favourite editor for the JVM side (e.g., IntelliJ).— Nathan Perdijk, Scala Developer, CodestarQuick start",
          "url": " /java/advantages/"
          },
          
          "community-advisory-board":  {
          "title": "GraalVM Project Advisory Board",
          "content": "GraalVM Project Advisory BoardWe are announcing the establishment of the GraalVM Project Advisory Board — an advisory committee, composed of key project contributors and partners in the ecosystem with a shared goal of driving the GraalVM project forward. Such organizations can nominate their Representative for the Board. The Representative will act as the main contact point for all project-related matters associated with their company.The Advisory Board Goals  Discuss community engagement and contributor interaction;  Provide cumulative feedback from the community and partner ecosystem;  Discuss ways to drive project awareness and adoption.The Board will meet at least every six months via video call and once per year in person. Board meetings may include additional attendees contributing to specific topics of interest. A summary of the discussions will be published on the project website.Advisory Board Members  Aleksei Voitylov, BellSoft. Works on bringing musl libc support to GraalVM and enhancing GraalVM on ARM platforms.  Brian Clozel, Broadcom. Works on Spring Framework, Spring GraphQL, and Spring Boot.  Bruno Caballero, Microdoc. Works on GraalVM integrations in the embedded space.  Johan Vos, Gluon. Works on the JavaFX and mobile/embedded platform support for GraalVM Native Image.  Kevin Menard, Shopify. Contributes to TruffleRuby – GraalVM Ruby implementation.  Max Rydahl Andersen, Red Hat. Develops Quarkus – a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best-of-breed Java libraries and standards.  Michael Simons, Neo4j. Works on the Neo4j integration with GraalVM to support polyglot dynamic languages for user-defined procedures.  Paul Hohensee, Amazon. Interested in GraalVM Community Edition, GraalVM Native Image, and AWS Lambda on GraalVM.  Sandra Ahlgrimm, Microsoft. Interested in GraalVM Native Image, particularly for running Java in the cloud.  San-Hong Li, Alibaba. Contributes to the project and share their experience with the community.  Thomas Wuerthinger, Oracle. Vice President of GraalVM Development at Oracle.New membersIf your organization would like to join the GraalVM project advisory board, please let us know. We are open to new members that align with the board’s goals and mission.Meeting notesMeeting notes are published after each meeting within five days. See the previous notes below.September 2024 MeetingIn-person meeting in ZurichApril 2024 MeetingSome of the topics discussed:  Project updates  CE releases and community backports  Governance  Open pull requests  Graal Vulnerability GroupView full meeting notes →September 2023 MeetingIn-person meeting in ZurichJanuary 2023 MeetingSome of the topics discussed:  Project updates  Release cadence change  Open PRs that require attention  Project governance, committer and reviewer roles  ParallelGC update from BellSoft  Project Leyden and Native ImageView full meeting notes →September 2022 MeetingIn-person meeting in ZurichMay 2022 MeetingSome of the topics discussed:  Project updates, recent and upcoming releases  Open PRs that require attention  Project roles  Project Leyden and Native ImageView full meeting notes →February 2022 MeetingSome of the topics discussed:  Project updates, 22.0 &amp;amp; 22.1 releases  Java 17 support in previous releases  ARM support  New GC implementations and improvements  Project Loom supportView full meeting notes →November 2021 MeetingSome of the topics discussed:  Project updates, 21.3 &amp;amp; 22.0 releases  New community survey going live  Open PRs that require attention  JVMCI support in different versions of JDKView full meeting notes →August 2021 MeetingSome of the topics discussed:  Project updates  New organization joined: BellSoft  Community contributions and project roles  Monitoring in Native Image: JFR and other tools  Native build tools  Performance improvements  Java versions support: 8/11/17View full meeting notes →May 2021 MeetingSome of the topics discussed:  Project updates  21.1 and 21.2 releases  Native Image memory usage in Java 8/11/11+  Memory usage during compilation  Plans for M1 builds  CI testingView full meeting notes →February 2021 MeetingSome of the topics discussed:  GraalVM Community Survey results  21.0 release and Java on Truffle  Project roadmap, upcoming features  Java versions support in GraalVM  RISC-V, SPARC, PowerPC support  CI automationView full meeting notes →November 2020 MeetingSome of the topics discussed:  Release schedule and project roadmap  GraalVM Developer survey  Platform support  GraalVM and OpenJDK  Autovectorization  mx, build instructionsView full meeting notes →August 2020 MeetingSome of the topics discussed:  Project updates and upcoming release;  Security collaboration group update;  Release process and supported platforms;  Ecosystem updates;  Advisory Board work evaluation;  Contributing and CI.View full meeting notes  →May 2020 MeetingSome of the topics discussed:  Project updates and upcoming release;  Security collaboration group: draft charter and further steps;  Release process and backporting;  Release roadmap updates;  Ecosystem updates, project Leyden;  Possibility of adding committer/reviewer roles to the project.View full meeting notes →February 2020 MeetingSome of the topics discussed:  The goals of the Advisory Board;  Community contributions and ways to support contributors;  Testing and build process;  Possibility to create a security collaboration group;  Enhancement requests.View full meeting notes →",
          "url": " /community/advisory-board/"
          },
          
          "docs-archives":  {
          "title": "Archived GraalVM Documentation",
          "content": "",
          "url": " /docs/archives/"
          },
          
          "graalvm-brand-guidelines":  {
          "title": "GraalVM Brand Guidelines",
          "content": "",
          "url": " /graalvm-brand-guidelines/"
          },
          
          "graalvm-brand-guidelines-mascot":  {
          "title": "GraalVM Community Mascot",
          "content": "",
          "url": " /graalvm-brand-guidelines/mascot/"
          },
          
          "latest-reference-manual-native-image-guides-build-and-run-native-executable-with-jfr":  {
          "title": "Build and Run Native Executables with JFR",
          "content": "Build and Run Native Executables with JFRJDK Flight Recorder (JFR) is a tool for collecting diagnostic and profiling data about a running Java application, built into the JVM.GraalVM Native Image supports JFR events and users can use the jdk.jfr.Event API with a similar experience to using JFR in the Java HotSpot VM.To collect JFR events when running a native executable, enable JFR support and JFR event recording as described in this guide.  Note: JFR event recording is not yet available with Native Image on Windows.Enable JFR Support and Record Events at RuntimeTo build a native executable with JFR events support, add the --enable-monitoring=jfr option when invoking the native-image tool, and then start JFR recording at runtime.Follow the steps below to practice building a native executable with JFR support and recording events at runtime.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Save the following code to the file named JFRDemo.java.     import jdk.jfr.Event; import jdk.jfr.Description; import jdk.jfr.Label; public class JFRDemo {   @Label(&quot;Hello World&quot;)   @Description(&quot;Build and run a native executable with JFR.&quot;)   static class HelloWorldEvent extends Event {       @Label(&quot;Message&quot;)       String message;   }   public static void main(String... args) {       HelloWorldEvent event = new HelloWorldEvent();       event.message = &quot;Hello, World!&quot;;       event.commit();   } }    This demo application consists of a simple class and JDK library classes. It creates an event, annotated with @Label from the jdk.jfr.* package. If you run this application, it will not print anything and just run that event.    Ccompile the application using the GraalVM JDK:     javac JFRDemo.java    It creates two class files: JFRDemo$HelloWorldEvent.classand JFRDemo.class.    Build a native executable with the VM inspection enabled:     native-image --enable-monitoring=jfr JFRDemo    The --enable-monitoring=jfr option enables features such as JFR that can be used to inspect the VM.    Run the executable and start recording:     ./jfrdemo -XX:StartFlightRecording=filename=recording.jfr    This command runs the application as a native executable. The -XX:StartFlightRecording option enables the built-in Flight Recorder and starts recording to a specified binary file, recording.jfr. Additionally, you can configure the log output for JFR by passing the -XX:FlightRecorderLogging runtime option.        Start VisualVM to view the contents of the recording file in a user-friendly way.        Go to File, then Add JFR Snapshot, browse recording.jfr, and open the selected file.Confirm the display name and click OK. Once opened, there are several options you can check (such as Monitoring, Threads, and Exceptions) but you are mostly interested in browsing events.It will look something like this:        Alternatively, you can view the contents of the recording file in the console window by running this command:     jfr print recording.jfr    It prints all the events recorded by Flight Recorder.  Related Documentation  Learn more about Native Image support for JFR events and how to further configure JFR recording and system logging.",
          "url": " /latest/reference-manual/native-image/guides/build-and-run-native-executable-with-jfr/"
          },
          
          "latest-reference-manual-native-image-guides-build-and-run-native-executable-with-remote-jmx":  {
          "title": "Build and Run Native Executables with Remote JMX",
          "content": "Build and Run Native Executables with Remote JMXRemote management using Java Management Extensions (JMX) is possible in native applications built with GraalVM Native Image.  Note: The feature is experimental.This guide covers the steps required to build, run, and interact with a native executable using JMX.It also shows you how to register a custom managed bean (MBean) with the JMX server and the additional steps required for it to work with Native Image.Currently Supported Features and LimitationsA JMX connection from a client to a remote MBean server is supported. The client, the server, or both may be a native executable.Only MXBeans, and standard user-defined MBeans, are supported. Dynamic and model MBeans are not supported because their management interfaces are defined at run time. Although remote management of MXBeans is supported, not all platform MXBean functionality is implemented or is applicable in a native executable. Additionally, to define and use standard MBeans, you must specify metadata configuration. This is further explained in this guide.Run a DemoPrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Create and navigate to a directory named jmx-test. Save the following code to a file named SimpleJmx.java. The application main() method registers a custom MBean, then loops endlessly, so you have time to inspect the process using VisualVM.     import javax.management.MBeanServer; import javax.management.ObjectName; import java.lang.management.ManagementFactory; public class SimpleJmx {     public static void main(String args[]) throws Exception {         ObjectName objectName = new ObjectName(&quot;com.jmx.test.basic:name=simple&quot;);         Simple simple = new Simple();         simple.setName(&quot;someName&quot;);         MBeanServer server = ManagementFactory.getPlatformMBeanServer();         server.registerMBean(simple, objectName);         while (true) {             Thread.sleep(1000);             System.out.println(&quot;JMX server running...&quot;);         }     }     public static interface SimpleMBean {         String getName();         void setName(String name);         String print();     }     static class Simple implements SimpleMBean {         private String name;         @Override         public String getName() {             return name;         }         @Override         public void setName(String name) {             this.name = name;         }         @Override         public String print() {             return &quot;Print output &quot; + name;         }     } }    Compile the application using the GraalVM JDK:     javac SimpleJmx.java    This creates SimpleJmx.class, SimpleJmx$Simple.class, and SimpleJmx$SimpleMBean.class files.    Add dynamic proxy configuration. JMX uses dynamic proxies, a dynamic feature of Java, to access MBeans. To be able to interact with the custom SimpleMBean at run time, you need to provide Native Image with additional dynamic-proxy metadata for the MBean interface. For this, create the META-INF/native-image directory in the current working directory (jmx-test). In the META-INF/native-image directory create a reachability-metadata.json file with the following contents:     {   &quot;reflection&quot;: [     {       &quot;type&quot;: {         &quot;proxy&quot;: [&quot;SimpleJmx$SimpleMBean&quot;]       }     }   ] }    Build a native executable with the VM inspection enabled:     native-image --enable-monitoring=jmxserver,jmxclient,jvmstat SimpleJmx    The --enable-monitoring=jmxserver option enables the JMX Server feature (to accept incoming connections). The --enable-monitoring=jmxclient option enables the JMX Client feature (to make outgoing connections). Both features can be used together, comma-separated, for example, --enable-monitoring=jmxserver,jmxclient.  The jvmstat option should also be included if you want to enable discovery by VisualVM and other JVMs: --enable-monitoring=jmxserver,jmxclient,jvmstat.    Run your native executable with JMX properties:     ./simplejmx -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=9996 -Dcom.sun.management.jmxremote.ssl=false    This starts the application as a simple JMX server, without password authentication or SSL using port 9996.  You can configure JMX to apply all the usual properties as shown in this guide, but this example uses a basic configuration for simplicity.  Now that the JMX server is running, inspect MBeans using VisualVM.Inspect MBeans Using VisualVM      Start VisualVM to view the managed beans in a user-friendly way.        Make sure you have the VisualVM-MBeans plugin installed (go to Tools, then Plugins, under Available Plugins, select VisualVM-MBeans, and click Install).        Go to the Applications tab and select the SimpleJmx process.From there you can select the MBeans tab.            In the MBeans tab, you can inspect the custom MBean you created earlier and perform operations on it.          To conclude, Native Image provides support for remote management using JMX.Users can enable the JMX agent in a native executable to monitor a client application running on a remote system.Related Documentation  Enabling and disabling JMX  Create Heap Dumps with VisualVM",
          "url": " /latest/reference-manual/native-image/guides/build-and-run-native-executable-with-remote-jmx/"
          },
          
          "latest-reference-manual-native-image-guides-build-java-modules-into-native-executable":  {
          "title": "Build Java Modules into a Native Executable",
          "content": "Build Java Modules into a Native ExecutableGraalVM Native Image supports the Java Platform Module System, introduced in Java 9, which means you can convert a modularized Java application into a native executable.The native-image tool accepts the module-related options such as --module (-m), --module-path (-p), --add-opens, --add-exports (same as for the java launcher). When such a module-related option is used, the native-image tool itself is used as a module too.In addition to supporting --add-reads and --add-modules, all module related options are considered prior to scanning the module path. This helps prevent class loading errors and allow for better module introspection at runtime.The command to build a native executable from a Java module is:native-image [options] --module &amp;lt;module&amp;gt;[/&amp;lt;mainclass&amp;gt;] [options]Run a DemoFollow the steps below to build a modular Java application into a native executable.For the demo, you will use a simple HelloWorld Java module gathered with Maven:├── hello│   └── Main.java│       &amp;gt; package hello;│       &amp;gt; │       &amp;gt; public class Main {│       &amp;gt;     public static void main(String[] args) {│       &amp;gt;         System.out.println(&quot;Hello from Java Module: &quot;│       &amp;gt;             + Main.class.getModule().getName());│       &amp;gt;     }│       &amp;gt; }│└── module-info.java    &amp;gt; module HelloModule {    &amp;gt;     exports hello;    &amp;gt; }PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Download or clone the demos repository and navigate to the directory native-image/build-java-modules/:     git clone https://github.com/graalvm/graalvm-demos     cd graalvm-demos/native-image/build-java-modules    Compile and package the project with Maven:     mvn clean package    Test running it on the GraalVM JDK:     java --module-path target/HelloModule-1.0-SNAPSHOT.jar --module HelloModule    Now build this module into a native executable:     native-image --module-path target/HelloModule-1.0-SNAPSHOT.jar --module HelloModule    It builds the modular Java application into a native executable called hellomodule in the project root directory that you can run:     ./hellomodule  Related Documentation  Learn more how you can access resources for a Java module at runtime.",
          "url": " /latest/reference-manual/native-image/guides/build-java-modules-into-native-executable/"
          },
          
          "latest-reference-manual-native-image-guides-build-native-executable-from-jar":  {
          "title": "Build a Native Executable from a JAR File",
          "content": "Build a Native Executable from a JAR FileYou can build a native executable from a class file, from a JAR file, or from a module.This guide demonstrates how to build a native executable from a JAR file.To build a native executable from a JAR file in the current working directory, use the following command:native-image [options] -jar jarfile [executable name]Run a DemoPrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.      Prepare the application.          Create a new Java project named “App”, for example in your favorite IDE or from your terminal, with the following structure:          | src  |   --com  |      -- example  |          -- App.java            Add the following Java code to the src/com/example/App.java file:          package com.example;  public class App {      public static void main(String[] args) {          String str = &quot;Native Image is awesome&quot;;          String reversed = reverseString(str);          System.out.println(&quot;The reversed string is: &quot; + reversed);      }      public static String reverseString(String str) {          if (str.isEmpty())              return str;          return reverseString(str.substring(1)) + str.charAt(0);      }  }        This is a small Java application that reverses a String using recursion.              Compile the application:     javac -d build src/com/example/App.java    This produces the file App.class in the build/com/example/ directory.    Create a runnable JAR file:     jar --create --file App.jar --main-class com.example.App -C build .    It will generate a runnable JAR file, named App.jar, in the project root directory. To view its contents, run the command:     jar tf App.jar    Create a native executable:     native-image -jar App.jar    It will produce a native executable in the project root directory. The default name of the executable will be the name of the JAR file (“App” in this case). It can be customized by either providing a custom name as a last argument (for example, native-image -jar App.jar executable_name), or by using -o executable_name before or after -jar jarfile, for example: native-image -jar App.jar -o executable_name.    Run the native executable:     ./App  The default behavior of native-image is aligned with the java command which means you can pass the -jar, -cp, -m  options to build with Native Image as you would normally do with java.For example, java -jar App.jar someArgument becomes native-image -jar App.jar and ./App someArgument.Related Documentation  Hands-on Labs: GraalVM Native Image Quick Start  Build Java Modules into a Native Executable",
          "url": " /latest/reference-manual/native-image/guides/build-native-executable-from-jar/"
          },
          
          "latest-reference-manual-native-image-guides-build-native-shared-library":  {
          "title": "Build a Native Shared Library",
          "content": "Build a Native Shared LibraryTo build a native shared library, pass the command-line option --shared to the native-image tool, as follows:native-image &amp;lt;class name&amp;gt; --sharedTo build a native shared library from a JAR file, use the following syntax:native-image -jar &amp;lt;jarfile&amp;gt; --sharedThe resulting native shared library will have the main() method of the given Java class as its entrypoint method.If your library does not include a main() method, use the -o command-line option to specify the library name, as follows:native-image --shared -o &amp;lt;libraryname&amp;gt; &amp;lt;class name&amp;gt;native-image --shared -jar &amp;lt;jarfile&amp;gt; -o &amp;lt;libraryname&amp;gt;GraalVM makes it easy to use C to call into a native shared library.There are two primary mechanisms for calling a method (function) embedded in a native shared library: the Native Image C API and the JNI Invocation API.This guide describes how to use the Native Image C API.It consists of the following steps:  Create and compile a Java class library containing at least one entrypoint method.  Use the native-image tool to create a shared library from the Java class library.  Create and compile a C application that calls that entrypoint method in the shared library.Tips and TricksThe shared library must have at least one entrypoint method.By default, only a method named main(), originating from a public static void main() method, is identified as an entrypoint and callable from a C application.To export any other Java method:  Declare the method as static.  Annotate the method with @CEntryPoint (org.graalvm.nativeimage.c.function.CEntryPoint).  Make one of the method’s parameters of type IsolateThread or Isolate, for example, the first parameter (org.graalvm.nativeimage.IsolateThread) in the method below. This parameter provides the current thread’s execution context for the call.  Restrict your parameter and return types to non-object types. These are Java primitive types including pointers, from the org.graalvm.nativeimage.c.type package.  Provide a unique name for the method. If you give two exposed methods the same name, the native-image builder will fail with the duplicate symbol message. If you do not specify the name in the annotation, you must provide the -o &amp;lt;libraryName&amp;gt; option at build time.Below is an example of the entrypoint method:@CEntryPoint(name = &quot;function_name&quot;)static int add(IsolateThread thread, int a, int b) {    return a + b;}When the native-image tool builds a native shared library, it also generates a C header file.The header file contains declarations for the Native Image C API (which enables you to create isolates and attach threads from C code) as well as declarations for each entrypoint in the shared library.This is the C header declaration for the example above:int add(graal_isolatethread_t* thread, int a, int b);A native shared library can have an unlimited number of entrypoints, for example to implement callbacks or APIs.Run a DemoIn the following example, you create a small Java class library (containing one class), use native-image to create a shared library from the class library, and then create a small C application that uses that shared library.The C application takes a String as an argument, passes it to the shared library, and prints environment variables that contain the argument.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Save the following Java code to a file named LibEnvMap.java:     import java.util.Map; import org.graalvm.nativeimage.IsolateThread; import org.graalvm.nativeimage.c.function.CEntryPoint; import org.graalvm.nativeimage.c.type.CCharPointer; import org.graalvm.nativeimage.c.type.CTypeConversion; public class LibEnvMap {     //NOTE: this class has no main() method     @CEntryPoint(name = &quot;filter_env&quot;)     private static int filterEnv(IsolateThread thread, CCharPointer cFilter) {         String filter = CTypeConversion.toJavaString(cFilter);         Map&amp;lt;String, String&amp;gt; env = System.getenv();         int count = 0;         for (String envName : env.keySet()) {             if(!envName.contains(filter)) continue;             System.out.format(&quot;%s=%s%n&quot;,                             envName,                             env.get(envName));             count++;         }         return count;     } }    Notice how the method filterEnv() is identified as an entrypoint using the @CEntryPoint annotation and the method is given a name as a argument to the annotation.    Compile the Java code and build a native shared library, as follows:     javac LibEnvMap.java     native-image -o libenvmap --shared    It produces the following artifacts:     Produced artifacts: /demo/graal_isolate.h (header) /demo/graal_isolate_dynamic.h (header) /demo/libenvmap.dylib (shared_lib) /demo/libenvmap.h (header) /demo/libenvmap_dynamic.h (header)    If you work with C or C++, use these header files directly. For other languages, such as Java, use the function declarations in the headers to set up your foreign call bindings.    Create a C application, main.c, in the same directory containing the following code:     #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &quot;libenvmap.h&quot; int main(int argc, char **argv) { if (argc != 2) {     fprintf(stderr, &quot;Usage: %s &amp;lt;filter&amp;gt;n&quot;, argv[0]);     exit(1); } graal_isolate_t *isolate = NULL; graal_isolatethread_t *thread = NULL; if (graal_create_isolate(NULL, &amp;amp;isolate, &amp;amp;thread) != 0) {     fprintf(stderr, &quot;initialization errorn&quot;);     return 1; } printf(&quot;Number of entries: %dn&quot;, filter_env(thread, argv[1])); graal_tear_down_isolate(thread); }    The statement #include &quot;libenvmap.h&quot; loads the native shared library.    Compile main.c using the clang compiler available on your system:     clang -I ./ -L ./ -l envmap -Wl,-rpath ./ -o main main.c    It creates an executable file main.    Run the C application by passing a string as an argument. For example:     ./main USER    It correctly prints out the name and value of the matching environment variable(s).  The advantage of using the Native Image C API is that you can determine what your API will look like.The restriction is that your parameter and return types must be non-object types.If you want to manage Java objects from C, you should consider JNI Invocation API.Related Documentation  Embedding Truffle Languages– a blog post by Kevin Menard where he compares both mechanisms for exposing Java methods.  Interoperability with Native Code  Java Native Interface (JNI) in Native Image  Native Image C API",
          "url": " /latest/reference-manual/native-image/guides/build-native-shared-library/"
          },
          
          "latest-reference-manual-native-image-guides-build-polyglot-native-executable":  {
          "title": "Build a Polyglot Native Executable (Java and JavaScript)",
          "content": "Build a Polyglot Native Executable (Java and JavaScript)With the GraalVM Polyglot API you can embed and run code from a guest language in a Java-based host application.GraalVM makes it possible to compile a Java application ahead-of-time with embedded JavaScript and to create a polyglot native executable. See the Embedding Languages documentation for more information about how a Java host application can interact with a guest language like JavaScript.  Note: JavaScript support by GraalVM Native Image is considered general availability.This guide demonstrates how to build a polyglot native executable with Java as a host language and JavaScript as a guest language.For the demo part, you will use a simple JSON Pretty Printer Java application that prints the output in JSON format:import java.io.*;import java.util.stream.*;import org.graalvm.polyglot.*;public class PrettyPrintJSON {  public static void main(String[] args) throws java.io.IOException {    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));    String input = reader.lines()    .collect(Collectors.joining(System.lineSeparator()));    try (Context context = Context.create(&quot;js&quot;)) {      Value parse = context.eval(&quot;js&quot;, &quot;JSON.parse&quot;);      Value stringify = context.eval(&quot;js&quot;, &quot;JSON.stringify&quot;);      Value result = stringify.execute(parse.execute(input), null, 2);      System.out.println(result.asString());    }  }}PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Download or clone the demos repository and navigate to the directory native-image/build-with-js-embedded/:     git clone https://github.com/graalvm/graalvm-demos     cd graalvm-demos/native-image/build-with-js-embedded    Open the project configuration file (in this case, pom.xml) and examine the required dependencies to enable interoperability with JavaScript.          To enable the polyglot runtime:        &amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;     &amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;            To enable Javascript:        &amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;js&amp;lt;/artifactId&amp;gt;     &amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;              Compile and package the project with Maven:     mvn clean package    Build a native executable:     mvn -Pnative package    It takes several minutes as it does not just build the executable, but also pulls in the JavaScript engine.  The JavaScript context will be available in the generated image.          Note: Building a polyglot native executable requires more physical memory because the Truffle framework is included.        Run the resulting executable and perform some pretty-printing:     ./target/PrettyPrintJSON &amp;lt;&amp;lt;EOF {&quot;GraalVM&quot;:{&quot;description&quot;:&quot;Language Abstraction Platform&quot;,&quot;supports&quot;:[&quot;combining languages&quot;,&quot;embedding languages&quot;,&quot;creating native images&quot;],&quot;languages&quot;: [&quot;Java&quot;, &quot;JavaScript&quot;, &quot;Python&quot;]}} EOF    The expected output is:     { &quot;GraalVM&quot;: {     &quot;description&quot;: &quot;Language Abstraction Platform&quot;,     &quot;supports&quot;: [       &quot;combining languages&quot;,       &quot;embedding languages&quot;,       &quot;creating native images&quot;     ],     &quot;languages&quot;: [       &quot;Java&quot;,       &quot;JavaScript&quot;,       &quot;Python&quot;     ]   } }  Related Documentation  Embedding Languages  JavaScript and Java Interoperability",
          "url": " /latest/reference-manual/native-image/guides/build-polyglot-native-executable/"
          },
          
          "latest-reference-manual-native-image-guides-build-spring-boot-app-into-native-executable":  {
          "title": "Build a Native Executable from a Spring Boot Application",
          "content": "Build a Native Executable from a Spring Boot ApplicationGraalVM Native Image can significantly boost the performance of a Spring Boot application.Spring Boot 3 has integrated support for GraalVM Native Image, making it easier to set up and configure your project.This guide demonstrates how to build a native executable from a Spring Boot 3 application.Create an ApplicationFor the demo part, you will create a simple REST server Java application.      Go to Spring Initializr and create a new Spring Boot project. Ensure to add the GraalVM Native Support and Spring Web dependencies.        Click GENERATE to create and download the project as a .zip file. Unzip the file and open it in your favorite IDE.    The project configuration already contains all necessary dependencies and plugins, including Native Build Tools.  For example, if you created a Maven project, these are the required plugins added in the pom.xml file:     &amp;lt;build&amp;gt;     &amp;lt;plugins&amp;gt;         &amp;lt;plugin&amp;gt;             &amp;lt;groupId&amp;gt;org.graalvm.buildtools&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;native-maven-plugin&amp;lt;/artifactId&amp;gt;         &amp;lt;/plugin&amp;gt;         &amp;lt;plugin&amp;gt;             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;         &amp;lt;/plugin&amp;gt;     &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;    The main application class was created by the initializer. In the same directory, create a REST controller in a file named HelloController.java with the following contents:     package com.example.demo; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController {     @GetMapping(&quot;/hello&quot;)     public String hello() {         return &quot;Hello, GraalVM!&quot;;     } }    (Optional) Package and run the application on a Java HotSpot Virtual Machine. Maven:     ./mvnw spring-boot:run    Gradle:     ./gradlew bootRun    It compiles the application, creates a JAR file, and runs the application.    The application starts in hundreds of milliseconds. Open a browser and navigate to localhost:8080/hello to see the application running.  You should see “Hello, GraalVM!”.  Build a Native Executable Using Paketo BuildpacksSpring Boot supports building container images containing native executables using the Paketo Buildpack for Oracle which provides GraalVM Native Image.PrerequisiteMake sure you have a Docker-API compatible container runtime such as Rancher Desktop or Docker installed and running.      First, enable the Paketo Buildpack for Oracle requesting the Native Image tool.          Maven. Open the pom.xml file, find the spring-boot-maven-plugin declaration, and change it so that it looks like this:          &amp;lt;plugin&amp;gt;      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;      &amp;lt;configuration&amp;gt;          &amp;lt;image&amp;gt;              &amp;lt;builder&amp;gt;paketobuildpacks/builder-jammy-buildpackless-tiny&amp;lt;/builder&amp;gt;&amp;lt;!--required for AArch64/M1 support --&amp;gt;              &amp;lt;buildpacks&amp;gt;                  &amp;lt;buildpack&amp;gt;paketobuildpacks/oracle&amp;lt;/buildpack&amp;gt;                  &amp;lt;buildpack&amp;gt;paketobuildpacks/java-native-image&amp;lt;/buildpack&amp;gt;              &amp;lt;/buildpacks&amp;gt;          &amp;lt;/image&amp;gt;      &amp;lt;/configuration&amp;gt;  &amp;lt;/plugin&amp;gt;        You should also ensure that your pom.xml file uses spring-boot-starter-parent.   The &amp;lt;parent&amp;gt; section should have been added by the initializer.            Gradle. Open the build.gradle file, and add the following lines:          bootBuildImage {          builder = &quot;paketobuildpacks/builder-jammy-buildpackless-tiny&quot;          buildpacks = [&quot;paketobuildpacks/oracle&quot;, &quot;paketobuildpacks/java-native-image&quot;]  }        When java-native-image is requested, the buildpack downloads Oracle GraalVM, which includes Native Image.              Build a native executable for this Spring application using buildpacks:          Maven:          ./mvnw -Pnative spring-boot:build-image            Gradle:          ./gradlew bootBuildImage              Once the build completes, a Docker image should be available. You can start your application using docker run. For example:     docker run --rm -p 8080:8080 docker.io/library/demo:0.0.1-SNAPSHOT  The Paketo documentation provides several examples that show you how to build applications with GraalVM Native Image using buildpacks.Build a Native Executable Using Native Build ToolsIf you do not want to use Docker and create a native executable on a host machine, use Native Build Tools which provide Maven and Gradle plugins for building native images.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!:sdk install java 21.0.4-graalSubstitute 21.0.4 with a preferred GraalVM release or early access build.For other installation options, visit the Downloads section.  Build a native executable using Native Build Tools:          Maven:          ./mvnw -Pnative native:compile        The command compiles the project and creates a native executable, demo, in the target/ directory.            Gradle:          ./gradlew nativeCompile        The command compiles the project and creates a native executable, demo, in the build/native/nativeCompile/ directory.              Run the application from the native executable:          Maven:          ./target/demo            Gradle:          ./build/native/nativeCompile/demo        With Gradle, you can also execute the nativeRun task: gradle nativeRun.        If you ran this application on HotSpot before, you would notice that startup time decreased significantly.            This guide demonstrated how you can create a native executable for a Spring Boot application. You can do that in a container environment using Paketo Buildpacks, or on a host machine using Native Build Tools.A Spring Boot application when compiled ahead of time into a native executable is not only faster and lighter, but also more efficient, especially in environments with constrained resources such as cloud platforms or containers.Related Documentation  Developing Your First GraalVM Native Application  Paketo Buildpack for Oracle  Native Build Tools",
          "url": " /latest/reference-manual/native-image/guides/build-spring-boot-app-into-native-executable/"
          },
          
          "latest-reference-manual-native-image-guides-build-static-executables":  {
          "title": "Build a Statically Linked or Mostly-Statically Linked Native Executable",
          "content": "Build a Statically Linked or Mostly-Statically Linked Native ExecutableGraalVM Native Image by default builds dynamically linked binaries: at build time it first loads your application classes and interfaces, and then hooks them together in a process of dynamic linking.However, you can create a statically linked or mostly-statically linked native executable, depending on your needs.A static native executable is a statically linked binary that you can use without any additional library dependencies.A static native executable is easy to distribute and deploy on a slim or distroless container (a scratch container).You can create a static native executable by statically linking it against musl-libc, a lightweight, fast and simple libc implementation.A mostly-static native executable is a binary that links all the shared libraries on which the native executable relies (zlib, JDK-shared static libraries) except the standard C library, libc. This is an alternative option to statically linking everything. Also, depending on the user’s code, it may link libstdc+ and libgcc.This approach is useful for deployment on a distroless container image.This guide shows how you can take advantage of Native Image linking options including fully dynamic, fully static, and mostly-static (except libc) to generate an executable ideal for your deployment scenario.Prerequisites and Preparation  Linux x64 operating system  GraalVM distribution for Java 17 or higher  A 64-bit musl toolchain, make, and configure  The latest zlib libraryThe easiest way to install GraalVM is with SDKMAN!.For other installation options, visit the Downloads section.To create statically linked applications with Native Image, you need a musl toolchain that includes the zlib library.Download the recommended musl toolchain: musl-toolchain-1.2.5-oracle-00001-linux-amd64.tar.gz.Download the archive, extract it, and add the toolchain’s bin directory to your system path:curl -SLO https://gds.oracle.com/download/bfs/archive/musl-toolchain-1.2.5-oracle-00001-linux-amd64.tar.gztar xzf musl-toolchain-1.2.5-oracle-00001-linux-amd64.tar.gzexport PATH=&quot;$(pwd)/musl-toolchain/bin:$PATH&quot;With the requirements set up, create the demo.Build a Static Native Executable  Save the following source code in a file named EnvMap.java:     import java.util.Map; public class EnvMap {     public static void main (String[] args) {         var filter = args.length &amp;gt; 0 ? args[0] : &quot;&quot;;         Map&amp;lt;String, String&amp;gt; env = System.getenv();         for (String envName : env.keySet()) {             if(envName.contains(filter)) {                 System.out.format(&quot;%s=%s%n&quot;,                                 envName,                                 env.get(envName));             }         }     } }    This application iterates over your environment variables and prints out the ones that contain the String of characters passed as a command line argument.    Compile the application:     javac EnvMap.java    Build a static native executable by running this command:     native-image --static --libc=musl EnvMap    This produces a native executable with statically linked system libraries. Run it with ./envmap.    You can confirm the application is fully statically linked using the ldd command:     ldd envmap    The output should be “not a dynamic executable”.  Build a Mostly-Static Native ExecutableWith GraalVM Native Image you can build a mostly-static native executable that statically links everything except libc.Statically linking all your libraries except libc ensures your application has all the libraries it needs to run on any Linux libc-based distribution.To build a mostly-static native executable, use this command:native-image --static-nolibc [other arguments] &amp;lt;Class&amp;gt;To build a mostly-static native executable for the above EnvMap demo, run:native-image --static-nolibc EnvMapThis produces a native executable that statically links all involved libraries (including JDK-shared static libraries) except for libc.This includes zlib.Also, depending on the user’s code, it may link libstdc+ and libgcc.One way to check what dynamic libraries your application depends on is to run ldd with the native executable, for example, ldd envmap.Frequently Asked QuestionsWhat is the recommended base container image for deploying a static or mostly-static native executable?A fully static native executable gives you the most flexibility to choose a base container image—it can even run on a scratch image.A mostly-static native executable requires a container image that provides libc, specifically glibc, but has no additional requirements.In both cases, choosing the base container image generally depends on your native executable’s specific requirements.Related Documentation  Tiny Java Containers demo shows how a simple Java application and a simple web server can be compiled to produce very small Docker container images using various lightweight base images.  From JIT to Native: Efficient Java Containers with GraalVM and Spring Boot workshop demonstrates how to build efficient, size-optimized native applications, and deploy them in various containers.",
          "url": " /latest/reference-manual/native-image/guides/build-static-executables/"
          },
          
          "latest-reference-manual-native-image-guides-configure-with-tracing-agent":  {
          "title": "Configure Native Image with the Tracing Agent",
          "content": "Configure Native Image with the Tracing AgentTo build a native executable for a Java application that uses Java reflection, dynamic proxy objects, JNI, or class path resources, you should either provide the native-image tool with a JSON-formatted metadata file or precompute metadata in the code.You can create configuration file(s) by hand, but a more convenient approach is to generate the configuration using the Tracing Agent (from now on, the agent). This guide demonstrates how to configure native-image with the agent. The agent generates the configuration for you automatically when you run an application on a JVM.To learn how to build a native executable with the metadata precomputed in the code, see the documentation.The example application in this guide makes use of reflection.The native-image tool can only partially detect application elements accessed through the Java Reflection API.Therefore, you need to explicitly provide details about the classes, methods, and fields accessed reflectively.Example with No ConfigurationPrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Save the following source code in a file named ReflectionExample.java:     import java.lang.reflect.Method;     class StringReverser {     static String reverse(String input) {         return new StringBuilder(input).reverse().toString();     } }     class StringCapitalizer {     static String capitalize(String input) {         return input.toUpperCase();     } }     public class ReflectionExample {     public static void main(String[] args) throws ReflectiveOperationException {         if (args.length == 0) {             System.err.println(&quot;You must provide the name of a class, the name of its method and input for the method&quot;);             return;         }         String className = args[0];         String methodName = args[1];         String input = args[2];             Class&amp;lt;?&amp;gt; clazz = Class.forName(className);         Method method = clazz.getDeclaredMethod(methodName, String.class);         Object result = method.invoke(null, input);         System.out.println(result);     } }    This Java application uses command-line arguments to determine the operation to be performed.    Compile the example and then run each command below.     javac ReflectionExample.java     java ReflectionExample StringReverser reverse &quot;hello&quot;     java ReflectionExample StringCapitalizer capitalize &quot;hello&quot;    The output of each command should be &quot;olleh&quot; and &quot;HELLO&quot;, respectively. (An exception is thrown if you provide any other string to identify the class or method.)    Create a native executable, as follows:     native-image ReflectionExample    Run the resulting native executable, using the following command:     ./reflectionexample StringReverser reverse &quot;hello&quot;    You should see an exception, similar to:     Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: StringReverser     at org.graalvm.nativeimage.builder/com.oracle.svm.core.hub.ClassForNameSupport.forName(ClassForNameSupport.java:190)     ...     at ReflectionExample.main(ReflectionExample.java:68)    This shows that, from its static analysis, the native-image tool was unable to determine that class StringReverser is used by the application and therefore did not include it in the native executable.  Example with ConfigurationThe following steps demonstrate how to use the agent, and its output, to create a native executable that relies on reflection and requires configuration.  Create a directory named META-INF/native-image/ in the working directory:     mkdir -p META-INF/native-image    Run the application with the agent enabled, as follows:     java -agentlib:native-image-agent=config-output-dir=META-INF/native-image ReflectionExample StringReverser reverse &quot;hello&quot;    This command creates a file named rechability-metadata.json containing the name of the class StringReverser and its reverse() method.     { &quot;reflection&quot;: [     {       &quot;type&quot;: &quot;StringReverser&quot;,       &quot;methods&quot;: [         {           &quot;name&quot;: &quot;reverse&quot;,           &quot;parameterTypes&quot;: [               &quot;java.lang.String&quot;           ]         }       ]     }   ] }    Build a native executable:     native-image ReflectionExample    The native-image tool automatically uses the metadata file in the META-INF/native-image/ directory. However, we recommend that the META-INF/native-image/ directory is on the class path, either via a JAR file or using the -cp option. (This avoids confusion for IDE users where a directory structure is defined by the IDE itself.)    Test your executable.     ./reflectionexample StringReverser reverse &quot;hello&quot; olleh     ./reflectionexample StringCapitalizer capitalize &quot;hello&quot;    You should see again an exception, similar to:     Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: StringCapitalizer     at org.graalvm.nativeimage.builder/com.oracle.svm.core.hub.ClassForNameSupport.forName(ClassForNameSupport.java:190)     ...     at ReflectionExample.main(ReflectionExample.java:68)    Neither the Tracing Agent nor the native-image tool can ensure that the configuration file is complete. The agent observes and records which program elements are accessed using reflection when you run the application.  In this case, the native-image tool has not been configured to include references to class StringCapitalizer.    Update the configuration to include class StringCapitalizer. You can manually edit the reachability-metadata.json file or re-run the Tracing Agent to update the existing configuration file using the config-merge-dir option, as follows:     java -agentlib:native-image-agent=config-merge-dir=META-INF/native-image ReflectionExample StringCapitalizer capitalize &quot;hello&quot;    This command updates the reachability-metadata.json file to include the name of the class StringCapitalizer and its capitalize() method.     {   &quot;reflection&quot;: [     {       &quot;type&quot;: &quot;StringCapitalizer&quot;,       &quot;methods&quot;: [         {           &quot;name&quot;: &quot;capitalize&quot;,           &quot;parameterTypes&quot;: [             &quot;java.lang.String&quot;           ]         }       ]     },     {       &quot;type&quot;: &quot;StringReverser&quot;,       &quot;methods&quot;: [         {           &quot;name&quot;: &quot;reverse&quot;,           &quot;parameterTypes&quot;: [             &quot;java.lang.String&quot;           ]         }       ]     }   ] }    Rebuild the native executable and run it.     native-image ReflectionExample     ./reflectionexample StringCapitalizer capitalize &quot;hello&quot;    The application should now work as intended.  Related Documentation  Assisted Configuration with Tracing Agent  Reachability Metadata: Reflection",
          "url": " /latest/reference-manual/native-image/guides/configure-with-tracing-agent/"
          },
          
          "latest-tools-chrome-debugger":  {
          "title": "Chrome Debugger",
          "content": "Chrome DebuggerGraalVM supports debugging of guest language applications and provides a built-in implementation of the Chrome DevTools Protocol.This allows you to attach compatible debuggers such as Chrome Developer Tools to GraalVM.To debug guest language applications, pass the --inspect option to the command line launcher, as in the following example with a Node.js HelloWorld program:var http = require(&#39;http&#39;);var server = http.createServer(function (request, response) {  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});  response.end(&quot;Hello World!n&quot;);});server.listen(8000);console.log(&quot;Server running at http://localhost:8000/&quot;);  Save this program as HelloWorld.js and then run:    $JAVA_HOME/bin/node --inspect HelloWorld.jsDebugger listening on ws://127.0.0.1:9229/SBqxI5YIqtREaDrXkFr8hLE0HL1AfKx8TjkI8qPMq2sFor help, see: https://www.graalvm.org/tools/chrome-debuggerFor example, in Chrome open: devtools://devtools/bundled/js_app.html?ws=127.0.0.1:9229/SBqxI5YIqtREaDrXkFr8hLE0HL1AfKx8TjkI8qPMq2s        Navigate to http://localhost:8000/ in your browser to launch the node application.        Open the devtools:... link in a separate Chrome browser tab.        Navigate to the HelloWorld.js file and submit a breakpoint at line 4.    Refresh the node.js app and you can see the breakpoint hit.Now you can inspect the stack, variables, evaluate variables, and selected expressions in a tooltip, and so on. By hovering your cursor over the response variable, for instance, you can inspect its properties, as seen in the screenshot below:Consult the JavaScript Debugging Reference for details on Chrome DevTools debugging features.This debugging process applies to all guest languages that GraalVM supports.Other languages such as R and Ruby can be debugged as easily as JavaScript, including stepping through language boundaries during guest language interoperability.Inspect OptionsNode LauncherThe Node.js runtime of GraalVM accepts the same options as node.js built on the V8 JavaScript engine, such as:--inspect[=[host:]&amp;lt;port number&amp;gt;]This enables the inspector agent and listens on port 9229 by default. To listen on a different port, specify the optional port number:--inspect-brk[=[host:]&amp;lt;port number&amp;gt;]This applies to the node launcher only.Other Language LaunchersOther guest language launchers such as js, python, Rscript, ruby, lli, and polyglot accept the --inspect[=[host:]&amp;lt;port number&amp;gt;] option, but suspend on the first line of the application code by default.--inspect.Suspend=(true|false)This disables the initial suspension if you specify --inspect.Suspend=false.Additional Common Inspect OptionsAll launchers also accept the following additional options:  --inspect.Path=&amp;lt;path&amp;gt; allows users to specify a custom path that generates the connection URL. Note: any website opened in your browser that has knowledge of this URL can connect to the debugger. A predictable path can thus be abused by a malicious website to execute arbitrary code on your computer, even if you are behind a firewall. Therefore the path is randomly generated by default.  --inspect.SourcePath=&amp;lt;source path&amp;gt; specifies a list of directories or ZIP/JAR files representing the source path. When the inspected application contains relative references to source files, their content is loaded from locations resolved with respect to this source path. It is useful during LLVM debugging, for instance.The paths are delimited by : on UNIX systems and by ; on MS Windows.  --inspect.Secure=(true|false) when true, use TLS/SSL to secure the debugging protocol. Besides changing the WS(web socket) protocol to WSS, the HTTP endpoint that serves metadata about the debuggeeis also changed to HTTPS. This is not compatible, with achrome://inspect page, which is not able to provide the debuggeeinformation and launch the debugger. Launch debugging via the printed WSS URL directly. Use the standard javax.net.ssl.* system options to provide information about keystore with the TLS/SSL encryption keys, or the following options:          --inspect.KeyStore - keystore file path      --inspect.KeyStoreType - keystore file type (defaults to JKS)      --inspect.KeyStorePassword - keystore password      --inspect.KeyPassword - password for recovering keys, if it’s different from the keystore password        --inspect.WaitAttached=(true|false) when true, no guest language source code is executed until the inspector client is attached. Unlike --inspect.Suspend=true, the execution is resumed rightafter the client is attached. This assures that no execution is missed by theinspector client. It is false by default.  --inspect.SuspensionTimeout sets a timeout of a debugger suspension. The debugger session is disconnected after the timeout expires. The timeout value consists of a positive integer value followed by a chronological time unit. For example, ‘15m’ or ’10s’. Valid time units are ‘ms’ for milliseconds, ‘s’ for seconds, ‘m’ for minutes, ‘h’ for hours, and ‘d’ for days. There is no timeout set by default.Advanced Debug OptionsThe following options are for language experts and language developers:  --inspect.Initialization=(true|false) when true, this option inspects the language initialization phase. When initial suspension is active, this suspends at the beginning of language initialization, not necessarily at the beginning of the application code. It is false by default.  --inspect.Internal=(true|false)  when true, internal sources are inspected as well. Internal sources may provide language implementation details. It is false by default.Programmatic Launch of Inspector BackendEmbedders can provide the appropriate inspector options to the Engine/Context to launch the inspector backend.The following code snippet provides an example of a possible launch:import org.graalvm.polyglot.*;class DebuggerSample {    public static void main(String... args) {        String port = &quot;4242&quot;;        String path = java.util.UUID.randomUUID().toString();        Context context = Context.newBuilder(&quot;js&quot;)                    .option(&quot;inspect&quot;, port)                    .option(&quot;inspect.Path&quot;, path)                    .build();        String hostAdress = &quot;localhost&quot;;        String url = String.format(                    &quot;chrome-devtools://devtools/bundled/js_app.html?ws=%s:%s/%s&quot;,                    hostAdress, port, path);    }}When running on OpenJDK, the following Maven dependencies must be declared to use the Chrome Inspector tool with embedded code:&amp;lt;dependency&amp;gt;     &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;     &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;     &amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.tools&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;chromeinspector&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;The Chrome Inspector tool is always available as a tool on GraalVM. No dependency needs to be explicitly declared there.",
          "url": " /latest/tools/chrome-debugger/"
          },
          
          "latest-getting-started-oci-cloud-shell":  {
          "title": "Oracle GraalVM in OCI Cloud Shell",
          "content": "Oracle GraalVM in OCI Cloud ShellThis guide shows you how to get started with Oracle GraalVM in Oracle Cloud Infrastructure (OCI) Cloud Shell.OCI Cloud Shell is a browser-based terminal accessible from the Oracle Cloud Console. It provides access to a Linux shell with a preauthenticated OCI Command Line Interface (CLI), preinstalled developer tools, and comes with 5GB of storage.Oracle GraalVM for JDK 17 is preinstalled in Cloud Shell, so you do not have to install and configure a development machine.Steps to Use Oracle GraalVM in Cloud ShellCloud Shell has several preinstalled JDKs, including Oracle GraalVM JDK.      Login to the Oracle Cloud Console and launch Cloud Shell.    List the installed JDKs using the csruntimectl java list command.     csruntimectl java list    The output lists the JDKs preinstalled in Cloud Shell: Oracle GraalVM for JDK 17, Oracle JDK 11, and Oracle JDK 8. The JDK marked with an asterisk is the current JDK.    Select Oracle GraalVM for JDK 17 as the current JDK:     csruntimectl java set graalvmjdk-17    You will see the confirmation message printed: “The current managed java version is set to graalvmjdk-17”.    Now confirm the values of the environment variables PATH and JAVA_HOME, and the versions of java and the native-image tool:     echo $JAVA_HOME     echo $PATH     java -version     native-image --version  You are all set to run Java applications using Oracle GraalVM JDK in Cloud Shell.Run a Java ApplicationThe example is a minimal REST-based application, built on top of Spring Boot 3 using Maven. The pom.xml file was generated using Spring Initializr with Spring Native Tools added as a feature. The Spring AOT plugin performs ahead-of-time transformations of a Spring application into a native executable.  Clone the demos repository and change to the application root directory:    git clone https://github.com/graalvm/graalvm-demos.gitcd graalvm-demos/native-image    Build the application with Maven (Apache Maven is also preinstalled in Cloud Shell):     ./mvnw clean package    This will generate a runnable JAR file that contains all of the application’s dependencies as well as a correctly configured MANIFEST file.    Run the Java application:     java -jar ./target/benchmark-jibber-0.0.1-SNAPSHOT.jar &amp;amp;    Call its REST endpoint:     curl http://localhost:8080/jibber    You should see some nonsense verse printed.    Bring the application to the foreground:     fg    Stop the application by pressing Ctrl+c.    Next, build a native executable for this Spring Boot application using the native Maven profile.     ./mvnw -Pnative native:compile    This will generate a native executable for Linux in the target directory, named benchmark-jibber.    Run the native executable, using the following command:    ./target/benchmark-jibber &amp;amp;    Call its endpoint to test:     curl http://localhost:8080/jibber    Again, you should see some nonsense verse printed.    Bring the application to the foreground:     fg    Stop the application by pressing Ctrl+c.  Congratulations! You have successfully used Oracle GraalVM JDK with Native Image to build and test a Spring Boot REST application in Cloud Shell.Thus, you can use Oracle GraalVM in OCI Cloud Shell to build and test simple Java applications with Micronaut, Spring, and other microservice frameworks.Related Documentation  Java Hello World with Oracle GraalVM in OCI Cloud Shell  Oracle GraalVM in OCI Code Editor",
          "url": " /latest/getting-started/oci/cloud-shell/"
          },
          
          "latest-tools-code-coverage":  {
          "title": "Code Coverage Command Line Tool",
          "content": "Code Coverage Command Line ToolGraalVM provides a code coverage command line tool that lets users record and analyze the source code coverage of a particular execution of code.Code coverage, as a percentage of source code lines, functions, or statements covered, is an important metric for understanding a particular source code execution, and is commonly associated with test quality (test coverage).Providing a visual coverage overview for individual lines of code shows the developer which code paths are covered and which are not, giving insight into the character of the execution which can, for example, inform further testing efforts.The example application below will be used to demonstrate GraalVM’s code coverage capabilities.This application defines a getPrime function that calculates the n-th prime using a basic prime number calculator based on the Sieve of Eratosthenes algorithm.It also has a somewhat naive cache of the first 20 prime numbers.  Copy the following code into a new file named primes.js:class AcceptFilter {    accept(n) {        return true    }}class DivisibleByFilter {    constructor(number, next) {        this.number = number;        this.next = next;    }    accept(n) {        var filter = this;        while (filter != null) {            if (n % filter.number === 0) {                    return false;            }            filter = filter.next;        }        return true;    }}class Primes {    constructor() {        this.number = 2;        this.filter = new AcceptFilter();    }    next() {        while (!this.filter.accept(this.number)) {            this.number++;        }        this.filter = new DivisibleByFilter(this.number, this.filter);        return this.number;    }}function calculatePrime(n) {    var primes = new Primes();    var primesArray = [];    for (let i = 0; i &amp;lt; n; i++) {        primesArray.push(primes.next());    }    return primesArray[n-1];}function getPrime(n) {    var cache = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71];    var n = arguments[0];    if (n &amp;gt; cache.length) { return calculatePrime(n); }    return cache[n-1];}// TESTSconsole.assert(getPrime(1) == 2);console.assert(getPrime(10) == 29);Notice that the last couple of lines are assertions to be treated as unit tests.      Run js primes.js. The example application should print no output, since all the assertions pass. But how well do the assertions test the implementation?    Run js primes.js --coverage to enable code coverage. The code coverage tool should print output for the example application as follows:    js primes.js --coverage--------------------------------------------------------Code coverage histogram.Shows what percent of each element was covered during execution-------------------------------------------------------- Path               |  Statements |    Lines |    Roots-------------------------------------------------------- /path/to/primes.js |      20.69% |   26.67% |   22.22%--------------------------------------------------------    The tracer prints a coverage histogram for each source file.You can see that statement coverage is roughly 20%, line coverage is roughly 26%, and root coverage (the term “root” covers functions, methods, etc.) is 22.22%.This tells your that our simple tests are not particularly good at exercising the source code.Next you will figure out which parts of the code are not covered.    Run js primes.js --coverage --coverage.Output=detailed. Prepare for a somewhat verbose output.Specifying the output as detailed will print all the source code lines with acoverage annotation at the beginning. Due to potentially large output, it isrecommended to combine this output mode with the --coverage.OutputFile optionwhich prints the output directly to a file. The output for our exampleapplication is as follows:js primes.js --coverage --coverage.Output=detailed--------------------------------------------------------Code coverage per line of code and what percent of each element was covered during execution (per source)  + indicates the line is covered during execution  - indicates the line is not covered during execution  p indicates the line is part of a statement that was incidentally covered during execution    for example, a not-taken branch of a covered if statement-------------------------------------------------------- Path               |  Statements |    Lines |    Roots /path/to/primes.js |      20.69% |   26.67% |   22.22%  class AcceptFilter {      accept(n) {-         return true      }  }  class DivisibleByFilter {      constructor(number, next) {-         this.number = number;-         this.next = next;      }      accept(n) {-         var filter = this;-         while (filter != null) {-             if (n % filter.number === 0) {-                     return false;-             }-             filter = filter.next;          }-         return true;      }  }  class Primes {      constructor() {-         this.number = 2;-         this.filter = new AcceptFilter();      }      next() {-         while (!this.filter.accept(this.number)) {-             this.number++;          }-         this.filter = new DivisibleByFilter(this.number, this.filter);-         return this.number;      }  }  function calculatePrime(n) {-     var primes = new Primes();-     var primesArray = [];-     for (let i = 0; i &amp;lt; n; i++) {-         primesArray.push(primes.next());      }-     return primesArray[n-1];  }  function getPrime(n) {+     var cache = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71];+     var n = arguments[0];p     if (n &amp;gt; cache.length) { return calculatePrime(n); }+     return cache[n-1];  }  // TESTS+ console.assert(getPrime(1) == 2);+ console.assert(getPrime(10) == 29);--------------------------------------------------------As the legend at the beginning of the output explains, lines that are covered by the execution are preceded with a +.Lines not covered by the execution are preceded with a -.Lines that are covered partially are preceded with p (for example, when an if statement is covered but only one branch is taken, consider the other bench to be incidentally covered).Looking at the output you can see that the calculatePrime function and all its calls are never executed. Looking again at the assertions and the getPrimefunction, it becomes clear that our tests always hit the cache.Thus most of the code is never executed. You can improve on that.  Add console.assert(getPrime(30) == 113); to the end of the primes.js file and run js primes.js --coverage. Since the new assertion added callsgetPrime with 30 (our cache only has 20 entries) the coverage will look like this:js primes.js --coverage-------------------------------------------------------Code coverage histogram.  Shows what percent of each element was covered during execution------------------------------------------------------- Path               |  Statements |    Lines |    Roots------------------------------------------------------- /path/to/primes.js |     100.00% |  100.00% |  100.00%-------------------------------------------------------Integrating with Other ToolsThe code coverage tool provides ways to integrate with other tools.Running with --coverage.Output=lcov produces output in the commonly used lcov format which is used by multiple tools (for example, genhtml) to display coverage data.Take a look at the next example that shows how to visualize coverage of a Node.js app with Visual Studio Code.  Copy the following code into a new file named nodeapp.js:const express = require(&#39;express&#39;)const app = express()const port = 3000app.get(&#39;/&#39;, (req, res) =&amp;gt; {  res.send(&#39;Hello World!&#39;)})app.get(&#39;/neverCalled&#39;, (req, res) =&amp;gt; {  res.send(&#39;You should not be here&#39;)})app.get(&#39;/shutdown&#39;, (req, res) =&amp;gt; {  process.exit();})app.listen(port, () =&amp;gt; console.log(`Example app listening on port ${port}!`))  Install the express module dependency:    $JAVA_HOME/bin/npm install express        Launch Visual Studio Code and install a code coverage plugin that supports lcov.    Run the nodeapp.js file with coverage enabled and configured:    $JAVA_HOME/bin/node --coverage --coverage.Output=lcov --coverage.OutputFile=coverage/lcov.info nodeapp.js  Note that the plugin may look for the lcov.info file in the coverage directory by default, so direct the output of the code coverage tool there.      Visit localhost:3000/ in your browser, then visit localhost:3000/shutdown to close the app.        Open Visual Studio Code, then open the folder containing the nodeapp.js file and coverage directory and you should be greeted with an image similar to the following:  If you wish to integrate the data gathered by the GraalVM code coverage tool with your own visualization, the --coverage.Output=json option results in the output being a JSON file with the raw data gathered by the tracker.",
          "url": " /latest/tools/code-coverage/"
          },
          
          "latest-getting-started-oci-code-editor":  {
          "title": "Oracle GraalVM in OCI Code Editor",
          "content": "Oracle GraalVM in OCI Code EditorThis guide shows you how to get started with Oracle GraalVM in Oracle Cloud Infrastructure (OCI) Code Editor.OCI Code Editor provides a rich, in-console editing environment that enables you to edit code without having to switch between the Oracle Cloud Console and your local development environment. The Code Editor enables you to edit and deploy code for OCI services directly from the OCI Console.Oracle GraalVM for JDK 17 is preinstalled in Cloud Shell, so you do not have to install and configure a development machine. Code Editor’s integration with Cloud Shell gives you direct access to it.Create and Run a Java Application in OCI Code EditorStep 1: Open a Terminal in Code Editor  Login to the Oracle Cloud Console and launch Code Editor.  Open a Terminal in Code Editor, by clicking New Terminal from the Terminal menu.Step 2: Select GraalVM JDK as the Default JDK  List the installed JDKs using the csruntimectl java list command.     csruntimectl java list    The output lists the JDKs preinstalled in Cloud Shell: Oracle GraalVM for JDK 17, Oracle JDK 11, and Oracle JDK 8. The JDK marked with an asterisk is the current JDK.    Select Oracle GraalVM for JDK 17 as the current JDK:     csruntimectl java set graalvmjdk-17    You will see the confirmation message printed: “The current managed java version is set to graalvmjdk-17”.    Now confirm the values of the environment variables PATH and JAVA_HOME, and the versions of java and the native-image tool:     echo $JAVA_HOME     echo $PATH     java -version     native-image --version  Step 3: Setup a Java Project and Run  Clone a demo repository and open it in OCI Code Editor. To achieve this, run the following commands one by one:     git init graalvmee-java-hello-world     cd graalvmee-java-hello-world     git remote add origin https://github.com/oracle-devrel/oci-code-editor-samples.git     git config core.sparsecheckout true     echo &quot;java-samples/graalvmee-java-hello-world/*&quot;&amp;gt;&amp;gt;.git/info/sparse-checkout     git pull --depth=1 origin main     cd java-samples/graalvmee-java-hello-world/    You can now view/edit the sample code in Code Editor.    Package the sample application into a runnable JAR file:     mvn clean package    Run the JAR file:     java -jar target/my-app-1.0-SNAPSHOT.jar    It prints out “Hello World!”.  Step 4: Build and Run a Native ExecutableThis Java application incorporates the Maven plugin for GraalVM Native Image that adds support for building native executables using Apache Maven. For testing purposes, build a native executable with the quick build mode first enabled and then disabled.Quick Build Mode Enabled  To enable the quick build mode, uncomment this line in pom.xml, as follows:     &amp;lt;quickBuild&amp;gt;true&amp;lt;/quickBuild&amp;gt;    Build a native executable using the native Maven profile:     mvn clean -Pnative -DskipTests package    This will generate a native executable for Linux in the target directory, named my-app.    Run the app native executable in the background:     ./target/my-app  Quick Build Mode Disabled  To disable the quick build mode, comment out this line in pom.xml, as follows:     &amp;lt;!-- &amp;lt;quickBuild&amp;gt;true&amp;lt;/quickBuild&amp;gt; --&amp;gt;    Build a native executable again:     mvn clean -Pnative -DskipTests package    This will generate a native executable, my-app, in the target directory, replacing the previous one. You have probably noticed how the quick build mode reduced the time required to generate a native executable, making it easier to use Native Image in a typical development cycle (compile, test, and debug). However, the size of a generated executable is larger and peak performance is worse. The quick build mode is recommended for development purposes only.    Run the native executable:     ./target/my-app  Congratulations! You have successfully built and run a native executable using Oracle GraalVM in OCI Code Editor without the need to switch between the Oracle Cloud Console and your local development environments.The Code Editor allows you to accomplish quick coding tasks and run applications directly from the OCI Console.Related Documentation  Java Hello World with Oracle GraalVM in OCI Code Editor  Micronaut Hello World REST App with Oracle GraalVM in OCI Code Editor  Working with Code Editor  Oracle GraalVM in OCI Cloud Shell",
          "url": " /latest/getting-started/oci/code-editor/"
          },
          
          "community":  {
          "title": "Community",
          "content": "GraalVM CommunityThe GraalVM project embraces an open and inclusive community. We welcome users and contributors alike. Also, we support projects that extend the platform with new tools, languages or embeddings.Stay Connected  Subscribe to low traffic graalvm-announce@oss.oracle.com for important news about GraalVM.  Follow @graalvm on Twitter and use the #GraalVM hashtag to tweet about the project or to see what others are tweeting.Community SupportWe provide free community support via public channels and always appreciate your feedback or questions.  Join the conversation at our Slack channels to directly connect with the GraalVM team.  Subscribe and post to graalvm-users@oss.oracle.com for GraalVM usability questions.  Create GitHub issues for bug reports, questions or requests for enhancements.  Report a security vulnerability to secalert_us@oracle.com. For additional information see Reporting Vulnerabilities guide.Contribute to GraalVMGraalVM welcomes contributors to the core platform and projects that extend the platform.There have already been significant contributions from both industry and academia.Please let us know about such efforts that we can support to grow the GraalVM community together.To help to provide immediate feedback to GraalVM developers, there are nightly GraalVM builds available.They are built from the main branch on a nightly basis.  Learn how to become a GraalVM contributor.  Subscribe and post to graalvm-dev@oss.oracle.com for questions related to working with the sources or extending the GraalVM ecosystem by creating new languages, tools or embeddings.",
          "url": " /community/"
          },
          
          "compatibility":  {
          "title": "GraalVM Compatibility",
          "content": "GraalVM Language CompatibilityA key concern when evaluating a new runtime to execute your application is whether theruntime is functionally complete. We run a comprehensive set of language specification testson each push to any of the GraalVM language repositories. Sometimes those test suites areincomplete, in which case we work with third parties to improve the overall ecosystem.We also run regular tests against a subset of popular packages for each of the supportedGraalVM languages. If you are interested in checking if your package is supported, use oneof the two tools below. Specify the name of the module or package you are interested in, or drop in your package.json, Gemfile.lock, or other files containing the list of your dependencies.Note that all the processing is done on the client-side in the browser, no information is sent to any servers.We run tests on the modules from their respective repositories: PyPI and the standard library for Python, NPM for node modules, RubyGems for Ruby gems. We try to download the module and run its tests. If the tests pass, the compatibility checker will report the amount of passed tests for the module, for example “100.00% tests pass”. Please use the compatibility checker as the initial tool to check the compatibility and assess it further yourself. In general, unless the tests clearly fail, there is a good chance the module will run on GraalVM.            Quickly check if a Python package or standard library module, an NPM module, or a Ruby gem is compatible with GraalVM.                                                            &amp;times;                        Check!                  Sorry, there are no compatibility results found for .        This does not mean  will not work with GraalVM. We just have not had a chance to add it to our regular testing process.          We currently test:            More than 95,000 NPM modules based on mocha, jest, ava, tape, and other test frameworks.      The top 1,000 most popular Ruby gems.          If there is an untested module you would love to see tested by us, please let us know.            Upload your package dependency lock file to  check all your dependencies at once!                                          Drag your file here  or                                          upload                                                                      Name          Version          Status                              ",
          "url": " /compatibility/"
          },
          
          "latest-reference-manual-java-compiler":  {
          "title": "Graal Compiler",
          "content": "Graal CompilerThe Graal compiler is a dynamic compiler, written in Java, that transforms bytecode into machine code.The Graal just-in-time (JIT) compiler is integrated with the Java HotSpot Virtual Machine and GraalVM.See Java Virtual Machine Guide and the section GraalVM as a Virtual Machine for more information.(The open source code of the Graal JIT compiler is available on GitHub.)Compiler AdvantagesThe Graal JIT compiler provides optimized performance for applications running on a Java Virtual Machine (JVM) through unique approaches to code analysis and optimization.It includes multiple optimization algorithms (called “Phases”), such as aggressive inlining, polymorphic inlining, and others.The Graal compiler can bring performance advantages for highly-abstracted programs.For example, it includes a partial-escape-analysis optimization that can remove the costly allocations of certain objects.See the value PartialEscapeAnalysis in the CEOptimization enum in the GraalVM GitHub repository for more information.The optimization determines when a new object is accessible outside a compilation unit and only allocates it on paths that “escape” the compilation unit (for example, if the object is passed as a parameter, stored in a field, or returned from a method).This approach can greatly improve the performance of an application by reducing the number of heap allocations.Code that uses more modern Java features such as Streams or Lambdas will see greater improvements in performance as this type of code involves a significant number of such non- or partially-escaping objects.Code bound by characteristics such as I/O or memory allocations that cannot be removed by the compiler will see less improvement.For more information on performance tuning, refer to Graal JIT Compiler Configuration.Graph CompilationTo run guest programming languages (namely JavaScript, Python, and Ruby) in the same runtime as the host JVM-based language, the compiler works with a language-independent intermediate graph representation between the source language and the machine code to be generated.(For more information on language interoperability, see Interoperability.)The graph can represent similar statements of different languages in the same way, such as “if” statements or loops, which makes it possible to mix languages in the same application.The Graal compiler can then perform language-independent optimization and generate machine code on this graph.Diagnostic DataIf an uncaught exception is thrown by the compiler, the compilation is typically discarded and execution continues.The Graal compiler can instead produce diagnostic data (such as immediate representation graphs) that can be submitted along with a bug report.This is enabled with the -Djdk.graal.CompilationFailureAction=Diagnose option.The default location of the diagnostics output is in the graal_dumps/ directory under the current working directory of the process but can be changed with the -Djdk.graal.DumpPath option.During the JVM shutdown, the location of the archive containing the diagnostic data is printed to the console.Furthermore, diagnostic data can be produced for any compilation performed by the Graal compiler with the -Djdk.graal.Dump option.This will produce diagnostic data for every method compiled by the compiler.To refine the set of methods for which diagnostic data is produced, use the -Djdk.graal.MethodFilter=&amp;lt;class&amp;gt;.&amp;lt;method&amp;gt; option.For example, -Djdk.graal.MethodFilter=java.lang.String.*,HashMap.get will produce diagnostic data only for methods in the java.lang.String class as well as methods named get in a class whose non-qualified name is HashMap.Related Documentation  Graal JIT Compiler Operations Manual  Graal JIT Compiler Configuration",
          "url": " /latest/reference-manual/java/compiler/"
          },
          
          "community-conduct":  {
          "title": "Contributor Covenant Code of Conduct",
          "content": "Contributor Covenant Code of ConductOur PledgeIn the interest of fostering an open and welcoming environment, we ascontributors and maintainers pledge to making participation in our project andour community a harassment-free experience for everyone, regardless of age, bodysize, disability, ethnicity, gender identity and expression, level of experience,nationality, personal appearance, race, religion, or sexual identity andorientation.Our StandardsExamples of behavior that contributes to creating a positive environmentinclude:  Using welcoming and inclusive language  Being respectful of differing viewpoints and experiences  Gracefully accepting constructive criticism  Focusing on what is best for the community  Showing empathy towards other community membersExamples of unacceptable behavior by participants include:  The use of sexualized language or imagery and unwelcome sexual attention oradvances  Trolling, insulting/derogatory comments, and personal or political attacks  Public or private harassment  Publishing others’ private information, such as a physical or electronicaddress, without explicit permission  Other conduct which could reasonably be considered inappropriate in aprofessional settingOur ResponsibilitiesProject maintainers are responsible for clarifying the standards of acceptablebehavior and are expected to take appropriate and fair corrective action inresponse to any instances of unacceptable behavior.Project maintainers have the right and responsibility to remove, edit, orreject comments, commits, code, wiki edits, issues, and other contributionsthat are not aligned to this Code of Conduct, or to ban temporarily orpermanently any contributor for other behaviors that they deem inappropriate,threatening, offensive, or harmful.ScopeThis Code of Conduct applies both within project spaces and in public spaceswhen an individual is representing the project or its community. Examples ofrepresenting a project or community include using an official project e-mailaddress, posting via an official social media account, or acting as an appointedrepresentative at an online or offline event. Representation of a project may befurther defined and clarified by project maintainers.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may bereported by contacting the project team. Allcomplaints will be reviewed and investigated and will result in a response thatis deemed necessary and appropriate to the circumstances. The project team isobligated to maintain confidentiality with regard to the reporter of an incident.Further details of specific enforcement policies may be posted separately.Project maintainers who do not follow or enforce the Code of Conduct in goodfaith may face temporary or permanent repercussions as determined by othermembers of the project’s leadership.AttributionThis Code of Conduct is adapted from the Contributor Covenant, version 1.4,available here.",
          "url": " /community/conduct/"
          },
          
          "latest-reference-manual-native-image-guides-configure-dynamic-proxies":  {
          "title": "Configure Dynamic Proxies Manually",
          "content": "",
          "url": " /latest/reference-manual/native-image/guides/configure-dynamic-proxies/"
          },
          
          "latest-reference-manual-native-image-guides-containerise-native-executable-and-run-in-docker-container":  {
          "title": "Containerize a Native Executable and Run in a Container",
          "content": "Containerize a Native Executable and Run in a ContainerContainers provide the flexibility of development environments to match a production environment, to help isolate your application, and to minimize overhead. For self-contained executables, generated with GraalVM Native Image, containers are an obvious deployment choice.To support container-based development, there are several GraalVM container images available, depending on the platform, the architecture, the Java version, and the edition:  Oracle GraalVM container images, available in Oracle Container Registry (OCR) under the GraalVM Free Terms and Conditions (GFTC) license.  GraalVM Community Edition container images published in the GitHub Container Registry.This guide shows how to containerize a native executable for your Java application.You will use a GraalVM container image with Native Image to compile a Java application ahead-of-time into a native executable.Download a Sample ApplicationThis guide uses the Spring Boot 3 Native Image Microservice example.The example is a minimal REST-based API application, built on top of Spring Boot 3.If you call the HTTP endpoint /jibber, it will return some nonsense verse generated in the style of the Jabberwocky poem, by Lewis Carroll.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.      Install and run a Docker-API compatible container runtime such as Rancher Desktop, Docker, or Podman.    Clone the GraalVM Demos repository:     git clone https://github.com/graalvm/graalvm-demos.git    Navigate to the demo directory:     cd graalvm-demos/native-image/spring-boot-microservice-jibber  Build and Run as a Native ExecutableWith the built-in support for GraalVM Native Image in Spring Boot 3, it has become much easier to compile a Spring Boot 3 application into a native executable.  Build a native executable:     ./mvnw native:compile -Pnative    The -Pnative profile is used to generate a native executable for your platform. This will generate a native executable called benchmark-jibber in the target/ directory.    Run the native executable and put it into the background by appending &amp;amp;:     ./target/benchmark-jibber &amp;amp;    Call the endpoint using curl:     curl http://localhost:8080/jibber    You should get a random nonsense verse.    Bring the application to the foreground using fg, and then enter &amp;lt;CTRL-c&amp;gt; to stop the application.Containerize the Native ExecutableThe generated native executable is platform-dependent.      Containerize the native executable using the following commands.          On Linux, containerize the native executable generated in the previous step:          docker build -f Dockerfiles/Dockerfile.native --build-arg APP_FILE=benchmark-jibber -t jibber-benchmark:native.0.0.1-SNAPSHOT .            On MacOS, Windows, or Linux, use multistage Docker builds to build a native executable inside a container, and package the native executable in a lightweight container image:          docker build -f Dockerfiles/Dockerfile -t jibber-benchmark:native.0.0.1-SNAPSHOT .              Run the application:     docker run --rm --name native -p 8080:8080 jibber-benchmark:native.0.0.1-SNAPSHOT    From a new terminal window, call the endpoint using curl:     curl http://localhost:8080/jibber    It should generate a random nonsense verse.    To stop the application, first get the container id using docker ps, and then run:     docker rm -f &amp;lt;container_id&amp;gt;    To delete the container images, first get the image id using docker images, and then run:     docker rmi -f &amp;lt;image_1_id&amp;gt; &amp;lt;image_n_id&amp;gt;  SummaryIn this guide, you saw how to use GraalVM container images to containerize a native executable for your Java application.With GraalVM Native Image you can also build fully static native executables and package them directly into tiny containers such as scratch or distroless containers.Related Documentation  Build a Native Executable from a Spring Boot Application  Oracle GraalVM Container Images  Hands-on Lab: GraalVM Native Image, Spring and Containerisation",
          "url": " /latest/reference-manual/native-image/guides/containerise-native-executable-and-run-in-docker-container/"
          },
          
          "latest-reference-manual-espresso-continuations":  {
          "title": "Continuation API",
          "content": "Continuation APIThe Continuation API enables you to control the program stack.When a continuation is suspended, the stack is unwound and copied onto the heap as ordinary Java objects.When a continuation is resumed, those objects are put back onto the stack, along with all the needed metadata to resume execution at the pause point.The heap objects can be serialized to resume execution in a different JVM running the same code (for example, after a restart).UsageAdd org.graalvm.espresso:continuations:25.0.2 to your classpath at compilation time (it will be automatically provided at runtime).The continuation feature is experimental and needs to be explicitly enabled by using these options: --experimental-options --java.Continuum=true.See an example usage of the Continuation API with serialization.High LevelIf you can model your use case as code that emits (or yields) a stream of objects, you can use the Generator&amp;lt;T&amp;gt;class. This provides something similar to Python’s generators with a convenient API:subclass it, implement generate, and call emit from inside it.See an example of using the Generator API.Low LevelYou create a new Continuation by passing the constructor an object that implements the functionalinterface ContinuationEntryPoint (which can be a lambda). That object’s start method receivesa SuspendCapability that lets you trigger suspension. You can do that from any depth in the stack aslong as the code was invoked via the entry point, and all the frames between the call to suspend and resume will beunwound and stored inside the Continuation object. You can then call resume() on it to kick it off for the firsttime or to restart from the last suspend point.Continuations are single-threaded constructs. There are no second threads involved, and the resume() method blocksuntil the continuation either finishes successfully, throws an exception or calls suspend.You can use isResumable() to check if the continuation can be resumed (for example, if the continuation has beenfreshly created or it has been previously suspended), and isCompleted() to verify whether the continuation has completed(either by returning normally, or if an exception escaped).Continuation implements Serializable and can serialize to a backwards compatible format. Because frames can point toanything in their parameters and local variables, the class ContinuationSerializable provides staticmethods readObjectExternal and writeObjectExternal which may be used to coordinate serialization ofcontinuation-related objects with a non-jdk serialization engine. Note that when the --java.Continuum flag is specified,all lambdas are serializable but deserialization will require special support from your serializer engine.SecurityContinuations that have not been materialized are safe, as the frame record is kept internal to the VM.Materializing a continuation refers to making the record visible to Java code, through theprivate ContinuationImpl.stackFrameHead field. Currently, the only path for materialization is through serialization.When restoring from a materialized frame (dematerialization), only minimal checks are performed by the VM, and only toprevent a VM crash. Examples of these checks are:  Ensures that resume only happens on invoke bytecodes.  Ensures that the recorded frame data is consistent with what was computed by the bytecode verifier.  Ensures that the last frame in the record is ContinuationImpl.suspend.Deserializing a continuation supplied by an attacker will allow complete takeover of the JVM. Only resume continuationsyou persisted yourself!Use CasesSerializing a continuation makes it multi-shot, meaning you can restart a continuation more than once and thus redothe same computation with different inputs. This ability to explore “parallel worlds” opens up many interesting usecases.  Speculative Execution: CPU-style data speculation to accelerate usage of remote high-latency datastores. See below.  Backtracking in Search Algorithms: Utilizing continuations to represent states in search trees, allowing easyreturn to these states for further exploration.  Implementing Coroutines/Yield: Facilitating cooperative multitasking by allowing functions to yield and resumeexecution at certain points.  Web Request Handling: Maintaining state across HTTP requests in web applications without relying on globalvariables or session storage.  Functional Reactive Programming (FRP): Managing control flow in FRP systems, where continuations represent futurestates of data streams.  Undo/Redo Functionality: Capturing application state at various points to enable undoing or redoing actions. Modelyour app as a continuation-based actor and serialize after each state mutation.  Game Development: Model NPCs and other interactive entities using continuations instead of hand-crafted statemachines. For example monster.walkTo(...) can be added to game logic, even though the walk operation is very slow.The state of these continuations can be included into save game files.  Delimited Continuations for Modularity: Encapsulating control flow in modular components, aiding in separation ofconcerns and code maintainability.  Serialized Continuations for Distributed Computing: Serializing continuation state, allowing distributed systemsto migrate units of work.  Parsing: Implementing non-deterministic parsers or interpreters where multiple potential parsing paths areexplored simultaneously.  Custom Control Structures: Creating new control structures (for example, loops, exception handling) that are not nativelysupported in the programming language.  Time-travel Debugging: Capturing continuations at various points in a program to enable “stepping back” in timeduring debugging sessions.  Live Programming/Hot Code Swapping: Using continuations to maintain program state while parts of the program areupdated or reloaded.Speculative ExecutionCPUs attempt to guess the direction of a branch when the data it depends on hasn’t arrived yet. This is helpful becausememory is slow. The same trick can be done at much higher levels using continuations when reading data from slow datasources such as a far away server. If you have a computation where CPU intensive work is interleaved with long blockingperiods, this can speed things up.When a continuation performs a slow operation that yields a value (for example, an RPC), you can suspend, serialize, dispatch the request.Instead of waiting for the result and scheduling other work—as would be standard in continuation-based async threads implementations such as Project Loom—youcan instead pick one or more values that we think the RPC might return.Then the continuation is deserialized for each value, resuming execution separately for each possibility.This approach forks the execution into multiple parallel paths. The new paths can then fork again, forming a tree of possibilities.If the continuation encounters an operation that is not controlled by the surrounding framework and cannot be undone (for example, a sideeffect), it suspends at that point and doesn’t continue speculatively.When results arrive from the remote server, the speculative tree of serialized continuations can be resolved incrementally.Serialized continuations corresponding to paths that are no longer valid are discarded.Once the final result is received, the continuation either completes execution or proceeds beyond a point where side effects occur.If the server protocol allows results to be chained together (for example,as Cap’n’Proto RPC does,or FoundationDB), back-to-back speculativecalls can be transmitted to the server for local processing, avoiding roundtrips.LimitationsThere are special situations in which a call to suspend may fail with IllegalContinuationStateException. These are:  If there is no call to resume in the call-stack.  If in between the call to resume and suspend any of the following holds:          A lock is held (this may be an object monitor through the MONITORENTER bytecode, or evena java.util.concurrent.locks.ReentrantLock).      There is a non-java frame on the stack (this could be a native method, or even a VM intrinsic).      Furthermore, there is currently no support for continuation-in-continuation.Internal Implementation NotesThis section is only relevant for people working on Espresso itself.Continuations interact with the VM through private intrinsics registered for the Continuation and ContinuationImpl classes.A continuation starts by calling into the VM. Execution resurfaces in the guest world at the private run method ofContinuationImpl, which then invokes the user’s given entry point.Suspending throws a host-side exception that is caught by the BytecodeNode interpreter loop. The stack frame is copiedinto a new host-side object called a HostFrameRecord (HFR). The exception is then rethrown. The HFRs are chainedtogether in a linked list. Once execution reaches the private run method of ContinuationImpl the HFR list isattached into a hidden field of ContinuationImpl. Control is then returned to the guest.On resuming a Continuation, the entire call stack needs to be re-winded. This happens through a different CallTargetthan for regular calls, and there is one such call target per encountered resume bci.These call targets take a single argument: the HostFrameRecord that was stored into the Continuation. Using thisrecord, the frame is restored for the current method, the current record is unlinked from the rest (for GC purposes), andthe rest of the records is passed to the next method. This is all done in a special invoke node, InvokeContinuableNode.The separation of the call targets has two advantages:  It does not interfere with regular calls.  Resuming and suspending can be partial-evaluated, leading to fast suspend/resume cycles.Serialization is done entirely in guest-side code, by having the Continuation class implement Serializable. Theformat is designed to enable backwards-compatible evolution of the format.Further Reading  Serialization of Continuations  Generator API",
          "url": " /latest/reference-manual/espresso/continuations/"
          },
          
          "community-contributors":  {
          "title": "Contribute to GraalVM",
          "content": "Contribute to GraalVMGraalVM is an open source Oracle project where people from all over the world contribute their work, help each other, and make GraalVM innovative.We are thankful for past contributions both big and small and always welcome new collaborators!Only a large community can make this project a strong language virtualization technology.There are two common ways to collaborate:  By submitting GitHub issues for bug reports, questions, or requests for enhancements. Note, that a security vulnerability should be reported to secalert_us@oracle.com.  By creating GitHub pull requests.If you consider contributing solely to the documentation, please check this guide.If you consider contributing to the GraalVM core, start by learning how to build a GraalVM distribution from sources, using mx – a unique building tool.Learn how to set up a proper development environment, load the GraalVM project into the IDE, and see the main classes one could look at to have the basic understanding what the compiler is doing. This video demonstrates the above.                              watch video                                                How to Become a GraalVM Contributor?Further below are some tips for contributing to GraalVM Community Edition and its projects, hosted in the Oracle organization on GitHub.We expect a contributor to abide by the Contributor Covenant Code of Conduct.Overall, there are three stages:I. Create a Pull RequestIf you believe your contribution is valuable for others, create a pull request (PR).The common process is forking a repository, submitting a change and creating a PR.When creating a PR, please make sure to include a clear description of the intention of the change, unless the change is self-explanatory, e.g., a version update.Describe why (1) the change or feature is needed, (2) how it is implemented, and, optionally, (3) what further implications it may have.You can either use the PR request description field or the commit message.It is recommended to address one feature or change per PR request.Once you have created a pull request, the Travis CI service will run some sanity checks on your change.Be sure to address any obvious issues caught by these checks (e.g., formatting violation), but keep in mind that test failures may not be directly related to your changes (no gate is perfect due to infrastructure issues and transient test failures).II. Sign the Oracle Contributor AgreementTo allow your pull request to be accepted, you will need to sign the Oracle Contributor Agreement (OCA).There are two types of OCAs: Individual OCAs and Company OCAs. Sign it online and, once your name or organization shows up in the OCA signatory list, we will add you to the database used to check that pull request authors are covered under the OCA.If it appears to be a delay in your entry showing up in the signatories list, please send an email to oracle-ca_us@oracle.com.If your entry is in the signatories list, but the bot leaves a message on your pull request that you have not signed the OCA, leave a comment on the pull request stating that you are now covered by the OCA.The bot operates from a database separate from the OCA signatories list (since the latter does not necessarily include email details) and must be manually updated.III. Review and MergeAn Oracle employee reviews the proposed change and once the pull request is in a mergeable state, takes responsibility for merging it to the main branch.To ensure extra diligence in terms of verifying externally contributed code meeting these requirements, we have an inbound-check-bot.What to Expect When Submitting a Pull Request?There are many directions to explore from smaller changes like bug fixes or improvements to the API documentation to larger changes that can either speed up theexecution, or give better control over the system.We look forward to extend the GraalVM ecosystem by implementing new languages support with the Truffle framework, providing better tooling for polyglot programming, or proposing new embedding scenarios.The continuous efforts are directed to the machine learning for optimizing compiler configurations.Contributors are welcomed to join the development of a fully meta-circular Java runtime written in Java.We keep on investigating techniques for more efficient memory usage and pursue improving performance for different workloads.To reach GraalVM developers for questions related to working with GraalVM sources, subscribe and post to graalvm-dev@oss.oracle.com.",
          "url": " /community/contributors/"
          },
          
          "latest-reference-manual-native-image-guides-create-heap-dump":  {
          "title": "Create a Heap Dump from a Native Executable",
          "content": "Create a Heap Dump from a Native ExecutableYou can create a heap dump of a running executable to monitor its execution.Just like any other Java heap dump, it can be opened with the VisualVM tool.To enable heap dump support, a native executable must be built with the --enable-monitoring=heapdump option. A heap dump can then be created in the following ways:  Create a heap dump with VisualVM.  The command-line option -XX:+HeapDumpOnOutOfMemoryError can be used to create a heap dump when the native executable runs out of Java heap memory.  Dump the initial heap of a native executable using the -XX:+DumpHeapAndExit command-line option.  Create a heap dump by sending a SIGUSR1 signal to the application at runtime.  Create a heap dump programmatically using the org.graalvm.nativeimage.VMRuntime#dumpHeap API.All approaches are described below.  Note: By default, a heap dump is created in the current working directory. The -XX:HeapDumpPath option can be used to specify an alternative filename or directory. For example:./helloworld -XX:HeapDumpPath=$HOME/helloworld.hprof  Creating a heap dump on the Microsoft Windows platform is not supported.Create a Heap Dump with VisualVMA convenient way to create a heap dump is to use VisualVM.For this, you need to add jvmstat to the --enable-monitoring option (for example, --enable-monitoring=heapdump,jvmstat).This will allow VisualVM to pick up and list running Native Image processes.You can then request a heap dump in the same way you can request one when your application runs on the JVM (for example, right-click on the process, then select Heap Dump).Create a Heap Dump on OutOfMemoryErrorStart the application with the option -XX:+HeapDumpOnOutOfMemoryError to get a heap dump when the native executable throws an OutOfMemoryError because it ran out of Java heap memory.The heap dump is created in a file named svm-heapdump-&amp;lt;PID&amp;gt;-OOME.hprof.For example:./mem-leak-example -XX:+HeapDumpOnOutOfMemoryErrorYou should see a similar output:Dumping heap to svm-heapdump-67799-OOME.hprof ...Heap dump file created [10046752 bytes in 0.49 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Garbage-collected heap size exceeded.Dump the Initial Heap of a Native ExecutableUse the -XX:+DumpHeapAndExit command-line option to dump the initial heap of a native executable.This can be useful to identify which objects the Native Image build process allocated to the executable’s heap. For a HelloWorld example, use the option as follows:native-image HelloWorld --enable-monitoring=heapdump./helloworld -XX:+DumpHeapAndExitThe heap dump is created at path/to/helloworld.hprof.Create a Heap Dump with SIGUSR1 (Linux/macOS only)  Note: This requires the Signal API, which is enabled by default except when building shared libraries.The following example is a simple multithreaded Java application that runs for 60 seconds. This provides you with enough time to send it a SIGUSR1 signal. The application will handle the signal and create a heap dump in the application’s working directory. The heap dump will contain the Collection of Persons referenced by the static variable CROWD.Follow these steps to build a native executable that will produce a heap dump when it receives a SIGUSR1 signal.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  Save the following code in a file named SVMHeapDump.java:    import java.nio.charset.Charset;import java.text.DateFormat;import java.util.ArrayList;import java.util.Collection;import java.util.Date;import java.util.Random;import org.graalvm.nativeimage.ProcessProperties;public class SVMHeapDump extends Thread {    static Collection&amp;lt;Person&amp;gt; CROWD = new ArrayList&amp;lt;&amp;gt;();    static DateFormat DATE_FORMATTER = DateFormat.getDateTimeInstance();    static int i = 0;    static int runs = 60;    static int sleepTime = 1000;    @Override    public void run() {        System.out.println(DATE_FORMATTER.format(new Date()) + &quot;: Thread started, it will run for &quot; + runs + &quot; seconds&quot;);        while (i &amp;lt; runs) {            // Add a new person to the collection            CROWD.add(new Person());            System.out.println(&quot;Sleeping for &quot; + (runs - i) + &quot; seconds.&quot;);            try {                Thread.sleep(sleepTime);            } catch (InterruptedException ie) {                System.out.println(&quot;Sleep interrupted.&quot;);            }            i++;        }    }    /**    * @param args the command line arguments    */    public static void main(String[] args) throws InterruptedException {        // Add objects to the heap        for (int i = 0; i &amp;lt; 1000; i++) {            CROWD.add(new Person());        }        long pid = ProcessProperties.getProcessID();        StringBuffer sb1 = new StringBuffer(100);        sb1.append(DATE_FORMATTER.format(new Date()));        sb1.append(&quot;: Hello GraalVM native image developer! n&quot;);        sb1.append(&quot;The PID of this process is: &quot; + pid + &quot;n&quot;);        sb1.append(&quot;Send it a signal: &quot;);        sb1.append(&quot;&#39;kill -SIGUSR1 &quot; + pid + &quot;&#39; n&quot;);        sb1.append(&quot;to dump the heap into the working directory.n&quot;);        sb1.append(&quot;Starting thread!&quot;);        System.out.println(sb1);        SVMHeapDump t = new SVMHeapDump();        t.start();        while (t.isAlive()) {            t.join(0);        }        sb1 = new StringBuffer(100);        sb1.append(DATE_FORMATTER.format(new Date()));        sb1.append(&quot;: Thread finished after: &quot;);        sb1.append(i);        sb1.append(&quot; iterations.&quot;);        System.out.println(sb1);    }}class Person {    private static Random R = new Random();    private String name;    private int age;                public Person() {        byte[] array = new byte[7];        R.nextBytes(array);        name = new String(array, Charset.forName(&quot;UTF-8&quot;));        age = R.nextInt(100);    }}        Build a native executable:    Compile SVMHeapDump.java as follows:     javac SVMHeapDump.java    Build a native executable using the --enable-monitoring=heapdump command-line option. (This causes the resulting native executable to produce a heap dump when it receives a SIGUSR1 signal.)     native-image SVMHeapDump --enable-monitoring=heapdump    The native-image builder creates a native executable from the file SVMHeapDump.class. When the command completes, the native executable svmheapdump is created in the current directory.        Run the application, send it a signal, and check the heap dump:    Run the application:     ./svmheapdump    You should see a similar output:     17 May 2022, 16:38:13: Hello GraalVM native image developer!  The PID of this process is: 57509 Send it a signal: &#39;kill -SIGUSR1 57509&#39;  to dump the heap into the working directory. Starting thread! 17 May 2022, 16:38:13: Thread started, it will run for 60 seconds    Make a note of the PID and open a second terminal.  Use the PID to send a signal to the application.  For example, if the PID is 57509:     kill -SIGUSR1 57509    The heap dump will be created in the working directory while the application continues to run. The heap dump can be opened with the VisualVM tool, as illustrated below.      Create a Heap Dump from within a Native ExecutableThe following example shows how to create a heap dump from a running native executable using VMRuntime.dumpHeap() if some condition is met.The condition to create a heap dump is provided as an option on the command line.      Save the code below in a file named SVMHeapDumpAPI.java.     import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.nio.charset.Charset; import java.text.DateFormat; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.Random; import org.graalvm.nativeimage.VMRuntime; public class SVMHeapDumpAPI {     static Collection&amp;lt;Person&amp;gt; CROWD = new ArrayList&amp;lt;&amp;gt;();     /**     * @param args the command line arguments     */     public static void main(String[] args) {            // Populate the crowd         for (int i = 0; i &amp;lt; 1000; i++) {             CROWD.add(new Person());         }         StringBuffer sb1 = new StringBuffer(100);         sb1.append(DateFormat.getDateTimeInstance().format(new Date()));         sb1.append(&quot;: Hello GraalVM native image developer. nYour command line options are: &quot;);         if (args.length &amp;gt; 0) {             sb1.append(args[0]);             System.out.println(sb1);             if (args[0].equalsIgnoreCase(&quot;--heapdump&quot;)) {                 createHeapDump();             }         } else {             sb1.append(&quot;None&quot;);             System.out.println(sb1);         }     }     /**     * Create a heap dump and save it into temp file     */     private static void createHeapDump() {         try {             File file = File.createTempFile(&quot;SVMHeapDumpAPI-&quot;, &quot;.hprof&quot;);             VMRuntime.dumpHeap(file.getAbsolutePath(), false);             System.out.println(&quot;  Heap dump created &quot; + file.getAbsolutePath() + &quot;, size: &quot; + file.length());         } catch (UnsupportedOperationException unsupported) {             System.err.println(&quot;Heap dump creation failed: &quot; + unsupported.getMessage());         } catch (IOException ioe) {             System.err.println(&quot;IO went wrong: &quot; + ioe.getMessage());         }     } } class Person {         private static Random R = new Random();         private String name;         private int age;                     public Person() {             byte[] array = new byte[7];             R.nextBytes(array);             name = new String(array, Charset.forName(&quot;UTF-8&quot;));             age = R.nextInt(100);         }     }    As in the earlier example, the application creates a Collection of Persons referenced by the static variable CROWD.  It then checks the command line to see if heap dump has to be created, and then in method createHeapDump() creates the heap dump.        Build a native executable.    Compile SVMHeapDumpAPI.java and build a native executable:     javac SVMHeapDumpAPI.java     native-image SVMHeapDumpAPI    When the command completes, the svmheapdumpapi native executable is created in the current directory.        Run the application and create a heap dump:     ./svmheapdumpapi --heapdump    You should see a similar output:     Sep 15, 2020, 4:06:36 PM: Hello GraalVM native image developer. Your command line options are: --heapdump   Heap dump created /var/folders/hw/s9d78jts67gdc8cfyq5fjcdm0000gp/T/SVMHeapDump-6437252222863577987.hprof, size: 8051959    The resulting heap dump can be then opened with the VisualVM tool like any other Java heap dump, as illustrated below.      Related Documentation  Debugging and Diagnostics  VisualVM",
          "url": " /latest/reference-manual/native-image/guides/create-heap-dump/"
          },
          
          "latest-tools-dap":  {
          "title": "Debug Adapter Protocol",
          "content": "Debug Adapter ProtocolGraalVM supports debugging of guest language applications, written in any of the supported languages (JavaScript/TypeScript, Python, R, or Ruby), and provides a built-in implementation of the Debug Adapter Protocol (DAP).By definition, Debug Adapter Protocol is to standardize the “communication” between the debugging component and a concrete debugger or runtime.This allows you to attach compatible debuggers such as Visual Studio Code (VS Code) to GraalVM.To open a debugger port serving Debug Adapter Protocol, you need to pass the --dap option to the command line launcher.The usage of Debug Adapter Protocol is similar to the existing Chrome DevTools Protocol implementation in the GraalVM runtime:  --dap.Suspend=false: disable the execution suspension at first source line, enabled by default.  --dap.WaitAttached: do not execute any source code until debugger client is attached. The default is false.  --dap=&amp;lt;[[host:]port]&amp;gt;: start the debugger on a different port than default (&amp;lt;host&amp;gt;:4711).Then you need a DAP client to connect to the open DAP port. VS Code will be used as an example.1. Save this Node.js application in a file named App.js:const express = require(&#39;express&#39;)const app = express()const port = 3000app.get(&#39;/&#39;, (req, res) =&amp;gt; {  res.send(&#39;Hello World!&#39;)})app.get(&#39;/neverCalled&#39;, (req, res) =&amp;gt; {  res.send(&#39;You should not be here&#39;)})app.get(&#39;/shutdown&#39;, (req, res) =&amp;gt; {  process.exit();})app.listen(port, () =&amp;gt; console.log(`Example app listening on port ${port}!`))2. Install the express module dependency in the directory where you saved the file:$JAVA_HOME/bin/npm install express3. Run the application with DAP enabled:$JAVA_HOME/bin/node --dap App.js[Graal DAP] Starting server and listening on localhost/127.0.0.1:47114. Start VS Code, freshly installed without any extensions:code .5. Open the App.js source in VS Code, and put a breakpoint, for example, at line 6 (res.send(&#39;Hello World!&#39;)).6. Navigate to View &amp;gt; Run to create a launch configuration (Ctrl+Shift+D):7. Then create the launch.json file with the following content:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;name&quot;: &quot;Attach&quot;,            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;attach&quot;,            &quot;debugServer&quot;: 4711        }    ]}8. Start debugging (F5).When debugging a guest language application from VS Code, a user can choose a protocol to use by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.To connect to the open DAP port in this scenario, the content of the launch.json should be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Node App&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;debugAdapter&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/App.js&quot;        }    ]}The advantage of using Debug Adapter Protocol over Chrome Dev Tools is that (1) it is ‘native’ to Visual Studio Code (VS Code), meaning it does not require any intermediate translation, and (2) that it supports multithreading, which can be particularly useful to debug, for example, a Ruby application.",
          "url": " /latest/tools/dap/"
          },
          
          "dashboard":  {
          "title": "GraalVM Dashboard",
          "content": "",
          "url": " /dashboard/"
          },
          
          "latest-reference-manual-native-image-guides-debug-native-image-process":  {
          "title": "Debug Native Executables with GDB",
          "content": "Debug Native Executables with GDBWhich GDB to Use?  Please use GDB 14.2 or later. The debug info is tested via mx debuginfotest against 14.2.  Note that later versions might have slightly different formatting of debugger output (which, for example, may cause CI/CD gate checks to fail)  GDB bundled in recent Linux releases works just fine for debugging sessionsBuild a Native Executable with Debug InformationTo build a native executable with debug information, provide the -g command-line option for javac when compiling the application, and then to the native-image builder. This enables source-level debugging, and the debugger (GDB) then correlates machine instructions with specific source lines in Java files.Adding -g to the native-image arguments causes debuginfo to be generated. Next to the native executable, there will be an &amp;lt;executable_name&amp;gt;.debug file that contains debuginfo and a sources/ directory that contains Java source files, which the debugger uses to show sources for lineinfo. For example:hello_imagehello_image.debugsourcesGDB automatically loads the &amp;lt;executable_name&amp;gt;.debug file for a given native executable &amp;lt;executable_name&amp;gt;. (There is a link between the native executable and its *.debug  file)  For a better debugging experience, we recommend combining -g with -O0.The latter option disables inlining and other optimizations of the Graal compiler, which otherwise would be observable in the debugger (for example, the debugger may jump back and forth between lines instead of allowing you to step from one line to the next one).At the same time, -O0 also enables additional metadata to be collected in the compiler, which then helps the debugger to resolve, for example, local variables.Use GDB with New Debug InformationBuild InformationThe *.debug file contains additional information about the build, which can be accessed as follows:readelf -p .debug.svm.imagebuild.classpath hello_image.debugIt gives a list of all class path entries that were used to build the native executable:String dump of section &#39;.debug.svm.imagebuild.classpath&#39;:  [     0]  /home/user/.mx/cache/HAMCREST_e237ae735aac4fa5a7253ec693191f42ef7ddce384c11d29fbf605981c0be077d086757409acad53cb5b9e53d86a07cc428d459ff0f5b00d32a8cbbca390be49/hamcrest.jar  [    b0]  /home/user/.mx/cache/JUNIT_5974670c3d178a12da5929ba5dd9b4f5ff461bdc1b92618c2c36d53e88650df7adbf3c1684017bb082b477cb8f40f15dcf7526f06f06183f93118ba9ebeaccce/junit.jar  [   15a]  /home/user/mx/mxbuild/jdk20/dists/jdk9/junit-tool.jar  [   1a9]  /home/user/graal/substratevm/mxbuild/jdk20/com.oracle.svm.test/binThe following sections are available  .debug.svm.imagebuild.classpath  .debug.svm.imagebuild.modulepath  .debug.svm.imagebuild.arguments  .debug.svm.imagebuild.java.propertiesWhere is the main() Method?Useinfo functions ::mainto find all methods named main and then use b &amp;lt;main method name&amp;gt;, for example:(gdb) info functions ::mainAll functions matching regular expression &quot;::main&quot;:File hello/Hello.java:76:void hello.Hello::main(java.lang.String[]*);File java/util/Timer.java:534:void java.util.TimerThread::mainLoop();(gdb) b &#39;hello.Hello::main&#39;Breakpoint 1 at 0x83c030: file hello/Hello.java, line 76.Set a BreakpointFirst, find the type of the method you want to set a breakpoint in, for example:(gdb) info types ArrayListAll types matching regular expression &quot;ArrayList&quot;:...File java/util/ArrayList.java:java.util.ArrayList;java.util.ArrayList$ArrayListSpliterator;java.util.ArrayList$Itr;java.util.ArrayList$ListItr;...Now use the following GDB autocompletion:(gdb) b &#39;java.util.ArrayList::Pressing tab twice now shows all ArrayList methods to choose from:java.util.ArrayList::ArrayList(int)                                                java.util.ArrayList::iterator()java.util.ArrayList::ArrayList(java.util.Collection*)                              java.util.ArrayList::lastIndexOf(java.lang.Object*)java.util.ArrayList::add(int, java.lang.Object*)                                   java.util.ArrayList::lastIndexOfRange(java.lang.Object*, int, int)java.util.ArrayList::add(java.lang.Object*)                                        java.util.ArrayList::listIterator()java.util.ArrayList::add(java.lang.Object*, java.lang.Object[]*, int)              java.util.ArrayList::listIterator(int)java.util.ArrayList::addAll(int, java.util.Collection*)                            java.util.ArrayList::nBits(int)java.util.ArrayList::addAll(java.util.Collection*)                                 java.util.ArrayList::outOfBoundsMsg(int)...If to complete with(gdb) b &#39;java.util.ArrayList::add`breakpoints in all variants of add are installed.ArraysArrays have a data field that can be accessed via an index to get the individual array elements, for example:Thread 1 &quot;hello_image&quot; hit Breakpoint 1, hello.Hello::main(java.lang.String[]*) (args=0x7ff33f800898) at hello/Hello.java:7676        Greeter greeter = Greeter.greeter(args);(gdb) p args$1 = (java.lang.String[] *) 0x7ff33f800898(gdb) p *args$2 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0x1e37be0    }, &amp;lt;No data fields&amp;gt;},   members of java.lang.String[]:  len = 4,  data = 0x7ff33f8008a0}(gdb) p args.data$3 = 0x7ff33f8008a0(gdb) ptype args.datatype = class _z_.java.lang.String : public java.lang.String {} *[0]Here args.data can be accessed via an index.In this case, the first of the four array elements is a pointer to a String:(gdb) p args.data[0]$4 = (_z_.java.lang.String *) 0x27011aStringsTo see the actual contents of a Java String object, look at its value field, for example:(gdb) p args.data[0]$4 = (_z_.java.lang.String *) 0x27011aargs.data[0] points to a String object. Let’s deref:(gdb) p *args.data[0]$5 = {  &amp;lt;java.lang.String&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1bb4780      }, &amp;lt;No data fields&amp;gt;},     members of java.lang.String:    value = 0x270118,    hash = 0,    coder = 0 &#39;000&#39;,    hashIsZero = false,    static CASE_INSENSITIVE_ORDER = 0x19d752,    ...    static COMPACT_STRINGS = true  }, &amp;lt;No data fields&amp;gt;}The value field holds the String data.Let’s check the type of value:(gdb) p args.data[0].value$3 = (_z_.byte[] *) 0x250119value is of type byte[].As you already learned before, the elements of an array can be accessed via its data field.(gdb) p args.data[0].value.data$10 = 0x7ff33f8008c8 &quot;this376376376376200G273001030001&#39;&quot;GDB is smart enough to interpret the byte-pointer as a C string out of the box.But in essence, it is an array.The following gives us the t from this.(gdb) p args.data[0].value.data[0]$13 = 116 &#39;t&#39;The reason for the garbage after the last char is that Java String values are not 0-terminated (unlike C strings).To know where the garbage starts you can inspect the len field.(gdb) p args.data[0].value.len$14 = 4DowncastingSuppose your source uses a variable of static type Greeter and you want to inspect its data.75    public static void main(String[] args) {76        Greeter greeter = Greeter.greeter(args);77        greeter.greet(); // Here you might have a NamedGreeterAs you can see, currently GDB only knows about the static type of greeter in line 77:Thread 1 &quot;hello_image&quot; hit Breakpoint 2, hello.Hello::main(java.lang.String[]*) (args=&amp;lt;optimized out&amp;gt;) at hello/Hello.java:7777        greeter.greet();(gdb) p greeter$17 = (hello.Hello$Greeter *) 0x7ff7f9101208Also, you are not able to see fields that only exist for the NamedGreeter subclass.(gdb) p *greeter$18 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0x1d1cae0    }, &amp;lt;No data fields&amp;gt;}, &amp;lt;No data fields&amp;gt;}But you do have the hub field, which points to the class-object of an object.Therefore, it allows you to determine the runtime-type of the Greeter object at address 0x7ff7f9101208:(gdb) p greeter.hub$19 = (_z_.java.lang.Class *) 0x1d1cae0(gdb) p *greeter.hub$20 = {  &amp;lt;java.lang.Class&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1bec910      }, &amp;lt;No data fields&amp;gt;},     members of java.lang.Class:    typeCheckStart = 1188,    name = 0xb94a2, &amp;lt;&amp;lt;&amp;lt;&amp;lt; WE ARE INTERESTED IN THIS FIELD    superHub = 0x90202,    ...    monitorOffset = 8,    optionalIdentityHashOffset = 12,    flags = 0,    instantiationFlags = 3 &#39;003&#39;  }, &amp;lt;No data fields&amp;gt;}(gdb) p greeter.hub.name$21 = (_z_.java.lang.String *) 0xb94a2(gdb) p greeter.hub.name.value.data$22 = 0x7ff7f80705b8 &quot;hello.Hello$NamedGreeter351001~*&quot;So you learned that the actual type of that object is hello.Hello$NamedGreeter.Now cast to that type:(gdb) set $rt_greeter = (&#39;hello.Hello$NamedGreeter&#39; *) greeterNow you can inspect the downcasted convenience variable rt_greeter:(gdb) p $rt_greeter$23 = (hello.Hello$NamedGreeter *) 0x7ff7f9101208(gdb) p *$rt_greeter$24 = {  &amp;lt;hello.Hello$Greeter&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1d1cae0      }, &amp;lt;No data fields&amp;gt;}, &amp;lt;No data fields&amp;gt;},   members of hello.Hello$NamedGreeter:  name = 0x270119}Now you can see the name field that only exists in the NamedGreeter subtype.(gdb) p $rt_greeter.name$25 = (_z_.java.lang.String *) 0x270119So the name field is of type String. You already know how to see the contents of a String:(gdb) p $rt_greeter.name.value.data$26 = 0x7ff7f91008c0 &quot;FooBar376376200G273001027001&#39;&quot;  Note: If the static type that you want to downcast from is a compressed reference then the type used in the downcast also needs to be that of a compressed reference.For example, if you have:(gdb) p elementData.data[0]$38 = (_z_.java.lang.Object *) 0x290fccIn the internal array of an ArrayList, the first entry points to a java.lang.Object with a _z_. prefix, which denotes that this is a compressed ref.To check what the runtime-type of that object is, use:(gdb) p elementData.data[0].hub.name.value.data$40 = 0x7ff7f8665600 &quot;java.lang.String=256271`&quot;Now you know that the compressed ref actually points to a java.lang.String.Then, when you cast, do not forget to use the _z_. prefix.(gdb) p (&#39;_z_.java.lang.String&#39; *) elementData.data[0]$41 = (_z_.java.lang.String *) 0x290fcc(gdb) p *$41$43 = {  &amp;lt;java.lang.String&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1bb4780      }, &amp;lt;No data fields&amp;gt;},     members of java.lang.String:    value = 0x290fce,    ...To see the contents of that String, again use:(gdb) p $41.value.data$44 = 0x7ff7f9207e78 &quot;#subsys_namethierarchytnum_cgroupstenabled&quot;Using the this variable in instance methods(gdb) bt#0  hello.Hello$NamedGreeter::greet() (this=0x7ff7f9101208) at hello/Hello.java:71#1  0x000000000083c060 in hello.Hello::main(java.lang.String[]*) (args=&amp;lt;optimized out&amp;gt;) at hello/Hello.java:77#2  0x0000000000413355 in com.oracle.svm.core.JavaMainWrapper::runCore0() () at com/oracle/svm/core/JavaMainWrapper.java:178#3  0x00000000004432e5 in com.oracle.svm.core.JavaMainWrapper::runCore() () at com/oracle/svm/core/JavaMainWrapper.java:136#4  com.oracle.svm.core.JavaMainWrapper::doRun(int, org.graalvm.nativeimage.c.type.CCharPointerPointer*) (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at com/oracle/svm/core/JavaMainWrapper.java:233#5  com.oracle.svm.core.JavaMainWrapper::run(int, org.graalvm.nativeimage.c.type.CCharPointerPointer*) (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at com/oracle/svm/core/JavaMainWrapper.java:219#6  com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_e6899342f5939c89e6e2f78e2c71f5f4926b786d(int, org.graalvm.nativeimage.c.type.CCharPointerPointer*) (__0=&amp;lt;optimized out&amp;gt;, __1=&amp;lt;optimized out&amp;gt;)at com/oracle/svm/core/code/IsolateEnterStub.java:1(gdb) p this$1 = (hello.Hello$NamedGreeter *) 0x7ff7f9001218(gdb) p *this$2 = {  &amp;lt;hello.Hello$Greeter&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1de2260      }, &amp;lt;No data fields&amp;gt;}, &amp;lt;No data fields&amp;gt;},   members of hello.Hello$NamedGreeter:  name = 0x25011b}(gdb) p this.name$3 = (_z_.java.lang.String *) 0x270119Just like in Java or C++ code, in instance-methods, prefixing with this. is not needed.(gdb) p name$7 = (_z_.java.lang.String *) 0x270119(gdb) p name.value.data$8 = 0x7ff7f91008c0 &quot;FooBar376376200G273001027001&#39;&quot;Accessing static fieldsWhile static fields are shown whenever an instance of an object is printed, you just want to see the value of a specific static field.(gdb) p &#39;java.math.BigDecimal::BIG_TEN_POWERS_TABLE&#39;$23 = (_z_.java.math.BigInteger[] *) 0x132b95To get a list of all static fields, use:(gdb) info variables ::Inspecting .class ObjectsFor every Java type in the image, there exists an easy way to access its class object (aka the hub).(gdb) info types PrintStreamAll types matching regular expression &quot;PrintStream&quot;:...File java/io/PrintStream.java:java.io.PrintStream;java.io.PrintStream$1;...To access the hub of java.io.PrintStream, you can use the .class suffix:(gdb) p &#39;java.io.PrintStream.class&#39;$4 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0x1bec910    }, &amp;lt;No data fields&amp;gt;},   members of java.lang.Class:  typeCheckStart = 1340,  name = 0xbab58,  superHub = 0x901ba,  ...  sourceFileName = 0xbab55,  classInitializationInfo = 0x14d189,  module = 0x14cd8d,  nestHost = 0xde78d,  simpleBinaryName = 0x0,  companion = 0x149856,  signature = 0x0,  ...}This allows you, for example, to check which module java.io.PrintStream belongs to:(gdb) p &#39;java.io.PrintStream.class&#39;.module.name.value.data$12 = 0x7ff7f866b000 &quot;java.base&quot;Inlined methodsSetting a breakpoint in PrintStream.writeln(gdb) b java.io.PrintStream::writelnBreakpoint 2 at 0x4080cb: java.io.PrintStream::writeln. (35 locations)Now you navigate to:(gdb) bt#0  java.io.BufferedWriter::min(int, int) (this=&amp;lt;optimized out&amp;gt;, a=8192, b=14) at java/io/BufferedWriter.java:216#1  java.io.BufferedWriter::implWrite(java.lang.String*, int, int) (this=0x7ff7f884e828, s=0x7ff7f9101230, off=&amp;lt;optimized out&amp;gt;, len=&amp;lt;optimized out&amp;gt;) at java/io/BufferedWriter.java:329#2  0x000000000084c50d in java.io.BufferedWriter::write(java.lang.String*, int, int) (this=&amp;lt;optimized out&amp;gt;, s=&amp;lt;optimized out&amp;gt;, off=&amp;lt;optimized out&amp;gt;, len=&amp;lt;optimized out&amp;gt;) at java/io/BufferedWriter.java:313#3  0x0000000000901369 in java.io.Writer::write(java.lang.String*) (this=&amp;lt;optimized out&amp;gt;, str=&amp;lt;optimized out&amp;gt;) at java/io/Writer.java:278#4  0x00000000008df465 in java.io.PrintStream::implWriteln(java.lang.String*) (this=0x7ff7f87e67b8, s=&amp;lt;optimized out&amp;gt;) at java/io/PrintStream.java:846#5  0x00000000008e10a5 in java.io.PrintStream::writeln(java.lang.String*) (this=0x7ff7f87e67b8, s=&amp;lt;optimized out&amp;gt;) at java/io/PrintStream.java:826#6  0x000000000083c00c in java.io.PrintStream::println(java.lang.String*) (this=&amp;lt;optimized out&amp;gt;, x=&amp;lt;optimized out&amp;gt;) at java/io/PrintStream.java:1168#7  hello.Hello$NamedGreeter::greet() (this=&amp;lt;optimized out&amp;gt;) at hello/Hello.java:71#8  0x000000000083c060 in hello.Hello::main(java.lang.String[]*) (args=&amp;lt;optimized out&amp;gt;) at hello/Hello.java:77#9  0x0000000000413355 in com.oracle.svm.core.JavaMainWrapper::runCore0() () at com/oracle/svm/core/JavaMainWrapper.java:178#10 0x00000000004432e5 in com.oracle.svm.core.JavaMainWrapper::runCore() () at com/oracle/svm/core/JavaMainWrapper.java:136#11 com.oracle.svm.core.JavaMainWrapper::doRun(int, org.graalvm.nativeimage.c.type.CCharPointerPointer*) (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at com/oracle/svm/core/JavaMainWrapper.java:233#12 com.oracle.svm.core.JavaMainWrapper::run(int, org.graalvm.nativeimage.c.type.CCharPointerPointer*) (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at com/oracle/svm/core/JavaMainWrapper.java:219#13 com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_e6899342f5939c89e6e2f78e2c71f5f4926b786d(int, org.graalvm.nativeimage.c.type.CCharPointerPointer*) (__0=&amp;lt;optimized out&amp;gt;, __1=&amp;lt;optimized out&amp;gt;)    at com/oracle/svm/core/code/IsolateEnterStub.java:1If you query extra info about the top frame, you see that min got inlined into implWrite:(gdb) info frameStack level 0, frame at 0x7fffffffdb20: rip = 0x84af8a in java.io.BufferedWriter::min(int, int) (java/io/BufferedWriter.java:216); saved rip = 0x84c50d inlined into frame 1 source language unknown. Arglist at unknown address. Locals at unknown address, Previous frame&#39;s sp in rspNow stepping into the use-site of min, you see that value 14 was returned by min (as expected):(gdb) bt#0  java.lang.String::getChars(int, int, char[]*, int) (this=0x7ff7f9101230, srcBegin=0, srcEnd=14, dst=0x7ff7f858ac58, dstBegin=0) at java/lang/String.java:1688#1  java.io.BufferedWriter::implWrite(java.lang.String*, int, int) (this=0x7ff7f884e828, s=0x7ff7f9101230, off=&amp;lt;optimized out&amp;gt;, len=&amp;lt;optimized out&amp;gt;) at java/io/BufferedWriter.java:330...Calling svm_dbg_ helper functions during debuggingWhen the image gets built with -H:+IncludeDebugHelperMethods, additional @CEntryPoint functions are defined that can be called from GDB during debugging, for example:(gdb) p greeter $3 = (hello.Hello$Greeter *) 0x7ffff6881900Here again, you have a local named greeter with the static-type hello.Hello$Greeter.To see its runtime-type, you can use the methods already described above.Alternatively, you can make use of the svm_dbg_ helper functions.For example, from within the running debug session, you can call:void svm_dbg_print_hub(graal_isolatethread_t* thread, size_t hubPtr)You have to pass a value for graal_isolatethread_t and the absolute address of the hub you want to get printed.In most situations, the value for graal_isolatethread_t is just the value of the current IsolateThread that can be found in a platform-specific register:            Platform      Register                  amd64      $r15              aarch64      $r28      Finally, before you can call svm_dbg_print_hub, make sure you have the absolute address of the hub you want to print. Using(gdb) p greeter.hub$4 = (_z_.java.lang.Class *) 0x837820 &amp;lt;java.io.ObjectOutputStream::ObjectOutputStream(java.io.OutputStream*)+1120&amp;gt;reveals that in the current situation, the hub field in greeter holds a compressed reference to the hub (the hub-type is prefixed with _z_.). Thus, you first need to get the absolute address of the hub field by using another svm_dbg_ helper method.(gdb) call svm_dbg_obj_uncompress($r15, greeter.hub)$5 = 140737339160608(gdb) p/x $5$6 = 0x7ffff71b7820With the help of calling svm_dbg_obj_uncompress, you now know that the hub is located at address 0x7ffff71b7820 and you can finally call svm_dbg_print_hub:(gdb) call (void) svm_dbg_print_hub($r15, 0x7ffff71b7820)hello.Hello$NamedGreeterBoth calls to svm_dbg_ helper can be combined into a single command line:(gdb) call (void) svm_dbg_print_hub($r15, svm_dbg_obj_uncompress($r15, greeter.hub))hello.Hello$NamedGreeterThe following svm_dbg_ helper methods are currently defined:int svm_dbg_ptr_isInImageHeap(graal_isolatethread_t* thread, size_t ptr);int svm_dbg_ptr_isObject(graal_isolatethread_t* thread, size_t ptr);int svm_dbg_hub_getLayoutEncoding(graal_isolatethread_t* thread, size_t hubPtr);int svm_dbg_hub_getArrayElementSize(graal_isolatethread_t* thread, size_t hubPtr);int svm_dbg_hub_getArrayBaseOffset(graal_isolatethread_t* thread, size_t hubPtr);int svm_dbg_hub_isArray(graal_isolatethread_t* thread, size_t hubPtr);int svm_dbg_hub_isPrimitiveArray(graal_isolatethread_t* thread, size_t hubPtr);int svm_dbg_hub_isObjectArray(graal_isolatethread_t* thread, size_t hubPtr);int svm_dbg_hub_isInstance(graal_isolatethread_t* thread, size_t hubPtr);int svm_dbg_hub_isReference(graal_isolatethread_t* thread, size_t hubPtr);long long int svm_dbg_obj_getHub(graal_isolatethread_t* thread, size_t objPtr);long long int svm_dbg_obj_getObjectSize(graal_isolatethread_t* thread, size_t objPtr);int svm_dbg_obj_getArrayElementSize(graal_isolatethread_t* thread, size_t objPtr);long long int svm_dbg_obj_getArrayBaseOffset(graal_isolatethread_t* thread, size_t objPtr);int svm_dbg_obj_isArray(graal_isolatethread_t* thread, size_t objPtr);int svm_dbg_obj_isPrimitiveArray(graal_isolatethread_t* thread, size_t objPtr);int svm_dbg_obj_isObjectArray(graal_isolatethread_t* thread, size_t objPtr);int svm_dbg_obj_isInstance(graal_isolatethread_t* thread, size_t objPtr);int svm_dbg_obj_isReference(graal_isolatethread_t* thread, size_t objPtr);long long int svm_dbg_obj_uncompress(graal_isolatethread_t* thread, size_t compressedPtr);long long int svm_dbg_obj_compress(graal_isolatethread_t* thread, size_t objPtr);int svm_dbg_string_length(graal_isolatethread_t* thread, size_t strPtr);void svm_dbg_print_hub(graal_isolatethread_t* thread, size_t hubPtr);void svm_dbg_print_obj(graal_isolatethread_t* thread, size_t objPtr);void svm_dbg_print_string(graal_isolatethread_t* thread, size_t strPtr);void svm_dbg_print_fatalErrorDiagnostics(graal_isolatethread_t* thread, size_t sp, void * ip);void svm_dbg_print_locationInfo(graal_isolatethread_t* thread, size_t mem);Related Documentation  Debug Info Feature  Debug Native Executables with a Python Helper Script",
          "url": " /latest/reference-manual/native-image/guides/debug-native-image-process/"
          },
          
          "latest-reference-manual-native-image-guides-debug-native-image-process-with-python-helper-script":  {
          "title": "Debug Native Executables with a Python Helper Script",
          "content": "Debug Native Executables with a Python Helper ScriptAdditionally to the GDB debugging, you can debug a native-image process using a Python helper script, gdb-debughelpers.py.The GDB Python API is used to provide a reasonably good experience for debugging native executables or shared libraries.It requires GDB with Python support.The debugging extension is tested against GDB 14.2 and supports the new debuginfo generation introduced in GraalVM for JDK 17 and later.  Note: The gdb-debughelpers.py file does not work with versions older than version 14.2 of gdb or versions older than GraalVM for JDK 17.The Python script gdb-debughelpers.py can be found in the &amp;lt;GRAALVM_HOME&amp;gt;/lib/svm/debug directory.If debuginfo generation is enabled (see Build a Native Executable with Debug Information), the script is copied to the build directory.The native-image tool adds the debugging section .debug_gdb_scripts to the debug info file, which causes GDB to automatically load gdb-debughelpers.py from the current working directory.For security reasonsthe first time GDB encounters a native executable or shared library that requests a specific Python file to be loaded it will print a warning:  warning: File &quot;&amp;lt;CWD&amp;gt;/gdb-debughelpers.py&quot; auto-loading has been declined by your `auto-load safe-path&#39; set to &quot;$debugdir:$datadir/auto-load&quot;.To enable execution of this file add        add-auto-load-safe-path &amp;lt;CWD&amp;gt;/gdb-debughelpers.pyline to your configuration file &quot;&amp;lt;HOME&amp;gt;/.gdbinit&quot;.To completely disable this security protection add        add-auto-load-safe-path /line to your configuration file &quot;&amp;lt;HOME&amp;gt;/.gdbinit&quot;.For more information about this security protection see the&quot;Auto-loading safe path&quot; section in the GDB manual.  E.g., run from the shell:        info &quot;(gdb)Auto-loading safe path&quot;To solve this, either add the current working directory to ~/.gdbinit as follows:echo &quot;add-auto-load-safe-path &amp;lt;CWD&amp;gt;/gdb-debughelpers.py&quot; &amp;gt;&amp;gt; ~/.gdbinitor pass the path as a command line argument to gdb:gdb -iex &quot;set auto-load safe-path &amp;lt;CWD&amp;gt;/gdb-debughelpers.py&quot; &amp;lt;binary-name&amp;gt;Both enable GDB to auto-load gdb-debughelpers.py from the current working directory.Auto-loading is the recommended way to provide the script to GDB.However, it is possible to manually load the script from GDB explicitly with:(gdb) source gdb-debughelpers.pyPretty Printing SupportLoading gdb-debughelpers.py registers a new pretty printer to GDB, which adds an extra level of convenience for debugging native executables or shared libraries.This pretty printer handles the printing of Java Objects, Arrays, Strings, and Enums for debugging native executables or shared libraries.If the Java application uses @CStruct and @CPointer annotations to access C data structures, the pretty printer will also try to print them as if they were Java data structures.If the C data structures cannot be printed by the pretty printer, printing is performed by GDB.The pretty printer also prints of the primitive value of a boxed primitive (instead of a Java Object).Whenever printing is done via the p alias of the print command the pretty printer intercepts that call to perform type casts to the respective runtime types of Java Objects.This also applies for auto-completion when using the p alias.This means that if the static type is different to the runtime type, the print command uses the static type, which leaves the user to discover the runtime type and typecast it.Additionally, the p alias understands Java field and array access and function calls for Java Objects.LimitationsThe print command still uses its default implementation, as there is no way to overwrite it, while still keeping the capability of the default print command.Overriding would cause printing non-Java Objects to not work properly.Therefore, only the p alias for the print command is overwritten by the pretty printer, such that the user can still make use of the default GDB print command.Options to Control the Pretty Printer BehaviorIn addition to the enhanced p alias, gdb-debughelpers.py introduces some GDB parameters to customize the behavior of the pretty printer.Parameters in GDB can be controlled with set &amp;lt;param&amp;gt; &amp;lt;value&amp;gt; and show &amp;lt;param&amp;gt; commands, and thus integrate with GDB’s customization options.      svm-print on/off  Use this command to enable/disable the pretty printer.This also resets the print command alias p to its default behavior.Alternatively pretty printing can be suppressed with theraw printing option of GDB’s print command:(gdb) show svm-printThe current value of &#39;svm-print&#39; is &quot;on&quot;.(gdb) print str$1 = &quot;string&quot;(gdb) print/r str$2 = (java.lang.String *) 0x7ffff689d2d0(gdb) set svm-print off1 printer disabled1 of 2 printers enabled(gdb) print str$3 = (java.lang.String *) 0x7ffff689d2d0      svm-print-string-limit &amp;lt;int&amp;gt;  Customizes the maximum length for pretty printing a Java String.The default value is 200.Set to -1 or unlimited for unlimited printing of a Java String.This does not change the limit for a C String, which can be controlled with GDB’s set print characters command.      svm-print-element-limit &amp;lt;int&amp;gt;  Customizes the maximum number of elements for pretty printing a Java Array, ArrayList, and HashMap.The default value is 10.Set to -1 or unlimited to print an unlimited number of elements.This does not change the limit for a C array, which can be controlled with GDB’s set print elements command.However, GDB’s parameter print elements is the upper bound for svm-print-element-limit.      svm-print-field-limit &amp;lt;int&amp;gt;  Customizes the maximum number of elements for pretty printing fields of a Java Object.The default value is 50.Set to -1 or unlimited to print an unlimited number of fields.GDB’s parameter print elements is the upper bound for svm-print-field-limit.      svm-print-depth-limit &amp;lt;int&amp;gt;  Customizes the maximum depth of recursive pretty printing.The default value is 1.The children of direct children are printed (a sane default to make contents of boxed values visible).Set to -1 or unlimited to print unlimited depth.GDB’s parameter print max-depth is the upper bound for svm-print-depth-limit.      svm-use-hlrep on/off  Enables/disables pretty printing for higher level representations.It provides a more data-oriented view on some Java data structures with a known internal structure such as Lists or Maps.Currently supports ArrayList and HashMap.      svm-infer-generics &amp;lt;int&amp;gt;  Customizes the number of elements taken into account to infer the generic type of higher level representations.The default value is 10.Set to 0 to not infer generic types and -1 or unlimited to infer the generic type of all elements.      svm-print-address absolute/on/off  Enables/disables printing of addresses in addition to regular pretty printing.When absolute mode is used even compressed references are shown as absolute addresses.Printing addresses is disabled by default.      svm-print-static-fields on/off  Enables/disables printing of static fields for a Java Object.Printing static fields is disabled by default.      svm-complete-static-variables on/off  Enables/disables auto-completion of static field members for the enhanced p alias.Auto-completion of static fields is enabled by default.      svm-selfref-check on/off  Enables/disables self-reference checks for data structures.The pretty printer detects a self-referential data structure and prevents further expansion to avoid endless recursion.Self-reference checks are enabled by default.For testing, this feature can be temporary disabled (usually you wouldn’t want to do this).Related Documentation  Debug Info Feature  Debug Native Executables with GDB",
          "url": " /latest/reference-manual/native-image/guides/debug-native-image-process-with-python-helper-script/"
          },
          
          "downloads-thanks":  {
          "title": "Download GraalVM",
          "content": "",
          "url": " /downloads-thanks/"
          },
          
          "downloads":  {
          "title": "Download GraalVM",
          "content": "",
          "url": " /downloads/"
          },
          
          "latest-reference-manual-embed-languages":  {
          "title": "Embedding Languages",
          "content": "Embedding Languages  Dependency Setup  Compile and Run a Polyglot Application  Define Guest Language Functions as Java Values  Access Guest Languages Directly from Java  Access Java from Guest Languages  Lookup Java Types from Guest Languages  Computed Arrays Using Polyglot Proxies  Host Access  Runtime Optimization Support  Build Native Executables from Polyglot Applications  Code Caching Across Multiple Contexts  Polyglot Isolates  Embed Guest Languages in Java  Build a Shell for Many Languages  Step Through with Execution Listeners  Setting the Heap Size  Compatibility with JSR-223 ScriptEngineThe GraalVM Polyglot API lets you embed and run code from guest languages in Java host applications.Throughout this section, you will learn how to create a host application in Java that runs on GraalVM and directly calls a guest language.You can use the tabs beneath each code example to choose between JavaScript, R, Ruby, and Python.  Note: The usage description for polyglot embeddings was revised with GraalVM for JDK 21 and Polyglot API version 23.1.0. If you are still using Polyglot API version older than 23.1.0, ensure the correct version of the documentation is displayed. More information on the change can be found in the release notes.Dependency SetupSince Polyglot API version 23.1.0, all necessary artifacts can be downloaded directly from Maven Central.Artifacts relevant to embedders can be found in the Maven dependency group org.graalvm.polyglot.See the polyglot embedding demonstration on GitHub for a complete runnable example.Here is an example Maven dependency setup that you can put into your project:&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;&amp;lt;!-- Select a language: js, ruby, python, java, llvm, wasm, languages--&amp;gt;&amp;lt;artifactId&amp;gt;js&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- Add additional languages if needed --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;!-- Select a tool: profiler, inspect, coverage, dap, tools --&amp;gt;&amp;lt;artifactId&amp;gt;profiler&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;  The pom type is a requirement for language or tool dependencies.Language and tool dependencies use the GraalVM Free Terms and Conditions (GFTC) license.To use community-licensed versions instead, add the -community suffix to each artifact (for example, js-community).To access polyglot isolate artifacts, use the -isolate suffix instead (for example, js-isolate).The artifacts languages and tools include all available languages and tools as dependencies.This artifact might grow or shrink between major releases.We recommend selecting only the needed language(s) for a production deployment.Additionally, your module-info.java file should require org.graalvm.polyglot when using Java modules:module com.mycompany.app {  requires org.graalvm.polyglot;}Whether your configuration can run with a Truffle runtime optimization depends on the GraalVM JDK you use.For further details, refer to the Runtime Compilation section.We recommend configuring polyglot embeddings using modules and the module path whenever possible.Be aware that using org.graalvm.polyglot from the class path instead will enable access to unsafe APIs for all libraries on the class path.If the application is not yet modularized, hybrid use of the class path and module path is possible.For example:$java -classpath=lib --module-path=lib/polyglot --add-modules=org.graalvm.polyglot ...In this example, lib/polyglot directory should contain all polyglot and language JAR files.To access polyglot classes from the class path, you must also specify the --add-modules=org.graalvm.polyglot JVM option.If you are using GraalVM Native Image, polyglot modules on the class path will be automatically upgraded to the module path.While we do support creating single uber JAR files from polyglot libraries, for example, using the Maven Assembly plugin, we do not recommend it.Also note that uber JAR files are not supported when creating native binaries with GraalVM Native Image.Compile and Run a Polyglot ApplicationGraalVM can run polyglot applications written in any language implemented with the Truffle language implementation framework.These languages are henceforth referenced as guest languages.Complete the steps in this section to create a sample polyglot application that runs on GraalVM and demonstrates programming language interoperability.      Create a new Java project using Maven.    Clone the polyglot-embedding-demo repository:     git clone https://github.com/graalvm/polyglot-embedding-demo.git        Insert the example code into the Main class.        Update the Maven pom.xml dependency configuration to include the languages to run as described in the previous section.        Download and install GraalVM by setting the value of the JAVA_HOME environment variable to the location of a GraalVM JDK.    Run mvn package exec:exec to build and execute the sample code.You now have a polyglot application that consists of a Java host application and guest language code, running on GraalVM.You can use this application with other code examples to demonstrate more advanced capabilities of the GraalVM Polyglot API.Define Guest Language Functions as Java ValuesPolyglot applications let you take values from one programming language and use them with other languages.Use the code example in this section with your polyglot application to show how the Polyglot API can return JavaScript or Python functions as Java values.              // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_js {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;js&quot;, &quot;x =&amp;gt; x+1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;}// END-SNIPPET    }}                        // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_python {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;python&quot;, &quot;lambda x: x + 1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;} // END-SNIPPET    }}                    JavaScript      Python          In this code:  Value function is a Java value that refers to a function.  The eval call parses the script and returns the guest language function.  The first assertion checks that the value returned by the code snippet can be executed.  The execute call executes the function with the argument 41.  The asInt call converts the result to a Java int.  The second assertion verifies that the result was incremented by one as expected.Access Guest Languages Directly from JavaPolyglot applications can readily access most language types and are not limited to functions.Host languages, such as Java, can directly access guest language values embedded in the polyglot application.Use the code example in this section with your polyglot application to show how the Polyglot API can access objects, numbers, strings, and arrays.              // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_js_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;js&quot;,                     &quot;({ &quot;                   +                        &quot;id   : 42, &quot;       +                        &quot;text : &#39;42&#39;, &quot;     +                        &quot;arr  : [1,42,3] &quot;  +                    &quot;})&quot;);    assert result.hasMembers();    int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;    String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);    Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                        // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_python_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;python&quot;,                     &quot;type(&#39;obj&#39;, (object,), {&quot; +                        &quot;&#39;id&#39;  : 42, &quot;         +                        &quot;&#39;text&#39;: &#39;42&#39;, &quot;       +                        &quot;&#39;arr&#39; : [1,42,3]&quot;     +                    &quot;})()&quot;);    assert result.hasMembers();        int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;        String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);        Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                    JavaScript      Python          In this code:  Value result is an Object that contains three members: a number named id, a string named text, and an array named arr.  The first assertion verifies that the return value can contain members, which indicates that the value is an object-like structure.  The id variable is initialized by reading the member with the name id from the resulting object. The result is then converted to a Java int using asInt().  The next assert verifies that result has a value of 42.  The text variable is initialized using the value of the member text, which is also converted to a Java String using asString().  The following assertion verifies the result value is equal to the Java String &quot;42&quot;.  Next the arr member that holds an array is read.  Arrays return true for hasArrayElements.  The next assertion verifies that the size of the array equals three. The Polyglot API supports big arrays, so the array length is of type long.  Finally we verify that the array element at index 1 equals 42. Array indexing with polyglot values is always zero-based, even for languages where indices start with one.Access Java from Guest LanguagesPolyglot applications offer bi-directional access between guest languages and host languages.As a result, you can pass Java objects to guest languages.Since the Polyglot API is secure by default, access is limited in the default configuration.To permit guest languages to access any public method or field of a Java object, you have to explicitly specify allowAllAccess(true) when the context is built.In this mode, the guest language code can access any resource that is accessible to host Java code.Use the code example in this section with your polyglot application to show how guest languages can access primitive Java values, objects, arrays, and functional interfaces.              // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_js {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getBindings(&quot;js&quot;).putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;js&quot;,               &quot;    javaObj.id         == 42&quot;          +               &quot; &amp;amp;&amp;amp; javaObj.text       == &#39;42&#39;&quot;        +               &quot; &amp;amp;&amp;amp; javaObj.arr[1]     == 42&quot;          +               &quot; &amp;amp;&amp;amp; javaObj.ret42()    == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                        // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_python {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getPolyglotBindings().putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;python&quot;,               &quot;import polyglot n&quot;                            +               &quot;javaObj =  polyglot.import_value(&#39;javaObj&#39;)n&quot; +               &quot;javaObj.id                   == 42&quot;            +               &quot; and javaObj.text            == &#39;42&#39;&quot;          +               &quot; and javaObj.arr[1]          == 42&quot;            +               &quot; and javaObj.ret42() == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                    JavaScript      Python          In this code:  The Java class MyClass has four public fields id, text, arr, andret42. The fields are initialized with 42, &quot;42&quot;, new int[]{1, 42, 3}, andlambda () -&amp;gt; 42 that always returns an int value of 42.  The Java class MyClass is instantiated and exported with the name javaObjinto the polyglot scope, which allows the host and guest languages to exchangesymbols.  A guest language script is evaluated that imports the javaObj symbol andassigns it to the local variable which is also named javaObj. To avoidconflicts with variables, every value in the polyglot scope must be explicitlyimported and exported in the top-most scope of the language.  The next two lines verify the contents of the Java object by comparing itto the number 42 and the string &#39;42&#39;.  The third verification reads from the second array position and compares itto the number 42. Whether arrays are accessed using 0-based or 1-based indicesdepends on the guest language. Independently of the language, the Java arraystored in the arr field is always accessed using translated 0-based indices. Forexample, in the JavaScript and Ruby languages, the secondarray element is at index 1. In all language examples, the Java array is readfrom using the same index 1.  The last line invokes the Java lambda that is contained in the field ret42and compares the result to the number value 42.  After the guest language script executes, validation takes place to ensurethat the script returns a boolean value of true as a result.Lookup Java Types from Guest LanguagesIn addition to passing Java objects to the guest language, it is possible to allow the lookup of Java types in the guest language.Use the code example in this section with your polyglot application to show how guest languages lookup Java types and instantiate them.              // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_js {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;js&quot;,            &quot;var BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;);&quot; +            &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                        // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_python {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;python&quot;,            &quot;import javan&quot; +            &quot;BigDecimal = java.type(&#39;java.math.BigDecimal&#39;)n&quot; +             &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                    JavaScript      Python          In this code:  A new context is created with all access enabled (allowAllAccess(true)).  A guest language script is evaluated.  The script looks up the Java type java.math.BigDecimal and stores it in a variable named BigDecimal.  The static method BigDecimal.valueOf(long) is invoked to create newBigDecimals with value 10. In addition to looking up static Java methods, itis also possible to directly instantiate the returned Java type., for example, inJavaScript using the new keyword.  The new decimal is used to invoke the pow instance method with 20 which calculates  10^20.  The result of the script is converted to a host object by calling asHostObject(). The return value is automatically cast to the BigDecimal type.  The result decimal string is asserted to equal to &quot;100000000000000000000&quot;.Computed Arrays Using Polyglot ProxiesThe Polyglot API includes polyglot proxy interfaces that let you customize Java interoperability by mimicking guest language types, such as objects, arrays, native objects, or primitives.Use the code example in this section with your polyglot application to see how you can implement arrays that compute their values lazily.  Note: The Polyglot API supports polyglot proxies either on the JVM or in Native Image.              // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;public class proxy_js {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.create()) {        ComputedArray arr = new ComputedArray();        context.getBindings(&quot;js&quot;).putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;js&quot;,                    &quot;arr[1] + arr[1000000000]&quot;)                .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                        // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.proxy.ProxyArray;public class proxy_python {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        ComputedArray arr = new ComputedArray();        context.getPolyglotBindings().putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;python&quot;,               &quot;import polyglotn&quot; +               &quot;arr = polyglot.import_value(&#39;arr&#39;) n&quot; +               &quot;arr[1] + arr[1000000000]&quot;)           .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                    JavaScript      Python          In this code:  The Java class ComputedArray implements the proxy interface ProxyArray sothat guest languages treat instances of the Java class-like arrays.  ComputedArray array overrides the method get and computes the valueusing an arithmetic expression.  The array proxy does not support write access. For this reason, it throwsan UnsupportedOperationException in the implementation of set.  The implementation for getSize returns Long.MAX_VALUE for its length.  The main method creates a new polyglot execution context.  A new instance of the ComputedArray class is then exported using the name arr.  The guest language script imports the arr symbol, which returns theexported proxy.  The second element and the 1000000000th element is accessed, summed up, andthen returned. Note that array indices from 1-based languages areconverted to 0-based indices for proxy arrays.  The result of the language script is returned as a long value and verified.For more information about the polyglot proxy interfaces, see the Polyglot API JavaDoc.Host AccessThe Polyglot API by default restricts access to certain critical functionality, such as file I/O.These restrictions can be lifted entirely by setting allowAllAccess to true.  Note: The access restrictions are currently only supported with JavaScript.Controlling Access to Host FunctionsIt might be desirable to limit the access of guest applications to the host.For example, if a Java method is exposed that calls System.exit, then the guest application will be able to exit the host process.In order to avoid accidentally exposed methods, no host access is allowed by default and every public method or field needs to be annotated with @HostAccess.Export explicitly.              // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.HostAccess;import org.graalvm.polyglot.PolyglotException;public class explicit_access_java_from_js {static// BEGIN-SNIPPETpublic class Employee {    private final String name;    Employee(String name) {this.name = name;}    @HostAccess.Export    public String getName() {        return name;    }}//END-SNIPPETstatic//BEGIN-SNIPPETpublic class Services {    @HostAccess.Export    public Employee createEmployee(String name) {        return new Employee(name);    }        public void exitVM() {        System.exit(1);    }}public static void main(String[] args) {    try (Context context = Context.create()) {        Services services = new Services();        context.getBindings(&quot;js&quot;).putMember(&quot;services&quot;, services);        String name = context.eval(&quot;js&quot;,                &quot;let emp = services.createEmployee(&#39;John Doe&#39;);&quot; +                 &quot;emp.getName()&quot;).asString();        assert name.equals(&quot;John Doe&quot;);                try {            context.eval(&quot;js&quot;, &quot;services.exitVM()&quot;);            assert false;        } catch (PolyglotException e) {            assert e.getMessage().endsWith(                    &quot;Unknown identifier: exitVM&quot;);        }    }}// END-SNIPPET}                      JavaScript            In this code:  The class Employee is declared with a field name of type String. Access to the getName method is explicitly allowed by annotating the method with @HostAccess.Export.  The Services class exposes two methods, createEmployee and exitVM. The createEmployee method takes the name of the employee as an argument and creates a new Employee instance. The createEmployee method is annotated with @HostAccess.Export and therefore accessible to the guest application. The exitVM method is not explicitly exported and therefore not accessible.  The main method first creates a new polyglot context in the default configuration, disallowing host access except for methods annotated with @HostAccess.Export.  A new Services instance is created and put into the context as global variable services.  The first evaluated script creates a new employee using the services object and returns its name.  The returned name is asserted to equal the expected name John Doe.  A second script is evaluated that calls the exitVM method on the services object. This fails with a PolyglotException as the exitVM method is not exposed to the guest application.Host access is fully customizable by creating a custom HostAccess policy.Controlling Host Callback Parameter ScopingBy default, a Value lives as long as the corresponding Context.However, it may be desirable to change this default behavior and bind a value to a scope, such that when execution leaves the scope, the value is invalidated.An example for such a scope are guest-to-host callbacks, where a Value may be passed as a callback parameter.We have already seen above how passing callback parameters works with the default HostAccess.EXPLICIT:public class Services {    Value lastResult;    @HostAccess.Export    public void callback(Value result) {        this.lastResult = result;    }    String getResult() {        return this.lastResult.asString();    }}public static void main(String[] args) {    Services s = new Services()    try (Context context = Context.newBuilder().allowHostAccess(HostAccess.EXPLICIT).build()) {        context.getBindings(&quot;js&quot;).putMember(&quot;services&quot;, s);        context.eval(&quot;js&quot;, &quot;services.callback(&#39;Hello from JS&#39;);&quot;);        System.out.println(s.getResult());    }}In this example, lastResult maintains a reference to the value from the guest that is stored on the host and remains accessible also after the scope of callback() has ended.However, this is not always desirable, as keeping the value alive may block resources unnecessarily or not reflect the behavior of ephemeral values correctly.For these cases, HostAccess.SCOPED can be used, which changes the default behavior for all callbacks, such that values that are passed as callback parameters are only valid for the duration of the callback.To make the above code work with HostAccess.SCOPED, individual values passed as a callback parameters can be pinned to extend their validity until after the callback returns:public class Services {    Value lastResult;    @HostAccess.Export    void callback(Value result, Value notneeded) {        this.lastResult = result;        this.lastResult.pin();    }    String getResult() {        return this.lastResult.asString();    }}public static void main(String[] args) {    Services s = new Services()    try (Context context = Context.newBuilder().allowHostAccess(HostAccess.SCOPED).build()) {        context.getBindings(&quot;js&quot;).putMember(&quot;services&quot;, s);        context.eval(&quot;js&quot;, &quot;services.callback(&#39;Hello from JS&#39;, &#39;foobar&#39;);&quot;);        System.out.println(services.getResult());    }}Alternatively, the entire callback method can opt out from scoping if annotated with @HostAccess.DisableMethodScope, maintaining regular semantics for all parameters of the callback:public class Services {    Value lastResult;    Value metaInfo;    @HostAccess.Export    @HostAccess.DisableMethodScope    void callback(Value result, Value metaInfo) {        this.lastResult = result;        this.metaInfo = metaInfo;    }    String getResult() {        return this.lastResult.asString() + this.metaInfo.asString();    }}public static void main(String[] args) {    Services s = new Services()    try (Context context = Context.newBuilder().allowHostAccess(HostAccess.SCOPED).build()) {        context.getBindings(&quot;js&quot;).putMember(&quot;services&quot;, s);        context.eval(&quot;js&quot;, &quot;services.callback(&#39;Hello from JS&#39;, &#39;foobar&#39;);&quot;);        System.out.println(services.getResult());    }}Access Privilege ConfigurationIt is possible to configure fine-grained access privileges for guest applications.The configuration can be provided using the Context.Builder class when constructing a new context.The following access parameters may be configured:  Allow access to other languages using allowPolyglotAccess.  Allow and customize access to host objects using allowHostAccess.  Allow and customize host lookup to host types using allowHostClassLookup. Allows the guest application to look up the host application classes permitted by the lookup predicate. For example, a Javascript context can create a Java ArrayList, provided that ArrayList is allowlisted by the classFilter and access is permitted by the host access policy: context.eval(&quot;js&quot;, &quot;var array = Java.type(&#39;java.util.ArrayList&#39;)&quot;)  Allow host class loading using allowHostClassLoading. Classes are only accessible if access to them is granted by the host access policy.  Allow the creation of threads using allowCreateThread.  Allow access to native APIs using allowNativeAccess.  Allow access to IO using allowIO and proxy file accesses using fileSystem.  Note: Granting access to class loading, native APIs, or host I/O effectively grants all access, as these privileges can be used to bypass other access restrictions.Runtime Optimization SupportPolyglot Truffle runtimes can be used on several host virtual machines with varying support for runtime optimization.Runtime optimization of guest application code is crucial for the efficient execution of embedded guest applications.This table shows the level of optimizations the Java runtimes currently provide:            Java Runtime      Runtime Optimization Level                  Oracle GraalVM      Best (includes additional compiler optimizations)              GraalVM Community Edition      Optimized              Oracle JDK      Optimized via VM option              OpenJDK      Optimized via VM option and --upgrade-module-path              JDK without JVMCI capability      No runtime optimizations (interpreter-only)      Explanations  Optimized: Executed guest application code can be compiled and executed as highly efficient machine code at run time.  Optimized with additional compiler passes: Oracle GraalVM implements additional optimizations performed during runtime compilation. For example, it uses a more advanced inlining heuristic. This typically leads to better runtime performance and memory consumption.  Optimized via VM option: Optimization is enabled by specifying -XX:+EnableJVMCI to the java launcher.  Optimized via VM option and --upgrade-module-path: Optimization is enabled by specifying -XX:+EnableJVMCI to the java launcher. Additionally, the Graal compiler must be downloaded as a JAR file and specified to the java launcher with --upgrade-module-path. In this mode, the compiler runs as a Java application and may negatively affect the execution performance of the host application.  No runtime optimizations: With no runtime optimizations or if JVMCI is not enabled, the guest application code is executed in interpreter-only mode.  JVMCI: Refers to the Java-Level JVM Compiler Interface supported by most Java runtimes.A project has been created to enable runtime optimization by default for Oracle JDK and OpenJDK.See Project Galahad for further details.Enable Optimization on OpenJDK and Oracle JDKWhen running on a JDK runtime optimization enabled by default, such as OpenJDK, you might see a warning like this:[engine] WARNING: The polyglot engine uses a fallback runtime that does not support runtime compilation to machine code.Execution without runtime compilation will negatively impact the guest application performance.This indicates that the guest application is executed with no runtime optimizations enabled.The warning can be suppressed by either suppressing using the --engine.WarnInterpreterOnly=false option or the -Dpolyglot.engine.WarnInterpreterOnly=false system property.In addition, the compiler.jar file and its dependencies must be downloaded from Maven Central and referred to use the option --upgrade-module-path.Note that compiler.jar must not be put on the module or class path.Refer to the polyglot embedding demonstration for an example configuration using Maven or Gradle.Switching to the Fallback EngineIf the need arises, for example, running only trivial scripts or in the resource-constrained systems, you may want to switch to the fallback engine without runtime optimizations.Since Polyglot version 23.1, the fallback engine can be activated by removing the truffle-runtime and truffle-enterprise modules from the class or module path.This can be achieved with Maven like this:&amp;lt;dependencies&amp;gt;  &amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;js&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;$graalvm-version&amp;lt;/version&amp;gt;    &amp;lt;exclusions&amp;gt;      &amp;lt;exclusion&amp;gt;        &amp;lt;groupId&amp;gt;org.graalvm.truffle&amp;lt;/groupId&amp;gt;        &amp;lt;artifactId&amp;gt;truffle-runtime&amp;lt;/artifactId&amp;gt;      &amp;lt;/exclusion&amp;gt;      &amp;lt;exclusion&amp;gt;        &amp;lt;groupId&amp;gt;org.graalvm.truffle&amp;lt;/groupId&amp;gt;        &amp;lt;artifactId&amp;gt;truffle-enterprise&amp;lt;/artifactId&amp;gt;      &amp;lt;/exclusion&amp;gt;    &amp;lt;/exclusions&amp;gt;  &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;The exclusion rule for truffle-enterprise is unnecessary if you only use -community dependencies.Since truffle-enterprise is excluded, the fallback engine does not support advanced extensions such as sandbox limits or polyglot isolates.It may be useful to double-check with mvn dependency:tree that the two dependencies are not included elsewhere.If the runtime was excluded successfully, you should see the following log message:[engine] WARNING: The polyglot engine uses a fallback runtime that does not support runtime compilation to native code.Execution without runtime compilation will negatively impact the guest application performance.The following cause was found: No optimizing Truffle runtime found on the module or class path.For more information see: https://www.graalvm.org/latest/reference-manual/embed-languages/.To disable this warning use the &#39;--engine.WarnInterpreterOnly=false&#39; option or the &#39;-Dpolyglot.engine.WarnInterpreterOnly=false&#39; system property.You can disable this message using the indicated options as an additional step.Removing these dependencies also automatically switches to the fallback engine in Native Image builds.Build Native Executables from Polyglot ApplicationsWith Polyglot version 23.1 on GraalVM for JDK 21 and later, no special configuration is required to use Native Image to build images with embedded polyglot language runtimes.Like any other Java dependency, the polyglot language JAR files must be on the class or module path when building a native executable.We recommend to use the Maven or Gradle Native Image plugins to configure your native-image builds.A sample Maven and Gradle configuration for Native Image can be found in the polyglot embedding demonstration repository.Here is a Maven profile configuration example:&amp;lt;profiles&amp;gt;    &amp;lt;profile&amp;gt;        &amp;lt;id&amp;gt;native&amp;lt;/id&amp;gt;        &amp;lt;build&amp;gt;            &amp;lt;plugins&amp;gt;                &amp;lt;plugin&amp;gt;                    &amp;lt;groupId&amp;gt;org.graalvm.buildtools&amp;lt;/groupId&amp;gt;                    &amp;lt;artifactId&amp;gt;native-maven-plugin&amp;lt;/artifactId&amp;gt;                    &amp;lt;version&amp;gt;${native.maven.plugin.version}&amp;lt;/version&amp;gt;                    &amp;lt;extensions&amp;gt;true&amp;lt;/extensions&amp;gt;                    &amp;lt;executions&amp;gt;                        &amp;lt;execution&amp;gt;                            &amp;lt;id&amp;gt;build-native&amp;lt;/id&amp;gt;                            &amp;lt;goals&amp;gt;                                &amp;lt;goal&amp;gt;compile-no-fork&amp;lt;/goal&amp;gt;                            &amp;lt;/goals&amp;gt;                            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;                        &amp;lt;/execution&amp;gt;                    &amp;lt;/executions&amp;gt;                    &amp;lt;configuration&amp;gt;                        &amp;lt;imageName&amp;gt;${project.artifactId}&amp;lt;/imageName&amp;gt;                        &amp;lt;mainClass&amp;gt;org.example.embedding.Main&amp;lt;/mainClass&amp;gt;                        &amp;lt;buildArgs&amp;gt;                            &amp;lt;buildArg&amp;gt;-J-Xmx20g&amp;lt;/buildArg&amp;gt;                        &amp;lt;/buildArgs&amp;gt;                    &amp;lt;/configuration&amp;gt;                &amp;lt;/plugin&amp;gt;            &amp;lt;/plugins&amp;gt;        &amp;lt;/build&amp;gt;    &amp;lt;/profile&amp;gt;&amp;lt;/profiles&amp;gt;To build a native executable with the above configuration, run:mvn -Pnative packageBuilding a native executable from a polyglot application, for example, a Java-host application embedding Python, automatically captures all the internal resources required by the included languages and tools.By default, the resources are included in the native executable itself.The inclusion of resources in the native executable can be disabled by -H:-IncludeLanguageResources.Another option is a separate resources directory containing all the required files.To switch to this option, use -H:+CopyLanguageResources. This is the default behavior when -H:+IncludeLanguageResources is not supported, i.e., with Graal Languages earlier than 24.2.x (see the versions roadmap).When -H:+CopyLanguageResources is used, the language runtime will look for the resources directory relative to the native executable or the shared library.At run time, the lookup location may be customized using the -Dpolyglot.engine.resourcePath=path/to/resources option.To disable the capturing of resources altogether, add both -H:-IncludeLanguageResources and -H:-CopyLanguageResources to build-time options.Note that some languages may not support running without their resources.With Graal Languages version 23.1 and newer the language home options like -Dorg.graalvm.home should no longer be used and were replaced with the resource directory option.The language home options remain functional for compatibility reasons but may be removed in future releases.Configuring Native Host ReflectionAccessing host Java code from the guest application requires Java reflection in order to work.When reflection is used within a native executable, the reflection configuration file is required.For this example we use JavaScript to show host access with native executables.Copy the following code in a new file named AccessJavaFromJS.java.import org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;import java.util.concurrent.*;public class AccessJavaFromJS {    public static class MyClass {        public int               id    = 42;        public String            text  = &quot;42&quot;;        public int[]             arr   = new int[]{1, 42, 3};        public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;    }    public static void main(String[] args) {        try (Context context = Context.newBuilder()                                   .allowAllAccess(true)                               .build()) {            context.getBindings(&quot;js&quot;).putMember(&quot;javaObj&quot;, new MyClass());            boolean valid = context.eval(&quot;js&quot;,                   &quot;    javaObj.id         == 42&quot;          +                   &quot; &amp;amp;&amp;amp; javaObj.text       == &#39;42&#39;&quot;        +                   &quot; &amp;amp;&amp;amp; javaObj.arr[1]     == 42&quot;          +                   &quot; &amp;amp;&amp;amp; javaObj.ret42()    == 42&quot;)               .asBoolean();            System.out.println(&quot;Valid &quot; + valid);        }    }}Copy the following code into reachability-metadata.json:{  &quot;reflection&quot;: [     { &quot;type&quot;: &quot;AccessJavaFromJS$MyClass&quot;, &quot;allPublicFields&quot;: true },     { &quot;type&quot;: &quot;java.util.concurrent.Callable&quot;, &quot;allPublicMethods&quot;: true }  ]}Now, you can add reachability-metadata.json to META-INF/native-image/&amp;lt;group-id&amp;gt;/ of your project.Code Caching Across Multiple ContextsThe GraalVM Polyglot API allows code caching across multiple contexts.Code caching allows compiled code to be reused and allows sources to be parsed only once.Code caching can often reduce memory consumption and warm-up time of the application.By default, code is cached within a single context instance only.An explicit engine needs to be specified to enable code caching between multiple contexts.The engine is specified when creating the context using the context builder.The engine instance determines the scope of code sharing.Code is only shared between contexts associated with one engine instance.All sources are cached by default.Caching may be disabled explicitly by setting cached(boolean cached) to false. Disabling caching may be useful in case the source is known to only be evaluated once.Consider the following code snippet as an example:public class Main {    public static void main(String[] args) {        try (Engine engine = Engine.create()) {            Source source = Source.create(&quot;js&quot;, &quot;21 + 21&quot;);            try (Context context = Context.newBuilder()                .engine(engine)                .build()) {                    int v = context.eval(source).asInt();                    assert v == 42;            }            try (Context context = Context.newBuilder()                .engine(engine)                .build()) {                    int v = context.eval(source).asInt();                    assert v == 42;            }        }    }}In this code:  import org.graalvm.polyglot.* imports the base API for the Polyglot API.  Engine.create() creates a new engine instance with the default configuration.  Source.create() creates a source object for the expression “21 + 21”. We use an explicit Source object to ensure the code cache does not get garbage collected between contexts.with “js” language, which is the language identifier for JavaScript.  Context.newBuilder().engine(engine).build() builds a new context withan explicit engine assigned to it. All contexts associated with an engine share the code.  context.eval(source).asInt() evaluates the source and returns the result as Value instance.Important: To keep the code cache of a cached source alive between executing contexts, the application must ensure that the Source object is continually referenced.The polyglot runtime may collect cached code of sources no longer referenced with the next GC cycle.Managing the Code CacheThe data for the code cache is stored as part of the Engine instance.There is never any code sharing happening between two separate engine instances.Hence, we recommend using a singleton Engine instance if a global code cache is needed.As opposed to contexts, engines can always be shared across multiple threads.Whether contexts can be shared across multiple threads depends on the language used.There is no explicit method to purge the code cache.We rely on the garbage collector to do this automatically with the next collection.The code cache of an engine is not collected as long as the engine is still strongly referenced and not closed.Also, the Source instance must be kept alive to ensure the associated code is not collected.If a source instance is no longer referenced, but the engine is still referenced, the code cache associated with a source object may be collected by the GC.We recommend, therefore, keeping a strong reference to the Source object as long as Source should remain cached.To summarize, the code cache can be controlled by keeping and maintaining strong references to the Engine and Source objects.Polyglot IsolatesOn Oracle GraalVM, a polyglot engine can be configured to run in a dedicated Native Image isolate.A polyglot engine in this mode executes within a VM-level fault domain with a dedicated garbage collector and JIT compiler.Polyglot isolates are useful for sandboxing.Running languages in an isolate works with HotSpot and Native Image host virtual machines.Languages used as polyglot isolates can be downloaded from Maven Central using the -isolate suffix.For example, a dependency on isolated JavaScript can be configured by adding a Maven dependency like this:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;    &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;js-isolate&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;    &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;Starting from the Polyglot API version 24.1.0, the polyglot engine supports polyglot isolates for individual platforms.To download a polyglot isolate for a specific platform, append the operating system and CPU architecture classifiers to the polyglot isolate Maven artifactId.For example, to configure a dependency on isolated Python for Linux amd64, add the following Maven dependencies:&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;python-isolate-linux-amd64&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;&amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;Supported platform classifiers are:  linux-amd64  linux-aarch64  darwin-aarch64  windows-amd64For a complete Maven POM file that adds the polyglot isolate Native Image dependency for the current platform, refer to the Polyglot Embedding Demonstration on GitHub.To enable isolate usage with the Polyglot API, the --engine.SpawnIsolate=true option must be passed to Engine or Context when constructed.The option engine.SpawnIsolate may not be available if used on any JDK other than Oracle GraalVM.import org.graalvm.polyglot.*;public class PolyglotIsolate {public static void main(String[] args) {try (Context context = Context.newBuilder(&quot;js&quot;)  .allowHostAccess(HostAccess.SCOPED)  .option(&quot;engine.SpawnIsolate&quot;, &quot;true&quot;).build()) {Value function = context.eval(&quot;js&quot;, &quot;x =&amp;gt; x+1&quot;);assert function.canExecute();int x = function.execute(41).asInt();assert x == 42;}}}Starting from GraalVM 25.0, a polyglot isolate can be launched in a separate external sub-process by setting the --engine.IsolateMode=external option.This allows the isolate to run in a fully separate OS process, providing an additional level of isolation. The default mode remains internal, which uses a Native Image isolate embedded in the same process.Context context = Context.newBuilder(&quot;js&quot;)  .allowHostAccess(HostAccess.SCOPED)  .option(&quot;engine.SpawnIsolate&quot;, &quot;true&quot;)  .option(&quot;engine.IsolateMode&quot;, &quot;external&quot;)  .build()Currently, the following languages are available as polyglot isolates:            Language      Available from                  JavaScript (js-isolate)      23.1              Python (python-isolate)      24.1              Wasm (wasm-isolate)      25.0      We plan to add support for more languages in future versions.In the previous example, we enable scoped references using HostAccess.SCOPED.This is necessary because the host GC and the guest GC are unaware of one another, so cyclic references between objects cannot be resolved automatically.We thus strongly recommend using scoped parameters for host callbacks to avoid cyclic references altogether.Multiple contexts can be spawned in the same isolated engine by sharing engines:public class PolyglotIsolateMultipleContexts {    public static void main(String[] args) {        try (Engine engine = Engine.newBuilder(&quot;js&quot;)                .option(&quot;engine.SpawnIsolate&quot;, &quot;true&quot;).build()) {            Source source = Source.create(&quot;js&quot;, &quot;21 + 21&quot;);            try (Context context = Context.newBuilder()                .engine(engine)                .build()) {                    int v = context.eval(source).asInt();                    assert v == 42;            }            try (Context context = Context.newBuilder()                .engine(engine)                .build()) {                    int v = context.eval(source).asInt();                    assert v == 42;            }        }    }}Passing Native Image Runtime OptionsEngines running in an isolate can make use of Native Image runtime options by passing --engine.IsolateOption.&amp;lt;option&amp;gt; to the engine builder.For example, this can be used to limit the maximum heap memory used by an engine by setting the maximum heap size for the isolate via --engine.IsolateOption.MaxHeapSize=128m:import org.graalvm.polyglot.*;public class PolyglotIsolateMaxHeap {  public static void main(String[] args) {    try {      Context context = Context.newBuilder(&quot;js&quot;)        .allowHostAccess(HostAccess.SCOPED)        .option(&quot;engine.SpawnIsolate&quot;, &quot;true&quot;)        .option(&quot;engine.IsolateOption.MaxHeapSize&quot;, &quot;64m&quot;).build()      context.eval(&quot;js&quot;, &quot;var a = [];while (true) {a.push(&#39;foobar&#39;);}&quot;);    } catch (PolyglotException ex) {      if (ex.isResourceExhausted()) {        System.out.println(&quot;Resource exhausted&quot;);      }    }  }}Exceeding the maximum heap size will automatically close the context and raise a PolyglotException.Ensuring Host Callback Stack HeadroomWith Polyglot Isolates, the --engine.HostCallStackHeadRoom ensures a minimum stack space available when performing a host callback.The host callback fails if the available stack size drops below the specified threshold.Memory ProtectionIn Linux environments that support Memory Protection Keys, the --engine.MemoryProtection=true option can be used to isolate the heaps of Polyglot Isolates at the hardware level.If an engine is created with this option, a dedicated protection key will be allocated for the isolated engine’s heap.GraalVM only enables access to the engine’s heap when executing code of the Polyglot Isolate.Embed a Guest Language in JavaThe GraalVM Polyglot API can be used from within a guest language using Java interoperability.This can be useful if a script needs to run isolated from the parent context.In Java as a host language a call to Context.eval(Source) returns an instance of Value, but since we executing this code as part of a guest language we can use the language-specific interoperability API instead.It is therefore possible to use values returned by contexts created inside of a language, like regular values of the language.In the example below we can conveniently write value.data instead of value.getMember(&quot;data&quot;).Please refer to the individual language documentation for details on how to interoperate with foreign values.More information on value sharing between multiple contexts can be found here.Consider the following code snippet as an example:import org.graalvm.polyglot.*;public class Main {    public static void main(String[] args) {        try (Context outer = Context.newBuilder()                                   .allowAllAccess(true)                               .build()) {            outer.eval(&quot;js&quot;, &quot;inner = Java.type(&#39;org.graalvm.polyglot.Context&#39;).create()&quot;);            outer.eval(&quot;js&quot;, &quot;value = inner.eval(&#39;js&#39;, &#39;({data:42})&#39;)&quot;);            int result = outer.eval(&quot;js&quot;, &quot;value.data&quot;).asInt();            outer.eval(&quot;js&quot;, &quot;inner.close()&quot;);            System.out.println(&quot;Valid &quot; + (result == 42));        }    }}In this code:  Context.newBuilder().allowAllAccess(true).build() builds a new outer context with all privileges.  outer.eval evaluates a JavaScript snippet in the outer context.  inner = Java.type(&#39;org.graalvm.polyglot.Context&#39;).create() the first JS script line looks up the Java host type Context and creates a new inner context instance with no privileges (default).  inner.eval(&#39;js&#39;, &#39;({data:42})&#39;); evaluates the JavaScript code ({data:42}) in the inner context and returns stores the result.  &quot;value.data&quot; this line reads the member data from the result of the inner context. Note that this result can only be read as long as the inner context is not yet closed.  context.eval(&quot;js&quot;, &quot;c.close()&quot;) this snippet closes the inner context. Inner contexts need to be closed manually and are not automatically closed with the parent context.  Finally the example is expected to print Valid true to the console.Build a Shell for Many LanguagesWith just a few lines of code, the GraalVM Polyglot API lets you build applications that integrate with any guest language supported by GraalVM.This shell implementation is agnostic to any particular guest language.BufferedReader input = new BufferedReader(new InputStreamReader(System.in));PrintStream output = System.out;Context context = Context.newBuilder().allowAllAccess(true).build();Set&amp;lt;String&amp;gt; languages = context.getEngine().getLanguages().keySet();output.println(&quot;Shell for &quot; + languages + &quot;:&quot;);String language = languages.iterator().next();for (;;) {    try {        output.print(language + &quot;&amp;gt; &quot;);        String line = input.readLine();        if (line == null) {            break;        } else if (languages.contains(line)) {            language = line;            continue;        }        Source source = Source.newBuilder(language, line, &quot;&amp;lt;shell&amp;gt;&quot;)                        .interactive(true).buildLiteral();        context.eval(source);    } catch (PolyglotException t) {        if(t.isExit()) {            break;        }        t.printStackTrace();    }}Step Through with Execution ListenersThe GraalVM Polyglot API allows users to instrument the execution of guest languages through the ExecutionListener class.For example, it lets you attach an execution listener that is invoked for every statement of the guest language program.Execution listeners are designed as simple API for polyglot embedders and may become handy in, for example, single-stepping through the program.import org.graalvm.polyglot.*;import org.graalvm.polyglot.management.*;public class ExecutionListenerTest {    public static void main(String[] args) {        try (Context context = Context.create(&quot;js&quot;)) {            ExecutionListener listener = ExecutionListener.newBuilder()                      .onEnter((e) -&amp;gt; System.out.println(                              e.getLocation().getCharacters()))                      .statements(true)                      .attach(context.getEngine());            context.eval(&quot;js&quot;, &quot;for (var i = 0; i &amp;lt; 2; i++);&quot;);            listener.close();        }    }}In this code:  The Context.create() call creates a new context for the guest language.  Create an execution listener builder by invoking ExecutionListeners.newBuilder().  Set onEnter event to notify when element’s execution is entered and consumed. At least one event consumer and one filtered source element needs to be enabled.  To complete the listener attachment, attach() needs to be invoked.  The statements(true) filters execution listeners to statements only.  The context.eval() call evaluates a specified snippet of guest language code.  The listener.close() closes a listener earlier, however execution listeners are automatically closed with the engine.Uber JAR File CreationUber JARs are JAR files that bundle all dependencies into a single archive for easier distribution.However, creating an Uber JAR is not recommended for Graal languages because it breaks module descriptors, file integrity metadata, and JAR signature information.Uber JARs are only supported on HotSpot and are not supported for native image generation, as the Native Image tool requires intact Java module descriptors.If you must use Uber JARs, use the minimal configuration below and verify that it is still up to date whenever you upgrade.You can find a working example of valid Maven Shade and Assembly plugin configurations in the polyglot embedding example.See the shade and assembly profiles in pom.xml.Maven Shade PluginIf you intend to use the Maven Shade plugin, include at least the following transformers and filter configuration:&amp;lt;profile&amp;gt;    &amp;lt;id&amp;gt;shade&amp;lt;/id&amp;gt;    &amp;lt;build&amp;gt;        &amp;lt;plugins&amp;gt;            &amp;lt;plugin&amp;gt;                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;                &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt;                &amp;lt;executions&amp;gt;                    &amp;lt;execution&amp;gt;                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;                        &amp;lt;goals&amp;gt;                            &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;                        &amp;lt;/goals&amp;gt;                    &amp;lt;/execution&amp;gt;                &amp;lt;/executions&amp;gt;                &amp;lt;configuration&amp;gt;                    &amp;lt;transformers&amp;gt;                        &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&amp;gt;                        &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;                            &amp;lt;mainClass&amp;gt;org.example.embedding.Main&amp;lt;/mainClass&amp;gt;                            &amp;lt;manifestEntries&amp;gt;                                &amp;lt;Multi-Release&amp;gt;true&amp;lt;/Multi-Release&amp;gt;                            &amp;lt;/manifestEntries&amp;gt;                        &amp;lt;/transformer&amp;gt;                    &amp;lt;/transformers&amp;gt;                    &amp;lt;filters&amp;gt;                      &amp;lt;!-- Filters JAR signature files --&amp;gt;                        &amp;lt;filter&amp;gt;                            &amp;lt;artifact&amp;gt;*:*:*:*&amp;lt;/artifact&amp;gt;                            &amp;lt;excludes&amp;gt;                                &amp;lt;exclude&amp;gt;META-INF/*.SF&amp;lt;/exclude&amp;gt;                                &amp;lt;exclude&amp;gt;META-INF/*.DSA&amp;lt;/exclude&amp;gt;                                &amp;lt;exclude&amp;gt;META-INF/*.RSA&amp;lt;/exclude&amp;gt;                            &amp;lt;/excludes&amp;gt;                        &amp;lt;/filter&amp;gt;                    &amp;lt;/filters&amp;gt;                &amp;lt;/configuration&amp;gt;            &amp;lt;/plugin&amp;gt;        &amp;lt;/plugins&amp;gt;    &amp;lt;/build&amp;gt;&amp;lt;/profile&amp;gt;Maven Assembly pluginIf you are using the Maven Assembly plugin, you may apply the following configuration:&amp;lt;profile&amp;gt;    &amp;lt;id&amp;gt;assembly&amp;lt;/id&amp;gt;    &amp;lt;build&amp;gt;        &amp;lt;plugins&amp;gt;            &amp;lt;plugin&amp;gt;                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;                &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;                &amp;lt;version&amp;gt;3.6.0&amp;lt;/version&amp;gt;                &amp;lt;executions&amp;gt;                    &amp;lt;execution&amp;gt;                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;                        &amp;lt;goals&amp;gt;                            &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;                        &amp;lt;/goals&amp;gt;                        &amp;lt;configuration&amp;gt;                            &amp;lt;archive&amp;gt;                                &amp;lt;manifest&amp;gt;                                    &amp;lt;mainClass&amp;gt;org.example.embedding.Main&amp;lt;/mainClass&amp;gt;                                &amp;lt;/manifest&amp;gt;                                &amp;lt;manifestEntries&amp;gt;                                    &amp;lt;Multi-Release&amp;gt;true&amp;lt;/Multi-Release&amp;gt;                                &amp;lt;/manifestEntries&amp;gt;                            &amp;lt;/archive&amp;gt;                            &amp;lt;descriptors&amp;gt;                                &amp;lt;descriptor&amp;gt;assembly.xml&amp;lt;/descriptor&amp;gt;                            &amp;lt;/descriptors&amp;gt;                        &amp;lt;/configuration&amp;gt;                    &amp;lt;/execution&amp;gt;                &amp;lt;/executions&amp;gt;            &amp;lt;/plugin&amp;gt;        &amp;lt;/plugins&amp;gt;    &amp;lt;/build&amp;gt;&amp;lt;/profile&amp;gt;with the corresponding assembly.xml:&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.2.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.2.0 http://maven.apache.org/xsd/assembly-2.2.0.xsd&quot;&amp;gt;    &amp;lt;id&amp;gt;jar-with-dependencies&amp;lt;/id&amp;gt;    &amp;lt;formats&amp;gt;        &amp;lt;format&amp;gt;jar&amp;lt;/format&amp;gt;    &amp;lt;/formats&amp;gt;    &amp;lt;includeBaseDirectory&amp;gt;false&amp;lt;/includeBaseDirectory&amp;gt;    &amp;lt;dependencySets&amp;gt;        &amp;lt;dependencySet&amp;gt;            &amp;lt;outputDirectory&amp;gt;/&amp;lt;/outputDirectory&amp;gt;            &amp;lt;useProjectArtifact&amp;gt;true&amp;lt;/useProjectArtifact&amp;gt;            &amp;lt;unpack&amp;gt;true&amp;lt;/unpack&amp;gt;            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;        &amp;lt;/dependencySet&amp;gt;    &amp;lt;/dependencySets&amp;gt;    &amp;lt;containerDescriptorHandlers&amp;gt;        &amp;lt;containerDescriptorHandler&amp;gt;            &amp;lt;handlerName&amp;gt;metaInf-services&amp;lt;/handlerName&amp;gt;        &amp;lt;/containerDescriptorHandler&amp;gt;    &amp;lt;/containerDescriptorHandlers&amp;gt;&amp;lt;/assembly&amp;gt;Compatibility with JSR-223 ScriptEngineThe Truffle language implementation framework does not provide a JSR-223 ScriptEngine implementation.The Polyglot API provides more fine-grained control over Truffle features and we strongly encourage users to use the org.graalvm.polyglot.Context interface in order to control many of the settings directly and benefit from finer-grained security settings in GraalVM.However, to easily evaluate a Truffle language as a replacement for other scripting languages that are integrated using the ScriptEngine API, we provide a single file script engine below.This file can be dropped into a source tree and used directly to evaluate a Truffle language via the ScriptEngine APIs.There are only two lines to adapt to your project:public final class CHANGE_NAME_EngineFactory implements ScriptEngineFactory {    private static final String LANGUAGE_ID = &quot;&amp;lt;&amp;lt;INSERT LANGUAGE ID HERE&amp;gt;&amp;gt;&quot;;    }Rename the class as desired and change the LANGUAGE_ID to the desired Truffle language (for example, “python” for GraalPy or “js” for GraalJS).To use it, include a META-INF/services/javax.script.ScriptEngineFactory file in your resources with the chosen class name.This will allow the default javax.script.ScriptEngineManager to discover the language automatically.Alternatively, the factory can be registered via javax.script.ScriptEngineManager#registerEngineName or instantiated and used directly.The best practice is to close the ScriptEngine when no longer used rather than relying on finalizers.To close it, use ((AutoCloseable) scriptEngine).close(); since ScriptEngine does not have a close() method.Note that GraalJS provides a ScriptEngine implementation for users migrating from the Nashorn JavaScript engine that was deprecated in JDK 11, so this method here is not needed.Expand to see the ScriptEngineFactory implementation for Truffle languages in a single file.import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.Reader;import java.io.Writer;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import javax.script.Bindings;import javax.script.Compilable;import javax.script.CompiledScript;import javax.script.Invocable;import javax.script.ScriptContext;import javax.script.ScriptEngine;import javax.script.ScriptEngineFactory;import javax.script.ScriptException;import org.graalvm.home.Version;import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Engine;import org.graalvm.polyglot.Language;import org.graalvm.polyglot.PolyglotException;import org.graalvm.polyglot.Source;import org.graalvm.polyglot.Value;public final class CHANGE_NAME_EngineFactory implements ScriptEngineFactory {    private static final String LANGUAGE_ID = &quot;&amp;lt;&amp;gt;&quot;;    /***********************************************************/    /* Everything below is generic and does not need to change */    /***********************************************************/    private final Engine polyglotEngine = Engine.newBuilder().build();    private final Language language = polyglotEngine.getLanguages().get(LANGUAGE_ID);    @Override    public String getEngineName() {        return language.getImplementationName();    }    @Override    public String getEngineVersion() {        return Version.getCurrent().toString();    }    @Override    public List getExtensions() {        return List.of(LANGUAGE_ID);    }    @Override    public List getMimeTypes() {        return List.copyOf(language.getMimeTypes());    }    @Override    public List getNames() {        return List.of(language.getName(), LANGUAGE_ID, language.getImplementationName());    }    @Override    public String getLanguageName() {        return language.getName();    }    @Override    public String getLanguageVersion() {        return language.getVersion();    }    @Override    public Object getParameter(final String key) {        switch (key) {            case ScriptEngine.ENGINE:                return getEngineName();            case ScriptEngine.ENGINE_VERSION:                return getEngineVersion();            case ScriptEngine.LANGUAGE:                return getLanguageName();            case ScriptEngine.LANGUAGE_VERSION:                return getLanguageVersion();            case ScriptEngine.NAME:                return LANGUAGE_ID;        }        return null;    }    @Override    public String getMethodCallSyntax(final String obj, final String m, final String... args) {        throw new UnsupportedOperationException(&quot;Unimplemented method &#39;getMethodCallSyntax&#39;&quot;);    }    @Override    public String getOutputStatement(final String toDisplay) {        throw new UnsupportedOperationException(&quot;Unimplemented method &#39;getOutputStatement&#39;&quot;);    }    @Override    public String getProgram(final String... statements) {        throw new UnsupportedOperationException(&quot;Unimplemented method &#39;getProgram&#39;&quot;);    }    @Override    public ScriptEngine getScriptEngine() {        return new PolyglotEngine(this);    }    private static final class PolyglotEngine implements ScriptEngine, Compilable, Invocable, AutoCloseable {        private final ScriptEngineFactory factory;        private PolyglotContext defaultContext;        PolyglotEngine(ScriptEngineFactory factory) {            this.factory = factory;            this.defaultContext = new PolyglotContext(factory);        }        @Override        public void close() {            defaultContext.getContext().close();        }        @Override        public CompiledScript compile(String script) throws ScriptException {            Source src = Source.create(LANGUAGE_ID, script);            try {                defaultContext.getContext().parse(src); // only for the side-effect of validating the source            } catch (PolyglotException e) {                throw new ScriptException(e);            }            return new PolyglotCompiledScript(src, this);        }        @Override        public CompiledScript compile(Reader script) throws ScriptException {            Source src;            try {                src = Source.newBuilder(LANGUAGE_ID, script, &quot;sourcefromreader&quot;).build();                defaultContext.getContext().parse(src); // only for the side-effect of validating the source            } catch (PolyglotException | IOException e) {                throw new ScriptException(e);            }            return new PolyglotCompiledScript(src, this);        }        @Override        public Object eval(String script, ScriptContext context) throws ScriptException {            if (context instanceof PolyglotContext) {                PolyglotContext c = (PolyglotContext) context;                try {                    return c.getContext().eval(LANGUAGE_ID, script).as(Object.class);                } catch (PolyglotException e) {                    throw new ScriptException(e);                }            } else {                throw new ClassCastException(&quot;invalid context&quot;);            }        }        @Override        public Object eval(Reader reader, ScriptContext context) throws ScriptException {            Source src;            try {                src = Source.newBuilder(LANGUAGE_ID, reader, &quot;sourcefromreader&quot;).build();            } catch (IOException e) {                throw new ScriptException(e);            }            if (context instanceof PolyglotContext) {                PolyglotContext c = (PolyglotContext) context;                try {                    return c.getContext().eval(src).as(Object.class);                } catch (PolyglotException e) {                    throw new ScriptException(e);                }            } else {                throw new ScriptException(&quot;invalid context&quot;);            }        }        @Override        public Object eval(String script) throws ScriptException {            return eval(script, defaultContext);        }        @Override        public Object eval(Reader reader) throws ScriptException {            return eval(reader, defaultContext);        }        @Override        public Object eval(String script, Bindings n) throws ScriptException {            throw new UnsupportedOperationException(&quot;Bindings for Polyglot language cannot be created explicitly&quot;);        }        @Override        public Object eval(Reader reader, Bindings n) throws ScriptException {            throw new UnsupportedOperationException(&quot;Bindings for Polyglot language cannot be created explicitly&quot;);        }        @Override        public void put(String key, Object value) {            defaultContext.getBindings(ScriptContext.ENGINE_SCOPE).put(key, value);        }        @Override        public Object get(String key) {            return defaultContext.getBindings(ScriptContext.ENGINE_SCOPE).get(key);        }        @Override        public Bindings getBindings(int scope) {            return defaultContext.getBindings(scope);        }        @Override        public void setBindings(Bindings bindings, int scope) {            defaultContext.setBindings(bindings, scope);        }        @Override        public Bindings createBindings() {            throw new UnsupportedOperationException(&quot;Bindings for Polyglot language cannot be created explicitly&quot;);        }        @Override        public ScriptContext getContext() {            return defaultContext;        }        @Override        public void setContext(ScriptContext context) {            throw new UnsupportedOperationException(&quot;The context of a Polyglot ScriptEngine cannot be modified.&quot;);        }        @Override        public ScriptEngineFactory getFactory() {            return factory;        }        @Override        public Object invokeMethod(Object thiz, String name, Object... args)                throws ScriptException, NoSuchMethodException {            try {                Value receiver = defaultContext.getContext().asValue(thiz);                if (receiver.canInvokeMember(name)) {                    return receiver.invokeMember(name, args).as(Object.class);                } else {                    throw new NoSuchMethodException(name);                }            } catch (PolyglotException e) {                throw new ScriptException(e);            }        }        @Override        public Object invokeFunction(String name, Object... args) throws ScriptException, NoSuchMethodException {            throw new UnsupportedOperationException();        }        @Override        public  T getInterface(Class interfaceClass) {            throw new UnsupportedOperationException();        }        @Override        public  T getInterface(Object thiz, Class interfaceClass) {            return defaultContext.getContext().asValue(thiz).as(interfaceClass);        }    }    private static final class PolyglotContext implements ScriptContext {        private Context context;        private final ScriptEngineFactory factory;        private final PolyglotReader in;        private final PolyglotWriter out;        private final PolyglotWriter err;        private Bindings globalBindings;        PolyglotContext(ScriptEngineFactory factory) {            this.factory = factory;            this.in = new PolyglotReader(new InputStreamReader(System.in));            this.out = new PolyglotWriter(new OutputStreamWriter(System.out));            this.err = new PolyglotWriter(new OutputStreamWriter(System.err));        }        Context getContext() {            if (context == null) {                Context.Builder builder = Context.newBuilder(LANGUAGE_ID)                        .in(this.in)                        .out(this.out)                        .err(this.err)                        .allowAllAccess(true);                Bindings globalBindings = getBindings(ScriptContext.GLOBAL_SCOPE);                if (globalBindings != null) {                    for (Entry&amp;lt;String, Object&amp;gt; entry : globalBindings.entrySet()) {                        Object value = entry.getValue();                        if (value instanceof String) {                            builder.option(entry.getKey(), (String) value);                        }                    }                }                context = builder.build();            }            return context;        }        @Override        public void setBindings(Bindings bindings, int scope) {            if (scope == ScriptContext.GLOBAL_SCOPE) {                if (context == null) {                    globalBindings = bindings;                } else {                    throw new UnsupportedOperationException(                            &quot;Global bindings for Polyglot language can only be set before the context is initialized.&quot;);                }            } else {                throw new UnsupportedOperationException(&quot;Bindings objects for Polyglot language is final.&quot;);            }        }        @Override        public Bindings getBindings(int scope) {            if (scope == ScriptContext.ENGINE_SCOPE) {                return new PolyglotBindings(getContext().getBindings(LANGUAGE_ID));            } else if (scope == ScriptContext.GLOBAL_SCOPE) {                return globalBindings;            } else {                return null;            }        }        @Override        public void setAttribute(String name, Object value, int scope) {            if (scope == ScriptContext.ENGINE_SCOPE) {                getBindings(scope).put(name, value);            } else if (scope == ScriptContext.GLOBAL_SCOPE) {                if (context == null) {                    globalBindings.put(name, value);                } else {                    throw new IllegalStateException(&quot;Cannot modify global bindings after context creation.&quot;);                }            }        }        @Override        public Object getAttribute(String name, int scope) {            if (scope == ScriptContext.ENGINE_SCOPE) {                return getBindings(scope).get(name);            } else if (scope == ScriptContext.GLOBAL_SCOPE) {                return globalBindings.get(name);            }            return null;        }        @Override        public Object removeAttribute(String name, int scope) {            Object prev = getAttribute(name, scope);            if (prev != null) {                if (scope == ScriptContext.ENGINE_SCOPE) {                    getBindings(scope).remove(name);                } else if (scope == ScriptContext.GLOBAL_SCOPE) {                    if (context == null) {                        globalBindings.remove(name);                    } else {                        throw new IllegalStateException(&quot;Cannot modify global bindings after context creation.&quot;);                    }                }            }            return prev;        }        @Override        public Object getAttribute(String name) {            return getAttribute(name, ScriptContext.ENGINE_SCOPE);        }        @Override        public int getAttributesScope(String name) {            if (getAttribute(name, ScriptContext.ENGINE_SCOPE) != null) {                return ScriptContext.ENGINE_SCOPE;            } else if (getAttribute(name, ScriptContext.GLOBAL_SCOPE) != null) {                return ScriptContext.GLOBAL_SCOPE;            }            return -1;        }        @Override        public Writer getWriter() {            return this.out.writer;        }        @Override        public Writer getErrorWriter() {            return this.err.writer;        }        @Override        public void setWriter(Writer writer) {            this.out.writer = writer;        }        @Override        public void setErrorWriter(Writer writer) {            this.err.writer = writer;        }        @Override        public Reader getReader() {            return this.in.reader;        }        @Override        public void setReader(Reader reader) {            this.in.reader = reader;        }        @Override        public List getScopes() {            return List.of(ScriptContext.ENGINE_SCOPE, ScriptContext.GLOBAL_SCOPE);        }        private static final class PolyglotReader extends InputStream {            private volatile Reader reader;            public PolyglotReader(InputStreamReader inputStreamReader) {                this.reader = inputStreamReader;            }            @Override            public int read() throws IOException {                return reader.read();            }        }        private static final class PolyglotWriter extends OutputStream {            private volatile Writer writer;            public PolyglotWriter(OutputStreamWriter outputStreamWriter) {                this.writer = outputStreamWriter;            }            @Override            public void write(int b) throws IOException {                writer.write(b);            }        }    }    private static final class PolyglotCompiledScript extends CompiledScript {        private final Source source;        private final ScriptEngine engine;        public PolyglotCompiledScript(Source src, ScriptEngine engine) {            this.source = src;            this.engine = engine;        }        @Override        public Object eval(ScriptContext context) throws ScriptException {            if (context instanceof PolyglotContext) {                return ((PolyglotContext) context).getContext().eval(source).as(Object.class);            }            throw new UnsupportedOperationException(                    &quot;Polyglot CompiledScript instances can only be evaluated in Polyglot.&quot;);        }        @Override        public ScriptEngine getEngine() {            return engine;        }    }    private static final class PolyglotBindings implements Bindings {        private Value languageBindings;        PolyglotBindings(Value languageBindings) {            this.languageBindings = languageBindings;        }        @Override        public int size() {            return keySet().size();        }        @Override        public boolean isEmpty() {            return size() == 0;        }        @Override        public boolean containsValue(Object value) {            for (String s : keySet()) {                if (get(s) == value) {                    return true;                }            }            return false;        }        @Override        public void clear() {            for (String s : keySet()) {                remove(s);            }        }        @Override        public Set keySet() {            return languageBindings.getMemberKeys();        }        @Override        public Collection values() {            List values = new ArrayList&amp;lt;&amp;gt;();            for (String s : keySet()) {                values.add(get(s));            }            return values;        }        @Override        public Set&amp;lt;Entry&amp;lt;String, Object&amp;gt;&amp;gt; entrySet() {            Set&amp;lt;Entry&amp;lt;String, Object&amp;gt;&amp;gt; values = new HashSet&amp;lt;&amp;gt;();            for (String s : keySet()) {                values.add(new Entry&amp;lt;String, Object&amp;gt;() {                    @Override                    public String getKey() {                        return s;                    }                    @Override                    public Object getValue() {                        return get(s);                    }                    @Override                    public Object setValue(Object value) {                        return put(s, value);                    }                });            }            return values;        }        @Override        public Object put(String name, Object value) {            Object previous = get(name);            languageBindings.putMember(name, value);            return previous;        }        @Override        public void putAll(Map&amp;lt;? extends String, ? extends Object&amp;gt; toMerge) {            for (Entry&amp;lt;? extends String, ? extends Object&amp;gt; e : toMerge.entrySet()) {                put(e.getKey(), e.getValue());            }        }        @Override        public boolean containsKey(Object key) {            if (key instanceof String) {                return languageBindings.hasMember((String) key);            } else {                return false;            }        }        @Override        public Object get(Object key) {            if (key instanceof String) {                Value value = languageBindings.getMember((String) key);                if (value != null) {                    return value.as(Object.class);                }            }            return null;        }        @Override        public Object remove(Object key) {            Object prev = get(key);            if (prev != null) {                languageBindings.removeMember((String) key);                return prev;            } else {                return null;            }        }    }}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;/details&amp;gt;",
          "url": " /latest/reference-manual/embed-languages/"
          },
          
          "native-image-error-report":  {
          "title": "Share a Native Image Error Report",
          "content": "",
          "url": " /native-image/error-report/"
          },
          
          "reference-manual-espresso":  {
          "title": "Espresso",
          "content": "EspressoEspresso, also known as Java on Truffle, is an implementation of the Java Virtual Machine Specification, built on top of GraalVM. It is a full-fledged Java VM that includes all core components of a VM, implements the same API as the Java Runtime Environment library, and reuses all JARs and native libraries from GraalVM.Espresso runs Java via a Java bytecode interpreter, implemented with the Truffle framework. Espresso offers benefits like better language isolation and the ability to run different Java versions simultaneously.Espresso is open source with its codebase accessible on GitHub, and fully supported with this Oracle GraalVM release. (See Oracle GraalVM Support Roadmap.)Learn more about Java on Truffle from its reference documentation.",
          "url": " /reference-manual/espresso/"
          },
          
          "java-on-truffle":  {
          "title": "Java on Truffle",
          "content": "",
          "url": " /java-on-truffle/"
          },
          
          "faq":  {
          "title": "Frequently Asked Questions",
          "content": "Frequently Asked QuestionsHow is GraalVM Licensed?Oracle GraalVM is licensed under GraalVM Free Terms and Conditions (GFTC) including License for Early Adopter Versions.Subject to the conditions in the license, including the License for Early Adopter Versions, the GFTC is intended to permit use by any user including commercial and production use. Redistribution is permitted as long as it is not for a fee.Oracle GraalVM is also free to use on Oracle Cloud Infrastructure.GraalVM Community Edition is distributed under version 2 of the GNU General Public License with the “Classpath” Exception. We also recommend checking the licenses of the individual GraalVM components (which are generally derivative of the license of a particular language).What is the “GraalVM Free Terms and Conditions (GFTC) including License for Early Adopter Versions” License?The GFTC is the license for GraalVM for JDK 21, and later releases. Subject to the conditions of the license, it permits free use for all users – even commercial and production use. There is no click through license so automating downloads of it has never been easier.What are the restrictions on the “GFTC”?The GFTC is intended to permit use of the Program, including runtime image output produced by the jlink tool or GraalVM Native Image feature, by any user, including in commercial and production use. Hosted use, including allowing use by third parties who do not obtain a copy of the Program or runtime images, is generally considered use for your internal business operations, and you may charge fees for your service. Redistribution is permitted as long as it is not for a fee.Where Should I Report Bugs, Security Issues, or Enhancement Requests?Please report any bugs or enhancement requests for GraalVM Community using GitHub Issues.Report Oracle GraalVM bugs or enhancement requests via My Oracle Support.Any security vulnerabilities in either Oracle GraalVM or GraalVM Community should only be reported via email to secalert_us@oracle.com.Please consult our Reporting Vulnerabilities guide for more information on reporting security vulnerabilities.Do not use GitHub Issues to report security issues.How do I Contribute to GraalVM?We welcome contributions to GraalVM from the community and are thankful for past contributions both big and small.There are two common ways to contribute:  By submitting GitHub issues for bug reports, questions, or requests for enhancements.  By creating GitHub pull requests.See how to become a GraalVM contributor.If you wish to contribute to the documentation, please check this guide.How Can I Receive Updates about GraalVM?We maintain three mailing lists:  graalvm-announce@oss.oracle.com – a low traffic announcement list used by the project maintainers;  graalvm-users@oss.oracle.com – an open source user mailing list for general questions and discussions;  graalvm-dev@oss.oracle.com – a list for contributors and language implementors.Additional ways to stay up-to-date with GraalVM development are to track GraalVM at the Medium blogging platform, follow the @graalvm Twitter handle, or watch the github.com/oracle/graal repository.What Are the Available Distributions of GraalVM?GraalVM is available as Oracle GraalVM and GraalVM Community Edition.Oracle GraalVM is based on Oracle JDK, whereas GraalVM Community Edition is based on OpenJDK.You can download Oracle GraalVM and GraalVM Community Edition from graalvm.org/downloads.There are also downstream distributions of GraalVM Community Edition from:  Bellsoft Liberica Native Image Kit  RedHat MandrelWhich Microservice Frameworks Employ GraalVM Native Image?Several Java microservice frameworks have accepted the GraalVM Native Image technology as a platform.Examples include: Micronaut, Spring, Helidon, and Quarkus.For these frameworks Native Image significantly reduces the startup time and runtime memory requirements.See Frameworks Ready for Native Image.Are There Existing Real-World Production Deployments of GraalVM?Several production deployments of GraalVM exist today.See the Use Cases section on GraalVM’s home page.We thank early adopters of our technology who give us feedback on the project and help us develop new features.",
          "url": " /faq/"
          },
          
          "r":  {
          "title": "FastR",
          "content": "",
          "url": " /r/"
          },
          
          "latest-reference-manual-r":  {
          "title": "FastR Documentation",
          "content": "",
          "url": " /latest/reference-manual/r/"
          },
          
          "latest-reference-manual-espresso-continuations-generators":  {
          "title": "Generators",
          "content": "GeneratorsAn example of how to use the included Generator&amp;lt;E&amp;gt; class below for Python-style generators. It prints out the numbers from 1-5.import org.graalvm.continuations.Generator;import java.io.*;public class GeneratorTest {    public static void main(String[] args) throws IOException, ClassNotFoundException {        var generator = new Generator&amp;lt;Integer&amp;gt;() {            @Override            protected void generate() {                for (int i = 1; i &amp;lt;= 5; i++) {                    doWork(i);                }            }            private void doWork(int i) {                if (i % 2 == 0) {                    emit(i);                }            }        };        while (generator.hasMoreElements()) {            System.out.println(generator.nextElement());            // Round-trip the generator through Java object serialization.            // In a real program you&#39;d write to disk, or just use            // generators alone without serialization.            generator = deserialize(serialize(generator));        }    }    private static ByteArrayOutputStream serialize(Object obj) throws IOException {        ByteArrayOutputStream bytes = new ByteArrayOutputStream();        try (ObjectOutputStream oos = new ObjectOutputStream(bytes)) {            oos.writeObject(obj);        }        return bytes;    }    @SuppressWarnings(&quot;unchecked&quot;)    private static &amp;lt;T&amp;gt; T deserialize(ByteArrayOutputStream firstSuspension) throws IOException, ClassNotFoundException {        return (T) new ObjectInputStream(new ByteArrayInputStream(firstSuspension.toByteArray())).readObject();    }}Here’s what the implementation looks like using the low level API.package org.graalvm.continuations;import java.io.Serial;import java.io.Serializable;import java.util.Enumeration;import java.util.NoSuchElementException;/** * An {@link Enumeration} that emits an element any time {@link #emit(Object)} is called from inside * the {@link #generate()} method. Emit can be called anywhere in the call stack. This type of * enumeration is sometimes called a &amp;lt;i&amp;gt;generator&amp;lt;/i&amp;gt;. */public abstract class Generator&amp;lt;E&amp;gt; implements Enumeration&amp;lt;E&amp;gt;, Serializable {    @Serial    private static final long serialVersionUID = -5614372125614425080L;    private final Continuation continuation;    private Continuation.SuspendCapability suspendCapability;    private transient E currentElement;    private transient boolean hasProduced;    /**     * This constructor exists only for deserialization purposes. Don&#39;t call it directly.     */    @SuppressWarnings(&quot;this-escape&quot;)    protected Generator() {        continuation = new Continuation((Continuation.EntryPoint &amp;amp; Serializable) suspendCapability -&amp;gt; {            this.suspendCapability = suspendCapability;            generate();        });    }    /**     * Runs the generator and returns true if it emitted an element. If it finished running, returns     * false. If the generator throws an exception it will be propagated from this method.     */    @Override    public final boolean hasMoreElements() {        if (hasProduced)            return true;        Continuation.State state = continuation.getState();        boolean ready = state == Continuation.State.SUSPENDED || state == Continuation.State.NEW;        if (!ready)            return false;        continuation.resume();        return hasProduced;    }    /**     * Runs the generator if necessary, and returns the element it yielded.     *     * @throws NoSuchElementException if the generator has finished and no longer emits elements,     * or if the generator has previously thrown an exception and failed.     */    @Override    public final E nextElement() {        if (!hasMoreElements())            throw new NoSuchElementException();        E el = currentElement;        currentElement = null;        hasProduced = false;        return el;    }    /**     * Call this method to emit an element from inside {@link #generate()}.     */    protected final void emit(E element) {        assert !hasProduced;        currentElement = element;        hasProduced = true;        suspendCapability.suspend();    }    /**     * Implement this method to {@link #emit(Object)} elements from the enumeration.     */    protected abstract void generate();    private transient boolean reentrancy = false;    @Override    public String toString() {        // Printing the continuation will invoke toString on everything reachable from the stack,        // thus we need to cancel the re-entrancy here.        if (reentrancy)            return &quot;this generator&quot;;        reentrancy = true;        String result = continuation.toString();        reentrancy = false;        return result;    }}",
          "url": " /latest/reference-manual/espresso/continuations/generators/"
          },
          
          "latest-getting-started":  {
          "title": "Getting Started with Oracle GraalVM",
          "content": "Getting Started with Oracle GraalVMHere you can find information about how to install Oracle GraalVM and run basic applications with it.If you are new to Oracle GraalVM, we recommend starting with the GraalVM Overview, where you will find information about GraalVM’s benefits, distributions, certified platforms, available features, and licensing.If you have Oracle GraalVM already installed and have experience using it, you can skip this page and proceed to the in-depth reference manuals.InstallingInstallation steps for your specific platform:  Oracle Linux  Linux  macOS  WindowsRunning an ApplicationOracle GraalVM includes the Java Development Kit (JDK), the just-in-time compiler (the Graal compiler), Native Image, and other familiar Java tools.You can use the GraalVM JDK just like any other JDK in your IDE, so having installed Oracle GraalVM, you can run any Java application unmodified.The java launcher runs the JVM with Graal as the last-tier compiler.Check the installed Java version:java -versionUsing GraalVM Native Image you can compile Java bytecode into a platform-specific, self-contained, native executable to achieve faster startup and a smaller footprint for your application.Compile this HelloWorld.java application to bytecode and then build a native executable:public class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}javac HelloWorld.javanative-image HelloWorldThe last command generates an executable file named helloworld in the current working directory.Invoking it runs the natively-compiled code of the HelloWorld class as follows:./helloworldHello, World!  Note: For compilation, native-image depends on the local toolchain. Make sure your system meets the prerequisites.What to Read NextNew UsersContinue to Native Image basics to educate yourself about the technology.For users who are familiar with GraalVM Native Image but may have little experience using it, proceed to User Guides.For more information on the compiler, see the Graal Compiler. Larger Java examples can be found in the GraalVM Demos repository on GitHub.Advanced UsersDevelopers who are more experienced with GraalVM or want to do more with GraalVM can proceed directly to Reference Manuals for in-depth documentation.You can find information on GraalVM’s security model in the Security Guide, and rich API documentation in the Oracle GraalVM Java API Reference.Oracle Cloud Infrastructure UsersOracle Cloud Infrastructure users who are considering Oracle GraalVM for their cloud workloads are invited to read Oracle GraalVM on OCI.This page focuses on using Oracle GraalVM with an Oracle Cloud Infrastructure Compute instance.We also recommend checking the GraalVM Team Blog.",
          "url": " /latest/getting-started/"
          },
          
          "reference-manual-graaljs":  {
          "title": "GraalJS",
          "content": "GraalJSGraalJS is a JavaScript language implementation, built on top of GraalVM.It is ECMAScript-compliant, implemented using the Truffle framework, and can be used to embed JavaScript code in Java applications.GraalJS is a suitable replacement for projects wanting to migrate from Nashorn or Rhino to a JavaScript engine that supports new ECMAScript standards and features.GraalJS is open source with its codebase accessible on GitHub, and fully supported with this Oracle GraalVM release. (See Oracle GraalVM Support Roadmap.)Learn more about GraalJS from its reference documentation.",
          "url": " /reference-manual/graaljs/"
          },
          
          "reference-manual-graalpy":  {
          "title": "GraalPy",
          "content": "GraalPyGraalPy is a Python language implementation, built on top of GraalVM.It is a Python 3 compliant runtime, implemented using the Truffle framework, and can be used to embed Python code in Java applications.GraalPy is a suitable replacement for projects wanting to migrate from CPython to a Python engine that supports Python 3.GraalPy is open source with its codebase accessible on GitHub, and fully supported with this Oracle GraalVM release. (See Oracle GraalVM Support Roadmap.)Learn more about GraalPy from its reference documentation.",
          "url": " /reference-manual/graalpy/"
          },
          
          "latest-python-docs":  {
          "title": "GraalPy Documentation",
          "content": "",
          "url": " /latest/python/docs/"
          },
          
          "latest-graalvm-as-a-platform":  {
          "title": "GraalVM as a Platform",
          "content": "GraalVM as a PlatformGraalVM is an open ecosystem and allows users to implement a custom language or tool on top of it with the Truffle language implementation framework which offers APIs for writing interpreters for programming languages in the form of Java programs.GraalVM loads and runs the Truffle framework, which itself is a Java program—a collection of JAR files—together with interpreters.These get optimized at runtime into efficient machine code for executing loaded programs.Learn more about this framework from its reference documentation.Implement Your LanguageWith the Language API offered by the Truffle framework, you can implement a language interpreter on top of GraalVM.To get started, proceed to Implement Your Language.Implement Your ToolWith the Instrument API offered by the Truffle framework, you can create language-agnostic tools like debuggers, profilers, or other instruments on top of GraalVM.To get started, proceed to Implement Your Tool.",
          "url": " /latest/graalvm-as-a-platform/"
          },
          
          "release-notes-jdk-25":  {
          "title": "GraalVM 25",
          "content": "GraalVM Community Edition 25.0.2(2026-01-20)This is the January 2026 Oracle Critical Patch Update (CPU) for GraalVM Community Edition.This release contains fixes to security vulnerabilities announced in the January 2026 Oracle Critical Patch Update Advisory.  Updated the Oracle JDK release on which Oracle GraalVM is built to 25.0.2+10. See Java SE 25 Release Notes.  Updated GraalVM Community Edition 25 to 25.0.2. See the OpenJDK 25 Updates.  Support for macOS x64 has been removed. Version 25.0.1 was the last release that supported this hardware architecture. GraalVM now only supports macOS on AArch64 (Apple Silicon).  Version compatibility:          GraalVM Community Edition 25.0.2 is compatible with Graal Languages and other components version 25.0.2.        Graal compiler          Enhanced boxing snippets with profile information to improve primitive caching performance and reduce boxing overhead.      Fixed hash collisions in CompilationResultBuilder.buildLabelOffsets() to improve Tier 1 compilation times on AArch64.      Fixed potential crash with DynamicObjectLibrary.removeKey to prevent type confusion during property deletion.      Fixed loop vectorization miscompilation that produced incorrect results due to improper handling of delayed phi patterns, where phi nodes used values from previous iterations.      Fixed OptimisticGuardsPhase to properly remove redundant guards and prevent incorrect deoptimizations when reverting OptimisticMemoryEdge.      Fixed frame access to use opaque placeholder values when deleting a VirtualFrameAccessorNode.        Native Image          Fixed JFR memory leak in Java event TLBs.      Fixed native-image-configure to properly register types from JNI sections as JNI-accessed.      Fixed a segfault in ReleasePrimitiveArrayCritical.      Added verification to ensure that objects in the young generation do not have a remembered set bit for improved garbage collection integrity.      Applied java_util_prefs substitution when java.prefs module is present.      Fixed in-place copySwap in JavaMemoryUtil.      Fixed the reachability metadata schema and included it in the GraalVM distribution.      Fixed constructor accessor checks for improved reflection handling.      Enabled FFM API without libc dependency for broader platform compatibility.      Improved error messages for better user experience.      Fixed Win32 API error handling in WindowsVMSemaphore.      Enhanced native memory management to use LibC.free() when freeing memory allocated by libc or other native code.      Ensured Native Image SBOM feature uses a compatible XML parser.      Fixed dynamic collection policy to call updateSizeParameters() only when DynamicCollectionPolicy is used.        GraalJS          Fixed converting values injected by Truffle instruments to types supported by GraalJS, preventing type errors when instruments inject unexpected interop values like short.      Fixed clearing temporary variables used during destructuring assignment that prevented proper garbage collection of referenced objects.        GraalPy          Fixed loading delvewheel wheels on Windows, resolving issues where NumPy wheels from graalvm.org could not be imported.      Made native slot wrappers context-specific.      Fixed missing descriptor for __hash__ in __slots__ to properly support classes that declare __hash__ as a slot attribute.        Truffle framework          Fixed assertion statements with explicit checks that provide clearer error messages when operation arguments are mismatched.      Fixed SubstrateEnterpriseOptimizedCallTarget without return profile to prevent deopt loops.      Fixed overloaded method caching regression in HostExecuteNode that caused performance regression in host interop microbenchmarks (interop-pointarray, interop-callmathmin, interop-callstringformat).      Fixed incorrect offset handling in FromJavaStringNode for TruffleStrings.      Removed DynamicThresholdsQueue and optimized compilation thresholds scaling for better performance.      Fixed heap root computation to be thread safe for improved stability.      GraalVM Community Edition 25.0.1(2025-10-21)This is the October 2025 Oracle Critical Patch Update (CPU) for GraalVM Community Edition.This release contains fixes to security vulnerabilities announced in the October 2025 Oracle Critical Patch Update Advisory.  Updated the Oracle JDK release on which Oracle GraalVM is built to 25.0.1+8. See Java SE 25 Release Notes.  Updated GraalVM Community Edition 25 to 25.0.1. See the OpenJDK 25 Updates.  Version compatibility:          GraalVM Community Edition 25.0.1 is compatible with Graal Languages and other components version 25.0.1.        Support for macOS x64 has been removed. Version 25.0.1 was the last release that supported this hardware architecture. GraalVM now only supports macOS on AArch64 (Apple Silicon).  Graal compiler          Improved Merge Explode partial evaluation by eliminating ProxyPlaceHolder nodes for better performance.      Analyzed and optimized Tier 2 compile times on function 5311 for improved compilation performance.      Enhanced LinearScan lifetime analysis by compressing bitsets to reduce memory overhead.      Fixed handling of StageFlag.VECTOR_API_EXPANSION for proper Vector API support.      Added support for conditional invocation plugin in runtime compilation scenarios.      Fixed HostInlining to correctly mark dominators as &quot;inInterpreter&quot; when branches are never executed.        Native Image          Improved array type handling in missing registration tests for better error reporting.      Corrected misleading help text for the --future-defaults option.      Enhanced crash log generation with additional diagnostic information including heap base alignment checks, isolated compilation support and status, compilation isolate details with main isolate ID, OS thread IDs and handles for all isolate threads, and image heap chunk information similar to G1 reporting.      Removed AMD64.CPUFeature.HT from build time CPU features.      Fixed GlobalAtomicLong.address reset to prevent runtime segmentation faults caused by uninitialized address values in the image heap.      Fixed pending JNI exception leak in native-image-agent for better resource management.      Enhanced exception handling to return UNCAUGHT_EXCEPTION for uncaught exceptions.      Fixed canonicalization of always-null guarded values.      Fixed rare race conditions for improved stability.      Optimized G1 InitialRAMPercentage to improve application startup time and memory usage.      Fixed TruffleFeature failure when blocklisting classes containing deleted methods.      Added support for conditional invocation plugin in runtime compilation scenarios.        Truffle framework          Improved deoptimization cycle detection by ignoring deopt nodes with “None” action.      Improved Merge Explode partial evaluation by eliminating ProxyPlaceHolder nodes for better performance.      Fixed TruffleFeature failure when blocklisting classes containing deleted methods.      Reduced excessive process execution times by optimizing compilation wait handling.      FixedHostInlining to correctly mark dominators as &quot;inInterpreter&quot; when branches are never executed.        Espresso          Enhanced multiple context handling for improved isolation and resource management.      Re-enabled class modifiers redefinition tests for JDK 25 compatibility.        GraalWasm          Added support for v128 values in polymorphic select instruction for better SIMD compatibility.        TRegex          Added intrinsic for TStringOps#runByteSwap to improve string operation performance.      GraalVM 25(2025-09-16)  Platform and Distributions  Availability of JDK 25 Features  Graal Compiler  Native Image  GraalJS  GraalPy  GraalWasm  Espresso  Polyglot Runtime  Truffle FrameworkPlatform and Distributions  Released Oracle GraalVM 25 based on Oracle JDK 25. See Java SE 25 Release Notes.  Released GraalVM Community Edition 25 based on OpenJDK 25. See OpenJDK 25 Updates.            Oracle GraalVM is now available for Oracle Linux 10. Support for Oracle GraalVM on Oracle Linux 7 has ended. For setup instructions, see the installation guide.        Version compatibility:          Oracle GraalVM 25 is compatible with Graal Languages and other components version 25.0.0.      Features  470: PEM Encodings of Cryptographic Objects (Preview)  502: Stable Values (Preview)  503: Remove the 32-bit x86 Port  505: Structured Concurrency (Fifth Preview)  506: Scoped Values  507: Primitive Types in Patterns, instanceof, and switch (Third Preview)  508: Vector API (Tenth Incubator)  509: JFR CPU-Time Profiling (Experimental)  510: Key Derivation Function API  511: Module Import Declarations  512: Compact Source Files and Instance Main Methods  513: Flexible Constructor Bodies  514: Ahead-of-Time Command-Line Ergonomics  515: Ahead-of-Time Method Profiling  518: JFR Cooperative Sampling  519: Compact Object Headers  520: JFR Method Timing &amp;amp; TracingGraal Compiler  Implemented initial optimization of Java Vector API (JEP 338) operations. Load, store, basic arithmetic, reduce, compare, and blend operations are transformed to efficient machine instructions where possible. Coverage of more operations is planned for the future. This optimization is experimental and can be disabled by setting the OptimizeVectorAPI option to false. Vector API operations are supported both on JIT and when building native images.Native ImagePerformance Improvements  Enabled Whole-Program Sparse Conditional Constant Propagation (WP-SCCP) by default, improving the precision of points-to analysis in Native Image. This optimization enhances static analysis accuracy and scalability, potentially reducing the size of the final native binary. Learn more about this optimization in SkipFlow: Producing Smaller Executables with GraalVM.  Refined the Graal Neural Network (GraalNN) models for control split profile inference by introducing two specialized variants: a more conservative model for O2 and a more aggressive one for O3. These updates are expected to deliver performance improvements of 1–3% for both O2 and O3 optimization levels, as well as a binary size reduction of over 1% in O2.The new GNN-based control split profile inference is enabled by default in O3. To enable it in O2, pass the option -H:+MLProfileInferenceUseGNNModel.  Added an XGBoost-based static profiler for call count profile inference in Native Image. The model classifies methods as either cold or regular/hot, guiding optimizations and reducing binary size with minimal impact on runtime performance. To enable it, use the option: -H:+MLCallCountProfileInference. Not available in GraalVM Community Edition.  Added the experimental option -H:+RelativeCodePointers to significantly reduce relocation entries in position-independent executables and shared libraries.New Features  Enhanced support for the Foreign Function &amp;amp; Memory (FFM) API (JEP 454) in Native Image:          Platform compatibility – Enabled FFM API (“Panama”) support on macOS AArch64 and Linux AArch64.      Introduced a new syntax for configuring the FFM API.      Implemented Arena.ofShared() from the FFM API.      Added the Tracing agent support for applications using the FFM API. The agent generates the FFM configuration in the reachability-metadata.json file. Additionally, support for FFM configurations has been added to the native-image-configure tool.      Added extensive reference documentation for FFM API support in Native Image.        Implemented initial optimization support of Java Vector API JEP 338 operations in native images. To enable these optimizations, build native images with the --add-modules jdk.incubator.vector and -H:+VectorAPISupport options.  Introduced --future-defaults=[all|run-time-initialize-jdk|&amp;lt;options&amp;gt;|none], which enables options planned to become defaults in future releases. The enabled options are:          run-time-initialize-jdk – Shifts from build-time initialization of the JDK to runtime initialization for most components. This transition is gradual, with different JDK components becoming runtime initialized in each release. In this release, it enables run-time-initialize-security-providers and run-time-initialize-file-system-providers.If JDK classes are not stored in the image heap, this option should have no effect. If the option breaks your build, follow the suggestions in the error messages.      complete-reflection-types – Ensures that reflective registration of a type (via metadata files or the Feature API) always includes all type metadata. All registered types now behave consistently with types defined in the reachability-metadata.json file.      run-time-initialize-security-providers – Shifts from build-time initialization of security providers to runtime initialization. Unless java.security.Provider-related classes are stored in the image heap, this option should have no effect. If it breaks your build, follow the suggestions in the error messages. Run-time initialization of security providers helps reduce image heap size by avoiding unnecessary objects inclusion.      run-time-initialize-file-system-providers – Shifts from build-time initialization of java.nio.file.spi.FileSystemProvider to runtime initialization. Unless FileSystemProvider-related classes are stored in the image heap, this option should have no effect. If it breaks your build, follow the suggestions in the error messages.        Enabled --install-exit-handlers by default for native executables and deprecated the option. If shared libraries were using this option, the same functionality can be restored by using the -H:+InstallExitHandlers host option.  Recurring callback support is no longer enabled by default. To enable this feature, use the -H:+SupportRecurringCallback host option at image build time.  Added the experimental option ClassForNameRespectsClassLoader, which makes Class.forName(...) respect the class loader hierarchy.Improved Security  Introduced advanced obfuscation for Native Image — an experimental Oracle GraalVM-only feature that applies symbol obfuscation to enhance protection against reverse engineering by renaming symbols in native images.Advanced obfuscation affects user code and third party dependencies, but not JDK and GraalVM classes, or names required by reachability metadata, annotations, and proxies.To enable the feature, pass -H:AdvancedObfuscation= to the native-image command.Learn more in the reference documentation.  A Software Bill of Materials (SBOM) is now embedded by default in native images. To disable the SBOM from being embedded, pass the option --enable-sbom=false. (Not available in GraalVM Community Edition).Simplified Metadata Configuration  Added the experimental option -H:Preserve to instruct the native-image tool to keep entire packages, modules, or all classes on the classpath. For example, if you pass -H:Preserve=package=&amp;lt;package_name&amp;gt;, all of the classes in that package will be available in the native executable, even if static analysis could not discover them. The usage syntax is -H:Preserve=[all|none|module=&amp;lt;module&amp;gt;|package=&amp;lt;package&amp;gt;|package=&amp;lt;package-wildcard&amp;gt;|path=&amp;lt;cp-entry&amp;gt;][,...]. See the example application for this use case.  JNI registration is now included as part of the &quot;reflection&quot; section in the reachability-metadata.json file using the &quot;jniAccessible&quot; attribute. Registrations performed through the &quot;jni&quot; section of reachability-metadata.json and through jni-config.json will still be accepted and parsed correctly.  Enabled lambda classes to be registered for reflection and serialization in the reachability-metadata.json file. The format is detailed here.  Resource bundle registration is now included as part of the &quot;resources&quot; section in the reachability-metadata.json file. When this is the case, the bundle name is specified using the &quot;bundle&quot; field. Find the examples in the documentation.  Missing registration errors are now subclasses of LinkageError.  Improved handling of invalid class names under --exact-reachability-metadata: Reflection and JNI queries now correctly throw the expected JDK exceptions without requiring metadata entries when the queried class name is clearly invalid.Experimental Native Image Tracing Agent  Added experimental support for a new Native Image Tracing Agent. Unlike the existing tracing agent (which observes application behavior on the JVM), the new agent operates in Native Image mode and is more closely aligned with Native Image semantics.          To use the new agent, build your application with -H:Preserve=all (which also enables -H:+MetadataTracing), and then run the executable with -XX:TraceMetadata=path=&amp;lt;trace_output_directory&amp;gt;.      The agent will trace the actual types, resources, and other elements required by Native Image, and generate reachability metadata. This metadata can then be used to re-build the application with only the required types and resources.      Platform Compatibility  In containers and CI environments, the build process now uses 85% of system memory. Otherwise, it tries to only use available memory. If less than 8GB of memory are available, it falls back to 85% of system memory. The reason for the selected memory limit is now also shown in the build resources section of the build output.Debugging and Monitoring Improvements  Added support for the runtime debug info generation using the option -H:+RuntimeDebugInfo. It adds runtime debugging information into a native image for use with GDB.  Added a JVM version check to the Native Image agent. The agent now aborts execution if the JVM major version does not match the version it was built with and issues a warning if the full JVM version differs.  Added validation of hosted options passed to native-image before starting the build process. Unknown options are detected early, with suggestions provided to help fix them.  Added the experimental -H:+JDWP option.Deprecated Functionality  Deprecated class-level metadata extraction using native-image-inspect and removed the DumpMethodsData option. Instead, use class-level SBOMs by passing --enable-sbom=class-level,export to the native-image builder. The default value of the IncludeMethodData option has been changed to false.  Removed the sequential reachability handler. The only remaining variant is the concurrent reachability handler, which has been the default implementation since its introduction. Additionally, the -H:-RunReachabilityHandlersConcurrently option was removed, which had been deprecated in GraalVM for JDK 24.  Removed the total number of loaded types, fields, and methods from the Native Image build output, deprecated these metrics in the build output schema, and removed already deprecated build output metrics.  Jipher Java Cryptographic Service Provider (JCP) is no longer available as part of the Oracle GraalVM release, but can be downloaded separately from Java Tools and Resources. For more information, see the Jipher JCP reference documentation.GraalJS  Enabled ECMAScript 2025 mode by default.  Made the option js.text-encoding stable and allowed in SandboxPolicy.CONSTRAINED.  Enabled source phase imports from WebAssembly modules (import source mod from &quot;./mod.wasm&quot;) by default if the js.webassembly option is enabled, and the js.source-phase-imports option is not explicitly set to false.  Implemented several ECMAScript proposals:          Intl.DurationFormat      Deferring Module Evaluation, available in ECMAScript staging mode (--js.ecmascript-version=staging)      Upsert, available in ECMAScript staging mode (--js.ecmascript-version=staging)        Updated Node.js to version 22.17.1.GraalPyImprovements and New Features  Updated the Python standard library and core to version 3.12.8.  The full-featured Python REPL is now available on GraalPy standalone builds for Windows.  The sys.implementation.version call now returns the GraalPy version instead of the Python version it implements. Additionally, the GraalPy version is available as sys.graalpy_version_info for easier discovery, especially by users familiar with PyPy’s sys.pypy_version_info.  The GRAALPY_VERSION_NUM C macro now includes the release level and serial number to fully conform to the hexversion format, without breaking existing version comparisons.  The dir(foreign_object) call now returns both foreign methods and Python methods, whereas previously it returned only foreign methods.  Added support for the __name__, __doc__, and __text_signature__ attributes on foreign executables, enabling better integration with Python-side introspection. This is useful, for example, when using Java functional interfaces in place of Python functions—such as with LangChain’s @tool annotation that inspects underlying functions.  Implemented faulthandler.dump_traceback_later to enhance support for testing frameworks that handle resilience to crashes.  Added support for sharing Arrow arrays and tables between Java, PyArrow, and Pandas, reducing data copying when embedding these libraries into Java projects.  Enabled FTS3, FTS4, FTS5, RTREE, and math function features in the bundled SQLite3 library.  Added compatibility patches for several libraries and versions, including Torch 2.7.0, PyGObject 3.52.3, xmlschema 4.0.0, lxml (below 5.4.0), SciPy 1.15, jq 1.8.0, NumPy (below 2.3), ormsgpack (below 1.9.1), pandas 2.2.3, PyArrow 19.0, and PyMuPDF 1.25.4.Removed Functionality  Removed support for running C extensions as LLVM bitcode. This also removes the related options python.UseSystemToolchain and python.NativeModules. Isolation of native code when embedding GraalPy into Java projects is now provided by the Oracle GraalVM polyglot isolate feature, which can launch in a separate external sub-process by setting the --engine.IsolateMode=external option.  Removed the built-in HPy module. HPy can now be installed and used from its upstream sources.Platform Compatibility  Fixed several issues affecting cibuildwheel on Windows to make it easier for Python projects to build and distribute native extensions for GraalPy on all supported platforms.  The GraalPy Native standalone on Linux now uses the G1 garbage collector which is much faster.GraalWasm  Context.eval now returns a compiled (but not yet instantiated) module object, rather than a module instance. To instantiate the module, call newInstance() on the returned module object. For example:    Context c = Context.create();Source wasmSource = Source.newBuilder(...).build();Value module = c.eval(wasmSource);Value instance = module.newInstance(); // prior to 25.0: c.eval(wasmSource)          This change allows a single compiled module to be instantiated multiple times and run independently within the same context. Previously, each module could only be instantiated once per context.      The newInstance() method optionally accepts an import object (similar to the WebAssembly JavaScript API), as well as other modules to link together.      To restore the previous behavior, pass the experimental option --wasm.EvalReturnsInstance=true to the builder.      Note that modules instantiated via module.newInstance() are not accessible through context.getBindings(&quot;wasm&quot;), unlike modules instantiated directly using context.eval when the --wasm.EvalReturnsInstance=true option is used.        Exports are no longer exposed as direct members of the module instance.Instead, use the exports member of the module instance to access its exports. For example:    Value mainFunction = instance.getMember(&quot;exports&quot;).getMember(&quot;main&quot;); // prior to 25.0: instance.getMember(&quot;main&quot;)    This change aligns the API with the WebAssembly JavaScript API and makes it possible to introduce other members on the module instance without name clashes.For more details and migration examples, see the GraalWasm Polyglot API Migration Guide and the project README.    Implemented support for editing primitive values during debugging. Fixed several debugger-related issues.  Implemented the WebAssembly SIMD proposal using the JDK’s Vector API. This improves peak performance when running WebAssembly code that makes heavy use of SIMD instructions. The new implementation is always enabled in native images. On the JVM, it is opt-in and requires setting --add-modules=jdk.incubator.vector. Because the Vector API is incubating, enabling it will print the following warning to stderr:    WARNING: Using incubator modules: jdk.incubator.vector  Espresso  Added support for guest Java version 25.  Added experimental support for -javaagent. The support for java agents helps integrate with various IDEs, debuggers, and so on. It can also be enabled via the Polyglot API by setting the option java.JavaAgent.$i to /path/to/jar=agent-options, where $i starts at 0 and increments by 1 for each additional Java agent.  Added the org.graalvm.continuations.IdentityHashCodes class, which provides utilities to restore identity hash codes. This can be used to improve deserialization of continuations.  Introduced the EnableAdvancedRedefinition option, which controls whether features such as method or field addition/removal and class hierarchy changes are enabled. This option controls access to these capabilities for both JDWP and Java agents. Previously, this functionality was enabled by default for JDWP; in this release, it must now be explicitly turned on.  Added experimental support for JVMCI, which can be enabled with the java.EnableJVMCI option.Polyglot Runtime  All language and tool POMs artifacts are now OSS licensed. It means:          The “community” Maven artifacts (those with an artifact ID ending in -community) are now identical to their corresponding “non-community” artifacts.      All community language and tool POM artifacts have been deprecated.      The only exception is org.graalvm.truffle:java-community vs. org.graalvm.truffle:java, which still differ in the bundled Java runtime.      Embedders using auxiliary engine caching, polyglot isolates, a isolated or untrusted sandbox policy, or the sandbox resource limits must now explicitly add the org.graalvm.truffle:truffle-enterprise Maven artifact to the classpath or module path.        Improved the memory isolation between multiple isolates, known as Monocle or Software Fault Isolation.Monocle is a new mitigation for speculative execution attacks for runtime-compiled code running inside GraalVM isolates. With Monocle enabled, every load generated from untrusted code is either (a) masked so it cannot address memory outside its own isolate heap, or (b) guarded by a lightweight fence when masking is impossible. This keeps one isolate from speculatively reading data belonging to another isolate in the same GraalVM process. Monocle is about 4x faster compared to the previous, fence-based mitigation, while delivering the same security guarantees. It is available for the AMD64 architecture and can be enabled with -R:+MemoryMaskingAndFencing.Monocle is used for polyglot isolates. As a result, sandboxed code execution is faster.  The option sandbox.MaxStackFrames is no longer mandatory for the UNTRUSTED polyglot sandbox policy, due to improved deoptimization handling in compiled code. Removing the option significantly improves performance of the sandboxed code.  The WebAssembly (Wasm) language is now available as a polyglot isolate under the name wasm-isolate on Maven Central. Wasm is now supported for untrusted code execution (all three are polyglot isolates related).Find a complete list of updates in the changelog.Truffle Framework  Added the deoptimization cycle detection feature, which is enabled by default. When a deoptimization cycle is detected, the compilation fails with a permanent bailout that includes the Java stack trace of the problematic location. If this error is encountered too frequently it can be disabled by setting compiler.DeoptCycleDetectionThreshold to -1. For further information, see the Automatic Detection of Deoptimization Cycles guide.  Implemented the extended Dynamic Object Model Layout that adds:          A shape obsolescence strategy enabling optimistic type speculation for primitive property values. When speculation fails, shapes gradually migrate to more general forms (for example, moving primitive slots to reference slots), eventually converging on a stable, general shape tree. This reduces shape polymorphism by replacing overly specific shapes with more general ones.      Automatic reference type tracking based on assumptions, which eliminates redundant type checks.      Automatic single-assignment tracking based on assumptions allowing languages to assume that a property is effectively final (i.e. stays unchanged after the initial assignment) as well as constant-fold values of a constant receiver with a known shape.      You can still disable the new layout and switch back to the previous implementation using the system property -Dtruffle.object.LayoutFactory=com.oracle.truffle.api.object.CoreLayoutFactory.        Enabled lazy deoptimization of runtime-compiled code by default for native-image hosts, which reduces memory used for deoptimization. It can be turned off using the -H:-LazyDeoptimization option.  Now you can specify language and instrument specific options using Source.Builder.option(String, String). Languages may describe available source options by implementing the methods TruffleLanguage.getSourceOptionDescriptors() and TruffleInstrument.getSourceOptionDescriptors() respectively.  Added multiple improvements to Bytecode DSL:          Improved builder performance: creating bytecode nodes is now 40% faster and requires five times less temporary memory.      Builder instances now implement toString(), which prints both the current operations and the instructions already emitted. This should make debugging builder usage easier.      Improved variadic support: variadic operands now compile and execute more efficiently, with fewer reallocations.      Added a startOffset parameter to @Variadic, allowing reservation of a fixed number of slots in the object array for custom use. The @Variadic annotation can now also be applied to @Operation-annotated classes to indicate that the operation produces a dynamic variadic return value. Dynamic @Variadic return values are efficiently flattened into the object array of a @Variadic operand.      Added a variadicStackLimit parameter to @GenerateBytecode that allows to specify how many variable arguments are stored on the stack before they are collapsed into an object array.      Find a complete list of updates in the Truffle changelog.",
          "url": " /release-notes/JDK_25/"
          },
          
          "latest-getting-started-container-images":  {
          "title": "GraalVM Community Edition Container Images",
          "content": "GraalVM Community Edition Container ImagesTo support container-based development, GraalVM Community Edition container images are published in the GitHub Container Registry.RepositoriesThere are different GraalVM Community Edition container images provided depending on the architecture and the Java version, and have -community as part of their names.These are: native-image-community, jdk-community, truffleruby-community, nodejs-community, and graalpy-community.The container images are multi-arch, for x64 and AArch64 processor architectures, with a choice of Oracle Linux versions 8, 9, and 10.GraalVM is installed in /usr/lib64/graalvm/graalvm-community-java&amp;lt;$FeatureVersion&amp;gt;/ where &amp;lt;$FeatureVersion&amp;gt; is 17, 21, 25, and so on.For instance, GraalVM 25 is installed in /usr/lib64/graalvm/graalvm-community-java25/.All binaries, including java, javac, native-image, and other binaries are available as global commands via the alternatives command.  Note: For GraalVM non-RPM based images (graalvm-community, python-community, truffleruby-community), the installation location is under /opt/ (/opt/graalvm-community-java&amp;lt;$FeatureVersion&amp;gt;/, /opt/truffleruby-&amp;lt;$GRAALVM_VERSION&amp;gt;/, and /opt/graalpy-&amp;lt;$GRAALVM_VERSION&amp;gt;/ respectively).  Note: GraalVM Community Edition container images are based on Oracle Linux slim images, and the default package manager is microdnf.See a full list of GraalVM Community Edition container images here.TagsEach repository provides multiple tags that let you choose the level of stability you need including the Java version, build number, and the Oracle Linux version.Image tags use the following naming convention:$version[-muslib(for native image only)][-$platform][-$buildnumber]The following tags are listed from the most-specific tag (at the top) to the least-specific tag (at the bottom).The most-specific tag is unique and always points to the same image, while the less-specific tags point to newer image variants over time.For example:25.0.2-ol925.0.225-ol925Pulling Images  To pull the container image for GraalVM JDK for a specific JDK feature version, such as 25, run:     docker pull ghcr.io/graalvm/jdk-community:25    Alternatively, to use the container image as the base image in your Dockerfile, use:     FROM ghcr.io/graalvm/jdk-community:25    You have pulled a size compact GraalVM Community Edition container image with the GraalVM JDK and the Graal compiler preinstalled.    To pull the container image with the native-image utility for a specific JDK feature version, such as 25, run:     docker pull ghcr.io/graalvm/native-image-community:25    Alternatively, to pull the container image with the native-image utility with the musl libc toolchain to create fully statically linked executables, use:     docker pull ghcr.io/graalvm/native-image-community:25-muslib    Alternatively, to use the container image as the base image in your Dockerfile, use:     FROM ghcr.io/graalvm/native-image-community:25-muslib    To verify, start the container and enter a Bash session:     docker run -it --rm --entrypoint /bin/bash ghcr.io/graalvm/native-image-community:25    To check the version of GraalVM and its installed location, run the env command from the Bash prompt:     env    The output includes the environment variable JAVA_HOME with its value corresponding to the installed GraalVM version and location.    To check the Java version, run:     java -version    To check the native-image version, run:     native-image --version    Calling docker pull without specifying a processor architecture pulls container images for the processor architecture that matches your Docker client. To pull a container image for a different platform architecture, specify the desired platform architecture with the --platform option and either linux/amd64 or linux/aarch64 as follows:     docker pull --platform linux/aarch64 ghcr.io/graalvm/native-image-community:25  Oracle GraalVM Container ImagesOracle GraalVM container images are published in the Oracle Container Registry (OCR) and include GFTC-licensed Oracle GraalVM.Learn more in the Oracle GraalVM Container Images documentation.Related Documentation  Tiny Java Containers: Learn how GraalVM Native Image can generate native executables ideal for containerization.",
          "url": " /latest/getting-started/container-images/"
          },
          
          "release-notes-jdk-17":  {
          "title": "GraalVM for JDK 17",
          "content": "GraalVM for JDK 17.0.9(2023-10-24)This is the October 2023 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM features bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 17.0.8.  Updated GraalVM Community Edition for JDK 17 to 17.0.9+9. See the OpenJDK 17 Updates.  Version compatibility:          Truffle languages and other components version 23.0.2 are designed for use with GraalVM for JDK 17.0.9.        Compiler fixes:          Fixed alternating Phi wrongly detected as induction variable.      Fixed macOS AArch64 miscompilation.        Native Image fixes:          Re-throw feature exceptions as user errors.      Properly set exceptionTemp for foreign calls.      Ignore accessors of RecordComponents when null.      Improved build reports.      Do not annotate non-final JDK methods as uninterruptible.      Fixed incorrect buffer pool adjustment during sampler start.      Made the physical memory size initialize eagerly.      Fixed “New VarHandle found after static analysis” in Netty 5.        Truffle framework fixes:          Fixed a NullPointerException when using isloates in JIT mode and sharing engine if the context is not closed.      Disconnected polyglot.Value instances created from BigInteger values should not return false by default for isNumber().      Fixed a NullPointerException in AbstractTruffleString.equals() method.      Fixed a deadlock in PolyglotStackFramesRetriever.      Disallowed untrusted code hardware mitigations until MPK support is complete.      GraalVM for JDK 17.0.8(2023-07-25)This is the July 2023 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM features bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 17.0.7.  Updated the OpenJDK release on which GraalVM Community Edition is built to 17.0.8+7. See the OpenJDK 17 Updates.  Graal compiler: Updated counted strip mining optimization to do not strip mine overflowing loops.  Native Image: Fixed jvmstat performance data initialization.  Native Image: Fixed JDK Flight Recorder (JFR) events constant pool IDs.  Native Image: Fixed user experience issues in Native Image.  Native Image: Fixed analysis results in build reports.GraalVM for JDK 17.0.7(2023-06-13)  Platform Updates  Java and Compiler Updates  Native Image  JavaScript and Node.js  Polyglot Embedding  Truffle Language and Tool Implementations  Java on Truffle  Python  Ruby  LLVM  WebAssemblyPlatform Updates  Released GraalVM Community Edition for JDK 17 based on OpenJDK 17.0.7+8. See OpenJDK 17 Updates.  Simplified the GraalVM package naming: it is graalvm-community-jdk-&amp;lt;full java version&amp;gt;_&amp;lt;platform&amp;gt;-&amp;lt;arch&amp;gt;, for example: graalvm-community-jdk-17.0.7_macos-aarch64_bin.tar.gz.Java and Compiler Updates  Added support for the ZGC garbage collector for workloads that require low latency or use a very large heap size. See #2149.  Strengthened the optimistic aliasing analysis by adding a non-speculative mode. (Improves loop vectorization.) Some code shapes were previously only vectorized in JIT, but not in ahead-of-time compilations. With the improved loop vectorization for Native Image, the differences in those code shapes are gone, allowing the compiler to vectorize more loops for faster execution.  Improved logging of the novel optimization compiler phase: unified interface to log and dump (for example, via JSON) optimization decisions. Optimization phases should use OptimizationLog to log transformations. Read more in OptimizationLog.md and Profdiff.md to learn how to compare performed optimizations in hot compilations.  Open-sourced Ideal Graph Visualizer (IGV) to make it easier for third-party compilers and language developers to use and contribute to it. See more here.See more updates in the changelog.Native ImagePackaging and Platform Updates  Native Image is now shipped as part of GraalVM for JDK 17, and no longer needs to be installed via gu install native-image. Read more here.  Native Image now sets build environments on Windows automatically if it can find a Visual Studio installation in a known location. Therefore, running in an x64 Native Tools Command Prompt is no longer a requirement.  Improved dynamic linking of AWT libraries on Linux. Static linking of AWT libraries on Linux has been a constant source of problems. Dynamic linking avoids the pitfalls of static linking at the expense of no longer having standalone binaries, which is a reasonable trade-off as shown by AWT support on Windows. The linker should no longer fail because of “multiple definitions of jvm”, or crash at the linking step for an AWS/Swing application on Linux.  Jipher JCE, a Java Cryptography Architecture (JCA) provider implemented on top of OpenSSL 3.0 FIPS, now supports GraalVM Native Image. It is recommended to enable Jipher with Native Image in contexts where only FIPS-allowed algorithms should be used. See the documentation to get started.New Features  Introduced a new feature: building a native executable from a self-contained bundle on demand. The new option --bundle-create=&amp;lt;imagename&amp;gt;.nib creates a &amp;lt;imagename&amp;gt;.nib file (a build bundle) and the launch.output directory alongside a native executable. The bundle file, &amp;lt;imagename&amp;gt;.nib, is a regular JAR file that contains all information required to build a native executable (or a native shared library). In contrast to regular native-image building, this mode of operation takes only a single *.nib file as an input. At any time later, if the same version of GraalVM is used, the executable can be rebuilt with:    native-image --bundle-apply=.../path/to/launch.nib    It will rebuild the native executable with the same image arguments, environment variables, system properties, classpath, and module-path options as in the initial build. It is a safe and reliable solution to encapsulate all the input required for building into a single file. Learn more in the Native Image Bundles reference manual.    Improved the memory footprint of the Native Image build process. The builder now takes available memory into account to reduce memory pressure when many other processes are running on the same machine. It also consumes less memory in many cases and is therefore also less likely to fail due to out-of-memory errors. At the same time, the memory limit was raised from 14GB to 32GB.  Native Image now targets x86-64-v3 architecture by default on AMD64 and provides a new -march option to specify target compatibility. Use -march=compatibility for best compatibility or -march=native for best performance if a native executable is deployed on the same machine or on a machine with the same CPU features. To list all available machine types, use -march=list.  Improved reporting of missing metadata in Native Image by throwing special exceptions. Native Image does not distinguish between missing reachability metadata and exceptions that were thrown by the Reflection API. For example, the ClassNotFoundException that is thrown when a class is not on the classpath, or when the metadata for a class is not present. Now Native Image users can catch metadata exceptions and debug their programs using the option -XX:ExitOnMissingMetadata to guarantee that all metadata entries are correct. Read more here. This is an experimental feature and is not enabled by default.  Introduced safe composition of Reflection and Resources metadata in Native Image. For example, reflective methods such as java.lang.Class#getDeclaredMethodsreturn are based on the reachability of other reflective elements. Adding new metadata makes more elements reachable and can change the program functionality. Thanks to the safe composition of metadata optimization, the native-image builder now ensures that every reflective call on java.lang.Class requires a metadata entry. Read more here.  Disallowed the --initialize-at-build-time option without arguments. As a temporary workaround, the -H:+AllowDeprecatedInitializeAllClassesAtBuildTime option turns this error into a warning.  Added an experimental RISC-V mode for Native Image through the LLVM backend. Read more in this blog post.  Improved Profile-Guided Optimizations (PGO) in Native Image (PGO is not available in GraalVM Community Edition):          Profile-guided optimizations have a new sampling profiler that collect call stacks periodically. Use the option --pgo-sampling to turn on the sampling profiler and collect call stacks. This data is then included in the .iprof file. When the PGO-instrumented executable is built, the sampling profiler turned on by default (but can be turned off with the option -H:-SamplingCollect). To get good profiles and therefore good peak performance, you need to run relevant workloads and properly warm up the application.      Implemented the Context-Aware Inliner (CAI) optimization which specializes in sampling profiles in the “hot” code, and invests more optimization effort into hot-compilation units. When the optimized image is built for PGO, the Context-Aware Inliner is automatically turned on (but can be turned off with the option -H:-AOTInliner). The results are 2-7% smaller executable sizes, and increased peak performance.      Improved merging profiles and enabled pre-packaged profiles.        Added Machine Learning (ML) based profile inference. When profiling is disabled, the Graal compiler in Native Image uses a pre-trained ML model to infer the profiles of the control split branches. Then, inferred profiles are used to perform the profile-guided optimizations. In some benchmarks such as Renaissance, Da Capo, and Da Capo con Scala, this optimization provides ~6% runtime speedup compared to the default Oracle GraalVM configuration. By running the native executable build with the ML profile inference, you can expect a slight binary size increase of 1%-2%.This optimization is enabled by default in Oracle GraalVM (not available in GraalVM Community Edition). To disable it, use the following option: -H:-MLProfileInference.  Native Image SBOMs now include a single SBOM component for runtime components. This component uses the java.vm.version property of the executable to identify the version and belongs to the new graalvm-native-image product.Build Output Improvements  The builder now can generate build reports that help you better understand the contents of your executables. Use -H:+BuildReport to try this new experimental feature.  Improved reporting of internal errors to be more user-friendly. A clear message tells users how to proceed: inspect the error report and, if unable to resolve the problem, file an issue with the error report. Inspired by HotSpot, the default filename for error reports is ./svm_err_b_&amp;lt;timestamp&amp;gt;_pid&amp;lt;pid&amp;gt;.md. This also adds a new option -H:ErrorFile to let you choose a different filename for error reports. See #5414.  Adjusted the native-image build output to report types (primitives, classes, interfaces, and arrays) instead of classes and revise the output schema of -H:BuildOutputJSONFile.  The output of the native-image --version command and various Java properties (for example, java.vm.version) are aligned with OpenJDK. To distinguish between GraalVM Community Edition, Oracle GraalVM, and GraalVM distributions from other vendors, refer to java.vm.vendor.Debugging and Monitoring Experience Improvements  Deprecated using the option --enable-monitoring without an argument. The option no longer defaults to all. Instead, always explicitly specify the list of monitoring features to be enabled, for example, --enable-monitoring=heapdump,jfr,jvmstat.  Added the option -XX:HeapDumpPath to control where a heap dumps is created.  Added more JFR events for application monitoring: ExecutionSample, ObjectAllocationInNewTLAB, and JavaMonitorInflate.  Improved debugging on Windows: debug information now includes information about Java types. (Together with Red Hat.)  Implemented the remote management over JMX to Native Image which can be enabled with the option --enable-monitoring, for example: --enable-monitoring=jmxclient,jmxserver. Read more here. The feature is experimental. (Together with Red Hat.)  Enabled the JFR event streaming for Native Image. The feature is experimental. (Together with Red Hat.)Find many more updates in the Native Image changelog.JavaScript and Node.js  Updated Node.js to version 18.14.1.  Added BigInteger interoperability support. Note that foreign BigIntegers require an explicit type cast using the BigInt function to opt into JS BigInt semantics. The default semantics is to treat all foreign numbers like JavaScript Number values, regardless of the original value or type. Arithmetic operators perform an implicit lossy conversion to double. Comparison operators attempt to do a precise value comparison where possible. JavaScript BigInt values can now be converted to java.math.BigInteger host objects, although a target type mapping may still be necessary to ensure consistent type mapping if the target type is ambiguous or absent.  Implemented several new ECMAScript proposals in the GraalVM JavaScript runtime:          The Iterator Helpers proposal. It is available behind the experimental option --js.iterator-helpers.      The ShadowRealm API proposal. It is available behind the experimental option --js.shadow-realm.      The Symbols as WeakMap keys proposal. It is available in ECMAScript staging mode, ()--js.ecmascript-version=staging).      The ArrayBuffer.prototype.transfer and friends proposal. It is available in ECMAScript staging mode (--js.ecmascript-version=staging).      The Change Array by copy proposal. It is available in ECMAScript staging mode (--js.ecmascript-version=staging).      Find more updates in the project changelog.Polyglot Embedding  This is the first release that supports running untrusted applications in a code sandbox. The sandbox policy Context.Builder#sandbox(SandboxPolicy) with four different levels of sandboxing, ISOLATED, UNTRUSTED, TRUSTED, and CONSTRAINED, was implemented to enable users to establish a security boundary between a host application and guest code. The policy is set by passing it to the Engine.Builder#sandbox(SandboxPolicy) or Context.Builder#sandbox(SandboxPolicy) builder method. A host code can execute untrusted guest code using, for example, the UNTRUSTED policy. Host code can also execute multiple mutually distrusting instances of guest code that will be protected from one another. Learn more in the polyglot sandboxing guide. Code sandboxing is currently only supported for JavaScript. The SandboxPolicy.ISOLATED and SandboxPolicy.UNTRUSTED policies are not available in GraalVM Community Edition.  Related to the code sandbox implementation, a new option TraceLimits was added to measure a guest application’s resource consumption and obtain realistic sandbox parameters.  Added the IOAccess API: the IO access configuration of a polyglot context. The IO access configuration determines how a guest language can access the host IO. The new IOAccess class provides a predefined configuration to disable host IO access, or to enable full host IO access. A custom configuration can be created using an IOAccess builder.  Added java.lang.BigInteger to the Polyglot Value API. By default, all host values of the type java.lang.BigInteger are now interpreted as number values (Value.isNumber()), unlike before. In order to restore the old behavior, set HostAccess.Builder.allowBigIntegerNumberAccess(boolean) to false. Note that the language support for interpreting numbers that do not fit into long values may vary. Some languages, such as JavaScript, may require explicit conversions of host big integers. Other languages, such as Ruby or Python, can use big integers without explicit conversion. The same applies to values passed across guest languages. See #2737.  Added automatic copying of language resources for embedding Truffle languages in Native Image. The documentation is available here.A full list of changes is available in the changelog.Truffle Language and Tool Implementations  Implemented several new features for Truffle DSL to improve performance. In particular, a new annotation called @GenerateInline was introduced which allows Truffle nodes to be object-inlined automatically. Object-inlined Truffle nodes become singletons and therefore reduce memory footprint. This works analogously to @GenerateCached and @GenerateUncached, which generate a cached or uncached node version. Please see the documentation for further details.Other updates contributing to performance improvements are:  Updated Truffle DSL nodes no longer require the node lock during specialization, resulting in improved first execution performance. CAS-style inline cache updates are now used to avoid deadlocks when calling CallTarget.call(...) in guards. Inline caches continue to guarantee no duplicate values and are not affected by race conditions. Language implementations should be aware that the reduced contention may reveal other thread-safety issues in the language.  Improved Truffle DSL node memory footprint by merging generated fields for state and excluding bit sets and improving specialization data class generation to consider activation probability. Specializations should be ordered by activation probability for optimal results.  Improved memory footprint by automatically inlining cached parameter values of enum types into the state bitset.  Truffle DSL now emits many more warnings for recommendations. For example, it emits warnings for inlining opportunities, cached sharing or when a cache initializer should be designated as @NeverDefault. To ease migration work, new ways to suppress the warnings temporarily for a Java package were added. For a list of possible warnings and further usage instructions, see the documentation.  Unclosed polyglot engines are no longer closed automatically on VM shutdown. They die with the VM. As a result, TruffleInstrument#onDispose is not called for active instruments on unclosed engines in the event of VM shutdown. In case an instrument is supposed to do some specific action before its disposal, for example, print some kind of summary, it should be done in TruffleInstrument#onFinalize.  Implemented the policies to control the restriction of code sandboxing. By default, languages and instruments support just the TRUSTED sandbox policy.          If a language wants to target a more restrictive sandbox policy, it must:                  Specify the most strict sandbox policy it satisfies using TruffleLanguage.Registration#sandbox().          For each option, the language must specify the most restrictive sandbox policy in which the option can be used via Option#sandbox(). By default, options have a TRUSTED sandbox policy.          If a language needs additional validation, it can use TruffleLanguage.Env#getSandboxPolicy() to obtain the current context sandbox policy.                    If an instrument wants to target a more restrictive sandbox policy, it must:                  Specify the most strict sandbox policy it satisfies using TruffleInstrument.Registration#sandbox().          For each option, the instrument must specify the most restrictive sandbox policy in which the option can be used via Option#sandbox(). By default, options have a TRUSTED sandbox policy.          If an instrument needs additional validation, it can use TruffleInstrument.Env#getSandboxPolicy() to obtain the engine’s sandbox policy.                    Find many more updates in the Truffle changelog.Java on Truffle (Espresso)New features:  The Truffle InteropLibrary has/getMetaParents API is now fully implemented.  Enabled foreign Instant, TimeZone, Time, Date, Duration when calling espresso via interop.Improvements:  Enabled calling overloaded and Varargs methods through interop.  Improved interoperability with foreign exceptions. A stack trace is now available and type mapping can be used to explicitly map exceptions.PythonPerformance Improvements:  Added a new implementation of the Python C API interface that uses fully native execution by default. This improves performance and compatibility with some extensions that spend a lot of time in native code (such as SciPy, PyTorch, …) but can have negative effects on workloads that frequently cross the Python/native boundary. There are new options to control how extensions are built and run: python.NativeModules and python.UseSystemToolchain. The new default is to use the host system’s toolchain for building extensions rather than the LLVM toolchain that ships with GraalVM and to run all modules natively. A new launcher (graalpy-lt) is available to get the old behavior, which can be useful for debugging.  The performance numbers we report on the website are now based on results from the community’s pyperformance benchmark suite, measuring GraalPy geomean speedup over CPython and Jython. This makes it easier to compare and reproduce our results.Platform Updates:  Implemented building and running basic GraalPy workloads on Windows. This enables Windows users to build and use GraalPy, especially for embedding into Java.  Added GraalPy plugin for Virtualenv as a builtin module, so that creating virtual environments with virtualenv on GraalPy works out of the box.  Updated the builtin venv module to create virtual environments with symlinks instead of generated shell scripts that are delegated to the base GraalPy.Compatibility Improvements:  Updated language version and the standard library to 3.10.8, making it compatible with more recent modules and packages.  Updated the distribution layout of GraalPy to match CPython’s. This reduces the number of patches needed for various build systems to discover GraalPy’s library locations.  Updated numpy and pandas versions.  Implemented scipy and scikit_learn with ginstall.A full list of updates can be found in the project changelog.RubyNew features:  Updated to Ruby 3.1.3.  Foreign big integers are now supported and work with all Numeric operators.Performance:  Made the system libyaml for psych to be used which improves warmup when parsing YAML. This means libyaml is now a dependency. See how to install LibYAML.  Marking of native structures wrapped in objects is now done on the C call exit to reduce memory overhead.  Optimized splitting (copying) of call targets by implementing cloneUninitialized().  Process.pid is now cached per process like $$.  Fixed repeated deoptimizations for methods building an Array which is growing over multiple calls at a given call site.Bug fixes:  Fixed spawn(..., fd =&amp;gt; fd) on macOS, it did not work due to a macOS bug.  Fixed rb_gc_register_address()/rb_global_variable() to read the latest value (see #2721, #2734).A full list of changes is available in the project changelog.LLVM  Updated the LLVM toolchain to version 15.0.6.  Update musl libc to version 1.2.3.  Implemented long double (128 bit floating point) on the Linux AArch64 architecture.WebAssembly  Added experimental debugging for DWARFv4. This enables debugging of C, C++, and Rust applications.  Added experimental support for Memory64. The feature can be enabled with the option --wasm.Memory64=true.  Implemented the Bulk-Memory and Reference-Types proposal. They can be disabled with the option --wasm.BulkMemoryAndRefTypes.",
          "url": " /release-notes/JDK_17/"
          },
          
          "release-notes-jdk-20":  {
          "title": "GraalVM for JDK 20",
          "content": "GraalVM for JDK 20.0.2(2023-07-25)This is the July 2023 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM features bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 20.0.1.  Updated the OpenJDK release on which GraalVM Community Edition is built to 20.0.2+9. See the OpenJDK 20 Updates.  Graal compiler: Updated counted strip mining optimization to do not strip mine overflowing loops.  Native Image: Fixed jvmstat performance data initialization.  Native Image: Fixed JDK Flight Recorder (JFR) events constant pool IDs.  Native Image: Fixed user experience issues in Native Image.  Native Image: Fixed analysis results in build reports.GraalVM for JDK 20.0.1(2023-06-13)  Platform Updates  Java and Compiler Updates  Native Image  JavaScript and Node.js  Polyglot Embedding  Truffle Language and Tool Implementations  Java on Truffle  Python  Ruby  LLVM  WebAssemblyPlatform Updates  Released GraalVM Community Edition for JDK 20 based on OpenJDK 20.0.1+8. See OpenJDK 20 Updates.  Simplified the GraalVM package naming: it is graalvm-community-jdk-&amp;lt;full java version&amp;gt;_&amp;lt;platform&amp;gt;-&amp;lt;arch&amp;gt;, for example: graalvm-community-jdk-20.0.1_macos-aarch64_bin.tar.gz.Java and Compiler Updates  Added support for the ZGC garbage collector for workloads that require low latency or use a very large heap size. See #2149.  Strengthened the optimistic aliasing analysis by adding a non-speculative mode. (Improves loop vectorization.) Some code shapes were previously only vectorized in JIT, but not in ahead-of-time compilations. With the improved loop vectorization for Native Image, the differences in those code shapes are gone, allowing the compiler to vectorize more loops for faster execution.  Improved logging of the novel optimization compiler phase: unified interface to log and dump (for example, via JSON) optimization decisions. Optimization phases should use OptimizationLog to log transformations. Read more in OptimizationLog.md and Profdiff.md to learn how to compare performed optimizations in hot compilations.  Open-sourced Ideal Graph Visualizer (IGV) to make it easier for third-party compilers and language developers to use and contribute to it. See more here.See more updates in the changelog.Native ImagePackaging and Platform Updates  Native Image is now shipped as part of GraalVM for JDK 20, and no longer needs to be installed via gu install native-image. Read more here.  Native Image now sets build environments on Windows automatically if it can find a Visual Studio installation in a known location. Therefore, running in an x64 Native Tools Command Prompt is no longer a requirement.  Improved dynamic linking of AWT libraries on Linux. Static linking of AWT libraries on Linux has been a constant source of problems. Dynamic linking avoids the pitfalls of static linking at the expense of no longer having standalone binaries, which is a reasonable trade-off as shown by AWT support on Windows. The linker should no longer fail because of “multiple definitions of jvm”, or crash at the linking step for an AWS/Swing application on Linux.  Jipher JCE, a Java Cryptography Architecture (JCA) provider implemented on top of OpenSSL 3.0 FIPS, now supports GraalVM Native Image. It is recommended to enable Jipher with Native Image in contexts where only FIPS-allowed algorithms should be used. See the documentation to get started.New Features  Introduced a new feature: building a native executable from a self-contained bundle on demand. The new option --bundle-create=&amp;lt;imagename&amp;gt;.nib creates a &amp;lt;imagename&amp;gt;.nib file (a build bundle) and the launch.output directory alongside a native executable. The bundle file, &amp;lt;imagename&amp;gt;.nib, is a regular JAR file that contains all information required to build a native executable (or a native shared library). In contrast to regular native-image building, this mode of operation takes only a single *.nib file as an input. At any time later, if the same version of GraalVM is used, the executable can be rebuilt with:    native-image --bundle-apply=.../path/to/launch.nib    It will rebuild the native executable with the same image arguments, environment variables, system properties, classpath, and module-path options as in the initial build. It is a safe and reliable solution to encapsulate all the input required for building into a single file. Learn more in the Native Image Bundles reference manual.    Improved the memory footprint of the Native Image build process. The builder now takes available memory into account to reduce memory pressure when many other processes are running on the same machine. It also consumes less memory in many cases and is therefore also less likely to fail due to out-of-memory errors. At the same time, the memory limit was raised from 14GB to 32GB.  Native Image now targets x86-64-v3 architecture by default on AMD64 and provides a new -march option to specify target compatibility. Use -march=compatibility for best compatibility or -march=native for best performance if a native executable is deployed on the same machine or on a machine with the same CPU features. To list all available machine types, use -march=list.  Improved reporting of missing metadata in Native Image by throwing special exceptions. Native Image does not distinguish between missing reachability metadata and exceptions that were thrown by the Reflection API. For example, the ClassNotFoundException that is thrown when a class is not on the classpath, or when the metadata for a class is not present. Now Native Image users can catch metadata exceptions and debug their programs using the option -XX:ExitOnMissingMetadata to guarantee that all metadata entries are correct. Read more here. This is an experimental feature and is not on by default.  Introduced safe composition of Reflection and Resources metadata in Native Image. For example, reflective methods such as java.lang.Class#getDeclaredMethodsreturn are based on the reachability of other reflective elements. Adding new metadata makes more elements reachable and can change the program functionality. Thanks to the safe composition of metadata optimization, the native-image builder now ensures that every reflective call on java.lang.Class requires a metadata entry. Read more here.  Disallowed the --initialize-at-build-time option without arguments. As a temporary workaround, the -H:+AllowDeprecatedInitializeAllClassesAtBuildTime option turns this error into a warning.  Added an experimental RISC-V mode for Native Image through the LLVM backend. Read more in this blog post.  Improved Profile-Guided Optimizations (PGO) in Native Image (PGO is not available in GraalVM Community Edition):          Profile-guided optimizations now have a new sampling profiler that collect call stacks periodically. Use the option --pgo-sampling to turn on the sampling profiler and collect call stacks. This data is then included in the .iprof file. When the PGO-instrumented executable is built, the sampling profiler turned on by default (but can be turned off with the option -H:-SamplingCollect). To get good profiles and therefore good peak performance, you need to run relevant workloads and properly warm up the application.      Implemented the Context-Aware Inliner (CAI) optimization which specializes in sampling profiles in the “hot” code, and invests more optimization effort into hot-compilation units. When the optimized image is built for PGO, the Context-Aware Inliner is automatically turned on (but can be turned off with the option -H:-AOTInliner). The results are 2-7% smaller executable sizes, and increased peak performance.      Improved merging profiles and enabled pre-packaged profiles.        Added Machine Learning (ML) based profile inference. When profiling is disabled, the Graal compiler in Native Image uses a pre-trained ML model to infer the profiles of the control split branches. Then, inferred profiles are used to perform the profile-guided optimizations. In some benchmarks such as Renaissance, Da Capo, and Da Capo con Scala, this optimization provides ~6% runtime speedup compared to the default Oracle GraalVM configuration. By running the native executable build with the ML profile inference, you can expect a slight binary size increase of 1%-2%.This optimization is enabled by default in Oracle GraalVM (not available in GraalVM Community Edition). To disable it, use the following option: -H:-MLProfileInference.  Native Image SBOMs now include a single SBOM component for runtime components. This component uses the java.vm.version property of the executable to identify the version and belongs to the new graalvm-native-image product.Build Output Improvements  The builder now can generate build reports that help you better understand the contents of your executables. Use -H:+BuildReport to try this new experimental feature.  Improved reporting of internal errors to be more user-friendly. A clear message tells users how to proceed: inspect the error report and, if unable to resolve the problem, file an issue with the error report. Inspired by HotSpot, the default filename for error reports is ./svm_err_b_&amp;lt;timestamp&amp;gt;_pid&amp;lt;pid&amp;gt;.md. This also adds a new option -H:ErrorFile to let you choose a different filename for error reports. See #5414.  Adjusted the native-image build output to report types (primitives, classes, interfaces, and arrays) instead of classes and revise the output schema of -H:BuildOutputJSONFile.  The output of the native-image --version command and various Java properties (for example, java.vm.version) are aligned with OpenJDK. To distinguish between GraalVM Community Edition, Oracle GraalVM, and GraalVM distributions from other vendors, refer to java.vm.vendor.Debugging and Monitoring Experience Improvements  Deprecated using the option --enable-monitoring without an argument. The option no longer defaults to all. Instead, always explicitly specify the list of monitoring features to be enabled, for example, --enable-monitoring=heapdump,jfr,jvmstat.  Added the option -XX:HeapDumpPath to control where a heap dumps is created.  Added more JFR events for application monitoring: ExecutionSample, ObjectAllocationInNewTLAB, and JavaMonitorInflate.  Improved debugging on Windows: debug information now includes information about Java types. (In collaboration with Red Hat.)  Added experimental support for JMX in Native Image. For example. use --enable-monitoring=jmxclient,jmxserver to include both the JMX client and server in your executables. Read more here. (Together with Red Hat.)  Enabled the JFR event streaming for Native Image. The feature is experimental. (Together with Red Hat.)Find many more updates in the Native Image changelog.JavaScript and Node.js  Updated Node.js to version 18.14.1.  Added BigInteger interoperability support. Note that foreign BigIntegers require an explicit type cast using the BigInt function to opt into JS BigInt semantics. The default semantics is to treat all foreign numbers like JavaScript Number values, regardless of the original value or type. Arithmetic operators perform an implicit lossy conversion to double. Comparison operators attempt to do a precise value comparison where possible. JavaScript BigInt values can now be converted to java.math.BigInteger host objects, although a target type mapping may still be necessary to ensure consistent type mapping if the target type is ambiguous or absent.  Implemented several new ECMAScript proposals in the GraalVM JavaScript runtime:          The Iterator Helpers proposal. It is available behind the experimental option --js.iterator-helpers.      The ShadowRealm API proposal. It is available behind the experimental option --js.shadow-realm.      The Symbols as WeakMap keys proposal. It is available in ECMAScript staging mode, ()--js.ecmascript-version=staging).      The ArrayBuffer.prototype.transfer and friends proposal. It is available in ECMAScript staging mode (--js.ecmascript-version=staging).      The Change Array by copy proposal. It is available in ECMAScript staging mode (--js.ecmascript-version=staging).      Find more updates in the project changelog.Polyglot Embedding  This is the first release that supports running untrusted applications in a code sandbox. The sandbox policy Context.Builder#sandbox(SandboxPolicy) with four different levels of sandboxing, ISOLATED, UNTRUSTED, TRUSTED, and CONSTRAINED, was implemented to enable users to establish a security boundary between a host application and guest code. The policy is set by passing it to the Engine.Builder#sandbox(SandboxPolicy) or Context.Builder#sandbox(SandboxPolicy) builder method. A host code can execute untrusted guest code using, for example, the UNTRUSTED policy. Host code can also execute multiple mutually distrusting instances of guest code that will be protected from one another. Learn more in the polyglot sandboxing guide. Code sandboxing is currently only supported for Javascript. The SandboxPolicy.ISOLATED and SandboxPolicy.UNTRUSTED policies are not available in GraalVM Community Edition.  Related to the code sandbox implementation, a new option TraceLimits was added to measure a guest application’s resource consumption and obtain realistic sandbox parameters.  Added the IOAccess API: the IO access configuration of a polyglot context. The IO access configuration determines how a guest language can access the host IO. The new IOAccess class provides a predefined configuration to disable host IO access, or to enable full host IO access. A custom configuration can be created using an IOAccess builder.  Added java.lang.BigInteger to the Polyglot Value API. By default, all host values of the type java.lang.BigInteger are now interpreted as number values (Value.isNumber()), unlike before. In order to restore the old behavior, set HostAccess.Builder.allowBigIntegerNumberAccess(boolean) to false. Note that the language support for interpreting numbers that do not fit into long values may vary. Some languages, such as JavaScript, may require explicit conversions of host big integers. Other languages, such as Ruby or Python, can use big integers without explicit conversion. The same applies to values passed across guest languages. See #2737.  Added automatic copying of language resources for embedding Truffle languages in Native Image. The documentation is available here.A full list of changes is available in the changelog.Truffle Language and Tool Implementations  Implemented several new features for Truffle DSL to improve performance. In particular, a new annotation called @GenerateInline was introduced which allows Truffle nodes to be object-inlined automatically. Object-inlined Truffle nodes become singletons and therefore reduce memory footprint. This works analogously to @GenerateCached and @GenerateUncached, which generate a cached or uncached node version. Please see the documentation for further details.Other updates contributing to performance improvements are:  Updated Truffle DSL nodes no longer require the node lock during specialization, resulting in improved first execution performance. CAS-style inline cache updates are now used to avoid deadlocks when calling CallTarget.call(...) in guards. Inline caches continue to guarantee no duplicate values and are not affected by race conditions. Language implementations should be aware that the reduced contention may reveal other thread-safety issues in the language.  Improved Truffle DSL node memory footprint by merging generated fields for state and excluding bit sets and improving specialization data class generation to consider activation probability. Specializations should be ordered by activation probability for optimal results.  Improved memory footprint by automatically inlining cached parameter values of enum types into the state bitset.  Truffle DSL now emits many more warnings for recommendations. For example, it emits warnings for inlining opportunities, cached sharing or when a cache initializer should be designated as @NeverDefault. To ease migration work, new ways to suppress the warnings temporarily for a Java package were added. For a list of possible warnings and further usage instructions, see the documentation.  Unclosed polyglot engines are no longer closed automatically on VM shutdown. They die with the VM. As a result, TruffleInstrument#onDispose is not called for active instruments on unclosed engines in the event of VM shutdown. In case an instrument is supposed to do some specific action before its disposal, for example, print some kind of summary, it should be done in TruffleInstrument#onFinalize.  Implemented the policies to control the restriction of code sandboxing. By default, languages and instruments support just the TRUSTED sandbox policy.          If a language wants to target a more restrictive sandbox policy, it must:                  Specify the most strict sandbox policy it satisfies using TruffleLanguage.Registration#sandbox().          For each option, the language must specify the most restrictive sandbox policy in which the option can be used via Option#sandbox(). By default, options have a TRUSTED sandbox policy.          If a language needs additional validation, it can use TruffleLanguage.Env#getSandboxPolicy() to obtain the current context sandbox policy.                    If an instrument wants to target a more restrictive sandbox policy, it must:                  Specify the most strict sandbox policy it satisfies using TruffleInstrument.Registration#sandbox().          For each option, the instrument must specify the most restrictive sandbox policy in which the option can be used via Option#sandbox(). By default, options have a TRUSTED sandbox policy.          If an instrument needs additional validation, it can use TruffleInstrument.Env#getSandboxPolicy() to obtain the engine’s sandbox policy.                    Find many more updates in the Truffle changelog.Java on Truffle (Espresso)New features:  The Truffle InteropLibrary has/getMetaParents API is now fully implemented.  Enabled foreign Instant, TimeZone, Time, Date, Duration when calling espresso via interop.Improvements:  Enabled calling overloaded and Varargs methods through interop.  Improved interoperability with foreign exceptions. A stack trace is now available and type mapping can be used to explicitly map exceptions.PythonPerformance Improvements:  Added a new implementation of the Python C API interface that uses fully native execution by default. This improves performance and compatibility with some extensions that spend a lot of time in native code (such as SciPy, PyTorch, …) but can have negative effects on workloads that frequently cross the Python/native boundary. There are new options to control how extensions are built and run: python.NativeModules and python.UseSystemToolchain. The new default is to use the host system’s toolchain for building extensions rather than the LLVM toolchain that ships with GraalVM and to run all modules natively. A new launcher (graalpy-lt) is available to get the old behavior, which can be useful for debugging.  The performance numbers we report on the website are now based on results from the community’s pyperformance benchmark suite, measuring GraalPy geomean speedup over CPython and Jython. This makes it easier to compare and reproduce our results.Platform Updates:  Implemented building and running basic GraalPy workloads on Windows. This enables Windows users to build and use GraalPy, especially for embedding into Java.  Added GraalPy plugin for Virtualenv as a builtin module, so that creating virtual environments with virtualenv on GraalPy works out of the box.  Updated the builtin venv module to create virtual environments with symlinks instead of generated shell scripts that are delegated to the base GraalPy.Compatibility Improvements:  Updated language version and the standard library to 3.10.8, making it compatible with more recent modules and packages.  Updated the distribution layout of GraalPy to match CPython’s. This reduces the number of patches needed for various build systems to discover GraalPy’s library locations.  Updated numpy and pandas versions.  Implemented scipy and scikit_learn with ginstall.A full list of updates can be found in the project changelog.RubyNew features:  Updated to Ruby 3.1.3.  Foreign big integers are now supported and work with all Numeric operators.Performance:  Made the system libyaml for psych to be used which improves warmup when parsing YAML. This means libyaml is now a dependency. See how to install LibYAML.  Marking of native structures wrapped in objects is now done on the C call exit to reduce memory overhead.  Optimized splitting (copying) of call targets by implementing cloneUninitialized().  Process.pid is now cached per process like $$.  Fixed repeated deoptimizations for methods building an Array which is growing over multiple calls at a given call site.Bug fixes:  Fixed spawn(..., fd =&amp;gt; fd) on macOS, it did not work due to a macOS bug.  Fixed rb_gc_register_address()/rb_global_variable() to read the latest value (see #2721, #2734).A full list of changes is available in the project changelog.LLVM  Updated the LLVM toolchain to version 15.0.6.  Update musl libc to version 1.2.3.  Implemented long double (128 bit floating point) on the Linux AArch64 architecture.WebAssembly  Added experimental debugging for DWARFv4. This enables debugging of C, C++, and Rust applications.  Added experimental support for Memory64. The feature can be enabled with the option --wasm.Memory64=true.  Implemented the Bulk-Memory and Reference-Types proposal. They can be disabled with the option --wasm.BulkMemoryAndRefTypes.",
          "url": " /release-notes/JDK_20/"
          },
          
          "release-notes-jdk-21":  {
          "title": "GraalVM for JDK 21",
          "content": "GraalVM for JDK 21.0.2(2024-01-16)This is the January 2024 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 21.  Updated GraalVM Community Edition for JDK 21.0.1 to 21.0.2+13. See the OpenJDK 21 Updates.  Version compatibility:          Truffle languages and other components version 23.1.2 are designed for use with GraalVM for JDK 21.0.2.        Compiler fixes:          Rearranged binary arithmetic operations that may be re-associated for loop invariants and constants.      Fixed Sulong benchmarks failing because of compilation failures.      Improved the AArch64 architecture support: allowed BranchOp to emit FarBranch; made AArch64 HotSpot null constant code generation more generic.      Ensured Guards Anchor to CaptureStateBegin.      The compiler now checks stamps before casting in IntegerLessThanNode.      HeapImpl.dirtyAllReferencesOf must be no-op for the Epsilon garbage collector.      Simplified the ValueAnchorNode implementation.      Removed explicit null check exceptions during generation of checkcast and instanceof.        Native Image fixes:          Updated OS detection code to recognize Windows 11 and Windows Server 2022.      Added an option that allows VM operations to exceed the max heap size.      Fixed a problem with -XX:+PrintGCSummary if assertions are enabled.      Fixed crashes during isolate teardown.      Native Image now ignores crashed threads.      Improved the OutOfMemoryError messages.      Native Image now reports consistent values when memory usage is queried via MemoryPoolMXBean.      Introduced the --disable-debuginfo-stripping argument for the mx tool.      Fixed handling native-image JSON properties stored in the wrong location.      Added a fix to prevent System.console().readPassword failures.      Improved mangling of primitive types in BFD name mangler#7423.      Fixed the native-image --bundle-create,container command failing if a driver is an image.      Made the initialization cycle break in NIO/cgroups code.      Fixed a transient guarantee failure in PointsToAnalysisMethod.getContextInsensitiveVirtualInvoke.      Improved the JFR support: switched to PlatformThreads.getCurrentThreadOrNull() instead of Thread.currentThread(); fixed race condition in JVM.commit(long).      Ensured DeoptTargets are generated for methods requiring FrameInformation.      Now the Native Image builder uses synchronized data structures for reachability handlers registration.      Added an async-signal-safe way to dump crash logs.      Added an option to artificially increase the header size.      Fixed stack walking heuristic used for the Native Image crash log.      Fixed joinThreadUnmanaged on Windows.      Used the vendor version for __svm_version_info.      Made the builder use ThreadLocal for AccessControlContext stack.      Fixed class-path order when MANIFEST files include “Class-Path” attributes.      Added support for execution of bootstrap methods at image run time, and support “constant dynamic” execution at image run time.      Native Image now prints crash log when exception handling fails.      Fixed clinit simulation for arraycopy with null values.      Included signers in the native executable only if registered.      Do not use the shadow heap for fields annotated with @Unknown*Field.        Truffle framework fixes:          Handle json-23.1.0.jar native-image.properties stored in the wrong location.      Upgraded the JSON parser library, org.json, to version 20231013.      Fixed regression in spawning an Espresso context on platforms where it runs on Sulong.      Fixed handling unlinked types in runtime compilation.      Disabled the class-path isolation by default.      Added polyglot version checks for unchained.      Added assertion triggers check that fails and throws an exception.        Tools:          Added the mandatory experimental property debuggerId and handle GET of the /json/list path.        Javascript:          Updated the expected Node.js structure after the update to version 18.18.2.      Prevent automatic leave of an explicitly entered context during close called from a host call.        LLVM:          Initializing LLVM fails if built with Xcode 15.      Regression in the Sulong library loading when IO access is denied.        Java on Truffle (Espresso):          Removed the need for a foreign field in EspressoForeignList.      Added missing Espresso artifacts on Maven.      Fixed ToEspresso collection type nodes not handling Espresso objects.      Fixed type converter combination for foreign exceptions and custom type converters.        Python:          Fixed Python JVM standalones only working on GraalVM Community Edition.        WebAssembly:          File system access from GraalWasm.        TRegex:          Added OracleDB flavor.        GraalVM integration:          Fixed a list of deployed artifacts.      Lambda without a target invoke.      GraalVM for JDK 21.0.1(2023-10-24)This is the October 2023 Critical Patch Update (CPU) for GraalVM Community Edition.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 21.  Updated GraalVM Community Edition for JDK 21 to 21.0.1+12. See the OpenJDK 21 Updates.  Version compatibility:          Truffle languages and other components version 23.1.1 are designed for use with GraalVM for JDK 21.0.1.        Compiler fixes:          Changed constant blinding to use RuntimeRandomness for ahead-of-time compilation.      Added FarBranch support for BranchOp for the AArch64 architecture.        Native Image fixes:          Fixed process crashing when uncommitting unused memory.      Added CEntryPointError if the stack boundaries cannot be determined.      Removed no longer needed JDK-specific Java Flight Recorder code.      Fixed an occasional crash using ProcessBuilder on macOS.      GraalVM for JDK 21(2023-09-19)  Platform and Distributions  Removed Functionality  Java and Compiler  Native Image  Polyglot Embedding  JavaScript and Node.js  Java on Truffle  Python  Ruby  WebAssembly  LLVM  Truffle Language and Tool ImplementationsPlatform and Distributions  Released GraalVM Community Edition for JDK 21 based on OpenJDK 21. See OpenJDK 21 Updates.  Released Oracle GraalVM for JDK 21 based on Oracle JDK 21. See Java SE 21 Release Notes.  Released language runtimes as standalone distributions, therefore there are no language launchers in the GraalVM JDK.Two standalone language runtime options are available for both Oracle GraalVM and GraalVM Community Edition: a Native Image compiled native launcher or a JVM-based runtime (included).To distinguish between the GraalVM editions, the GraalVM Community Edition version has the suffix -community in the name, for example:  graaljs-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz.To distinguish between the runtime mode, a JVM standalone type has the -jvm suffix in a name.Standalone distributions are available on GitHub, in corresponding language repositories.Learn more here.Removed Functionality  Removed GraalVM Updater, gu, used to extend GraalVM installations with GraalVM language runtimes and other components by modifying the installation directory.As part of the alignment with OpenJDK, modifying JDK installations is not common.To continue using the GraalVM language runtime(s) and other components, use language standalones or specify them as Maven or Gradle dependencies in your project.For more information, see Polyglot Embedding updates and the GitHub issue #6855.  Removed the option --language:&amp;lt;language&amp;gt; (to enable a specific language runtime at build time) and some macro options. See below for more details.Java and Compiler  Implemented initial optimization of Java Vector API (JEP 338) operations.Load, store, basic arithmetic, reduce, compare, and blend operations are transformed to efficient machine instructions where possible.It is enabled by default and can be disabled with -Dgraal.OptimizeVectorAPI=false.This optimization is not available in GraalVM Community Edition and not yet available in GraalVM Native Image.Coverage of more operations and Native Image support are planned for the future.This optimization is experimental.  Implemented all intrinsics prior to JDK 21 on both AMD64 and AArch64 architectures for the Graal compiler.We have also ported various HotSpot assembly stubs into Java, including all of the SHA message digest stubs and part of the BigInteger arithmetic computation stubs.This allows Native Image to benefit from these high performance assembly codes.  Users can enable backward-edge CFI in the Graal compiler by setting the -XX:UseBranchProtectionHotSpot option.Whether the user provides standard or PAC-RET protection, the Graal compiler will automatically enable backward-edge CFI when running on the AArch64 architecture.Before a function returns, the Graal compiler issues an authentication instruction that checks the integrity of the signed return address.If this integrity check fails, the authentication instruction stamps the higher bits of the corrupted address reserved for the pointer authentication code (PAC) to invalidate the pointer.When the function returns to the corrupted pointer, then the OS will raise a SIGSEGV signal, since the corrupted pointer now refers to an invalid (for example, unmapped) address.Even if an adversary has full control over the stored return address, the authentication instruction takes away control by resetting whatever the adversary provides to a random point high up in the process address space.Learn more about UseBranchProtection here.  The following JDK 21 features are not available:          JEP 439 Generational ZGC      Native ImageNew Features  Users can now use G1 Garbage Collector on the Linux AArch64 architecture to build efficient native executables with large heaps and minimal pause times (not available in GraalVM Community Edition).Previously, it was only available for Linux AMD64.To enable it, pass the option --gc=G1 to the native-image builder.Learn more about Memory Management in Native Image.  Introduced a new class initialization approach that will become the default in the future: all classes are now allowed to be used and initialized at build time, regardless of the class initialization configuration. For classes that are configured as --initialize-at-run-time this means that they will appear as uninitialized again at run time. To enable the new approach, pass the --strict-image-heap flag to Native Image. For more information and implementation details, take a look at the proposal #4684. Note that there is a known issue when a build that does not satisfy the new policy would fail with the following error: Boolean option value can be only + or -. This will be resolved in a patch release on October 24, 2023 and we will share more details on the new policy and best practices in the upcoming blog post.  Improved the reporting of missing metadata by throwing MissingReflectionRegistrationError when attempting to create a Proxy class without having it registered at build time, instead of VMError.  Added optimization level 3 to the native-image builder for the best peak performance (not available in GraalVM Community Edition).This new level includes optimizations that previously were part of optimization level 2 and that work best together with Profile-Guided Optimizations.As a result, the compilation time when building with the default -O2 is significantly reduced.Also, the --pgo option automatically enables -O3.  Added experimental support for foreign down calls (OpenJDK project Panama) in Native Image. Please test it and provide feedback. Support for upcalls is planned for the future.      Added the option --parallelism to control how many threads are used by the Native Image build process. The minimal number is 2. This option is useful for build environments with constrained resources.Also, starting from this release, the build output will print out the memory and thread limits of the build process, for example:      Build resources:  - 13.24GB of memory (42.7% of 31.00GB system memory, determined at start)  - 16 thread(s) (100.0% of 16 available processor(s), determined at start)    Added the option --color[=WHEN] to color the build output. Replace WHEN with always, never, or auto.This API option supersedes the experimental option -H:+BuildOutputColorful.  Introduced a new option -H:±UnlockExperimentalVMOptions to explicitly unlock access to experimental options, the majority of hosted options (starting with -H:), in Native Image.If access is not explicitly requested, an attempt to use any experimental option will fail the build with an actionable error message in this release.Also, to help users understand which dependencies requested these options, active experimental options will be listed as part of the build output alongside their origin.In the next release, this warning will be turned into a build failure.Meanwhile, the community is encouraged to open issues if certain experimental options should be promoted to public API and marked as stable.For more information, see GitHub issue #7105.  The following JDK 21 features are not available:          JEP 439 Generational ZGC      JEP 442 Foreign Function &amp;amp; Memory API (Third Preview)      JEP 448 Vector API (Sixth Incubator)      Debugging and Monitoring Improvements  Improved the monitoring experience: added support for the Java Flight Recording ThreadCPULoad event. (Together with BellSoft.)  Added support for -XX:+HeapDumpOnOutOfMemoryError. (Together with Red Hat.)See a complete list of updates in the changelog.Refactoring GraalVM SDKThe GraalVM SDK is split into four fine-grained modules.The use of the graalvm-sdk module is now deprecated.Note that all GraalVM APIs remain compatible in this release.The following new modules are available:  org.graalvm.nativeimage: The public API of Native Image for advanced use cases.  org.graalvm.polyglot: A library that allows to embed polyglot language implementations in Java.  org.graalvm.word: A low-level library for machine-word-sized values in Java.  org.graalvm.collections: A collections library for GraalVM components.Update your Maven and module dependencies accordingly.If you previously used the GraalVM SDK for Native Image via:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.sdk&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;graal-sdk&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;Now you use:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.sdk&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;nativeimage&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;Polyglot embedders can now use:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;For more details, see Polyglot Embedding updates.Find a complete list of updates in the GraalVM SDK changelog.Polyglot Embedding  Turned all GraalVM languages artifacts into standard Maven dependencies for polyglot embedders (see #6852).Previously, to use a GraalVM language in embeddings, you had to install it using the GraalVM Updater tool (e.g., gu install python).To enable a language now, language artifacts now need to be on the Java module or class path.  The use of the graalvm-sdk module is now deprecated; use the org.graalvm.polyglot:polyglot artifact instead.The org.graalvm.polyglot module is no longer contained by default in the GraalVM JDK.To enable a language embedding in Java, specify the language as a dependency.If you need the Truffle tools for your polyglot application, enable them through a dependency too.Below is an example of the Maven configuration:      &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;  &amp;lt;/dependency&amp;gt;  &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;!-- Select the language --&amp;gt;      &amp;lt;artifactId&amp;gt;js|python|ruby|wasm|llvm|java&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;      &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;  &amp;lt;/dependency&amp;gt;  &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;tools&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;      &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;  &amp;lt;/dependency&amp;gt;    These dependencies use the language and tools built on top of Oracle GraalVM.  To use the GraalVM Community Edition version, add the suffix -community to artifactId, for example, js-community. Please refer to the updated Embedding Languages documentation for further details.        Removed the option --language:&amp;lt;language&amp;gt; (to enable a specific language runtime at build time) and some macro options, namely:      --macro:polyglot-launcher  --macro:polyglot-library  --macro:truffle  --macro:truffle-language-library    They are no longer needed as putting them on the class/module-path does everything necessary.  More updates can be found in the changelog.JavaScript and Node.js  Released the JavaScript (GraalJS) and Node.js runtimes as standalone distributions.Two standalone language runtime options are available for both Oracle GraalVM and GraalVM Community Edition: a Native Image compiled native launcher or a JVM-based runtime (included).To distinguish between them, the GraalVM Community Edition version has the suffix -community in the name: graaljs-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz., graalnodejs-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz.,A standalone that comes with a JVM has a -jvm suffix in a name.Standalone distributions are available on GitHub.  The ScriptEngine implementation for running JavaScript is no longer shipped with GraalVM. Migrate your setup to explicitly depend on the ScriptEngine module and add it to the module path.See ScriptEngine documentation for details.  To enable the JavaScript runtime, you no longer install it with gu install js (since GraalVM Updater is removed), but add it as a Maven dependency (see below), or explicitly put the JAR on the module path.The Maven dependency for embedding JavaScript into Java were also updated.Below is the Maven configuration for a JavaScript embedding:      &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;  &amp;lt;/dependency&amp;gt;  &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;js&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;      &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;  &amp;lt;/dependency&amp;gt;    It enables the Oracle GraalVM JavaScript runtime.  To use a community-licensed version instead, add the -community suffix to each artifact (e.g., js-community). See the dependency setup for language embeddings.    Enabled ECMAScript 2023 features by default.  Implemented new proposals:          Async Context, available behind the experimental option --js.async-context.      String.dedent, available in ECMAScript staging mode behind the --js.ecmascript-version=staging option.        Updated Node.js to version 18.17.1.Find more updates in the project changelog.Java on Truffle  Java on Truffle (Espresso) is no longed shipped with GraalVM, but as a separate standalone distribution and a Maven artifact.Two standalone options are available: Oracle GraalVM and GraalVM Community Edition with a native launcher included.To distinguish between them, the GraalVM Community Edition version has the suffix -community in the name:espresso-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz.See the Java on Truffle Getting Started.Standalone distributions are available on GitHub.  To enable Java on Truffle, you no longer install it with gu install espresso (since GraalVM Updater is removed), but add it as a Maven dependency (see below), or explicitly put the JAR on the module path.      &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;  &amp;lt;/dependency&amp;gt;  &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;java&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;      &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;      &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;  &amp;lt;/dependency&amp;gt;    It enables the Oracle GraalVM Java on Truffle runtime.    Added the option --enable-preview.Find more updates in the project changelog.Python      Released the Python runtime (GraalPy) as a standalone distribution and a Maven artifact (see below).Two standalone language runtime options are available for both Oracle GraalVM and GraalVM Community Edition: a Native Image compiled native launcher or a JVM-based runtime (included).To distinguish between them, the GraalVM Community Edition version has the suffix -community in the name:graalpy-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz.A standalone that comes with a JVM has the -jvm suffix in a name.See the GraalPy Getting Started.    You can install a GraalPy Community standalone also with pyenv:      # To install GraalPy Community Edition  pyenv install graalpy-community-23.1.0    Standalone distributions are available on GitHub.    To enable GraalVM Python for embedding into Java, add it as a Maven dependency or explicitly put the JAR on the module path. Below is the Maven configuration for a Python embedding:      &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;polyglot&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;  &amp;lt;/dependency&amp;gt;  &amp;lt;dependency&amp;gt;      &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;python&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;23.1.0&amp;lt;/version&amp;gt;      &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;  &amp;lt;/dependency&amp;gt;    GraalPy is now available for Windows users. GraalPy can be installed on Windows with  venv or pip tools, and supports compilation and execution of C extensions using the native MSVC toolchain.  Improved the GraalPy standalone tool: you can now build single-file executable Python binaries for Linux, Windows, and macOS. The tool can also generate a skeleton Maven project that sets up a polyglot embedding of Python packages into Java.  Added support for the sqlite3 module. This allows many packages like Coverage or Flask-SQLAlchemy to work on top of an embedded database.Find more updates in the project changelog.Ruby  Updated to Ruby 3.2.2.  TruffleRuby standalone for Linux, built on Oracle GraalVM Native Image, now supports the G1 garbage collector which provides significantly better run-time performance.  The TruffleRuby ScriptEngine implementation is removed in favor of the generic ScriptEngine in GraalVM.See a complete list of updates in the project changelog.WebAssembly  Released the GraalVM WebAssembly runtime as a standalone distribution.Two standalone language runtime options are available for both Oracle GraalVM and GraalVM Community Edition: a Native Image compiled native launcher or a JVM-based runtime (included).To distinguish between them, the GraalVM Community Edition version has the suffix -community in the name:wasm-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz.A standalone that comes with a JVM has the -jvm suffix in a name.See the WebAssembly Getting Started.Standalone distributions are available on GitHub.  Implemented the extended const expressions proposal. The feature can be enabled with the option --wasm.ExtendedConstExpressions=true.  Added the option to enable multiple memories within a Wasm module: --wasm.MultiMemory=true.LLVM  The GraalVM LLVM runtime is no longed shipped with GraalVM, but as a separate standalone distribution.It contains the LLVM toolchain by default.Two standalone language runtime options are available for both Oracle GraalVM and GraalVM Community Edition: a Native Image compiled native launcher or a JVM-based runtime (included).To distinguish between them, the GraalVM Community Edition version has the suffix -community in the name:llvm-community-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.tar.gz.A standalone that comes with a JVM has the -jvm suffix in a name.See the LLVM Getting Started.Standalone distributions are available on GitHub.  Updated LLVM toolchain to version 16.0.1.  Added the flang toolchain wrapper to enable Fortran compilation with embedded bitcode.Truffle Language and Tool Implementations  Truffle language and tools implementations are isolated from the embedder using the Java module-based isolation.This means that they were migrated to Java modules to prevent accidental use of internal APIs.See the details of Truffle languages and instruments required modularization in this document.  Implemented the Internal Resource API for Truffle languages and instruments to be able to lazily unpack and consume resources from the application module path, necessary for execution.This API replaces the concept of “language homes”.For a language or instrument that requires additional files to execute, it needs to follow these steps:          Bundle the necessary files into a standalone distribution (JAR).      Implement the InternalResource interface for handling the resource file unpacking.      Call the Env#getInternalResource method when a language or instrument needs the bundled resource files. This method ensures that the requested InternalResource is unpacked and provides a directory containing the unpacked files. Since unpacking internal resources can be an expensive operation, the implementation ensures that internal resources are cached.        Truffle languages or instruments are now loaded from the application module path, unlike before when they were provided using -Dtruffle.class.path.append on a GraalVM JDK.The Truffle class path is deprecated and should no longer be used.Languages now need to be capable of running as named modules, so the language needs to be migrated.Languages can still be loaded from the class path, but Truffle internally loads them in its own classloader and module layer, so they are required to become modules.  Improved Ideal Graph Visualizer dumping experience:          IR dumping: folders for Truffle now include the compilation tier to differentiate compilations better. Inlined IR graphs are now additionally dumped in separate folders if dump level is &amp;gt;= 2.      AST dumping: the Truffle AST is now dumped as part of the IR dump folder. The dumped AST tree now shows all inlined ASTs in a single tree. Individual functions can be grouped using the “Cluster nodes” function in IGV (top status bar). Root nodes now display their name. Every AST node now has a property graalIRNode that allows to find the corresponding Graal IR constant if there is one.      Find a complete list of updates in the Truffle changelog.",
          "url": " /release-notes/JDK_21/"
          },
          
          "release-notes-jdk-22":  {
          "title": "GraalVM for JDK 22",
          "content": "GraalVM for JDK 22.0.2(2024-07-16)This is the July 2024 Critical Patch Update (CPU) for GraalVM Community Edition for JDK 22.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 22.  Updated the OpenJDK release on which GraalVM Community Edition is built to 22.0.2+9. See OpenJDK 22 Updates.  Version compatibility:          Truffle languages and other components version 24.0.2 are designed for use with GraalVM for JDK 22.0.2.        Graal compiler:          Added epsilon to more floating-point probability comparisons.      Fixed SIMD reinterpret stamp folding.      Improved Strip mining optimization to not strip mine loops with CaptureStateBegin successors.      Improved Counted strip mining optimization to use correct inner-to-outer state.      Unsigned loops that need an overflow to terminate must not be counted.      Properly implemented isConstantStride for masked negate strides.        Native Image:          Fixed values reported in the GCHeapSummary JFR event.      Disabled failing tests for the FFM API (project Panama).      Improved reference processing to be more robust, especially against OOME during tear-down.      Removed OpaqueValueNodes at the end of low tier.      Implemented skipping a G1 argument parsing if -H:-ParseRuntimeOptions is specified.      Added partial support for physical memory usage and JFR tests for periodic native events.      Recomputed Buffer.address field for array-based buffers in the image heap.      Added tests to verify the conversion function.      Added the runtime module layer tests.      Removed getpwuid in favor of getpwuid_r.      Fixed data limitation for breakdown charts in build reports.      Added a few OutOfMemoryError-related fixes.      Fixed a consistency issue in HeapImplMemoryMXBean.getHeapMemoryUsage().      Made stack pointer aligned while in deoptStub.      Changed CCharPointer from “char” to “signed char”.        Truffle framework:          Improved the error message when a polyglot implementation is missing.      Disabled LoggingTest#testDisableLoggersSingleContext.      Improved the ContextPolicyTest#testOptionDescriptorContextReuse method to be more robust.      Fixed the issue when com.oracle.truffle.polyglot.InternalResourceRoots$Root.path() could not be invoked because this.owningRoot was null.      Fixed the issue when SpeculationReason could not be re-used after the speculate call.        Java on Truffle (Espresso):          Fixed the JDWP method invocation.      Fixed type converter combination for foreign exceptions and custom type converters.      Fixed stepping into intrinsified Java methods in JDWP.      Added profiling to Espresso method resolution from interop.      Added support for converting foreign object to a non-mapped interface.        JavaScript:          Upgraded the underlying Node.js to version 18.20.2.      Changed the esm-eval-returns-exports option be stable and usable in the sandbox mode.        Tooling          Updated CPUSampler to not log interrupts if the sampler is already closed, and added various other CPUSampler fixes.      GraalVM for JDK 22.0.1(2024-04-16)This is the April 2024 Critical Patch Update (CPU) for GraalVM Community Edition for JDK 22.It is based on the corresponding OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 22.  Updated the OpenJDK release on which GraalVM Community Edition is built to 22.0.1+8. See OpenJDK 22 Updates.  Version compatibility:          Truffle languages and other components version 24.0.1 are designed for use with GraalVM for JDK 22.0.1.        Graal compiler:          Removed SIMD vectorization.      Ensure guards are attached to MoveGuardsUpwards to respect a DOM tree.      Run OptimisticGuards as cleanup before OptimisticAliasingAnalysis.      Fixed a simplification of always-deoptimize FixedGuard.      Added a guard against deletion in PiNode.canonical recursion.        Native Image:          Register the virtual thread group unconditionally.      Updated -g to include all information for profiling. Fix the problem with objcopy strip command.      Fixed a deadlock in IsolateAwareTruffleCompiler.tearDownIsolateOnShutdown.      Report an error if building a static executable without musl libc.      Consider stack slot sizes when limiting number of parameters in SBOutlining.      Documented -O, -march, and build artifacts.        Truffle framework:          Added InsertGuardFencesPhase into runtime compilation phases.        Java on Truffle (Espresso):          Fixed NullPointerException in JDWP when debugger asks for local variable table.      Fixed single stepping in Espresso JDWP when stepping within code that is not yet loaded.        JavaScript:          Upgraded the underlying Node.js to version 18.19.1.      Added a check to the instanceof operator whether the left side is a foreign object.      GraalVM for JDK 22(2024-03-19)  Platform and Distributions  Availability of JDK 22 Features  Java and Compiler  Native Image  Polyglot Runtime  Polyglot Embedding  JavaScript and Node.js  Java on Truffle  Python  Ruby  LLVM  Truffle Language and Tool ImplementationsPlatform and Distributions  Released GraalVM Community Edition for JDK 22 based on OpenJDK 22. See OpenJDK 22 Updates.  Released Oracle GraalVM for JDK 22 based on Oracle JDK 22. See Java SE 22 Release Notes.  Version compatibility:          GraalVM for JDK 22 is compatible with Truffle languages and other components version 24.0.0.      Availability of JDK 22 Features            JEP      Title      Graal JIT      Native Image                  423      Region Pinning for G1      ✅      ✅ Garbage collection already enabled during JNI critical regions              447      Statements before super(…) (Preview)      ✅      ✅              454      Foreign Function &amp;amp; Memory API      ✅      🧩 #8113              456      Unnamed Variables &amp;amp; Patterns      ✅      ✅              457      Class-File API (Preview)      ✅      ✅              458      Launch Multi-File Source-Code Programs      ✅      ℹ️              459      String Templates (Second Preview)      ✅      ✅              460      Vector API (Seventh Incubator)      ✅ full optimization in progress      🏗️              461      Stream Gatherers (Preview)      ✅      ✅              462      Structured Concurrency (Second Preview)      ✅      ✅              463      Implicitly Declared Classes and Instance Main Methods (Second Preview)      ✅      ✅              464      Scoped Values (Second Preview)      ✅      ✅              439      Generational ZGC (from JDK 21)      🏗️ #8117      ℹ️      ✅ fully available🧩 partially available🏗️ not available yet, in progressℹ️ not applicableJava and Compiler  The Graal module has been renamed from jdk.internal.vm.compiler to jdk.graal.compiler. Likewise, the compiler packages moved into the jdk.graal.compiler namespace. This renaming was done in preparation for Project Galahad, and to establish the namespace jdk.graal for Graal subprojects. See #7621.  The Graal options now use the jdk.graal. prefix, for example, -Djdk.graal.PrintCompilation=true. The legacy graal. prefix is deprecated but still supported (for example, -Dgraal.PrintCompilation=true).  Added -Djdk.graal.PrintIntrinsics to log the intrinsics used by Graal in the current runtime.Find more updates in the changelog.Native ImageNew Features  Added experimental support for the Foreign Function &amp;amp; Memory API (part of “Project Panama”, JEP 454) on the x64 architecture. The API must be explicitly enabled with -H:+ForeignAPISupport (requires also -H:+UnlockExperimentalVMOptions). Currently, it includes support for foreign memory functionality and foreign functions downcalls. Modules that perform “restricted” native operations must be specified using the --enable-native-access option. Check Foreign Function and Memory API in Native Image for a more detailed overview of the FFM API support.  The --strict-image-heap option is now enabled by default, so it can be removed from the argument list. It allows all classes to be used at build time but also requires types of all objects in the heap to be explicitly marked for build-time initialization.  Added support for the NATIVE_IMAGE_OPTIONS environment variable, which allows users and tools to pass additional arguments via the environment. Similar to JAVA_TOOL_OPTIONS, the value of the environment variable is prepended to the options supplied to native-image. See GitHub issue #4650.Improvements  Improved the Native Image agent tracking calls mechanism: the agent now tracks calls to ClassLoader.findSystemClass, ObjectInputStream.resolveClass, and Bundles.of, and registers resource bundles as bundle name-locale pairs.  Updated the Lambda class name format in Native Image to CapturingClass$$Lambda/0xstableHash to be consistent with the JDK name format.  Improved intrinsification of method handles. This especially improves the performance of equals and hashCode methods for Java records, which use now intrinsified method handles.  Methods, fields, and constructors of the Java Object class, primitive classes, and array classes are now registered by default for reflection.  Improved reporting missing metadata in Native Image by throwing special exceptions (experimental). The users can catch metadata exceptions early and debug related issues using the -H:ThrowMissingRegistrationErrors=&amp;lt;package-prefix&amp;gt; option (or -H:ThrowMissingRegistrationErrors for all packages).  Improved Native Image to correctly rethrow build-time linkage errors at run time for registered reflection queries. This prevents the same queries return empty results without throwing an exception. See GitHub issue #6691.  System#setSecurityManager now throws a java.lang.UnsupportedOperationException by default, instead of a VM error in cases where it is expected to throw an exception. This prevents from halting program execution. If the property java.security.manager is set to anything, but disallow at program startup, this function will throw java.lang.SecurityException according to the Java specification.Debugging and Monitoring Improvements  Added support for the following JFR events: AllocationRequiringGC, SystemGC, and ThreadAllocationStatistics. See GitHub pull requests #7263 and #7294. (Together with Red Hat.)  Provided the API option for creating thread dumps --enable-monitoring=threaddump. The option -H:±DumpThreadStacksOnSignal is now deprecated and marked for removal.Deprecated and Removed Functionality  The options ParseOnce, ParseOnceJIT, and InlineBeforeAnalysis are deprecated and no longer have any effect.  The legacy build option was removed from native-image-agent.Polyglot Runtime  Removed support for legacy &amp;lt;language-id&amp;gt;.home system property. Only org.graalvm.language.&amp;lt;language-id&amp;gt;.home will be used.Polyglot Embedding  Added the ability to use Value#as(Collection.class) to map guest language arrays, (Value#hasArrayElements()), to the Java Collection interface in order to access the array elements without copying the guest language array. Set GitHub issue #260.  Implemented mapping of interop buffers to byte[] in a host application, which included:          Added Value#readBuffer(long, byte[], int, int) to enable bulk reads of buffers into byte arrays.      Custom implementations of ByteSequence, same as the values returned by ByteSequence.create(byte[]), are now interpreted by guest languages as buffers.      Added the ability to use Value#as(ByteSequence.class) to map guest language byte buffers (Value#hasBufferElements()) to the read-only ByteSequence interface in order to access the bytes without copying the guest language buffer.        Deprecated the FileSystems#allowLanguageHomeAccess() method and introduced FileSystem#allowInternalResourceAccess() as a replacement. To ensure compatibility, both methods now provide support for language homes and internal resources.Find a complete list of updates in the changelog.JavaScript and Node.js  Updated Node.js to version 18.18.2.  Implemented the WebAssembly threads proposal.Implemented the Promise.withResolvers proposal. It is available in the ECMAScript staging mode (enabled with --js.ecmascript-version=staging).  Moved the implementation of Async Iterator Helpers proposal (that was split out from Iterator Helpers proposal) behind the experimental option --js.async-iterator-helpers.  Implemented the Well-Formed Unicode Strings proposal. It is available in the ECMAScript staging mode (enabled with --js.ecmascript-version=staging).  Implemented the JSON.parse source text access proposal. It is available in the ECMAScript staging mode (enabled with --js.ecmascript-version=staging).  The WebAssembly support in Node.js was enabled by default. It can be disabled using the experimental option --js.webassembly=false.  Replaced the --js.import-assertions option with --js.import-attributes because the corresponding Import Attributes proposal migrated from the usage of assertions to the usage of attributes.Java on Truffle (Espresso)  Added support for transparently converting common JDK exception types that flow from a host to an embedded Espresso context.  Added support for transparently converting host primitive arrays to Espresso primitive arrays.  Added support for foreign BigInteger when calling Espresso via the Interop protocol. It included also the adoption of fitsInBigInteger and asBigInteger Truffle interop messages.  Added support for removeArrayElement interop messages for Espresso List objects.  Added bringing overload-selection to parity with what is supported for calling methods when using a constructor via Interop.  Java on Truffle (Espresso) can now run on a JDK 22 host. Supported guest JDK versions are 8, 11, 17, and 21.PythonNew Features  Switched to using the system toolchain instead of the GraalVM LLVM runtime (Sulong). This reduces the footprint in the default configuration where C extensions are run natively.  Added a new option python.InitialLocale to change the default locale. If not set, then Java’s Locale#getDefault is used.  The multiprocessing module now creates new processes by default, using the spawn method. The formerly default method that uses threads and multiple Truffle contexts can be selected using multiprocessing.set_start_method(&#39;graalpy&#39;).  We now provide a collection of GitHub Actions scripts to build popular native extensions on GraalPy. This enables the Python users to build native applications, in a reproducible way, with the correct dependencies on GitHub, and download artifacts from there. See Scripts to build wheels for GraalPy to get started.  Added the GraalPy integration with jBang. You can try it out with the following command:      jbang hello@oracle/graalpython/release/graal-vm/24.0 &quot;print(&#39;Hello GraalPy!&#39;)&quot;  Compatibility  Updated to Python 3.10.13. It inlines the security and bug fixes from 3.10.8 to 3.10.13.  Improved Windows compatibility: added support for installing packages with native extensions on Windows. Simple packages like ujson or kiwisolver will now work when installed from venv inside a Visual Studio command prompt. This means that users can build native applications on Windows.  Included the GraalPy C API revision in the ABI tag for the Python wheels packaging format. This avoids accidentally using incompatible binaries when using snapshots.  Expanded support for the following modules: llvmlite, pydantic-core, catboost, ray, tensorflow, tensorflow-io, readme-renderer, safetensors, keras, pybind11, protbuf, grpcio, PyO3, cryptography, bcrypt, cramjam, libcst, orjson, rpds_py.Interoperability  Improved the polyglot module by adding the API to redefine Truffle interop messages for external user-defined types. For more details see the Truffle Interoperability Extension API.  Interop null values are now treated as identical, not only equal to Python’s None. This means that when java.type(&quot;java.lang.Object[]&quot;)(1)[0] is None, it will return True.  Enabled the allowHostSocketAccess configuration in embeddings. This means sockets can now be disabled independently of other IO operations.  Foreign BigIntegers are now supported and work with all Numeric operators.Find a complete list of updates in the project changelog.RubyNew Features  C/C++ extensions are now compiled using the system toolchain and executed natively instead of using the GraalVM LLVM runtime (Sulong). This leads to faster startup, no warmup, better compatibility, smaller distribution, and faster installation for C/C++ extensions (#3118).  Added full support for the Ruby 3.2 and Ruby 3.3 syntax by adopting the Prism parser (#3117, #3039).  Added support for pattern matching (#3332, #2683).  Implemented most of Ruby 3.2 features (#3039).Performance  Optimized calls with ruby2_keywords forwarding by deciding it per call site instead of per callee.There were multiple bug fixes and compatibility improvements in this release, which you can find in the TruffleRuby release notes.LLVM  Made ld64.lld the default linker on macOS instead of a system linker. This fixes compatibility problems with the LLVM toolchain wrappers and Xcode 15 on macOS platforms.Truffle Language and Tool Implementations  The Truffle languages and tools implementations are now loaded exclusively using the context class loader if it is set and Truffle is found there. If the context class loader is not set or Truffle is not found, then the system class loader is used instead. Context class loaders that do not delegate to the system class loader are commonly used to implement hot-reload functionality.  Added the --engine.AssertProbes option, which asserts that enter and return are always called in pairs on ProbeNode, and verifies the correct behavior of wrapper nodes. Java asserts need to be turned on for this option to have an effect.  Added a new performance warning to Truffle DSL when mixing shared and non-shared inline nodes/profiles triggers the slow path in inlining support code.  Added the system property -Dtruffle.UseFallbackRuntime=true. This property is preferred over the usage of -Dtruffle.TruffleRuntime=com.oracle.truffle.api.impl.DefaultTruffleRuntime.  Added InteropLibrary#readBuffer(long, byte[], int, int) to enable bulk reads of buffers into byte arrays.  Implemented the onYield() and onResume() instrumentation events in the debugger stepping logic.Find a complete list of updates in the Truffle changelog.",
          "url": " /release-notes/JDK_22/"
          },
          
          "release-notes-jdk-23":  {
          "title": "GraalVM for JDK 23",
          "content": "GraalVM for JDK 23.0.2(2025-01-21)This is the January 2025 Oracle Critical Patch Update (CPU) for GraalVM Community Edition for JDK 23.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 23.  Updated GraalVM Community Edition for JDK 23 to 23.0.2+7. See the OpenJDK 23 Updates.  Version compatibility:          Truffle languages and other components version 24.1.2 are designed for use with GraalVM for JDK 23.0.2.      This release also includes the following fixes:  Graal compiler          Fix Vector API CompareNode propagating the wrong unorderIsTrue value.      Add an explicit null check on StringBuilder(String) constructor’s argument.      Infinite recursion in AArch64MacroAssembler.add/sub with immediate = Integer.MIN_VALUE.      Add safepoint policy changes.      Fix source launcher regression.      Ensure only safepoint usages are left.      Allow no exit safepoint if end safepoints are disabled.        Native Image          Preserve local symbols if post-link stripping follows.      Adopt JDK-8314794: Improve UTF8 String support.      Fix missing state for StoreIndexedNode.      Make missing registration warn mode stack trace length customizable.      Improve Visual Studio detection in Native Image and related error messages.      Make PosixPlatformTimeUtils.javaTimeSystemUTC uninterruptible.      Fix a problem with invalid PGO profiles during Native Image build.        Truffle framework          Clear polyglot source cache more aggressively.      Handle static frame slots in BytecodeOSRMetadata#restoreParentFrame.      Fix documentation for the sandbox.MaxHeapMemory resource limit.      Fix int overflow in ObjectSizeCalculator#increaseByArraySize.        GraalJS          Include GraalWasm in the JavaScript standalone.      Fix of top-level for-await-of in a module.      Handle mixing overloaded operators with non-numeric primitives.      Fix missing return value conversion in Polyglot.eval[File].        GraalWasm          Handle static frame slots in BytecodeOSRMetadata#restoreParentFrame.        GraalPy          Improve manifest files.      Shared engine cannot be used with GraalPyResources.      Fix GraalPy Gradle plugin that fails to build if a project does not contain any resource files.        Espresso          Fix duplicate class definition attempts for generated type-mapped proxies.      Remove the workaround for array-based static object crash.        TruffleRuby          Change order of module creation steps and assign a module’s full name before calling the Module#const_added callback.      GraalVM for JDK 23.0.1(2024-10-15)This is the October 2024 Oracle Critical Patch Update (CPU) for GraalVM Community Edition for JDK 23.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 23.  Updated GraalVM Community Edition for JDK 23 to 23.0.1+11. See the OpenJDK 23 Updates.  Version compatibility:          Truffle languages and other components version 24.1.1 are designed for use with GraalVM for JDK 23.0.1.        Graal compiler:          Avoid getHostBackend when instantiating UnimplementedGraalIntrinsics.        Native Image:          Prevent emission of typeReachable in the reachability-metadata.json.      Reset the Provider.Service.constructorCache field.      Fixed the --bundle-create option and bundle-launcher feature on Windows.      Move setConservativeLabelRange after resetting crb on the AArch64 architecture.      Do not include TruffleJfrFeature if PGO configuration is specified.      Made caches in ValueConversions initialize eagerly.      Added version information to the manifest only when it is available from the suite.        Truffle framework:          Fixed the Addr part alignment in Truffle compilation logs.        JavaScript:          Made the option js.webassembly stable.        GraalWasm:          Removed constant memory buffer assumption and simplified ByteArrayWasmMemory.        GraalPy:          Created GraalPy Gradle plugin with similar features as the GraalPy Maven plugin.      Updated the bouncycastle dependency.      Deprecated exposed Truffle filesystem spi in VirtualFileSystem.      GraalVM for JDK 23(2024-09-17)  Platform and Distributions  Availability of JDK 23 Features  Graal Compiler  Native Image  Polyglot Runtime  Polyglot Embedding  Espresso  GraalJS  GraalPy  GraalWasm  Truffle Language and Tool ImplementationsPlatform and Distributions  Released Oracle GraalVM for JDK 23 based on Oracle JDK 23. See Java SE 23 Release Notes.  Released GraalVM Community Edition for JDK 23 based on OpenJDK 23. See OpenJDK 23 Updates.  Version compatibility:          GraalVM for JDK 23 is compatible with Truffle languages and other components version 24.1.0.      Availability of JDK 23 Features  455: Primitive Types in Patterns, instanceof, and switch (Preview)  466: Class-File API (Second Preview)  467:Markdown Documentation Comments  471:Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal  473:Stream Gatherers (Second Preview)  476: Module Import Declarations (Preview)  477:Implicitly Declared Classes and Instance Main Methods (Third Preview)  480:Structured Concurrency (Third Preview)  481:Scoped Values (Third Preview)  482:Flexible Constructor Bodies (Second Preview)Enable preview features by passing --enable-preview to use any of them.Graal Compiler  Introduced a new compiler optimization to reduce code size on the x64 architecture, by emitting smaller jump instructions if the displacement fits in one byte. This optimization is enabled for Native Image by default and disabled elsewhere. Use -Djdk.graal.OptimizeLongJumps=true to enable.  Starting from JDK 24, the Graal options specified via a -Dgraal. prefix will be deprecated and result in a deprecation warning.Native ImageNew Features  Added a new optimization level, -Os, to configure the optimizer to get the smallest code size and, thus, a reduced file size. It enables -O2 optimizations except those that can increase code or executable size significantly. Learn more in Native Image Optimization Levels.  Replaced typeReachable conditions with typeReached. typeReached conditions make the metadata entry available at run time when the type is considered reached. A type is reached at run time, right before the class-initialization routine starts for that type (class or interface), or any of the type’s subtypes are reached.  Streamlined Native Image reachability metadata configuration into a single file reachability-metadata.json. The formerly-used individual metadata files (reflection-config.json, resource-config.json, and so on) are now deprecated, but will still be accepted. See the documentation for more details.  Added support for glob patterns to specify file path to a resource in addition to Java regular expressions. The Tracing Agent now prints entries in the glob format. Learn more in Accessing Resources in Native Image.  Enabled the registration of java.lang.reflect.Proxy classes for reflection by adding proxy-type entries. This allows members of Proxy classes to be accessed reflectively at run time. The metadata file proxy-config.json is now deprecated, but will still be honored for backward compatibility. The Tracing Agent is modified to use the new approach. The new format to specify proxy classes in reachability-metadata.json is:      {    &quot;reflection&quot;: [      {        &quot;type&quot;: { &quot;proxy&quot;: [ &quot;IA&quot;, &quot;IB&quot; ] }      }    ]  }    Added a stable name for the Proxy types in Native Image. The name $Proxy[id] is replaced by $Proxy.s[hashCode] where hashCode is computed using the names of the Proxy interfaces, the name of the class loader, and the name of the module if it is not a dynamic module.  Introduced a type field in reflection and JNI configuration files to support more than simple name types.  Improved the Foreign Function &amp;amp; Memory API (JEP 454) by adding experimental support for upcalls from foreign functions (part of “Project Panama”). Currently, foreign calls are supported on the x64 architecture. Enable with -H:+ForeignAPISupport. See Foreign Function and Memory API in Native Image for more details.  Fields that are accessed via a VarHandle or MethodHandle are no longer marked as “unsafely accessed” when VarHandle/MethodHandle can be fully intrinsified. This improves the run-time performance.  Introduced a new --static-nolibc API option to build mostly static native executables. It replaces the experimental -H:±StaticExecutableWithDynamicLibC option.  Implemented the compact garbage collection mode for the Serial GC old generation. Enable it with the -H:+CompactingOldGen option. The primary intention is to reduce the memory usage compared to the copying GC. Find more details at github.com/oracle/graal/pull/8870. This is an experimental feature.  Added the option -H:+GenerateEmbeddedResourcesFile to print information about embedded resources into embedded-resources.json.  Added support to catch OutOfMemoryError exceptions at build time if there is no memory left.  Changed the digest (used, for example, for symbol names) from SHA-1 encoded as a hex string (40 bytes) to 128-bit Murmur3 as a Base-62 string (22 bytes).Deprecated Functionality  The old class initialization strategy, which was deprecated in GraalVM for JDK 22, is now removed. The option --StrictImageHeap no longer has any effect.  Reporting unsupported elements at run time is now enabled by default. The option --report-unsupported-elements-at-runtime is deprecated.Improvements  Added a check to ensure that an explicitly set name (specified via -o name) is not accidentally overwritten by the -jar jarfile option.  Added a check that will cause the build process to fail and report an appropriate error if the --static option is not followed by --libc=musl. Static linking is currently only supported with musl.  In the strict reflection configuration mode (when ThrowMissingRegistrationErrors is enabled), Unsafe.allocateInstance is allowed only for types registered explicitly in the configuration.  Native Image now throws missing registration errors for JNI queries when the query was not included in the reachability metadata.Debugging and Monitoring Improvements  Added a new API option --emit to generate build reports. It replaces the experimental host option -H:+BuildReport. Providing a path where to store a report is possible via --emit build-report=custom-build-report.html, instead of using the old option -H:BuildReportFile=custom-build-report.html. (Only available in Oracle GraalVM.)  Added initial support for the native memory tracking. Enable with --enable-monitoring=nmt. (Together with Red Hat.)  Improved the JFR monitoring experience by adding support for event throttling and the ObjectAllocationSample event. Also added the initial support for the OldObjectSample event. (Together with Red Hat.)  Now you can use vswhere to find Visual Studio Code installations more reliably and in non-standard installation locations.  The option -XX:MissingRegistrationReportingMode can now be used on the invocation instead of as a build option, to avoid rebuilding when debugging missing registration errors.Polyglot Runtime  Enabled random offsets of runtime compiled functions entry points for the UNTRUSTED polyglot sandbox policy.GraalVM additionally pads the starting offset of functions with a random number of trap instructions which helps prevent a potential JIT spray attack.  Added TruffleLanguage.Env.getScopePublic(LanguageInfo) and TruffleLanguage.Env.getScopeInternal(LanguageInfo) to enable languages direct access to other language scopes to implement new polyglot builtins.  Added PolyglotException.StackFrame.getBytecodeIndex() which enables to access the internal bytecode index that the language uses to identify an execution location.Polyglot Embedding  Added the system property polyglot.engine.userResourceCache which enables embedders to override the default location of the resources cache directory for a Java application running on HotSpot. By default, the resources cache directory is located in the org.graalvm.polyglot directory within the OS-specific cache directory in the user’s home directory. The main rationale behind this override is to accommodate applications running in containers where the user’s home directory may not be writable.  Added the option engine.InterpreterCallStackHeadRoom to protect against stack overflow in the middle of a guest method execution in the interpreter. For the UNTRUSTED polyglot sandbox policy, the value for the option is computed automatically based on the value of the mandatory option sandbox.MaxASTDepth, the option sandbox.MaxStackFrames is no longer mandatory. The new option is available only in the AOT mode.  Added experimental support for virtual threads on HotSpot. Not all languages are currently supported for use with virtual threads. Check the language changelog for further information. Truffle debugging, CPU time limits, and some memory limits are currently not supported on virtual threads. The number of threads is currently limited to 65535 threads entered per context.  The RuntimeOptions.listDescriptors and getDescriptor methods also return the Graal compiler options (if any) that could already be accessed through RuntimeOptions.get and set.  Java host interop no longer exposes bridge methods.Find a complete list of updates in the changelog.Espresso  Espresso can now use TRegex to execute java.util.regex patterns. TRegex offers better performance than the standard implementation. Use java.UseTRegex to enable this engine.  The interop ReadBuffer method can now be used from the guest Interop API and guest ByteBuffer objects implement this interop message.  Fixed several JDWP compatibility issues improving the user experience when debugging Espresso with a Java IDE.  Added the org.graalvm.continuations package, along with support for continuations. See the Espresso Continuations documentation for more details.  Added java.RuntimeResourceId to enable customizing the resource used to locate the Java standard library used by Espresso. The resource called espresso-runtime- will be used. By default, jdk21, and then openjdk21 are attempted.GraalJS  The JavaScript WebAssembly API is now a stable feature of GraalJS and supported as part of Oracle GraalVM.  ECMAScript 2024 Language Specification enabled by default.  Implemented the Make eval-introduced global vars redeclarable proposal.  Implemented the Float16Array proposal. It is available in the ECMAScript staging mode (--js.ecmascript-version=staging).  Implemented the Array.fromAsync proposal. It is available in the ECMAScript staging mode (--js.ecmascript-version=staging).  Implemented the Resizable and Growable ArrayBuffers proposal.  Made the option js.esm-eval-returns-exports stable and allowed in the TRUSTED sandbox policy.GraalPy  GraalPy is now considered stable. While many native libraries do work, support for native extensions remains experimental.  Updated to Python 3.11.7.  Added the intrinsified _pickle module implementation to GraalPy built on top of GraalVM Community Edition.  The Polyglot API eval method now throws more meaningful exceptions when evaluating code from other languages in Python. Exceptions from a language are raised directly as interop objects (typed as polyglot.ForeignException). The shortcut for executing Python code without specifying a language was removed. Use the regular eval method.GraalWasm  GraalWasm is now considered stable.  Implemented the SIMD proposal. This feature is enabled by default and can be disabled with the option --wasm.SIMD=false.  Added support for the clock_res_get, fd_advise, fd_datasync, fd_fdstat_set_rights, fd_filestat_set_size, fd_pread, fd_pwrite, fd_readdir, fd_renumber, fd_sync, and fd_tell functions.Truffle Language and Tool Implementations  Deprecated Node.getCost() and the associated NodeCost class without replacement. A Truffle DSL no longer generates implementations of this method automatically and will therefore always return NodeCost.MONOMORPHIC by default. This is intended to reduce the binary footprint.  Improved the debugging experience:          DebuggerSession.suspend(Thread thread) now preserves ongoing stepping strategies.      Added SuspendedEvent.isStep(), SuspendedEvent.isUnwind(), and SuspendedEvent.isBreakpointHit() to enable debugger backends or languages to query reasons for the suspension.        Added the MathUtils API providing additional mathematical functions useful for language implementations such as asinh, acosh, and atanh.  Added the UnadoptableNode interface. This interface should be preferred to overriding Node.isAdoptable() if the result is statically known.Find a complete list of updates in the Truffle changelog.",
          "url": " /release-notes/JDK_23/"
          },
          
          "release-notes-jdk-24":  {
          "title": "GraalVM for JDK 24",
          "content": "GraalVM for JDK 24.0.2(2025-07-15)This is the July 2025 Oracle Critical Patch Update (CPU) for GraalVM Community Edition for JDK 24.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 24.  Updated the OpenJDK release on which GraalVM Community Edition is built to 24.0.2+11. See the OpenJDK 24 Updates.  Version compatibility:          Truffle languages and other components version 24.2.2 are designed for use with GraalVM for JDK 24.0.2.        Graal compiler          Prevented vectorization of reads with usages both inside and outside the loop.      Added proper handling of nested frame states in loop vectorization.      Used DWORD comparisons for search values in AMD64ArrayIndexOfOp.      Invalidated profiling information in VectorGuardTest#emptyLoopWithDeoptExit.      Reverted load conversion in SimdStamp.readConstant.        Native Image          Fixed a bug in the JFR type repository.      Added handling of metadata/component in the Build Report’s SBOM components list.      Updated the SBOM to use identical values for the bom-ref and ref fields.      Corrected class names in heap dumps.      Applied various fixes for system properties and locales, including:                  Fix for SystemPropertiesSupport          Fix for locale initialization crashes          Allowing StaticProperty.&amp;lt;clinit&amp;gt; to execute before system properties are fully initialized                    Unified SBOMProducers and added a fallback mechanism for standalone mode.      Removed unnecessary parallel stream processing for classpath entries.      Validated reachable objects before propagating them.      Fixed a bug for class-level SBOMs on Windows.      Fixed JFR-related UnsatisfiedLinkErrors.      Fixed RecurringCallbackTests_testManyMonitorOps.        GraalJS          Improved JavaScript exception message.      Modified ExportValueNode.doTruffleObject() to exclude SafeIntegers.      Corrected Array.prototype.flat() to avoid producing a foreign array.        GraalWasm          Prevented WasmCallStubNode from being cast to WasmDirectCallNode.      Added missing Truffle Safepoint poll in the bytecode interpreter loop.        Espresso          Fixed the JDWP frames command when a thread has no frames.      Fixed a performance regression in Polyglot.castWithGenerics.      Added test coverage for Espresso interop reading of foreign elements.        GraalPy          Made storing NO_VALUE in an attribute remove the key-value pair.      Added support for ormsgpack and prepared upstreaming some changes.      Reverted breaking ABI changes in graalpy242 wheels.        Truffle framework          Reduced the number of threads for sandbox limit checking and ensured they are stopped when no active contexts remain.      Update JCodings to version 1.0.63.        TRegex          Fixed the GenerateDFAImmediately option to free the NFA matcher.      GraalVM for JDK 24.0.1(2025-04-15)This is the April 2025 Oracle Critical Patch Update (CPU) for GraalVM Community Edition for JDK 24.It is based on the OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU, platform updates, and some GraalVM bug fixes.It is a full distribution and supersedes the previous release of GraalVM Community Edition for JDK 24.  Updated the OpenJDK release on which GraalVM Community Edition is built to 24.0.1+9. See the OpenJDK 24 Updates.  Version compatibility:          Truffle languages and other components version 24.2.1 are designed for use with GraalVM for JDK 24.0.1.        Graal compiler          Removed unqualified exports from jdk.graal.compiler.      Moved resetting of rethrowExceptions to creating jump targets.      Configured the maximum Eden size for LibGraalCollectionPolicy.      AMD64ArrayIndexOfOp: Fixed a short jump across unknown alignment.      EnterpriseReadElimination: Fixed handling of ObjectClone.      Emit additional reinterpret when generating float CAS from node matching rules.        Native Image          Adopted JDK-8345266: imported the new MonitorEnterWaitOOME virtual thread test in JDK.      Implemented the use of the correct acquisition count in acquireOnOOME.      AMD64ArrayIndexOfOp: Fixed a short jump across unknown alignment.      Marked certain constant loads as not rematerializable to the stack.      EnterpriseReadElimination: Fixed handling of ObjectClone.      Strip fields from Maven-generated SBOMs so that only the fields defined by Native Image are kept.      Prevent absent hashcode computation split across safepoint checks.      Ensure tje bom-ref field is kept for all SBOM components.        GraalJS          Fixed compilation failure in ImportMetaNode.      Implemented clearing away Wasm memory when WasmInstance is out of scope.      Set the CONSTRAINED sandbox policy for the js.webassembly option.      Made the option js.text-encoding stable and allowed in SandboxPolicy.CONSTRAINED.      Fixed ClassCastException in super property access.        GraalWasm          Fixed a compilation bailout in WasmFunctionInstance InteropLibrary.      Avoid rereading code entries of already instantiated Wasm modules.      Set the CONSTRAINED sandbox policy for the js.webassembly option.        GraalPy          Added several fixes for PyMuPDF.        TruffleRuby          Updated to Ruby 3.3.7.        TRegex          Added multiple fixes for look-behind merging across main expression boundary.        Truffle framework          Fixed out-of-bounds read in AMD64CodepointIndexToByteIndexOp.      Fixed boolean boxing elimination in combination with short-circuits could lead to deopt loops.      Fixed TruffleSafepoint.poll(...) must not fail if performed on unrelated threads while thread local actions are performed on a different thread.      Fixed when a return type compatibility check can lead to void specializations being filtered.      GraalVM for JDK 24(2025-03-18)  Platform and Distributions  Availability of JDK 24 Features  Graal Compiler  Native Image  Polyglot Runtime  GraalJS  GraalPy  GraalWasm  Espresso  TruffleRuby  Truffle Language Implementation FrameworkPlatform and Distributions  Released Oracle GraalVM for JDK 24 based on Oracle JDK 24. See Java SE 24 Release Notes.  Released GraalVM Community Edition for JDK 24 based on OpenJDK 24. See OpenJDK 24 Updates.  Version compatibility:          GraalVM for JDK 24 is compatible with Graal Languages and other components version 24.2.0.      Features  450: Compact Object Headers (Experimental)  472: Prepare to Restrict the Use of JNI  475: Late Barrier Expansion for G1  478: Key Derivation Function API (Preview)  479: Remove the Windows 32-bit x86  484: Class-File API  485: Stream Gatherers  486: Permanently Disable the Security Manager  487: Scoped Values (Fourth Preview)  488: Primitive Types in Patterns, instanceof, and switch (Second Preview)  489:Vector API (Ninth Incubator)  490: ZGC: Remove the Non-Generational Mode  491: Synchronize Virtual Threads without Pinning  492: Flexible Constructor Bodies (Third Preview)  493: Linking Run-Time Images without JMODs  494: Module Import Declarations (Second Preview)  495:Simple Source Files and Instance Main Methods (Fourth Preview)  496: Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism  497: Quantum-Resistant Module-Lattice-Based Digital Signature Algorithm  498: Warn upon Use of Memory-Access Methods in sun.misc.Unsafe  499: Structured Concurrency (Fourth Preview)  501: Deprecate the 32-bit x86 Port for RemovalGraal Compiler  The default number of JVMCI threads is now the same as of C2 threads (-XX:JVMCINativeLibraryThreadFraction=0.66). This benefits program warmup but could increase the maximum RSS. Setting -XX:JVMCINativeLibraryThreadFraction to a smaller value will result in smaller maximum RSS but potentially longer warmup. (See JDK-8337493.)  Display a deprecation warning upon the first use of the legacy graal. prefix. This warning will be upgraded to an error in GraalVM in JDK 26 or later.Native ImageImprovements and New Features  In this release, a new generation of machine learning-powered profile inference has been introduced—the Graal Neural Network (GNN) static profiler—resulting in a 7.9% peak performance improvement observed across a wide range of microservices benchmarks. To enable this optimization, pass the -O3 option to Native Image. This feature is only available in Oracle GraalVM. Learn more in the documentation.  Introduced SkipFlow: a new experimental extension to the Native Image static analysis that tracks primitive values and evaluates branching conditions dynamically during the analysis process. SkipFlow can provide up to a 4% reduction in binary size without any additional impact on build time. The feature is available in GraalVM for JDK 24, but is not enabled by default. Enable and test it using the following options: -H:+TrackPrimitiveValues and -H:+UsePredicates. This enhancement is the result of a research collaboration. Find the paper here to read more.  Added experimental support for running premain methods of Java agents at runtime. At build time, specify the premain classes using the -H:PremainClasses option. At runtime, provide the premain runtime options along with the main class arguments in the format -XXpremain:&amp;lt;class&amp;gt;:&amp;lt;options&amp;gt;. (See #8988.)  Enhanced experimental Vector API support in Native Image AOT compilation, now on par with Graal JIT. To enable Vector API optimizations when building native images, use the --add-modules jdk.incubator.vector and -H:+VectorAPISupport options. (See #10285.) Improvements include a greater number of optimized Vector API operations. The following operations are now efficiently compiled to SIMD code, where supported by the target hardware:          Operations on Vector API masks      Masked Vector API loads and stores      General Vector API rearrange operations      Vector API loads/stores to and from memory segments        Optimized the Foreign Function and Memory API (FFM) in Native Image by introducing specialized upcalls for direct method handles.  Enhanced the Software Bill of Materials (SBOM) support in GraalVM Native Image to improve security and provide deeper insights into application dependencies:          Class-level metadata inclusion: You can now include class-level metadata to the SBOM components in a native image using the --enable-sbom=class-level,export option. This information can be useful for advanced vulnerability scanning and better understanding of the image contents.      Dependency tree generation: The SBOM now includes a detailed dependency tree derived from the static analysis. This feature provides a hierarchical view of component dependencies within the native executable.      Improved accuracy of the SBOM which is critical for vulnerability scanning: The GAV coordinates are now more accurate by extending parsing and handling of manifest files and integrating with the Native Image Maven plugin, reducing false-negatives. Shaded and Fat JARs are now better handled to prune redundant components and reduce false positives in vulnerability scanning.        Only available in Oracle GraalVM. Read more in the documentation.    Include serialization JSON reachability metadata as part of the reflection metadata by introducing the serializable flag for reflection entries.  Preserve the origin of a resource included in a native image. The information is included in the Build Report by default, or can be produced by passing the -H:+GenerateEmbeddedResourcesFile option.  Added support for GetStringUTFLengthAsLong in JNI. (See JDK-8328877.)  The length of the printed stack trace when using -XX:MissingRegistrationReportingMode=Warn can now be set with -XX:MissingRegistrationWarnContextLines= and its default length is now 8.  ActiveProcessorCount is now required to be set during isolate or VM creation.  Optimized the ForkJoinPool.commonPool() builder method to consistently respect the value set by NativeImageOptions.NumberOfThreads.  Added DuringSetupAccess.registerObjectReachabilityHandler to allow registering a callback that is executed when an object of a specified type is marked as reachable during heap scanning.Platform Compatibility      Native Image now targets armv8.1-a by default on AArch64. Pass -march=compatibility at build time for best compatibility or -march=native for best performance if the native executable is deployed on the same machine or a machine with the same CPU features. To list all available machine types, use -march=list.        Added support for Java module system-based service loading. For example, defining the following in a module-info.java file:    module Foo {    provides MyService with org.example.MyServiceImpl;}  Debugging and Monitoring Improvements  Added experimental support for jcmd on Linux and macOS. Use the --enable-monitoring=jcmd option to build a native image with jcmd enabled. See the documentation for more information.  Added a possibility to debug native executables with a Python helper script, gdb-debughelpers.py, based on the GDB Python API. See the documentation to learn more.  Updated debug info from DWARF4 to DWARF5 and now store type information in DWARF type units. Switching to DWARF5 reduces the size of debugging information by 30%.  Added support for emitting the Windows x64 unwind information. This enables stack walking in native tooling such as debuggers and profilers.Deprecated Functionality  Removed the customTargetConstructorClass field from the serialization JSON metadata. All possible constructors are now registered by default when registering a type for serialization. RuntimeSerialization.registerWithTargetConstructorClass is now deprecated.  Display a deprecation warning upon the first use of the legacy graal. prefix. This warning will be upgraded to an error in GraalVM in JDK 26 or later.Polyglot Runtime  Language and instrument resources are now automatically included when embedding a Graal Language in a native image. By default, a separate resources folder is no longer created next to the image. Read more in the Embedding Languages guide.  Starting in GraalVM for JDK 24, users must configure native access privileges to the java executable in order to avoid warnings from being printed by the JDK. For usages of the module-path, pass the --enable-native-access=org.graalvm.truffle option, and for class-path usages, pass the --enable-native-access=ALL-UNNAMED option to resolve the new warning. Note that Truffle automatically forwards the native access capability to all loaded languages and tools, therefore no further configuration is required. If the native access is denied by the user with --illegal-native-access=deny, then loading the optimizing runtime will fail and the fallback runtime will be used. More information can be found in the integrity-by-default JEP 472.  Context and Engine is now automatically closed when no longer strongly referenced. A reachable Value or PolyglotException will keep the associated Context reachable. Additionally, the Context remains reachable when explicitly entered or if there is an active polyglot thread within it. The Engine remains reachable when there is a strongly reachable Language, Instrument, or Context instance. However, it is still recommended not to rely on garbage collection for closing. Instead, use the try-with-resources pattern for explicit context and engine management. For more information, refer to the Automatic Close on GC documentation.  Added the ability to use Value#as(byte[].class) to copy the contents of a guest language byte buffer (Value#hasBufferElements()) to a new byte array. The new functionality has precedence over accessing the guest object as array (Value#hasArrayElements()) if both ways are available.  Added support for creation of strings from raw byte arrays and native memory using Value.fromByteBasedString(...) and Value.fromNativeString(...). Value.StringEncoding must be provided.Find a complete list of updates in the changelog.GraalJS  Implemented several ECMAScript proposals:          Error.isError, available in ECMAScript staging mode (--js.ecmascript-version=staging).      Math.sumPrecise,  available in ECMAScript staging mode (--js.ecmascript-version=staging).      Atomics.pause, available in ECMAScript staging mode (--js.ecmascript-version=staging).      Promise.try, available in ECMAScript staging mode (–js.ecmascript-version=staging).      Uint8Array to/from base64 and hex, available in ECMAScript staging mode (--js.ecmascript-version=staging).      RegExp.escape, available in ECMAScript staging mode (--js.ecmascript-version=staging).      Iterator Sequencing, available in ECMAScript staging mode (--js.ecmascript-version=staging).      Source Phase Imports, available behind the experimental option --js.source-phase-imports.      Regular Expression Pattern Modifiers, available by default.        Implemented the TextDecoder and TextEncoder APIs of the WHATWG Encoding Standard. They are available behind the experimental option --js.text-encoding.  Made options js.load, js.print, js.graal-builtin, and js.locale stable and allowed in the SandboxPolicy.UNTRUSTED mode.  GraalJS now supports WebAssembly/ES module integration that allows .wasm modules to be loaded via import statements. The optionjs.webassembly is now stable.Find a complete list of updates in the project changelog.GraalPyNew Features  Released the GraalPy Gradle Plugin for embedding of Python packages into Java.  Added the experimental python.IsolateNativeModules option to allow loading native extensions multiple times in different contexts. See the documentation for more information.  Foreign objects are now given a Python class corresponding to their interop traits. Foreign lists now inherit from Python list, foreign dictionaries from dict, foreign strings from str, foreign iterators from iterator, foreign exceptions from BaseException, foreign numbers from polyglot.ForeignNumber, foreign booleans from polyglot.ForeignBoolean, and foreign null values from NoneType. This means all Python methods of these types are available on the corresponding foreign objects, which behave as close as possible as if they were Python objects.When calling a method on a foreign object in Python code, Python methods are now prioritized over foreign members.Also added polyglot.register_interop_type and @polyglot.interop_type to define custom Python methods for a given foreign class ot type. See the documentation for more information.Java Embeddings Improvements  Introduced new types: KeywordArguments and PositionalArguments in the GraalPy Embedding library (org.graalvm.python:python-embedding), to support directly passing keyword and positional arguments from Java to Python.  Deprecated the org.graalvm.python.embedding.util package and added new equivalents to org.graalvm.python.embedding.  Maven and Gradle plugins do not embed Python home into the generated virtual filesystem. Instead, the handling of language home for any Graal Language, including GraalPy, for the GraalVM Native Image build can be controlled by new Native Image options +H:IncludeLanguageResources and +H:CopyLanguageResources. By default, the whole Python home is embedded into the native executable. In the case of JVM deployment, the language home is embedded in the GraalPy artifacts at Maven Central.Find a complete list of updates in the project changelog.GraalWasm  WebAssembly modules now can be loaded in JavaScript via import statements. GraalJS now supports WebAssembly/ES module integration. Read more here.  Implemented the Relaxed SIMD proposal. This feature can be enabled with the option --wasm.RelaxedSIMD.  Deprecated the --wasm.AsyncParsingBinarySize and --wasm.AsyncParsingStackSize options. These options no longer have any effect and will be removed in a future release.Find a complete list of updates in the project changelog.Espresso  Improvements to Espresso Continuation API: continuation suspension now clears slots based on liveness analysis. This ensures the set of captured variables is predictable and deterministic.  Added support for automatically using generic type parameters for incoming host objects, to allow more seamless communication between host and Espresso contexts.  Custom type converters now always take precedence over built-in converters when passing objects from the host to the embedded Espresso context.  Espresso’s hash interop implementation now throws an unsupported operation exception when attempting to modify an unmodifiable guest map.  Polyglot.cast() now applies custom type converters and interface type mappings, same as Polyglot.castWithGenerics().  The &amp;lt;ProcessReferences&amp;gt; builtin no longer hangs when multi-threading is disabled.Find a complete list of updates in the project changelog.TruffleRuby  Updated to Ruby 3.3.5.  Polyglot::ForeignException now inherits from StandardError instead of Exception.  Added support for OpenSSL versions 1.1 through 3.4, with preference given to OpenSSL 3.0.x, followed by 3.x, and 1.1 (End of Life). Resolved a compilation issue with OpenSSL 3.4.  Improved the speedup of some C extensions like sqlite3, trilogy, and json by 2 to 3 times by using the Panama NFI backend for faster upcalls in the JVM mode.  Optimized encoding negotiation for ASCII-compatible encodings.Find a complete list of updates and bug fixes in the TruffleRuby changelog.Truffle Language Implementation Framework  Added the experimental Bytecode DSL, a new framework for implementing bytecode interpreters. The Bytecode DSL automatically generates a complete bytecode interpreter from a set of user-specified operations. The generated interpreter defines all the necessary components of a bytecode interpreter, including an instruction set, a bytecode generator, and an optimizing interpreter. Bytecode DSL interpreters are designed to improve footprint and interpreter speed over AST interpreters without compromising peak performance. Bytecode DSL interpreters support a variety of features, including tiered interpretation, bytecode quickening, and boxing elimination, continuations, and serialization. They also integrate with existing Truffle tooling for instrumentation and debugging. See the Introduction to Bytecode DSL to get started, or check the user guide for more information. The Bytecode DSL is experimental in this release.  Java Native access for JEP 472: Prepare to Restrict the Use of JNI is now automatically provided for all languages and tools by Truffle.  Added the TruffleLanguage.Env.getHostLanguage() method returning the host language info. This allows languages to lookup the top scope of the host language using Env.getScopeInternal(LanguageInfo).  Added the @Bind.DefaultExpression annotation. Default expressions allow you to omit an explicit expression when declaring a @Bind parameter (the default expression for the parameter’s type is used).  Added RootNode.findInstrumentableCallNode(...) that allows resolving the instrumentation location given a call node, frame, and bytecode index. This allows to store instrumentable nodes in a side data structure for bytecode interpreters. Also the TruffleStackTraceElement.getInstrumentableLocation() and FrameInstance.getInstrumentableCallNode() methods were added to access the resolved locations. Tools using the Truffle instrumentation framework are encouraged to use these APIs instead for the purpose of accessing node locations.Find a complete list of updates in the Truffle changelog.",
          "url": " /release-notes/JDK_24/"
          },
          
          "latest-getting-started-oci":  {
          "title": "Using Oracle GraalVM on OCI",
          "content": "Using Oracle GraalVM on OCILearn how to start using Oracle GraalVM with different OCI services:  Compute Instance  Cloud Shell  Code Editor  DevOps Build Pipelines",
          "url": " /latest/getting-started/oci/"
          },
          
          "latest-reference-manual-graalvm-updater":  {
          "title": "GraalVM Updater",
          "content": "The GraalVM Updater was removed in GraalVM for JDK 21. For more details and information on migration options, see issue #6855.",
          "url": " /latest/reference-manual/graalvm-updater/"
          },
          
          "reference-manual-graalwasm":  {
          "title": "GraalWasm",
          "content": "GraalWasmGraalWasm is a WebAssembly runtime. It runs WebAssembly programs in binary format and can be used to embed and leverage WebAssembly modules in Java applications.GraalWasm is open source with its codebase accessible on GitHub, and fully supported with this Oracle GraalVM release. (See Oracle GraalVM Support Roadmap.)Learn more about GraalWasm from its reference documentation.",
          "url": " /reference-manual/graalwasm/"
          },
          
          "latest-webassembly-docs":  {
          "title": "GraalWasm Documentation",
          "content": "",
          "url": " /latest/webassembly/docs/"
          },
          
          "latest-guides":  {
          "title": "Guides",
          "content": "GuidesThese guides help developers get started with GraalVM Native Image, acquaint them with available features, and describe potential usage scenarios.Here you will learn how to:  Access Environment Variables  Add Logging to a Native Executable  Build a Native Executable from a JAR File  Build a Native Shared Library  Build a Polyglot Native Executable (Java and JavaScript)  Build a Static or Mostly-Static Native Executable  Build and Run Native Executables with JFR  Build and Run Native Executables with Remote JMX  Build Java Modules into a Native Executable  Configure Native Image with the Tracing Agent  Containerize a Native Executable and Run in a Docker Container  Create a Heap Dump from a Native Executable  Debug Native Executables with GDB  Debug Native Executables with a Python Helper Script  Embed an SBOM in a Native Executable to Identify Its Dependencies  Include Reachability Metadata Using the Native Image Gradle Plugin  Include Reachability Metadata Using the Native Image Maven Plugin  Include Resources in a Native Executable  Optimize a Native Executable with Profile-Guided Optimization  Optimize a Native Executable for File Size  Optimize Size of a Native Executable using Build Reports  Optimize Memory Footprint of a Native Executable  Specify Class Initialization Explicitly  Use Gradle to Build a Native Executable from a Java Application  Use Maven to Build a Native Executable from a Java ApplicationMicroservices Frameworks  Build a Native Executable from a Spring Boot 3 Application  Build a Native Executable from a Micronaut Application  Build a Native Executable from a Quarkus Application  Build a Native Executable from a Helidon MP Application  Build a Native Executable from a Helidon SP Application",
          "url": " /latest/guides/"
          },
          
          "latest-tools-igv":  {
          "title": "Ideal Graph Visualizer",
          "content": "Ideal Graph VisualizerIdeal Graph Visualizer (IGV) is a developer tool to analyze compilation graphs and investigate performance issues.IGV is developed to view and inspect intermediate representation graphs—a language-independent intermediate representation (IR) between the sourcelanguage and the machine code, generated by the compiler. It is essential for any language implementers building on top of GraalVM.The IGV tool is developed to allow GraalVM language implementers to optimize their languages assembled with the Truffle framework. As a development tool it should not be installed to production environments.Prerequisites  GraalVM installed.  The mx tool for the development of GraalVM projects (see below).Get StartedIGV is free to use and has to be built on user’s machine with the mx tool - a command-line tool to build, test, run, update the code, and built artifacts for GraalVM.  Clone the mx repository to your work directory:     git clone https://github.com/graalvm/mx.git    Clone the Graal repository:     git clone https://github.com/oracle/graal.git    Add mx to the PATH environment variable:     export PATH=&quot;/path/to/mx:$PATH&quot;    To check whether the installation was successful, run the command:     mx --version     Launch IGV with mx:     mx -p graal/compiler igv  Dump Graphs Using a Ruby ExampleUsing a host Ruby application that embeds some Java, you will now dump compiler graphs over the network.      Save the following code snippet in a file named Test.rb:     require &#39;json&#39; obj = {   time: Time.now,   msg: &#39;Hello World&#39;,   payload: (1..10).to_a } encoded = JSON.dump(obj) js_obj = Polyglot.eval(&#39;js&#39;, &#39;JSON.parse&#39;).call(encoded) puts js_obj[:time] puts js_obj[:msg] puts js_obj[:payload].join(&#39; &#39;)    Install Ruby from a TruffleRuby standalone using a Ruby manager/installer.Check its version to make sure you are running the TruffleRuby distribution:     ruby --version    Run the application, connecting the process to the running IGV:     ruby --vm.Djdk.graal.Dump=:1 --vm.Djdk.graal.PrintGraph=Network Test.rb  This dumps compiler graphs, in the IGV format, over the network to an IGV process listening on 127.0.0.1:4445. Once the connection is made, you are able to see the graphs in the Outline view. Find, for example, the java.lang.String.char(int) folder and open its After Parsing graph by double-clicking. If the node has sourceNodePosition property, then the Processing window will attempt to display its location and the entire stacktrace.Browse GraphsOnce a specific graph is opened, you can search for nodes by name, ID, or by property=value data, and all matching results will be shown.Another great feature of this tool is the ability to navigate to the original guest language source code.Select a node in the graph and click the Go to Source button in the Stack View window.Graphs navigation is also available from the Context menu, enabled by focusing and right-clicking a specific graph node.The Extract Nodes option re-renders a graph and displays only the selected nodes and their neighbors.If the graph is larger than the screen, manipulate with the Satellite view button in the main toolbar to move the viewport rectangle.For user preference, the graph color scheme is adjustable by editing the Coloring filter, enabled by default in the left sidebar.View Source CodeSource code views can be opened in manual and assisted modes.Once you select a node in the graph view, the Processing view opens.If the IGV knows where the source code for the current frame is, the green Go to Source arrow is enabled.If the IGV does not know where the source is, the line is greyed out and a Looking Glass button appears.Press it and select Locate in Java project to locate the correct project in the dialog.The IGV hides projects which do not contain the required source file.The Source Collections serves to display the standalone roots added by Add root of sources general action.If the source is located using the preferred method (for example, from a Java project), its project can be later managed on the Project tab.That one is initially hidden, but you can display the list of opened projects using Window, then Projects.Dump Graphs from Embedded JavaTo dump the GraalVM compiler graphs from an embedded Java application to IGV, you need to add options to the GraalVM-based process.Depending on the language/VM used, you may need to prefix the options by --vm. See the particular language’s documentation for the details.The main option to add is -Djdk.graal.Dump=:1.This will dump graphs in an IGV readable format to the local file system.To send the dumps directly to the IGV over the network, add -Djdk.graal.PrintGraph=Network when starting a GraalVM instance.Optionally a port can be specified.Then dumps are sent to the IGV from the running GraalVM on localhost.If the IGV does not listen on localhost, check under Options, then Ideal Graph Settings|Accept Data From Network can be checked.If there is not an IGV instance listening on 127.0.0.1, or it cannot be connected to, the dumps will be redirected to the local file system.The file system location is graal_dumps/ under the current working directory of the process and can be changed with the -Djdk.graal.DumpPath option.In case an older GraalVM version is used, you may need to explicitly request that dumps include the nodeSourcePosition property.This is done by adding the -XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints options.Relative Documentation  Implement Your Language  The mx tool",
          "url": " /latest/tools/igv/"
          },
          
          "latest-graalvm-as-a-platform-implement-instrument":  {
          "title": "Getting Started with Instruments in GraalVM",
          "content": "Getting Started with Instruments in GraalVMTools are sometimes referred to as Instruments within the GraalVM platform.The Instrument API is used to implement such instruments.Instruments can track very fine-grained, VM-level runtime events to profile, inspect, and analyze the runtime behavior of applications running on GraalVM.Simple ToolTo provide an easier starting point for tool developers we have created a Simple Tool example project.This is a javadoc-rich Maven project which implements a simple code coverage tool.We recommend cloning the repository and exploring the source code as a starting point for tool development.The following sections will provide a guided tour of the steps needed to build and run a GraalVM tool, using Simple Tool source code as the running example.These sections do not cover all of the features of the Instrument API so we encourage you to check the javadoc for more details.RequirementsAs mentioned before, Simple Tool is a code coverage tool.Ultimately, it should provide the developer with information on what percentage of source code lines was executed, as well as exactly which lines were executed.With that in mind, we can define some high-level requirements from our tool:  The tool keeps track of loaded source code.  The tool keeps track of executed source code.  On application exit, the tool calculates and prints per-line coverage information.Instrument APIThe main starting point for tools is subclassing the TruffleInstrument class.Unsurprisingly, the simple tool code base does exactly this, creating the SimpleCoverageInstrument class.The Registration annotation on the class ensures that the newly created instrument is registered with the Instrument API, in other words, that it will be automatically discovered by the framework.It also provides some metadata about the instrument: ID, name, version, which services the instrument provides, and whether the instrument is internal or not.In order for this annotation to be effective the DSL processor needs to process this class.This is, in the case of Simple Tool, done automatically by having the DSL processor as a dependency in the Maven configuration.Now we will look back at the implementation of the SimpleCoverageInstrument class, namely which methods from TruffleInstrument it overrides.These are onCreate, onDispose, and getOptionDescriptors.The onCreate and onDispose methods are self-explanatory: they are called by the framework when the instrument is created and disposed.We will discuss their implementations later, but first let us discuss the remaining one: getOptionDescriptors.The Truffle language implementation framework comes with its own system for specifying command-line options.These options allow tool users to control the tool either from the command line or when creating polyglot contexts.It is annotation-based, and examples for such options are the ENABLED and PRINT_COVERAGE fields of SimpleCoverageInstrument.Both of these are static final fields of the type OptionKey annotated with Option which, similar to the Registration annotation, provides some metadata for the option.Again, as with the Registration annotation, for the Option annotation to be effective the DSL processor is needed, which generates a subclass of OptionDescriptors (in our case named SimpleCoverageInstrumentOptionDescriptors).An instance of this class should be returned from the getOptionDescriptors method to let the framework know which options the instrument provides.Returning to the onCreate method, as an argument, we receive an instance of the Env class.This object gives a lot of useful information, but for the onCreate method we are primarily interested in the getOptions method, which can be used to read which options are passed to the tool.We use this to check whether the ENABLED option has been set and if so we enable our tool by calling the enable method.Similarly, in the onDispose method we check the options for the state of the PRINT_COVERAGE option, and if it is enabled we call the printResults method which will print our results.What does it mean “to enable a tool?”In general, it means that we tell the framework about the events we are interested in and how we want to react to them. Looking at our enable method, it does the following:  First, it defines SourceSectionFilter.This filter is a declarative definition of the parts of the source code we are interested in.In our example, we care about all nodes that are considered expressions, and we do not care about internal language parts.  Second, we obtain an instance of anInstrumenterclass which is an object allowing us to specify which parts of the system we wish to instrument.  Finally, using the Instrumenter class, we specify a Source Section Listener and an Execution Event Factory which are both described in the next two sections.Source Section ListenerThe Language API provides the notion of a Source which is the source code unit, and a SourceSection which is one continuous part of a Source, e.g., one method, one statement, one expression, and so on. More details can be found in the respective javadoc.The first requirement for Simple Tool is to keep track of loaded source code.The Instrument API provides the LoadSourceSectionListener which, when subclassed and registered with the instrumenter, allows users to react to the runtime loading source sections.This is exactly what we do with the GatherSourceSectionsListener, which is registered in the enable method of the instrument.The implementation of GatherSourceSectionsListener is quite simple: we override the onLoad method to notify the instrument of each loaded source section.The instrument keeps a mapping from each Source to a Coverage object which keeps a set of loaded source sections for each source.Execution Event NodeGuest languages are implemented as Abstract Syntax Tree (AST) interpreters.The language implementers annotate certain nodes with tags, which allows us to select which nodes we are interested in, by using the aforementioned SourceSectionFilter, in a language-agnostic manner.The main power of the Instrument API lies in its ability to insert specialized nodes in the AST which “wrap” the nodes of interest.These nodes are built using the same infrastructure that the language developers use, and are, from the perspective of the runtime, indistinguishable from the language nodes.This means that all of the techniques used to optimize guest languages into such high performing language implementations are available to the tool developers as well.More information about these techniques is available in the language implementation documentation.Suffice it to say that for Simple Tool to meet its second requirement, we need to instrument all expressions with our own node that will notify us when that expression is executed.For this task we use the CoverageNode.It is a subclass of ExecutionEventNode which, as the name implies, is used to instrument events during execution.The ExecutionEventNode offers many methods to override, but we are only interested in onReturnValue.This method is invoked when the “wrapped” node returns a value, that is, it is successfully executed.The implementation is rather simple. We just notify the instrument that the node with this particular SourceSection has been executed, and the instrument updates the Coverage object in its coverage map.The instrument is notified only once per node, as the logic is guarded by the flag.The fact that this flag is annotated with CompilationFinal and that the call to the instrument is preceded by a call to transferToInterpreterAndInvalidate() is a standard technique in Truffle, which ensures that once this instrumentation is no longer needed (a node has been executed), the instrumentation is removed from further compilations, along with any performance overhead.In order for the framework to know how to instantiate the CoverageNode when it is needed, we need to provide a factory for it.The factory is the CoverageEventFactory, a subclass of ExecutionEventNodeFactory.This class just ensures that each CoverageNode knows the SourceSection it is instrumenting by looking it up in the provided EventContext.Finally, when we are enabling the instrument, we tell the instrumenter to use our factory to “wrap” the nodes selected by our filter.Interaction Between Users and InstrumentsThe third and final requirement Simple Tool has is to actually interact with its user by printing line coverage to standard output.The instrument overriders the onDispose method which is unsurprisingly called when the instrument is being disposed of.In this method we check that the proper option has been set and, if so, calculate and print the coverage as recorded by our map of Coverage objects.This is a simple way of providing useful information to a user, but it is definitely not the only one.A tool could dump its data directly to a file, or run a web endpoint which shows the information, etc.One of the mechanisms that the Instrument API provides users with is registering instruments as services to be looked up by other instruments.If we look at the Registration annotation of our instrument we can see that it provides a services field where we can specify which services the instrument provides to other instruments.These services need to be explicitly registered.This allows a nicer separation of concerns among instruments so that, for example, we could have a “real time coverage” instrument which would use our SimpleCoverageInstrument to provide on-demand coverage information to a user through a REST API, and an “aborts on low coverage” instrument which stops the execution if coverage drops below a threshold, both using the SimpleCoverageInstrument as a service.Note: For reasons of isolation, instrument services are not available to application code, and instrument services can only be used from other instruments or guest languages.Installing a Tool into GraalVMSo far, Simple Tool seems to meet all requirements but the question remains: how do we use it?As mentioned before, Simple Tool is a Maven project.Setting JAVA_HOME to a GraalVM installation and running mvn package produces a target/simpletool-&amp;lt;version&amp;gt;.jar.This is the Simple Tool distribution form.The Truffle framework offers a clear separation between the language/tooling code and the application code.For this reason, putting the JAR file on the class path will not result in the framework realizing a new tool is needed.To achieve this we use --vm.Dtruffle.class.path.append=/path/to/simpletool-&amp;lt;version&amp;gt;.jar as is illustrated in a launcher script for our simple tool.This script also shows we can set the CLI options we specified for Simple Tool.This means that if we execute ./simpletool js example.js, we will launch the js launcher of GraalVM, add the tool to the framework class path, and run the included example.js file with Simple Tool enabled, resulting in the following output:==Coverage of /path/to/simpletool/example.js is 59.42%+ var N = 2000;+ var EXPECTED = 17393;  function Natural() {+     x = 2;+     return {+         &#39;next&#39; : function() { return x++; }+     };  }  function Filter(number, filter) {+     var self = this;+     this.number = number;+     this.filter = filter;+     this.accept = function(n) {+       var filter = self;+       for (;;) {+           if (n % filter.number === 0) {+               return false;+           }+           filter = filter.filter;+           if (filter === null) {+               break;+           }+       }+       return true;+     };+     return this;  }  function Primes(natural) {+     var self = this;+     this.natural = natural;+     this.filter = null;+     this.next = function() {+         for (;;) {+             var n = self.natural.next();+             if (self.filter === null || self.filter.accept(n)) {+                 self.filter = new Filter(n, self.filter);+                 return n;+             }+         }+     };  }+ var holdsAFunctionThatIsNeverCalled = function(natural) {-     var self = this;-     this.natural = natural;-     this.filter = null;-     this.next = function() {-         for (;;) {-             var n = self.natural.next();-             if (self.filter === null || self.filter.accept(n)) {-                 self.filter = new Filter(n, self.filter);-                 return n;-             }-         }-     };+ }- var holdsAFunctionThatIsNeverCalledOneLine = function() {return null;}  function primesMain() {+     var primes = new Primes(Natural());+     var primArray = [];+     for (var i=0;i&amp;lt;=N;i++) { primArray.push(primes.next()); }-     if (primArray[N] != EXPECTED) { throw new Error(&#39;wrong prime found: &#39; + primArray[N]); }  }+ primesMain();Other ExamplesThe following examples are intended to show common use-cases that can be solved with the Instrument API.  Coverage Instrument: a coverage tool example which was used to build up Simple Tool. It is used as the running example in further text where appropriate.  Debugger Instrument: a sketch on how a debugger can be implemented. Note that the Instrument API already provides a Debugger Instrument that can be used directly.  Statement Profiler: a profiler that is able to profile the execution of statements.Instrumentation Event ListenersThe Instrument API is defined in the com.oracle.truffle.api.instrumentation package.Instrumentation agents can be developed by extending the TruffleInstrument class, and can be attached to a running GraalVM instance using the Instrumenter class.Once attached to a running language runtime, instrumentation agents remain usable as long as the language runtime is not disposed.Instrumentation agents on GraalVM can monitor a variety of VM-level runtime events, including any of the following:  Source code-related events: The agent can be notified every time a new Source or SourceSection element is loaded by the monitored language runtime.  Allocation events: The agent can be notified every time a new object is allocated in the memory space of the monitored language runtime.  Language runtime and thread creation events: The agent can be notified as soon as a new execution context or a new thread for a monitored language runtime is created.  Application execution events: The agent gets notified every time a monitored application executes a specific set of language operations. Examples of such operations include language statements and expressions, thus allowing an instrumentation agent to inspect running applications with very high precision.For each execution event, instrumentation agents can define filtering criteria that will be used by the GraalVM instrumentation runtime to monitor only the relevant execution events.Currently, GraalVM instruments accept one of the following two filter types:  AllocationEventFilter to filter allocation events by allocation type.  SourceSectionFilter to filter source code locations in an application.Filters can be created using the provided builder object. For example, the following builder creates a SourceSectionFilter:SourceSectionFilter.newBuilder()                   .tagIs(StandardTag.StatementTag)                   .mimeTypeIs(&quot;x-application/js&quot;)                   .build()The filter in the example can be used to monitor the execution of all JavaScript statements in a given application.Other filtering options such as line numbers or file extensions can also be provided.Source section filters like the one in the example can use Tags to specify a set of execution events to be monitored. Language-agnostic tags such as statements and expressions are defined in the com.oracle.truffle.api.instrumentation.Tag class, and are supported by all GraalVM languages.In addition to standard tags, GraalVM languages may provide other, language-specific, tags to enable fine-grained profiling of language-specific events.(As an example, the GraalVM JavaScript engine provides JavaScript-specific tags to track the usages of ECMA builtin objects such as Array, Map, or Math.)Monitoring Execution EventsApplication execution events enable very precise and detailed monitoring. GraalVM supports two different types of instrumentation agents to profile such events, namely:  Execution listener: an instrumentation agent that can be notified every time a given runtime event happens. Listeners implement the ExecutionEventListener interface, and cannot associate any state with source code locations.  Execution event node: an instrumentation agent that can be expressed using Truffle Framework AST nodes. Such agents extend the ExecutionEventNode class and have the same capabilities of an execution listener, but can associate state with source code locations.Simple Instrumentation AgentA simple example of a custom instrumentation agent used to perform runtime code coverage can be found in the CoverageExample class.What follows is an overview of the agent, its design, and its capabilities.All instruments extend the TruffleInstrument abstract class and are registered in the GraalVM runtime through the @Registration annotation:@Registration(id = CoverageExample.ID, services = Object.class)public final class CoverageExample extends TruffleInstrument {  @Override  protected void onCreate(final Env env) {  }  /* Other methods omitted... */}Instruments override the onCreate(Env env) method to perform custom operations at instrument loading time.Typically, an instrument would use this method to register itself in the existing GraalVM execution environment.As an example, an instrument using AST nodes can be registered in the following way:@Overrideprotected void onCreate(final Env env) {  SourceSectionFilter.Builder builder = SourceSectionFilter.newBuilder();  SourceSectionFilter filter = builder.tagIs(EXPRESSION).build();  Instrumenter instrumenter = env.getInstrumenter();  instrumenter.attachExecutionEventFactory(filter, new CoverageEventFactory(env));}The instrument connects itself to the running GraalVM using the attachExecutionEventFactory method, providing the following two arguments:  SourceSectionFilter: a source section filter used to inform the GraalVM about specific code sections to be tracked.  ExecutionEventNodeFactory: the Truffle AST factory that provides instrumentation AST nodes to be executed by the agent every time a runtime event (as specified by the source filter) is executed.A basic ExecutionEventNodeFactory that instruments the AST nodes of an application can be implemented in the following way:public ExecutionEventNode create(final EventContext ec) {  return new ExecutionEventNode() {    @Override    public void onReturnValue(VirtualFrame vFrame, Object result) {      /*       * Code to be executed every time a filtered source code       * element is evaluated by the guest language.       */    }  };}Execution event nodes can implement certain callback methods to intercept runtime execution events. Examples include:  onEnter: executed before an AST node corresponding to a filtered source code element (for example, a language statement or an expression) is evaluated.  onReturnValue: executed after a source code element returns a value.  onReturnExceptional: executed in case the filtered source code element throws an exception.Execution event nodes are created on a per code location basis.Therefore, they can be used to store data specific to a given source code location in the instrumented application.As an example, an instrumentation node can simply keep track of all code locations that have already been visited using a node-local flag.Such a node-local boolean flag can be used to track the execution of AST nodes in the following way:// To keep track of all source code locations executedprivate final Set&amp;lt;SourceSection&amp;gt; coverage = new HashSet&amp;lt;&amp;gt;();public ExecutionEventNode create(final EventContext ec) {  return new ExecutionEventNode() {    // Per-node flag to keep track of execution for this node    @CompilationFinal private boolean visited = false;    @Override    public void onReturnValue(VirtualFrame vFrame, Object result) {      if (!visited) {        CompilerDirectives.transferToInterpreterAndInvalidate();        visited = true;        SourceSection src = ec.getInstrumentedSourceSection();        coverage.add(src);      }    }  };}As the above code shows, an ExecutionEventNode is a valid AST node.This implies that the instrumentation code will be optimized by the GraalVM runtime together with the instrumented application, resulting in minimal instrumentation overhead. Furthermore, this allows instrument developers to use the Truffle framework compiler directives directly from instrumentation nodes.In the example, compiler directives are used to inform the Graal compiler that visited can be considered compilation-final.Each instrumentation node is bound to a specific code location.Such locations can be accessed by the agent using the provided EventContext object. The context object gives instrumentation nodes access to a variety of information about the current AST nodes being executed.Examples of query APIs available to instrumentation agents through EventContext include:  hasTag: to query an instrumented node for a certain node Tag (for example, to check if a statement node is also a conditional node).  getInstrumentedSourceSection: to access the SourceSection associated with the current node.  getInstrumentedNode: to access the Node corresponding to the current instrumentation event.Fine-grained Expression ProfilingInstrumentation agents can profile even fractional events such as language expressions. To this end, an agent needs to be initialized providing two source section filters:// What source sections are we interested in?SourceSectionFilter sourceSectionFilter = SourceSectionFilter.newBuilder()  .tagIs(JSTags.BinaryOperation.class)  .build();// What generates input data to track?SourceSectionFilter inputGeneratingLocations = SourceSectionFilter.newBuilder()  .tagIs(StandardTags.ExpressionTag.class)  .build();instrumenter.attachExecutionEventFactory(sourceSectionFilter, inputGeneratingLocations, factory);The first source section filter (sourceSectionFilter, in the example) is a normal filter equivalent to other filters described before, and is used to identify the source code locations to be monitored.The second section filter, inputGeneratingLocations, is used by the agent to specify the intermediate values that should be monitored for a certain source section.Intermediate values correspond to all observable values that are involved in the execution of a monitored code element, and are reported to the instrumentation agent by means of the onInputValue callback.As an example, let us assume an agent needs to profile all operand values provided to sum operations (+) in JavaScript:var a = 3;var b = 4;// the &#39;+&#39; expression is profiledvar c = a + b;By filtering on JavaScript binary expressions, an instrumentation agent would be able to detect the following runtime events for the above code snippet:  onEnter(): for the binary expression at line 3.  onInputValue(): for the first operand of the binary operation at line 3. The value reported by the callback will be 3, that is, the value of the a local variable.  onInputValue(): for the second operand of the binary operation. The value reported by the callback will be 4, that is, the value of the b local variable.  onReturnValue(): for the binary expression. The value provided to the callback will be the value returned by the expression after it has completed its evaluation, that is, the value 7.By extending the source section filters to all possible events, an instrumentation agent will observe something equivalent to the following execution trace (in pseudocode):// First variable declarationonEnter - VariableWrite    onEnter - NumericLiteral    onReturnValue - NumericLiteral  onInputValue - (3)onReturnValue - VariableWrite// Second variable declarationonEnter - VariableWrite    onEnter - NumericLiteral    onReturnValue - NumericLiteral  onInputValue - (4)onReturnValue - VariableWrite// Third variable declarationonEnter - VariableWrite    onEnter - BinaryOperation        onEnter - VariableRead        onReturnValue - VariableRead      onInputValue - (3)        onEnter - VariableRead        onReturnValue - VariableRead      onInputValue - (4)    onReturnValue - BinaryOperation  onInputValue - (7)onReturnValue - VariableWriteThe onInputValue method can be used in combination with source section filters to intercept very fine-grained execution events such as intermediate values used by language expressions.The intermediate values that are accessible to the Instrumentation framework greatly depend on the instrumentation support provided by each language.Moreover, languages may provide additional metadata associated with language-specific Tag classes.Altering the Execution Flow of an ApplicationThe instrumentation capabilities that we have presented so far enable users to observe certain aspects of a running application.In addition to passive monitoring of an application’s behavior, the Instrument API features support for actively altering the behavior of an application at runtime.Such capabilities can be used to write complex instrumentation agents that affect the behavior of a running application to achieve specific runtime semantics.For example, one could alter the semantics of a running application to ensure that certain methods or functions are never executed (for example, by throwing an exception when they are called).Instrumentation agents with such capabilities can be implemented by leveraging the onUnwind callback in execution event listeners and factories.As an example, let’s consider the following JavaScript code:function inc(x) {  return x + 1}var a = 10var b = a;// Let&#39;s call inc() with normal semanticswhile (a == b &amp;amp;&amp;amp; a &amp;lt; 100000) {  a = inc(a);  b = b + 1;}c = a;// Run inc() and alter it&#39;s return type using the instrumentreturn inc(c)An instrumentation agent that modifies the return value of inc to always be 42 can be implemented using an ExecutionEventListener, in the following way:ExecutionEventListener myListener = new ExecutionEventListener() {  @Override  public void onReturnValue(EventContext context, VirtualFrame frame, Object result) {    String callSrc = context.getInstrumentedSourceSection().getCharacters();    // is this the function call that we want to modify?    if (&quot;inc(c)&quot;.equals(callSrc)) {      CompilerDirectives.transferToInterpreter();      // notify the runtime that we will change the current execution flow      throw context.createUnwind(null);    }  }  @Override  public Object onUnwind(EventContext context, VirtualFrame frame, Object info) {    // just return 42 as the return value for this node    return 42;  }}The event listener can be executed intercepting all function calls, for example using the following instrument:@TruffleInstrument.Registration(id = &quot;UniversalAnswer&quot;, services = UniversalAnswerInstrument.class)public static class UniversalAnswerInstrument extends TruffleInstrument {  @Override  protected void onCreate(Env env) {    env.registerService(this);    env.getInstrumenter().attachListener(SourceSectionFilter.newBuilder().tagIs(CallTag.class).build(), myListener);  }}When enabled, the instrument will execute its onReturnValue callback each time a function call returns.The callback reads the associated source section (using getInstrumentedSourceSection) and looks for a specific source code pattern (the function call inc(c), in this case).As soon as such code pattern is found, the instrument throws a special runtime exception, called UnwindException, that instructs the Instrumentation framework about a change in the current application’s execution flow.The exception is intercepted by the onUnwind callback of the instrumentation agent, which can be used to return any arbitrary value to the original instrumented application.In the example, all calls to inc(c) will return 42 regardless of any application-specific data.A more realistic instrument might access and monitor several aspects of an application, and might not rely on source code locations, but rather on object instances or other application-specific data.",
          "url": " /latest/graalvm-as-a-platform/implement-instrument/"
          },
          
          "latest-graalvm-as-a-platform-implement-language":  {
          "title": "Introduction to SimpleLanguage",
          "content": "Introduction to SimpleLanguageTo implement your own language, get started by extending an existing language such as SimpleLanguage.SimpleLanguage is a demonstration language built using the Language API.The SimpleLanguage project provides a showcase on how to use the Language APIs for writing your own language.It aims to use most of the available Truffle language implementation framework (henceforth “Truffle”) features, and documents their use extensively with inline source documentation.The SimpleLanguage demonstration language is licensed under the Universal Permissive License (UPL).Prerequisites  Maven available in your system.  GraalVM installed.  The mx tool for the development of GraalVM projects (see below).Get Started  Clone the SimpleLanguage repository by running:     git clone https://github.com/graalvm/simplelanguage    Execute mvn package from the SimpleLanguage directory to build the language. Before that, verify that native-image is available with your GraalVM installation to avoid a build failure:     cd simplelanguage     native-image --version     mvn package    The command builds the slnative executable in the simplelanguage/native directory and the sl-component.jar language component.    You can disable the SimpleLanguage native executable build during the packaging phase by running:     export SL_BUILD_NATIVE=false mvn package    Run SimpleLanguage from the project root directory:     ./sl language/tests/HelloWorld.sl    To see assembly code for the compiled functions, run:     ./sl -disassemble language/tests/SumPrint.sl  IDE SetupThe Truffle framework provides language-agnostic infrastructure to realize standard IDE features by providing additional APIs.If you would like to experiment with your language and get the benefits of an IDE, consider importing SimpleLanguage as an example.EclipseThe SimpleLanguage teaching project has been tested with Eclipse Neon.2 Release 4.6.2, and Eclipse Oxygen.3A. To import the project directory to the desirable Eclipse environment:  Open Eclipse with a new workspace.  Install the m2e and m2e-apt plugins from the Eclipse marketplace (Help -&amp;gt; Eclipse Marketplace).  Finally, import the SimpleLanguage project from File -&amp;gt; Import -&amp;gt; Maven -&amp;gt; Existing Maven Projects -&amp;gt; browse to the SimpleLanguage directory -&amp;gt; Finish.NetBeansNetBeans provides GUI support for debugging arbitrary languages. To upload SimpleLanguage to NetBeans interface, go to File -&amp;gt; Open Project -&amp;gt; select simplelanguage directory -&amp;gt; check Open Required Projects -&amp;gt; open Project.IntelliJ IDEAThe SimpleLanguage project was tested with IntelliJ IDEA. Open IntelliJ IDEA and, from the main menu bar, select  File -&amp;gt; Open -&amp;gt; Navigate to and select the simplelanguage directory -&amp;gt; Press OK. All dependencies will be included automatically.Dump GraphsTo investigate performance issues, consider using the Ideal Graph Visualizer (IGV) on top of GraalVM. IGV is developed to view and inspect intermediate representation graphs – a language-independent intermediate representation (IR) between the source language and the machine code, generated by the compiler. IGV is free to use.  Set up the mx tool on your computer.          Clone the mx repository by running:         git clone https://github.com/graalvm/mx.git            Clone the Graal repository to your work directory:         git clone https://github.com/oracle/graal.git            Add mx to the PATH environment variable:         export PATH=&quot;/path/to/mx:$PATH&quot;            To check whether the installation was successful, run the command:         mx --version               Launch IGV with mx:     mx -p graal/compiler igv    Execute the following from the SimpleLanguage root directory to dump graphs to IGV:     ./sl -dump language/tests/SumPrint.sl  This dumps compiler graphs in the IGV format over the network to an IGV process listening on 127.0.0.1:4445. Once the connection is made, you are able to see the graphs in the Outline window. Open a specific graph, search for nodes by name, ID, or by property=value data, and all matching results will be shown. Learn more here.DebugTo start debugging the SimpleLanguage implementation with a Java debugger, pass the -debug option to the command-line launcher of your program:./sl -debug language/tests/HelloWorld.slThen attach a Java remote debugger (such as Eclipse) on port 8000.SimpleLanguage Component for GraalVMLanguages implemented with the Truffle framework can be packaged as components which later can be installed into GraalVM using the GraalVM Updater tool.Running mvn package in the SimpleLanguage directory also builds a sl-component.jar.This file is the SimpleLanguage component for GraalVM and can be installed by running:gu -L install /path/to/sl-component.jarSimpleLanguage Native ImageA language built with Truffle can be AOT compiled using Native Image.Running mvn package in the SimpleLanguage directory also builds a slnative executable in the native directory.This executable is the full SimpleLanguage implementation as a single native application, and has no need for GraalVM in order to execute SimpleLanguage code.Besides this, a big advantage of using the native executable when compared to running on GraalVM is the greatly faster startup time as shown below:time ./sl language/tests/HelloWorld.sl== running on org.graalvm.polyglot.Engine@2db0f6b2Hello World!real    0m0.405suser    0m0.660ssys     0m0.108stime ./native/slnativelanguage/tests/HelloWorld.sl== running on org.graalvm.polyglot.Engine@7fd046f06898Hello World!real    0m0.004suser    0m0.000ssys     0m0.000sThis snipped shows a timed execution of a “Hello World” program using the sl launcher script, which runs SimpleLanguage on GraalVM, using Native Image.We can see that when running on GraalVM the execution takes 405ms.Since our SimpleLanguage program does just one print statement, we can conclude that almost all of this time is spent starting up GraalVM and initializing the language itself.When using the native executable we see that the execution takes only 4ms, showing two orders of magnitude faster startup than running on GraalVM.For more information on the native-image tool consider reading the reference manual.Disable SimpleLanguage Native Image BuildBuilding the native executable through Maven is attached to the Maven package phase.Since the native executable build can take a bit of time, we provide the option to skip this build by setting the SL_BUILD_NATIVE environment variable to false like so:export SL_BUILD_NATIVE=falsemvn package...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building simplelanguage-graalvm-native[INFO] ------------------------------------------------------------------------[INFO][INFO] --- exec-maven-plugin:1.6.0:exec (make_native) @ simplelanguage-graalvm-native ---Skipping the native image build because SL_BUILD_NATIVE is set to false.[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------...Run SimpleLanguage with the Newest (Development) version of the CompilerTo run SimpleLanguage with the development version of the Graal compiler we must build a GraalVM with that compiler.Clone the graal repository (https://github.com/oracle/graal) and follow the instructions in the vm/README.md file to build a GraalVM.Once that’s done, point JAVA_HOME to the newly built GraalVM and proceed with normal building and running of SimpleLanguage.Run SimpleLanguage Using Command LineExecuting SimpleLanguage code is normally done with the sl script which sets up the necessary command line depending on whether JAVA_HOME points to GraalVM or another JVM installation.The following subsections describe the command line for both cases.Run SimpleLanguage with GraalVM as JAVA_HOMEAssuming JAVA_HOME points to the GraalVM installation and that the current working directory is the simplelanguage directory, to run SimpleLanguage one should execute the following command:$JAVA_HOME/bin/java     -cp launcher/target/launcher-22.1.0-SNAPSHOT.jar     -Dtruffle.class.path.append=language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.slIn short, we place the launcher JAR file on the class path and execute its main class, but we inform GraalVM of the presence of SimpleLanguage by using the -Dtruffle.class.path.append option and providing it the path to the fat language JAR file.Having the language on a separate class path ensures a strong separation between the language implementation and its embedding context (in this case, the launcher).Disable Class Path SeparationNOTE! This should only be used during development.For development purposes it is useful to disable the class path separation and enable having the language implementation on the application class path (for example, for testingthe internals of the language).The Language API JAR file on Maven Central exports all API packages in its module-info.Apply the --upgrade-module-path option together with -Dgraalvm.locatorDisabled=true and this JAR file to export Language API packages:-Dgraalvm.locatorDisabled=true --module-path=&amp;lt;yourModulePath&amp;gt;:${truffle.dir} --upgrade-module-path=${truffle.dir}/truffle-api.jarA sample POM using --upgrade-module-path to export Language API packages can be found in the Simple Language POM.xml file.  Note: Disabling the locator effectively removes all installed languages from the module path as the locator also creates the class loader for the languages.To still use the built-in languages, add them to the module path by updating the module path to include the paths of all the languages you need (for example, $GRAALVM/languages/js).Other JVM ImplementationsUnlike GraalVM, which includes all the dependencies needed to run a language implemented with Truffle, other JVM implementations need additional JAR files to be present on the class path.These are the Language API and GraalVM SDK JAR files available from Maven Central.Assuming JAVA_HOME points to a stock JDK installation, and that the current working directory is the simplelanguage directory and the Language API and GraalVM SDK JAR files are present in that directory, one can execute SimpleLanguage with the following command:$JAVA_HOME/bin/java     -cp graal-sdk-22.1.0.jar:truffle-api-22.1.0.jar:launcher/target/launcher-22.1.0-SNAPSHOT.jar:language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.sl",
          "url": " /latest/graalvm-as-a-platform/implement-language/"
          },
          
          "latest-reference-manual-native-image-guides-use-reachability-metadata-repository-gradle":  {
          "title": "Include Reachability Metadata Using the Native Image Gradle Plugin",
          "content": "Include Reachability Metadata Using the Native Image Gradle PluginYou can build a native executable from a Java application with Gradle. For that, use the GraalVM Native Image Gradle plugin provided as part of the Native Build Tools project.A “real-world” Java application likely requires some Java reflection objects, or it calls some native code, or accesses resources on the class path - dynamic features that the native-image tool must be aware of at build time, and provided in the form of metadata. (Native Image loads classes dynamically at build time, and not at run time.)Depending on your application dependencies, there are three ways to provide the metadata with the Native Image Gradle Plugin:  Using the GraalVM Reachability Metadata Repository  Using the Tracing Agent  Autodetecting (if the required resources are directly available on the class path, in the src/main/resources/ directory)This guide demonstrates how to build a native executable using the GraalVM Reachability Metadata Repository, and with the Tracing Agent.The goal of this guide is to illustrate the difference between the two approaches, and demonstrate how the use of reachability metadata can simplify your development tasks.We recommend that you follow the instructions and create the application step-by-step. Alternatively, you can go right to the completed example.Prepare a Demo Application  Note: A Java version between 17 and 21 is required to execute Gradle (see the Gradle Compatibility Matrix). However, if you want to run your application with Java 23 (or higher), there is a workaround: set JAVA_HOME to a Java version between 17 and 21, and GRAALVM_HOME to GraalVM for JDK 23. See the Native Image Gradle Plugin documentation for more details.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.      Create a new Java project with Gradle in your favorite IDE, called “H2Example”, in the org.graalvm.example package.    Rename the default app/ directory to H2Example/, then rename the default filename App.java to H2Example.java and replace its contents with the following:     package org.graalvm.example; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.Comparator; import java.util.HashSet; import java.util.List; import java.util.Set; public class H2Example {     public static final String JDBC_CONNECTION_URL = &quot;jdbc:h2:./data/test&quot;;     public static void main(String[] args) throws Exception {         withConnection(JDBC_CONNECTION_URL, connection -&amp;gt; {             connection.prepareStatement(&quot;DROP TABLE IF EXISTS customers&quot;).execute();             connection.commit();         });         Set&amp;lt;String&amp;gt; customers = Set.of(&quot;Lord Archimonde&quot;, &quot;Arthur&quot;, &quot;Gilbert&quot;, &quot;Grug&quot;);         System.out.println(&quot;=== Inserting the following customers in the database: &quot;);         printCustomers(customers);         withConnection(JDBC_CONNECTION_URL, connection -&amp;gt; {             connection.prepareStatement(&quot;CREATE TABLE customers(id INTEGER AUTO_INCREMENT, name VARCHAR)&quot;).execute();             PreparedStatement statement = connection.prepareStatement(&quot;INSERT INTO customers(name) VALUES (?)&quot;);             for (String customer : customers) {                 statement.setString(1, customer);                 statement.executeUpdate();             }             connection.commit();         });         System.out.println(&quot;&quot;);         System.out.println(&quot;=== Reading customers from the database.&quot;);         System.out.println(&quot;&quot;);         Set&amp;lt;String&amp;gt; savedCustomers = new HashSet&amp;lt;&amp;gt;();         withConnection(JDBC_CONNECTION_URL, connection -&amp;gt; {             try (ResultSet resultSet = connection.prepareStatement(&quot;SELECT * FROM customers&quot;).executeQuery()) {                 while (resultSet.next()) {                     savedCustomers.add(resultSet.getObject(2, String.class));                 }             }         });         System.out.println(&quot;=== Customers in the database: &quot;);         printCustomers(savedCustomers);     }     private static void printCustomers(Set&amp;lt;String&amp;gt; customers) {         List&amp;lt;String&amp;gt; customerList = new ArrayList&amp;lt;&amp;gt;(customers);         customerList.sort(Comparator.naturalOrder());         int i = 0;         for (String customer : customerList) {             System.out.println((i + 1) + &quot;. &quot; + customer);             i++;         }     }     private static void withConnection(String url, ConnectionCallback callback) throws SQLException {         try (Connection connection = DriverManager.getConnection(url)) {             connection.setAutoCommit(false);             callback.run(connection);         }     }     private interface ConnectionCallback {         void run(Connection connection) throws SQLException;     } }    Open the Gradle configuration file build.gradle, and replace its contents with the following:     plugins {     id &#39;application&#39;     // 1. Native Image Gradle plugin     id &#39;org.graalvm.buildtools.native&#39; version &#39;0.10.3&#39; } repositories {     mavenCentral() }     // 2. Application main class application {     mainClass.set(&#39;org.graalvm.example.H2Example&#39;) } dependencies {     // 3. H2 Database dependency     implementation(&quot;com.h2database:h2:2.2.220&quot;) } // 4. Native Image build configuration graalvmNative {     binaries {         main {             imageName.set(&#39;h2example&#39;)             buildArgs.add(&quot;-Ob&quot;)         }     } }    1 Enable the Native Image Gradle plugin. The plugin discovers which JAR files it needs to pass to native-image and what the executable main class should be.    2 Specify the application main class explicitly.    3 Add a dependency on the H2 Database, an open source SQL database for Java. The application interacts with this database through the JDBC driver.    4 You can pass parameters to the native-image tool in the graalvmNative plugin configuration. In individual buildArgs you can pass parameters exactly the same way as you do on the command line. The -Ob option to enable the quick build mode (recommended during development only) is used as an example. imageName.set() is used to specify the name for the resulting binary. Learn about other configuration options from the plugin’s documentation.    The plugin is not yet available on the Gradle Plugin Portal, so declare an additional plugin repository. Open the settings.gradle file and replace the default content with this:     pluginManagement {     repositories {         mavenCentral()         gradlePluginPortal()     } } rootProject.name = &#39;H2Example&#39; include(&#39;H2Example&#39;)    Note that the pluginManagement {} block must appear before any other statements in the file.    (Optional) Build and run the application:    gradle run    This generates a runnable JAR file that returns a list of customers stored in the H2 Database.  Build a Native Executable Using the GraalVM Reachability Metadata RepositoryGraalVM Reachability Metadata repository provides GraalVM configuration for libraries which do not support GraalVM Native Image by default.One of these is the H2 Database this application depends on.The Native Image Gradle plugin automatically downloads the metadata from the repository at build time.With Gradle you can build a native executable and run it at one step:gradle nativeRunThe native executable, named h2example, is created in the build/native/nativeCompile directory.The command also runs the application from that native executable.Build a Native Executable with the Tracing AgentThe second way to provide the medatata configuration for native-image is by injecting the Tracing Agent (later the agent) at compile time.The agent can run in three modes:  Standard: Collects metadata without conditions. This is recommended if you are building a native executable.  Conditional: Collects metadata with conditions. This is recommended if you are creating conditional metadata for a native shared library intended for further use.  Direct: For advanced users only. This mode allows directly controlling the command line passed to the agent.You can configure the agent by either passing the options on the command line, or in the build.gradle file.See below how to collect metadata with the agent, and build a native executable.  Open the build.gradle file and add the agent configuration in the graalvmNative block:     agent {     defaultMode = &quot;standard&quot; }    It defines which mode the agent should run on. If you prefer the command-lime option, it is -Pagent=standard.    Now run your application with the agent, on the JVM. To enable the agent with the Native Image Gradle plugin, pass the -Pagent option to any Gradle tasks that extends JavaForkOptions (for example, test or run):    gradle -Pagent run    The agent captures and records calls to the H2 Database and all the dynamic features encountered during a test run into the JSON file(s) in the /build/native/agent-output/run directory.    Once the metadata is collected, copy it into the project’s /META-INF/native-image/ directory using the metadataCopy task:     gradle metadataCopy --task run --dir src/main/resources/META-INF/native-image    It is not required but recommended that the output directory is /resources/META-INF/native-image/. The native-image tool picks up metadata from that location automatically. For more information about how to collect metadata for your application automatically, see Collecting Metadata Automatically.    Build a native executable using configuration collected by the agent:     gradle nativeRun    The command also runs the application.    (Optional) To clean up the project, run gradle clean, and delete the directory META-INF with its contents.SummaryThis guide demonstrated how to build a native executable using the GraalVM Reachability Metadata Repository and with the Tracing Agent. The goal was to show the difference, and prove how using the reachability metadata can simplify the work.Using the GraalVM Reachability Metadata Repository enhances the usability of Native Image for Java applications depending on 3rd party libraries.Related Documentation  Reachability Metadata  Native Image Build Tools  Collect Metadata with the Tracing Agent",
          "url": " /latest/reference-manual/native-image/guides/use-reachability-metadata-repository-gradle/"
          },
          
          "latest-reference-manual-native-image-guides-use-reachability-metadata-repository-maven":  {
          "title": "Include Reachability Metadata Using the Native Image Maven Plugin",
          "content": "Include Reachability Metadata Using the Native Image Maven PluginYou can build a native executable from a Java application with Maven. For that, use the GraalVM Native Image Maven plugin provided as part of the Native Build Tools project.A “real-world” Java application likely requires some Java reflection objects, or it calls some native code, or accesses resources on the class path - dynamic features that the native-image tool must be aware of at build time, and provided in the form of metadata. (Native Image loads classes dynamically at build time, and not at run time.)Depending on your application dependencies, there are three ways to provide the metadata:  Using the GraalVM Reachability Metadata Repository  Using the Tracing Agent  Autodetecting (if the required resources are directly available on the class path, in the src/main/resources/ directory)This guide demonstrates how to build a native executable using the GraalVM Reachability Metadata Repository, and with the Tracing Agent.The goal of this guide is to illustrate the difference between the two approaches, and demonstrate how the use of reachability metadata can simplify your development tasks.We recommend that you follow the instructions and create the application step-by-step. Alternatively, you can go right to the completed example.Prepare a Demo ApplicationPrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.      Create a new Java project with Maven in your favorite IDE or from the command line, called “H2Example”, in the org.graalvm.example package.    Open the main class file, src/main/java/org/graalvm/example/H2Example.java, and replace its contents with the following:     package org.graalvm.example; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.Comparator; import java.util.HashSet; import java.util.List; import java.util.Set; public class H2Example {     public static final String JDBC_CONNECTION_URL = &quot;jdbc:h2:./data/test&quot;;     public static void main(String[] args) throws Exception {         withConnection(JDBC_CONNECTION_URL, connection -&amp;gt; {             connection.prepareStatement(&quot;DROP TABLE IF EXISTS customers&quot;).execute();             connection.commit();         });         Set&amp;lt;String&amp;gt; customers = Set.of(&quot;Lord Archimonde&quot;, &quot;Arthur&quot;, &quot;Gilbert&quot;, &quot;Grug&quot;);         System.out.println(&quot;=== Inserting the following customers in the database: &quot;);         printCustomers(customers);         withConnection(JDBC_CONNECTION_URL, connection -&amp;gt; {             connection.prepareStatement(&quot;CREATE TABLE customers(id INTEGER AUTO_INCREMENT, name VARCHAR)&quot;).execute();             PreparedStatement statement = connection.prepareStatement(&quot;INSERT INTO customers(name) VALUES (?)&quot;);             for (String customer : customers) {                 statement.setString(1, customer);                 statement.executeUpdate();             }             connection.commit();         });         System.out.println(&quot;&quot;);         System.out.println(&quot;=== Reading customers from the database.&quot;);         System.out.println(&quot;&quot;);         Set&amp;lt;String&amp;gt; savedCustomers = new HashSet&amp;lt;&amp;gt;();         withConnection(JDBC_CONNECTION_URL, connection -&amp;gt; {             try (ResultSet resultSet = connection.prepareStatement(&quot;SELECT * FROM customers&quot;).executeQuery()) {                 while (resultSet.next()) {                     savedCustomers.add(resultSet.getObject(2, String.class));                 }             }         });         System.out.println(&quot;=== Customers in the database: &quot;);         printCustomers(savedCustomers);     }     private static void printCustomers(Set&amp;lt;String&amp;gt; customers) {         List&amp;lt;String&amp;gt; customerList = new ArrayList&amp;lt;&amp;gt;(customers);         customerList.sort(Comparator.naturalOrder());         int i = 0;         for (String customer : customerList) {             System.out.println((i + 1) + &quot;. &quot; + customer);             i++;         }     }     private static void withConnection(String url, ConnectionCallback callback) throws SQLException {         try (Connection connection = DriverManager.getConnection(url)) {             connection.setAutoCommit(false);             callback.run(connection);         }     }     private interface ConnectionCallback {         void run(Connection connection) throws SQLException;     } }    Open the project configuration file, pom.xml, and replace its contents with the following:     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;     &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;     &amp;lt;groupId&amp;gt;org.graalvm.buildtools.examples&amp;lt;/groupId&amp;gt;     &amp;lt;artifactId&amp;gt;maven&amp;lt;/artifactId&amp;gt;     &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;     &amp;lt;properties&amp;gt;         &amp;lt;h2.version&amp;gt;2.2.220&amp;lt;/h2.version&amp;gt;         &amp;lt;maven.compiler.source&amp;gt;21&amp;lt;/maven.compiler.source&amp;gt;         &amp;lt;maven.compiler.target&amp;gt;21&amp;lt;/maven.compiler.target&amp;gt;         &amp;lt;native.maven.plugin.version&amp;gt;0.10.3&amp;lt;/native.maven.plugin.version&amp;gt;         &amp;lt;mainClass&amp;gt;org.graalvm.example.H2Example&amp;lt;/mainClass&amp;gt;         &amp;lt;imageName&amp;gt;h2example&amp;lt;/imageName&amp;gt;     &amp;lt;/properties&amp;gt;     &amp;lt;dependencies&amp;gt;         &amp;lt;!-- 1. H2 Database dependency --&amp;gt;         &amp;lt;dependency&amp;gt;             &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;             &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;             &amp;lt;version&amp;gt;${h2.version}&amp;lt;/version&amp;gt;         &amp;lt;/dependency&amp;gt;     &amp;lt;/dependencies&amp;gt;     &amp;lt;!-- 2. Native Image Maven plugin within a Maven profile --&amp;gt;     &amp;lt;profiles&amp;gt;         &amp;lt;profile&amp;gt;             &amp;lt;id&amp;gt;native&amp;lt;/id&amp;gt;             &amp;lt;build&amp;gt;                 &amp;lt;plugins&amp;gt;                     &amp;lt;plugin&amp;gt;                         &amp;lt;groupId&amp;gt;org.graalvm.buildtools&amp;lt;/groupId&amp;gt;                         &amp;lt;artifactId&amp;gt;native-maven-plugin&amp;lt;/artifactId&amp;gt;                         &amp;lt;version&amp;gt;0.10.3&amp;lt;/version&amp;gt;                         &amp;lt;extensions&amp;gt;true&amp;lt;/extensions&amp;gt;                         &amp;lt;executions&amp;gt;                             &amp;lt;execution&amp;gt;                                 &amp;lt;id&amp;gt;build-native&amp;lt;/id&amp;gt;                                 &amp;lt;goals&amp;gt;                                     &amp;lt;goal&amp;gt;compile-no-fork&amp;lt;/goal&amp;gt;                                 &amp;lt;/goals&amp;gt;                                 &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;                             &amp;lt;/execution&amp;gt;                         &amp;lt;/executions&amp;gt;                         &amp;lt;configuration&amp;gt;                             &amp;lt;buildArgs&amp;gt;                                 &amp;lt;!-- 3. Quick build mode --&amp;gt;                                 &amp;lt;buildArg&amp;gt;-Ob&amp;lt;/buildArg&amp;gt;                             &amp;lt;/buildArgs&amp;gt;                         &amp;lt;/configuration&amp;gt;                     &amp;lt;/plugin&amp;gt;                 &amp;lt;/plugins&amp;gt;             &amp;lt;/build&amp;gt;         &amp;lt;/profile&amp;gt;     &amp;lt;/profiles&amp;gt;     &amp;lt;build&amp;gt;         &amp;lt;finalName&amp;gt;${project.artifactId}&amp;lt;/finalName&amp;gt;         &amp;lt;plugins&amp;gt;             &amp;lt;plugin&amp;gt;                 &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;                 &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;                 &amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;                 &amp;lt;configuration&amp;gt;                     &amp;lt;descriptorRefs&amp;gt;                         &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;                     &amp;lt;/descriptorRefs&amp;gt;                     &amp;lt;archive&amp;gt;                         &amp;lt;manifest&amp;gt;                             &amp;lt;mainClass&amp;gt;${mainClass}&amp;lt;/mainClass&amp;gt;                         &amp;lt;/manifest&amp;gt;                     &amp;lt;/archive&amp;gt;                 &amp;lt;/configuration&amp;gt;                 &amp;lt;executions&amp;gt;                     &amp;lt;execution&amp;gt;                         &amp;lt;id&amp;gt;assemble-all&amp;lt;/id&amp;gt;                         &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;                         &amp;lt;goals&amp;gt;                             &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;                         &amp;lt;/goals&amp;gt;                     &amp;lt;/execution&amp;gt;                 &amp;lt;/executions&amp;gt;             &amp;lt;/plugin&amp;gt;         &amp;lt;/plugins&amp;gt;     &amp;lt;/build&amp;gt; &amp;lt;/project&amp;gt;    1 Add a dependency on the H2 Database, an open source SQL database for Java. The application interacts with this database through the JDBC driver.    2 Enable the Native Image Maven plugin within a Maven profile, attached to the package phase. You are going to build a native executable using a Maven profile. A Maven profile allows you to decide whether to just build a JAR file, or a native executable. The plugin discovers which JAR files it needs to pass to native-image and what the executable main class should be.    3 You can pass parameters to the underlying native-image build tool using the &amp;lt;buildArgs&amp;gt; section. In individual &amp;lt;buildArg&amp;gt; tags you can pass parameters exactly the same way as you do on the command line. The -Ob option to enable the quick build mode (recommended during development only) is used as an example. Learn about other configuration options from the plugin’s documentation.    (Optional) Build the application:     mvn -DskipTests clean package    This generates an executable JAR file.  Build a Native Executable Using the GraalVM Reachability Metadata RepositoryGraalVM Reachability Metadata repository provides GraalVM configuration for libraries which do not support GraalVM Native Image by default.One of these is the H2 Database this application depends on.The Native Image Maven plugin automatically downloads the metadata from the repository at build time.  Build a native image:     mvn -DskipTests -Pnative package    This generates an executable file for the platform in the target/ directory, called h2example. Notice the new directory target/graalvm-reachability-metadata where the metadata is pulled into.    Run the application from the native executable which should return a list of customers stored in the H2 Database:     ./target/h2example     Run mvn clean to clean up the project and delete the metadata directory with its contents before you continue.Build a Native Executable with the Tracing AgentThe second way to provide the medatata configuration for native-image is by injecting the Tracing Agent (later the agent) at compile time.The agent is disabled by default, but it can be enabled within your pom.xml file or via the command line.The agent can run in three modes:  Standard: Collects metadata without conditions. This is recommended if you are building a native executable. (Default)  Conditional: Collects metadata with conditions. This is recommended if you are creating conditional metadata for a native shared library intended for further use.  Direct: For advanced users only. This mode allows directly controlling the command line passed to the agent.See below how to collect metadata with the Tracing Agent, and build a native executable applying the provided configuration.Before you continue, clean the project from the previous build: mvn clean.  Enable the agent by adding the following into the &amp;lt;configuration&amp;gt; element of the native profile:     &amp;lt;agent&amp;gt;     &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt; &amp;lt;/agent&amp;gt;    The configuration block should resemble this:     &amp;lt;configuration&amp;gt;     &amp;lt;agent&amp;gt;         &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;     &amp;lt;/agent&amp;gt;     &amp;lt;buildArgs&amp;gt;         &amp;lt;buildArg&amp;gt;-Ob&amp;lt;/buildArg&amp;gt;     &amp;lt;/buildArgs&amp;gt; &amp;lt;/configuration&amp;gt;    Executing your application with the agent is more involved and requires you to configure a separate MOJO execution which allows forking a Java process. In the native Maven profile section, add the exec-maven-plugin plugin:     &amp;lt;plugin&amp;gt;     &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;     &amp;lt;artifactId&amp;gt;exec-maven-plugin&amp;lt;/artifactId&amp;gt;     &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt;     &amp;lt;executions&amp;gt;         &amp;lt;execution&amp;gt;             &amp;lt;id&amp;gt;java-agent&amp;lt;/id&amp;gt;             &amp;lt;goals&amp;gt;                 &amp;lt;goal&amp;gt;exec&amp;lt;/goal&amp;gt;             &amp;lt;/goals&amp;gt;             &amp;lt;phase&amp;gt;test&amp;lt;/phase&amp;gt;             &amp;lt;configuration&amp;gt;                 &amp;lt;executable&amp;gt;java&amp;lt;/executable&amp;gt;                 &amp;lt;workingDirectory&amp;gt;${project.build.directory}&amp;lt;/workingDirectory&amp;gt;                 &amp;lt;arguments&amp;gt;                     &amp;lt;argument&amp;gt;-classpath&amp;lt;/argument&amp;gt;                     &amp;lt;classpath/&amp;gt;                     &amp;lt;argument&amp;gt;${mainClass}&amp;lt;/argument&amp;gt;                 &amp;lt;/arguments&amp;gt;             &amp;lt;/configuration&amp;gt;         &amp;lt;/execution&amp;gt;     &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt;    Run your application with the agent on the JVM:     mvn -Pnative -DskipTests -DskipNativeBuild=true package exec:exec@java-agent    The agent captures and records calls to the H2 Database and all the dynamic features encountered during a test run into the reachability-metadata.json file in the target/native/agent-output/main/ directory.    Build a native executable using configuration collected by the agent:     mvn -Pnative -DskipTests package    It generates a native executable for the platform in the target/ directory, called h2example.    Run the application from the native executable:     ./target/h2example  SummaryThis guide demonstrated how to build a native executable using the GraalVM Reachability Metadata Repository and with the Tracing Agent.The goal was to show the difference, and prove how using the reachability metadata can simplify the work.Using the GraalVM Reachability Metadata Repository enhances the usability of Native Image for Java applications depending on 3rd party libraries.Related Documentation  Reachability Metadata  Collect Metadata with the Tracing Agent  Native Image Build Tools",
          "url": " /latest/reference-manual/native-image/guides/use-reachability-metadata-repository-maven/"
          },
          
          "latest-reference-manual-native-image-guides-include-resources":  {
          "title": "Include Resources in a Native Executable",
          "content": "Include Resources in a Native ExecutableBy default, the native-image tool does not integrate any resource files into a native executable.You must specify resources that should be accessible by your application at run time.This guide demonstrates how to register resources to be included in a native executable by providing a resource configuration file.See Accessing Resources in Native Image for more ways to include resources.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.Run a DemoIn the following example, you run a “fortune teller” application that simulates the traditional fortune Unix program (for more information, see fortune).  Save the following Java source code as a file named Fortune.java:     import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Random; import java.util.Scanner; public class Fortune {     private static final String SEPARATOR = &quot;%&quot;;     private static final Random RANDOM = new Random();     private ArrayList&amp;lt;String&amp;gt; fortunes = new ArrayList&amp;lt;&amp;gt;();     public Fortune(String path) {         // Scan the file into the array of fortunes         Scanner s = new Scanner(new BufferedReader(new InputStreamReader(this.getClass().getResourceAsStream(path))));         s.useDelimiter(SEPARATOR);         while (s.hasNext()) {             fortunes.add(s.next());         }     }             private void printRandomFortune() throws InterruptedException {         int r = RANDOM.nextInt(fortunes.size()); // Pick a random number         String f = fortunes.get(r);  // Use the random number to pick a random fortune         for (char c: f.toCharArray()) {  // Print out the fortune           System.out.print(c);             Thread.sleep(100);          }     }           public static void main(String[] args) throws InterruptedException {         Fortune fortune = new Fortune(&quot;/fortunes.u8&quot;);         fortune.printRandomFortune();     } }        Download the fortunes.u8 resource file and save it in the same directory as Fortune.java.    Create a configuration file, named reachability-metadata.json, and save it in the META-INF/native-image/ subdirectory. Register the resource using a glob pattern:     {   &quot;resources&quot;: [     {       &quot;glob&quot;: &quot;fortunes.u8&quot;     }   ] }    The native-image tool picks up all configuration files that it finds in the META-INF/native-image/ directory automatically.    Compile the application:     javac Fortune.java    Build a native executable:     native-image Fortune    Run the fortune teller application to test:     ./fortune  To see which resources were included in your native executable, pass the option --emit build-report to the native-image tool at build time.It generates an HTML file that can be examined with a regular web browser.The information about all included resources will be under the Resources tab.In this demo the path to the resource file is straightforward, but it may be more complex in a real-world use case.A resource or resource bundle may come from a module.Learn more how to specify it in Resources in Java Modules.For more advanced use-cases, you can register resources using the API methods (see class RuntimeResourceAccess).Learn more about specifying a resource path using a glob and some syntax rules to be observed from Accessing Resources in Native Image.Related Documentation  Accessing Resources in Native Image  Resource Metadata in JSON",
          "url": " /latest/reference-manual/native-image/guides/include-resources/"
          },
          
          "":  {
          "title": "",
          "content": "",
          "url": " /"
          },
          
          "latest-getting-started-oci-compute-instance":  {
          "title": "Oracle GraalVM on an OCI Compute Instance with Oracle Linux",
          "content": "Oracle GraalVM on an OCI Compute Instance with Oracle LinuxThis guide describes how to install Oracle GraalVM on an Oracle Cloud Infrastructure (OCI) Compute instance with Oracle Linux 7, 8, 9, and 10.For complete beginners, start with this tutorial to create and launch your first Linux instance.PrerequisitesTo replicate the steps in this guide, create a Compute instance and connect to it.Install Oracle GraalVMFor convenience, the RPM package for Oracle GraalVM 25 is available in the Oracle YUM repository with the package name graalvm-25-native-image.This distribution includes a JDK and Native Image.It is self-contained and all the required dependencies will be automatically resolved during the installation.That means that OCI customers can use Oracle GraalVM in their compute instances, just like any Java Development Kit, by installing it with yum, dnf, or microdnf default package managers, depending on the Oracle Linux version.Use the following command to connect to the OCI Compute Instance from a Unix-style system:ssh -i .ssh/id_rsa opc@INSTANCE_PUBLIC_IPWhere .ssh/id_rsa is the full path and name of the file containing your private SSH key; opc is the default name for the Oracle Linux image; and INSTANCE_PUBLIC_IP is the instance IP address provisioned from the console.For more details, refer to the Connecting to Your Linux Instance Using SSH tutorial.The installation steps may differ per Oracle Linux version or package manager.Oracle Linux 10On Oracle Linux 10 with the yum package manager, run these commands one by one:sudo yum update -y oraclelinux-release-el10sudo yum config-manager --set-enabled el10_codeready_buildersudo yum install graalvm-25-native-imageConfirm that the installed package size is correct by entering yes at the prompt.On Oracle Linux 10 with dnf or microdnf default package managers, run these commands one by one:sudo dnf update -y oraclelinux-release-el10sudo dnf config-manager --set-enabled el10_codeready_buildersudo dnf install graalvm-25-native-imageOracle Linux 9On Oracle Linux 9 with the yum package manager, run these commands one by one:sudo yum update -y oraclelinux-release-el9sudo yum config-manager --set-enabled ol9_codeready_buildersudo yum install graalvm-25-native-imageConfirm that the installed package size is correct by entering yes at the prompt.On Oracle Linux 9 with dnf or microdnf default package managers, run these commands one by one:sudo dnf update -y oraclelinux-release-el9sudo dnf config-manager --set-enabled ol9_codeready_buildersudo dnf install graalvm-25-native-imageOracle Linux 8On Oracle Linux 8 with the yum package manager, run these commands one by one:sudo yum update -y oraclelinux-release-el8sudo yum config-manager --set-enabled ol8_codeready_buildersudo yum install graalvm-25-native-imageConfirm that the installed package size is correct by entering yes at the prompt.On Oracle Linux 8 with dnf or microdnf default package managers, run these commands one by one:sudo dnf update -y oraclelinux-release-el8sudo dnf config-manager --set-enabled ol8_codeready_buildersudo dnf install graalvm-25-native-imageOracle Linux 7  Install a newer devtoolset with GCC version 10 (required by Oracle GraalVM Native Image):    sudo yum -y install oracle-softwarecollection-release-el7    sudo yum install devtoolset-10    Enable the newer devtoolset by default:    echo &#39;source scl_source enable devtoolset-10&#39; &amp;gt;&amp;gt; ~/.bashrc    Enter a new bash session with the newer devtoolset enabled:    bash    Install the latest Oracle GraalVM:    sudo yum install graalvm-25-native-image    Confirm that the installed package size is correct by entering yes at the prompt.  Configure Environment VariablesConfigure environment variables to point to the Oracle GraalVM installation for this SSH session.After installation, the package files are placed in the /usr/lib64/graalvm directory, and binaries in bin accordingly.  Set the values of the PATH and JAVA_HOME environment variables in the bash configuration to point to the location of the Oracle GraalVM installation with the following commands:    echo &quot;export JAVA_HOME=/usr/lib64/graalvm/graalvm-java25&quot; &amp;gt;&amp;gt; ~/.bashrc    echo &#39;export PATH=$JAVA_HOME/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.bashrc    Activate this change:    source ~/.bashrc    Check the values of PATH and JAVA_HOME, and the Java version to confirm the installation was successful:    echo $JAVA_HOME    echo $PATH    java -version  Congratulations! You have installed Oracle GraalVM on the Compute instance with the Oracle Linux image, and can use it as any other Java Development Kit.Related Documentation  Oracle GraalVM in OCI DevOps Build Pipelines  Oracle GraalVM in OCI Cloud Shell",
          "url": " /latest/getting-started/oci/compute-instance/"
          },
          
          "latest-getting-started-oci-devops-build-pipeline":  {
          "title": "Oracle GraalVM in OCI DevOps Build Pipelines",
          "content": "Oracle GraalVM in OCI DevOps Build PipelinesThis guide describes how to use Oracle GraalVM in the Oracle Cloud Infrastructure (OCI) DevOps service.OCI DevOps is a continuous integration/continuous delivery (CI/CD) service that enables developers to automate the delivery and deployment of software to OCI compute platforms.OCI DevOps service provides build runners with Oracle Linux 8 as the base container image along with a number of runtimes and tools.Oracle GraalVM RPMs are available in the Oracle YUM repository.Each RPM is self-contained and will automatically pull in all its required dependencies.You can install and use Oracle GraalVM in DevOps Build Pipelines using the YUM package manager.Prerequisites  DevOps project  OCI Notification Topic  OCI DevOps Build PipelineTo work with a Build Pipeline, add statements to a build specification file, build-spec.yml.The DevOps CI/CD platform reads the file and runs the commands one by one.You do not need to run a YUM package manager command manually.RPMs for Oracle GraalVM are available with the package names graalvm-17-native-image, graalvm-21-native-image, and graalvm-25-native-image.Each package includes the JDK and the Native Image tool.To install and use Oracle GraalVM in your DevOps Build Pipeline, update your build specification file as shown in the following example.      Add a command to install Oracle GraalVM 25 with Native Image and Java Development Kit (JDK):     steps: - type: Command     name: &quot;Install Oracle GraalVM 25&quot;     command: |     yum -y install graalvm-25-native-image        Add a command to set the value of the JAVA_HOME environment variable for Oracle GraalVM 25:     env: variables:     &quot;JAVA_HOME&quot; : &quot;/usr/lib64/graalvm/graalvm-java25&quot;        Add the command to set the value of the PATH environment variable:     env: variables:     # PATH is a reserved variable and cannot be defined as a variable.     # PATH can be changed in a build step and the change is visible in subsequent steps. steps: - type: Command     name: &quot;Set PATH Variable&quot;     command: |     export PATH=$JAVA_HOME/bin:$PATH  Here is an example of a complete build specification file for GraalVM for JDK 21.Oracle GraalVM provides more features, each of which can be installed as an add-on.Use the yum list command to get a list of the available RPMs for your installation.For instance, for Oracle GraalVM 25, run:yum list graalvm-25*...To try this feature out, use the sample project: Using Oracle GraalVM in OCI DevOps Build Pipelines.It describes how to set up Oracle GraalVM in OCI DevOps service, create a Build Pipeline, add build stages, and so on.Related Documentation  OCI DevOps: Using Oracle GraalVM in DevOps Build Pipelines  OCI Build Examples: Using Oracle GraalVM in OCI DevOps Build Pipelines  OCI Build Examples: Using Oracle GraalVM in OCI DevOps to build a Micronaut REST App",
          "url": " /latest/getting-started/oci/devops-build-pipeline/"
          },
          
          "community-internship":  {
          "title": "Internship Program",
          "content": "",
          "url": " /community/internship/"
          },
          
          "latest-introduction":  {
          "title": "Introduction",
          "content": "Introduction to GraalVMGraalVM accelerates application performance while consuming fewer resources—improving application efficiency and reducing IT costs.It achieves this by compiling your Java application ahead of time into a native binary.The binary is smaller, starts up to 100x faster, provides peak performance with no warmup, and uses less memory and CPU than an application running on a Java Virtual Machine (JVM).With profile-guided optimization and the G1 (Garbage-First) garbage collector, you can get lower latency and on-par or better peak performance and throughput compared to an application running on a JVM.Key BenefitsGraalVM’s key benefits are:  Low Resource Usage: A Java application compiled ahead-of-time by GraalVM requires less memory and CPU to run. No memory and CPU cycles are spent on just-in-time compilation. As a result, your application needs fewer resources to run and is cheaper to operate at scale.  Fast Startup: With GraalVM, you can start your Java application faster by initializing parts of it at build time instead of runtime, and instantly achieve predictable peak performance with no warmup.  Compact Packaging: A Java application compiled ahead-of-time by GraalVM is small and can be easily packaged into a lightweight container image for fast and efficient deployment.  Improved Security: GraalVM reduces the attack surface of your Java application by excluding the following: unreachable code (unused classes, methods, and fields), the just-in-time compilation infrastructure, and build-time initialized code. GraalVM’s closed world assumption prevents your application from loading unknown code by disabling dynamic features such as reflection, serialization, and so on at runtime, and requires an explicit include list of such classes, methods, and fields at build time. GraalVM can embed a software bill of materials (SBOM) in your binary, making it easier for you to use common security scanners to check your Java application for published Common Vulnerabilities and Exposures (CVEs).  Easily Build Cloud Native Microservices: Popular microservices frameworks such as Micronaut, Spring Boot, Helidon, and Quarkus, and cloud platforms such as Oracle Cloud Infrastructure (OCI), Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure all support GraalVM. This makes it easy for you to build cloud native Java microservices, compiled as binaries, packaged in small containers, and run on the most popular cloud platforms.  Extend your Java Application with Python and Other Languages: With GraalVM you can embed languages such as Python, JavaScript, and others to extend your Java application.  Use Existing Development and Monitoring Tools: Your existing Java application development and monitoring tools work with GraalVM application binaries. GraalVM provides build plugins for Maven and Gradle, and GitHub Actions for CI/CD. GraalVM supports Java Flight Recorder (JFR), Java Management Extensions (JMX), heap dumps, VisualVM, and other monitoring tools. GraalVM works with existing Java editors/IDEs, and unit test frameworks such as JUnit.Licensing and SupportOracle GraalVM is licensed under GraalVM Free Terms and Conditions (GFTC) including License for Early Adopter Versions.Subject to the conditions in the license, including the License for Early Adopter Versions, the GFTC is intended to permit use by any user including commercial and production use. Redistribution is permitted as long as it is not for a fee.GraalVM Community Edition is open-source project built from the sources available on GitHub and distributed under version 2 of the GNU General Public License with the “Classpath” Exception, which are the same terms as for Java.Check the licenses of individual GraalVM components which are generally derivative of the license of a particular language and may differ.What to Read Next  Start with the installation guide.  GraalVM is based on the Java HotSpot Virtual Machine. Read more about GraalVM as a Java Virtual Machine and its optimizing just-in-time compiler, Graal Compiler.  Whether you are new to GraalVM Native Image, or have little experience using it, continue to Getting Started with Native Image. We suggest you to take look at User Guides.  Developers interested in embedding other languages into Java, proceed directly to the Embedding Languages documentation.  Developers interested in building interpreters for programming languages which then run on GraalVM, continue to the Truffle language implementation framework documentation.  To learn more about security considerations in GraalVM, check the Security Guide.  If you cannot find the answer you need in the available documentation or have a troubleshooting query, ask for help in a Slack channel or submit a GitHub issue.",
          "url": " /latest/introduction/"
          },
          
          "java":  {
          "title": "Java",
          "content": "",
          "url": " /java/"
          },
          
          "javascript":  {
          "title": "JavaScript",
          "content": "",
          "url": " /javascript/"
          },
          
          "pages-javadocs-jdk17-html":  {
          "title": "SDK Javadoc for JDK 17",
          "content": "",
          "url": " /pages/javadocs/jdk17.html"
          },
          
          "jdk17-introduction":  {
          "title": "GraalVM Overview",
          "content": "",
          "url": " /jdk17/introduction/"
          },
          
          "jdk17-getting-started":  {
          "title": "Getting Started",
          "content": "",
          "url": " /jdk17/getting-started/"
          },
          
          "pages-javadocs-jdk21-html":  {
          "title": "SDK Javadoc for JDK 21",
          "content": "",
          "url": " /pages/javadocs/jdk21.html"
          },
          
          "jdk21-introduction":  {
          "title": "GraalVM Overview",
          "content": "",
          "url": " /jdk21/introduction/"
          },
          
          "jdk21-getting-started":  {
          "title": "Getting Started",
          "content": "",
          "url": " /jdk21/getting-started/"
          },
          
          "pages-javadocs-jdk25-html":  {
          "title": "SDK Javadoc for JDK 25",
          "content": "",
          "url": " /pages/javadocs/jdk25.html"
          },
          
          "latest-reference-manual-languages":  {
          "title": "Graal Languages",
          "content": "Graal LanguagesGraalVM provides runtimes for JavaScript, Python, and a number of other languages.GraalVM’s polyglot capabilities make it possible to mix multiple programming languages in a single application while eliminating any foreign language call costs.If you are mostly interested in a specific language runtime on GraalVM, see the following:  Espresso  GraalJS  GraalPy  GraalWasm",
          "url": " /latest/reference-manual/languages/"
          },
          
          "native-image-libraries-and-frameworks":  {
          "title": "Libraries and Frameworks Ready for GraalVM Native Image",
          "content": "",
          "url": " /native-image/libraries-and-frameworks/"
          },
          
          "licensing-information":  {
          "title": "Licensing Information User Manual",
          "content": "",
          "url": " /licensing-information/"
          },
          
          "latest-getting-started-linux":  {
          "title": "Installation on Linux Platforms",
          "content": "Installation on Linux PlatformsGraalVM is available for Linux on x64 and AArch64 architectures.You can install GraalVM on Linux:  using SDKMAN!  from an archive  using script-friendly URLsSelect the installation option that you prefer.SDKMAN!Install Oracle GraalVM with SDKMAN!:sdk install java &amp;lt;version&amp;gt;-graalTo install GraalVM Community Edition, change the distribution from graal to graalce in the command.SDKMAN! helps you install and easily switch between JDKs.To check which GraalVM releases are available for installation, run:sdk list javaTo switch to the specified GraalVM version for your current terminal session, run:sdk use java &amp;lt;version&amp;gt;-graalTo set a version as the default for all new terminal sessions, run:sdk default java &amp;lt;version&amp;gt;-graalFrom an ArchiveInstall GraalVM from an archive (.tar.gz) for the current user into any location, without affecting other JDK installations.      Navigate to the GraalVM Downloads page. Select the Java version, Linux for the operating system, x64 or aarch64 for the architecture, and download.        Change to the directory where you want to install GraalVM, then move the .tar.gz file to that directory.    Unzip the archive:     tar -xzf graalvm-jdk-&amp;lt;version&amp;gt;_linux-&amp;lt;architecture&amp;gt;.tar.gz    There can be multiple JDKs installed on the machine. Configure the runtime environment:          Set the value of the JAVA_HOME environment variable to the installation directory:         export JAVA_HOME=/path/to/&amp;lt;graalvm&amp;gt;            Set the value of the PATH environment variable to the GraalVM bin/ directory:         export PATH=/path/to/&amp;lt;graalvm&amp;gt;/bin:$PATH            To confirm that the installation was successful, run the java -version command.Optionally, you can specify GraalVM as the default JRE or JDK installation in your Java IDE.Script-Friendly URLsScript-friendly URLs enable you to download GraalVM from a command line, or automatically in your script and Dockerfile by using a download URL. Substitute &amp;lt;version&amp;gt; and &amp;lt;architecture&amp;gt; with the JDK version and aarch64 or x64 architecture.# Download with wgetwget https://download.oracle.com/graalvm/&amp;lt;version&amp;gt;/latest/graalvm-jdk-&amp;lt;version&amp;gt;_linux-&amp;lt;architecture&amp;gt;_bin.tar.gz# Download with curlcurl https://download.oracle.com/graalvm/&amp;lt;version&amp;gt;/latest/graalvm-jdk-&amp;lt;version&amp;gt;_linux-&amp;lt;architecture&amp;gt;_bin.tar.gz# Download from archivecurl https://download.oracle.com/java/&amp;lt;version&amp;gt;/archive/jdk-&amp;lt;version&amp;gt;_linux-&amp;lt;architecture&amp;gt;_bin.tar.gzFor other installation options, visit the GraalVM Downloads page.Prerequisites for Native Image on LinuxNative Image depends on the local toolchain, including header files for the C library, glibc-devel, zlib, gcc, and/or libstdc++-static.These dependencies can be installed (if not yet installed) using a package manager on your Linux machine.On Oracle Linux use the yum package manager:sudo yum install gcc glibc-devel zlib-develSome Linux distributions may additionally require libstdc++-static.You can install libstdc++-static if the optional repositories are enabled (ol7_optional_latest on Oracle Linux 7, ol8_codeready_builder on Oracle Linux 8, and ol9_codeready_builder on Oracle Linux 9).On Ubuntu Linux use the apt-get package manager:sudo apt-get install build-essential zlib1g-devOn other Linux distributions use the dnf package manager:sudo dnf install gcc glibc-devel zlib-devel libstdc++-static",
          "url": " /latest/getting-started/linux/"
          },
          
          "latest-tools-lsp":  {
          "title": "Language Server Protocol",
          "content": "Language Server ProtocolGraalVM supports Language Server Protocol (LSP) for guest languages.It provides features like code-completion, find usages and alike for the client tools – IDEs such as Visual Studio Code.To start the GraalVM Language Server, pass the --lsp option to the command line launcher as in the following example with a Node.js application.Note: The GraalVM Language Server is offered as a technology preview and requires the user to pass the --experimental-options option for its activation.$JAVA_HOME/bin/node --experimental-options --lsp app.js[Graal LSP] Starting server and listening on localhost/127.0.0.1:8123Example app listening on port 3000!Oracle GraalVM-provided code completion for R script, part of the Node.js Polyglot applicationThe GraalVM Language Server itself does not provide the static data usually gathered by parsing the application sources (as these data are sometimes fuzzy in the cases of dynamic languages).Instead, the Language Server was designed to provide the accurate dynamic data gathered from the application runtime.However, the Language Server could delegate to the existing language servers written specially for the particular languages (using the --lsp.Delegates launcher option) and merge the static data returned from these servers with its own dynamic data to a single result.",
          "url": " /latest/tools/lsp/"
          },
          
          "latest-getting-started-macos":  {
          "title": "Installation on macOS Platforms",
          "content": "Installation on macOS PlatformsGraalVM is available for macOS on AArch64 architecture. Support for macOS on x64 architecture has been removed.You can install GraalVM on macOS:  using SDKMAN!  from an archive  using script-friendly URLsNote that on macOS the JDK installation path is: /Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home/.Select the installation option that you prefer.SDKMAN!Install Oracle GraalVM with SDKMAN!:sdk install java &amp;lt;version&amp;gt;-graalTo install GraalVM Community Edition, change the distribution from graal to graalce in the command.SDKMAN! helps you install and easily switch between JDKs.To check which GraalVM releases are available for installation, run:sdk list javaTo switch to the specified GraalVM version for your current terminal session, run:sdk use java &amp;lt;version&amp;gt;-graalTo set a version as the default for all new terminal sessions, run:sdk default java &amp;lt;version&amp;gt;-graalFrom an ArchiveInstall GraalVM from an archive (.tar.gz) for the current user into any location, without affecting other JDK installations.      Navigate to the GraalVM Downloads page. Select the Java version, macOS for the operating system, aarch64 for the architecture, and download.        Unzip the archive.     tar -xzf graalvm-jdk-&amp;lt;version&amp;gt;_macos-&amp;lt;architecture&amp;gt;.tar.gz    Alternatively, open the file in Finder.        Move the downloaded package to its proper location, the /Library/Java/JavaVirtualMachines/ directory. Since this is a system directory, sudo is required:     sudo mv graalvm-jdk-&amp;lt;version&amp;gt; /Library/Java/JavaVirtualMachines    To verify that the move is successful and to get a list of all installed JDKs, run /usr/libexec/java_home -V.        There can be multiple JDKs installed on the machine. The next step is to configure the runtime environment:        Set the JAVA_HOME environment variable to resolve to the GraalVM installation directory:    export JAVA_HOME=/Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home        Set the value of the PATH environment variable to the GraalVM bin/ directory:    export PATH=/Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home/bin:$PATH  To confirm that the installation was successful, run the java -version command.Optionally, you can specify GraalVM as the default JRE or JDK installation in your Java IDE.Script-Friendly URLsScript-friendly URLs enable you to download GraalVM from a command line, or automatically in your script and Dockerfile by using a download URL.Substitute &amp;lt;version&amp;gt; with the JDK version. Only aarch64 architecture is supported on macOS.# Download with wgetwget https://download.oracle.com/graalvm/&amp;lt;version&amp;gt;/latest/graalvm-jdk-&amp;lt;version&amp;gt;_macos-&amp;lt;architecture&amp;gt;_bin.tar.gz# Download with curlcurl https://download.oracle.com/graalvm/&amp;lt;version&amp;gt;/latest/graalvm-jdk-&amp;lt;version&amp;gt;_macos-&amp;lt;architecture&amp;gt;_bin.tar.gz# Download from archivecurl https://download.oracle.com/java/&amp;lt;version&amp;gt;/archive/jdk-&amp;lt;version&amp;gt;_macos-&amp;lt;architecture&amp;gt;_bin.tar.gzFor other installation options, visit the GraalVM Downloads page.Prerequisites for Native Image on macOSNative Image requires the Xcode command line tools.To install them, run:xcode-select --installInstallation NotesOn JAVA_HOME CommandThe information property file, Info.plist, is located in the top-level Contents/ directory.This allows GraalVM to integrate with the macOS-specific /usr/libexec/java_home mechanism.Depending on other installed JDKs, running /usr/libexec/java_home -v&amp;lt;version&amp;gt; may return /Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home.To view all JVMs recognized by java_home, run /usr/libexec/java_home -V. This command lists JVMs in descending version order.",
          "url": " /latest/getting-started/macos/"
          },
          
          "community-summit":  {
          "title": "Community Summit",
          "content": "",
          "url": " /community/summit/"
          },
          
          "js-mle-oracle-db":  {
          "title": "JavaScript in the Oracle Database",
          "content": "JavaScript in the Oracle DatabaseThis page describes how to run JavaScript in an Oracle Database using the Oracle Database Multilingual Engine (MLE).MLE is powered by GraalVM: it can run JavaScript code in Oracle Database 23ai (and later) on Linux x64.Preparation  Get an Oracle Cloud Free Tier account and choose a home region that offers Oracle Database 23ai or later.  Provision an Autonomous Database Transaction Processing instance and start your favorite SQL IDE, such as one of the following:          Oracle SQL Developer      Oracle Database Actions      SQL Developer for VS Code              Prerequisites: see the section titled “Prerequisites for using JavaScript in Oracle Database 23c Free - Developer Release” in Introduction to JavaScript in Oracle Database 23c Free - Developer Release. (Although targeted at an earlier release, they are still valid.)      ExamplesThe examples assume that you have created a database account with the necessary privileges to create MLE modules and environments, as well as PL/SQL functions, procedures, and packages.The account has also been granted the privilege to execute JavaScript code.(For more information, see MLE Security.)      The first example shows how to create an MLE module.     create or replace mle module helper_module_inline language javascript as /** * Convert a delimited string into key-value pairs and return JSON * @param {string} inputString - the input string to be converted * @returns {JSON} */ function string2obj(inputString) {     if ( inputString === undefined ) {         throw `must provide a string in the form of key1=value1;...;keyN=valueN`;     }     let myObject = {};     if ( inputString.length === 0 ) {         return myObject;     }     const kvPairs = inputString.split(&quot;;&quot;);     kvPairs.forEach( pair =&amp;gt; {         const tuple = pair.split(&quot;=&quot;);         if ( tuple.length === 1 ) {             tuple[1] = false;         } else if ( tuple.length != 2 ) {             throw &quot;parse error: you need to use exactly one &#39;=&#39; between &quot; +                     &quot;key and value and not use &#39;=&#39; in either key or value&quot;;         }         myObject[tuple[0]] = tuple[1];     });     return myObject; } /** * Convert a JavaScript object to a string * @param {object} inputObject - the object to transform to a string * @returns {string} */ function obj2String(inputObject) {     if ( typeof inputObject != &#39;object&#39; ) {         throw &quot;inputObject isn&#39;t an object&quot;;     }     return JSON.stringify(inputObject); } export { string2obj, obj2String } /          Note: MLE only supports ECMA Script modules. CommonJS and other popular techniques are not available.        The above module defines two functions:          string2obj()      obj2Str()        The export keyword at end of the module means that these functions can be called by other MLE modules, PL/SQL, as well as SQL.        The second example shows how to make these functions available in SQL and PL/SQL.Functions within JavaScript modules cannot be called directly in SQL and PL/SQL.Instead, you create a call specification for them.A call specification can be thought of as a “wrapper” in PL/SQL.Depending on your requirements you can either use standalone functions and procedures, or group them in a package.Since these two functions belong to the helper_module they go in a package.     create or replace package helper_pkg as     function string2obj(         p_inputString varchar2     ) return JSON         as mle module helper_module_inline         signature &#39;string2obj&#39;;     function obj2String(         p_inputObject JSON     ) return varchar2         as mle module helper_module_inline         signature &#39;obj2String&#39;; end helper_pkg; /    With the call specification in place you can convert a string, delimited by ; into a JavaScript object and return it to the caller, as follows     select json_serialize(     helper_pkg.string2obj(         &#39;order_id=1;order_date=2023-04-24T10:27:52;order_mode=mail;promotion_id=1&#39;     )     pretty ) string2obj;    You should see the following output:     STRING2OBJ ---------------------------------------- {     &quot;order_id&quot; : &quot;1&quot;,     &quot;order_date&quot; : &quot;2023-04-24T10:27:52&quot;,     &quot;order_mode&quot; : &quot;mail&quot;,     &quot;promotion_id&quot; : &quot;1&quot;         }        Beginning with Oracle Database 23.3 it is possible to provide the JavaScript code in line with the call specification if all you need to do is invoke a standard piece of JavaScript code, as shown below:     create or replace function date_to_epoch(   &quot;ts&quot; timestamp ) return number as mle language javascript ; /    Inline JavaScript procedures have some limitations, e.g. they cannot import other MLE modules (they can, however require the libraries that ship with MLE). This is why you should consider using MLE modules for writing more complex logic and/or making it re-usable within other modules. You can now invoke the date_to_epoch() function directly from SQL as shown in this example:     select   date_to_epoch (     to_timestamp(&#39;2000-01-01 12:00:00&#39;, &#39;yyyy-mm-dd hh24:mi:ss&#39;)   ) seconds_since_epoch /        You can invoke MLE modules from other modules. This is typically the case when CREATING more complex logic, or third-party modules. Load the popular validator.js module into the database as described in Using JavaScript community modules in Oracle Database 23c Free - Developer Release—adhering to the caveats such as license and compliance. Now you can import the ECMASCript (ESM) version of the module from your favorite Content Delivery Network (CDN), as described in the article above.  Assume the validator module is created as validator_module in the database.  You can use the module in your own code as follows:     create or replace mle module validator_usage_demo_module language javascript as import validator from &#39;validator&#39;; export function emailCheck(str) {   return validator.isEMail(str); }    The element that maps the import name (validator) to the module is called an MLE environment. Because there is no file system that MLE can use to resolve import names, you have to explicitly declare the mapping, as follows:     create or replace mle env validator_env imports (   &#39;validator&#39; module validator_module );    The MLE environment helps map import names to modules in call specifications. If you want to expose the SQL function emailCheck(), then create the following call specification:     create or replace function email_check(p_str varchar2) return boolean as mle module validator_usage_demo_module env validator_env signature &#39;emailCheck&#39;; /    Now you can call email_check almost anywhere.  Type ConversionsKnowing how type conversions work is very important—whenever your code “leaves” SQL or PL/SQL, the types must be converted to their analogous JavaScript types.(For more information about Type Conversions, see MLE Type Conversions.)You may know that a JavaScript Number is implemented as a double-precision 64-bit binary format IEEE 754 value.There might be problems with the maximum number it can store as well as loss of precision.The following examples demonstrate the potential loss of precision.create table demo_table (  id      number constraint pk_demo_table primary key,  value   number not null);insert into demo_table(  id,  value) values  (1, 0.1),  (2, 0.2);create or replace procedure precision_loss(  &quot;id1&quot; demo_table.id%type,  &quot;id2&quot; demo_table.id%type)as mle language javascript;/begin precision_loss(1, 2); end;/The precision_loss() procedure prints a value of 0.30000000000000004 to the console (instead of 0.3).To circumvent the loss of precision you can follow many strategies laid out in Calling PL/SQL and SQL from the MLE JavaScript SQL Driver.One approach is to instruct the SQL driver to return the number as the type OracleNumber: a wrapper type for Oracle’s Number data type in JavaScript:create or replace procedure precision_preserved(  &quot;id1&quot; demo_table.id%type,  &quot;id2&quot; demo_table.id%type)as mle language javascript;/begin precision_preserved(1, 2); end;/The precision_preserved() procedure now prints the correct result (0.3) to the console.Wrapper data types are documented in the mle-js-plsqltypes module.Whenever you require number precision, consider using one of the wrapper data types.Dynamic JavaScript executionOracle Database 21c introduced MLE in form of the DBMS_MLE package.It is still available, however its focus has shifted to framework developers and embedding into REPL (Read Eval Print Loop) systems.APEX, Database Actions and others use the package under the covers.Here is a basic example how to code with DBMS_MLE:set serveroutput on;declare    l_ctx           dbms_mle.context_handle_t;    l_source_code   clob;begin    -- Create execution context for MLE execution    l_ctx    := dbms_mle.create_context();    -- using q-quotes to avoid problems with unwanted string termination    l_source_code :=q&#39;~    const result = session.execute(        `select &#39;hello, world&#39;`,        [],        {            outFormat: oracledb.OUT_FORMAT_ARRAY        }    );    const message = result.rows[0][0];    console.log(message);   ~&#39;;    dbms_mle.eval(        context_handle =&amp;gt; l_ctx,        language_id =&amp;gt; &#39;JAVASCRIPT&#39;,        source =&amp;gt; l_source_code,        source_name =&amp;gt; &#39;example01&#39;    );    dbms_mle.drop_context(l_ctx);exception    when others then        dbms_mle.drop_context(l_ctx);        raise;end;/The anonymous PL/SQL block prints hello, world to the console.If you want to use modules other than those built into MLE, you must use MLE environments.Building on the foundation laid by the previously created validator_env, you can verify an email using DBMS_MLE as follows:set serveroutput on;declare    l_ctx           dbms_mle.context_handle_t;    l_source_code   clob;begin    -- Create execution context for MLE execution and provide an environment    l_ctx    := dbms_mle.create_context(&#39;VALIDATOR_ENV&#39;);    -- using q-quotes to avoid problems with unwanted string termination    l_source_code :=q&#39;~(async() =&amp;gt; {  const { default: validator } = await import (&#39;validator&#39;);  const str = &#39;not an email address&#39;;  console.log(`Is ${str} a valid email address? ${validator.isEmail(str)}`);})()   ~&#39;;    dbms_mle.eval(        context_handle =&amp;gt; l_ctx,        language_id =&amp;gt; &#39;JAVASCRIPT&#39;,        source =&amp;gt; l_source_code,        source_name =&amp;gt; &#39;example02&#39;    );    dbms_mle.drop_context(l_ctx);exception    when others then        dbms_mle.drop_context(l_ctx);        raise;end;/You cannot use static import statements because DBMS_MLE evaluates JavaScript code in script mode.However, you can use dynamic imports as illustrated in the snippet above.  APEX and Database Actions are great tools because they allow you to focus on writing JavaScript (l_source_code in the above example).Related Documentation  Oracle® Database JavaScript Developer’s Guide.  Martin Bach’s blog posts on using JavaScript in Oracle Database.  Using MLE Modules.",
          "url": " /js/mle-oracle-db/"
          },
          
          "native-image":  {
          "title": "Native Image",
          "content": "",
          "url": " /native-image/"
          },
          
          "latest-security-guide-native-image":  {
          "title": "Security Considerations in Native Image",
          "content": "Security Considerations in Native ImageThe native-image builder generates a snapshot of an application after startup and bundles it in a binary executable.The security report section of the native image build output provides security relevant information about the native image build.Class InitializationThe native-image builder may execute the static initializers of certain classes at build time (see class initialization for more details).Executing static initializers at build time persists the state after initialization in the image heap.This means that any information that is obtained or computed in static initializers becomes part of a native executable.This can either result in sensitive data ending up in the snapshot or fixing initialization data that is supposed to be obtained at startup, such as random number seeds.Developers can request static initializers that process sensitive information to be executed at run time by specifying the --initialize-at-run-time CLI parameter when building a native executable, followed by a comma-separated list of packages and classes (and implicitly all of their subclasses) that must be initialized at runtime and not during image building.Alternatively developers can make use of the RuntimeClassInitialization API.Developers should run the native-image builder in a dedicated environment, such as a container, that does not contain any sensitive information in the first place.Software Bill of MaterialsNative Image can embed a Software Bill of Materials (SBOM) which is an inventory of all the components, libraries, and modules that make up an application.Read more in Software Bill of Materials (SBOM) in Native Image.ObfuscationNative Image provides strong obfuscation capabilities by default through native compilation and aggressive optimizations. For an additional layer of protection, use the experimental Advanced Obfuscation feature to obfuscate symbol names (module, package, class, method, field, and source file names).Obfuscation makes reverse engineering more difficult and helps protect intellectual property.Java serializationNative Image supports Serialization to help users deserialize the constructors for classes, contained in a native executable.Unless picked up by native image analysis automatically, these classes have to be prespecified, as classes not contained in a native executable cannot be deserialized.Native Image cannot prevent exploitation of deserialization vulnerabilities in isolation.The serialization and deserialization Secure Coding Guidelines for Java SE should be followed.The security report section of the native image build output provides information on whether deserialization code is part of a native image’s attack surface or not.MiscellaneousSetting the security manager is not allowed. For more information see the compatibility documentation.Native Image provides multiple ways to specify a certificate file used to define the default TrustStore.While the default behavior for native-image is to capture and use the default TrustStore from the build-time host environment, this can be changed at run time by setting the “javax.net.ssl.trustStore*” system properties.See the documentation for more details.The directory containing the native executable is part of the search path when loading native libraries using System.loadLibrary() at run time.Native Image will not allow a Java Security Manager to be enabled because this functionality has now deprecated since Java 17.Attempting to set a security manager will trigger a runtime error.Related Documentation  Security Guide  Sandboxing  Jipher JCE with Native Image",
          "url": " /latest/security-guide/native-image/"
          },
          
          "reference-manual-native-image-guides":  {
          "title": "User Guides",
          "content": "",
          "url": " /reference-manual/native-image/guides/"
          },
          
          "community-opensource":  {
          "title": "GraalVM Open Source",
          "content": "",
          "url": " /community/opensource/"
          },
          
          "latest-reference-manual-native-image-guides-optimize-for-file-size":  {
          "title": "Optimize a Native Executable for File Size",
          "content": "Optimize a Native Executable for File SizeYou can optimize your native executable by taking advantage of different optimization levels. This guide will demonstrate how to create small native executables for a given application, using the optimization for size, -Os.  -Os enables -O2 optimizations except those that can increase code or executable size significantly. Typically, it creates the smallest possible executables at the cost of reduced performance. Learn more in Optimization Levels.PrerequisiteMake sure you have installed Oracle GraalVM for JDK 23 or later.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.For the demo, run a “fortune teller” application that simulates the traditional fortune Unix program (for more information, see fortune).  Clone the GraalVM Demos repository:     git clone https://github.com/graalvm/graalvm-demos.git    Change directory to fortune-demo/fortune-maven:     cd native-image/native-build-tools/maven-plugin  Build a Native Executable with Default Configuration  Create a native executable using the Maven plugin for Native Image building:     ./mvnw -Pnative package    The command compiles the project, creates a JAR file with all dependencies, and then generates a native executable, fortune, in the target directory.    (Optional) Run the application:     ./target/fortune    The application will return a random saying.    Check the file size which should be around 13M:     du -h target/fortune  Build a Native Executable Optimized for SizeNext create a native executable with the size optimization on, giving a different name for the output file to differentiate it from the previous build.  Open the pom.xml file. Find the native-maven-plugin declaration, and notice the following build arguments within the &amp;lt;configuration&amp;gt; element:     &amp;lt;configuration&amp;gt;     &amp;lt;imageName&amp;gt;fortune-optimized&amp;lt;/imageName&amp;gt;     &amp;lt;buildArgs&amp;gt;         &amp;lt;buildArg&amp;gt;-Os&amp;lt;/buildArg&amp;gt;         &amp;lt;buildArg&amp;gt;--emit build-report&amp;lt;/buildArg&amp;gt;     &amp;lt;/buildArgs&amp;gt; &amp;lt;/configuration&amp;gt;    The -Os option enables size optimization.  The option --emit build-report generates a Build Report along with other artifacts in the target directory.    Create the second native executable:     ./mvnw -Pnative package    The command generates an executable file, fortune-optimized, in the target directory.    Compare the sizes of all relevant output files:     du -h target/fortune*    You should see the output similar to this:     13M    target/fortune 16K    target/fortune-1.0-SNAPSHOT.jar 9.8M   target/fortune-optimized 1.9M   target/fortune-optimized-build-report.html    The file size decreased from 13M to 9.8M!  How much the file size can be reduced by the -Os option varies between applications, and depends on how much Native Image applies inlining and other optimizations that increase size in the default -O2 mode.The build report generated in the previous step, fortune-optimized-build-report.html, tells exactly what was included in your native executable.It is an HTML file that you can open in a regular web browser.In case your native executable is quite large in file size, you may want to review the list of embedded resources, the list of modules and packages included in the code area, or the list of object types in the image heap, and check whether these elements are essential for your application.Sometimes, large files are accidentally embedded as a resource due to erroneous regular expression patterns in the resource configuration of reachability metadata.Registering wrong or too many Java types for reflection can also increase the size of a native executable significantly, by making unnecessary parts of the application, libraries, or the JDK reachable by accident.Moreover, build-time initialization, if not used towards a specific goal, can cause large Java objects such as empty caches to be accidentally included in the image heap and, thus, cause bloat in a native executable.Generally, it is a good idea to check file size, number of embedded resources, or other metrics from time to time, for example, when adding or updating dependencies, or even monitor build metrics frequently.For this, you can use the machine-readable version of the build output or the build reports for GitHub Actions.There are other Native Image techniques that can positively affect the executable size, besides improving other metrics, for example, Profile-Guided Optimization (PGO).Related Documentation  Optimizations and Performance",
          "url": " /latest/reference-manual/native-image/guides/optimize-for-file-size/"
          },
          
          "latest-reference-manual-native-image-guides-optimize-memory-footprint":  {
          "title": "Optimize Memory Footprint of a Native Executable",
          "content": "Optimize Memory Footprint of a Native ExecutableChoosing an appropriate garbage collector and tailoring the garbage collection configuration can reduce GC times and memory footprint.When running a native image, Java heap settings are determined based on the system configuration and GC.You can override the default configuration to further improve your use case on the relevant metrics.This guide demonstrates how to optimize an application in the area of memory consumption and trade off between GC pause times, memory footprint, and performance.PrerequisiteMake sure you have installed Oracle GraalVM for JDK 23 or later.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.1. Prepare the ApplicationA Java application that does some heavy text processing, like log analysis, where large strings are frequently concatenated, split, or manipulated, is a good approach to stress test the garbage collector.The application you will use generates a significant number of temporary strings putting pressure on the GC.  Save the following Java code in a file named StringManipulation.java:     import java.util.ArrayDeque; public class StringManipulation {     public static void main(String[] args) {         System.out.println(&quot;Starting string manipulation GC stress test...&quot;);         // Parse arguments         int iterations = 1000000;         int numKeptAliveObjects = 100000;         if (args.length &amp;gt; 0) {             iterations = Integer.parseInt(args[0]);         }         if (args.length &amp;gt; 1) {             numKeptAliveObjects = Integer.parseInt(args[1]);         }         ArrayDeque&amp;lt;String[]&amp;gt; aliveData = new ArrayDeque&amp;lt;String[]&amp;gt;(numKeptAliveObjects + 1);         for (int i = 0; i &amp;lt; iterations; i++) {             // Simulate log entry generation and log entry splitting. The last n entries are kept in memory.             String base = &quot;log-entry&quot;;             StringBuilder builder = new StringBuilder(base);             for (int j = 0; j &amp;lt; 100; j++) {                 builder.append(&quot;-&quot;).append(System.nanoTime());             }             String logEntry = builder.toString();             String[] parts = logEntry.split(&quot;-&quot;);             aliveData.addLast(parts);             if (aliveData.size() &amp;gt; numKeptAliveObjects) {                 aliveData.removeFirst();             }             // Periodically log progress             if (i % 100000 == 0) {                 System.out.println(&quot;Processed &quot; + i + &quot; log entries&quot;);             }         }         System.out.println(&quot;String manipulation GC stress test completed: &quot; + aliveData.hashCode());     } }    At run time, you specify on the command line how long this application should run (the 1st argument, number of iterations) and how much memory it should keep alive (the 2nd argument).    Compile and run the application on HotSpot, timing the results:     javac StringManipulation.java     /usr/bin/time java StringManipulation 500000 50000    On a machine with 48GB of memory, 8 CPUs, and the default G1 GC on HotSpot, the results should be similar, displaying the user and elapsed time, system CPU usage, and the maximum memory usage required to execute this request:     Starting string manipulation GC stress test... Processed 0 log entries Processed 100000 log entries Processed 200000 log entries Processed 300000 log entries Processed 400000 log entries String manipulation GC stress test completed: 1791741888 6.61user 0.57system 0:03.35elapsed 214%CPU (0avgtext+0avgdata 4046128maxresident)k 0inputs+64outputs (8major+39776minor)pagefaults 0swaps    The results show a wall-clock time of 3.35 seconds, a total CPU time of 6.61 seconds + 0.57 seconds (indicating actual CPU usage), and a maximum memory usage of 3.85GB (resident set size, RSS).  2. Build a Native Image with Default GCNow compile this application ahead of time with the default garbage collector in Native Image which is Serial GC.Serial GC is a non-parallel, stop and copy GC optimized for low memory footprint and small Java heap sizes.  Build with native-image:     native-image -o testgc-serial StringManipulation    The -o option defines the name of the output file to be generated.    The build output prints the GC information at the Initialization stage which is:     [1/8] Initializing... ... Garbage collector: Serial GC (max heap size: 80% of RAM) ...    Run the native executable with the same arguments, timing the results:     /usr/bin/time ./testgc-serial 500000 50000    The resources usage is now different:     Starting string manipulation GC stress test... ... 8.82user 1.24system 0:10.10elapsed 99%CPU (0avgtext+0avgdata 611272maxresident)k 0inputs+0outputs (0major+854664minor)pagefaults 0swaps    When using the default GC, this benchmark shows higher elapsed time but a lower maximum resident set size compared to the HotSpot run above.    Get more insights for this GC by passing -XX:+PrintGC at run time to print the logs:     /usr/bin/time ./testgc-serial 500000 50000 -XX:+PrintGC    Notice that pause times are high with Serial GC, which can be a problem for applications where latency is important. For example:     [9.301s] GC(55) Pause Full GC (Collect on allocation) 400.19M-&amp;gt;214.69M 318.384ms    Here, the GC paused the application for 318.384ms.  3. Build a Native Image with G1 GCThe next step is to change the garbage collector. Native Image supports the G1 garbage collector by passing --gc=G1 to the native-image builder. G1 GC is a generational, incremental, parallel, mostly concurrent, stop-the-world GC, recommended for improving latency and throughput of the application.  G1 GC is available with Oracle GraalVM and supported on Linux only.  We recommend using G1 GC in combination with Profile-Guided Optimization (PGO) for the best application performance. However, PGO is not applied in this guide to keep the instructions straightforward.  Build the second native executable with G1 GC, specifing a different name for the output file, so the executables will not overwrite each other:     native-image --gc=G1 -o testgc-g1 StringManipulation    The build output now prints a different GC information:     [1/8] Initializing... ... Garbage collector: G1 GC (max heap size: 25.0% of RAM)    Run this native executable with the same arguments, passing also -XX:+PrintGC to get more insights into pause times, and compare the results:     /usr/bin/time ./testgc-g1 500000 50000 -XX:+PrintGC     ... Processed 300000 log entries [2.705s][info][gc] GC(16) Pause Young (Normal) (G1 Evacuation Pause) 2301M-&amp;gt;1690M(4840M) 25.144ms Processed 400000 log entries [3.322s][info][gc] GC(17) Pause Young (Normal) (G1 Evacuation Pause) 2715M-&amp;gt;1870M(4840M) 20.364ms String manipulation GC stress test completed: 305943342 5.77user 0.47system 0:03.85elapsed 161%CPU (0avgtext+0avgdata 3707920maxresident)k 0inputs+0outputs (0major+12980minor)pagefaults 0swaps    G1 GC is significantly faster than Serial GC, so the wall-clock time drops from 10.1s to 3.85s. Pause times are much better! However, memory usage with G1 GC is higher than with Serial GC.    When compared with the HotSpot execution above (which also uses the G1 GC), performance is on the same level, while memory usage is lower (3.68GB versus 3.85GB) because objects are more compact in Native Image than on HotSpot. The total CPU time is lower as well.  4. Build a Native Image with Epsilon GCThere is one more garbage collector supported by Native Image: Epsilon GC.Epsilon GC is a no-op garbage collector that does not do any garbage collection and therefore never frees any allocated memory.The primary use case for this GC are very short running applications that only allocate a small amount of memory.Epsilon GC should only be used in very specific cases.We recommend always comparing Epsilon GC against the default GC (Serial GC) to determine if Epsilon GC really provides an actual benefit for your application.  To enable the Epsilon GC, pass --gc=epsilon at image build time:     native-image --gc=epsilon -o testgc-epsilon StringManipulation    The build output reports about Epsilon GC being used:     [1/8] Initializing... ... Garbage collector: Epsilon GC (max heap size: 80% of RAM)    Run this native image but increase the number of iterations:     /usr/bin/time ./testgc-epsilon 3200000 50000     Starting string manipulation GC stress test... ... Processed 3100000 log entries Exception in thread &quot;main&quot;  Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;main&quot; PlatformThreads.ensureCurrentAssigned() failed during shutdown: java.lang.OutOfMemoryError: Could not allocate an aligned heap chunk because the heap address space is exhausted. Consider re-building the image with compressed references disabled (&#39;-H:-UseCompressedReferences&#39;). Command exited with non-zero status 1 21.07user 13.11system 0:34.25elapsed 99%CPU (0avgtext+0avgdata 33556824maxresident)k 0inputs+0outputs (0major+8387698minor)pagefaults 0swaps    The OutOfMemoryError exception happens because Epsilon GC does not do any garbage collection, and the heap is full at some point. You need to reduce how long this application should run.    The usage results are not comparable to the ones in the previous steps because more work was performed (more iterations).  5. Build a Native Image Setting the Maximum Heap SizeBy default, a native image will set its maximum Java heap size to 80% of the physical memory when using Serial or Epsilon GC, and to 25% when using G1 GC.For example, on a machine with 16GB of RAM, the maximum heap size will be set to 12.8GB with Serial or Epsilon GC.However, if you run on Oracle GraalVM with compressed references support enabled, the maximum Java heap cannot be larger than 32GB.This information can be found in the output for each build.To override the default behavior, you can explicitly set the maximum heap size.There are two ways to do that.5.1. Set the Maximum Heap Size at Run TimeThe first and recommended way is to build a native image with the default heap settings, and then override the maximum heap size in bytes at run time using -Xmx.Test this option with both Serial G1 and G1 GC native images.  Serial GC:     /usr/bin/time ./testgc-serial -Xmx512m 500000 50000     Starting string manipulation GC stress test... ... 9.53user 1.40system 0:10.99elapsed 99%CPU (0avgtext+0avgdata 590404maxresident)k 0inputs+0outputs (0major+953535minor)pagefaults 0swaps    G1 GC:     /usr/bin/time ./testgc-g1 -Xmx512m 500000 50000     Starting string manipulation GC stress test... ... 14.99user 0.41system 0:05.13elapsed 300%CPU (0avgtext+0avgdata 554004maxresident)k 0inputs+0outputs (0major+5622minor)pagefaults 0swaps  5.2. Define the Maximum Heap Size at Build TimeThe second way is to build a native image and set a new default value for the maximum heap size using the -R:MaxHeapSize option.This default will then be used at run time, unless it is explicitly overridden at run time by passing the -X... or -XX:... options.  Create a new native executable:     native-image --gc=G1 -R:MaxHeapSize=512m -o testgc-maxheapset-g1 StringManipulation    Notice the updated GC information:     [1/8] Initializing... ... Garbage collector: G1 GC (max heap size: 512.00MB)    Run it with the same load:     /usr/bin/time ./testgc-maxheapset-g1 500000 50000    On this test machine, the results should match the previous numbers at step 5.1:     Starting string manipulation GC stress test... ... 14.87user 0.44system 0:05.33elapsed 287%CPU (0avgtext+0avgdata 552292maxresident)k 0inputs+0outputs (0major+5694minor)pagefaults 0swaps    Besides -Xmx, there are plenty of other GC-specific options that experts can use for performance tuning, for example, -XX:MaxGCPauseMillis to set target maximum pause times. Find a full list of performance tuning options in the reference documentation.SummarySelecting the right garbage collector and configuring a suitable garbage collection configuration can significantly reduce GC pauses and improve overall application responsiveness.You can achieve more predictable memory usage, helping your native application run more efficiently under varying workloads.This guide provides insights into choosing the best GC strategy depending on your application goals: low latency, minimal memory overhead, or optimal performance.Related Documentation  Memory Management in Native Image",
          "url": " /latest/reference-manual/native-image/guides/optimize-memory-footprint/"
          },
          
          "latest-reference-manual-native-image-guides-optimize-native-executable-size-using-build-report":  {
          "title": "Optimize Size of a Native Executable using Build Reports",
          "content": "Optimize Size of a Native Executable using Build ReportsYou can optimize your native executable by taking advantage of different tools provided with Native Image.The guide demonstrates how to use the Build Report tool to better understand the contents of a produced native executable, and how a small alteration in an application, without any semantic change, can influence the final binary size.  Note: Build Report is not available in GraalVM Community Edition.PrerequisitesMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.For the demo, you will run a simple Java application that extracts the i-th word from an input string.The words are delimited by commas and may be enclosed by an arbitrary number of whitespace characters.  Save the following Java code to a file named IthWord.java:    public class IthWord {  public static String input = &quot;foo     t , t bar ,      baz&quot;;   public static void main(String[] args) {       if (args.length &amp;lt; 1) {           System.out.println(&quot;Word index is required, please provide one first.&quot;);           return;       }       int i = Integer.parseInt(args[0]);       // Extract the word at the given index.       String[] words = input.split(&quot;s+,s+&quot;);       if (i &amp;gt;= words.length) {           System.out.printf(&quot;Cannot get the word #%d, there are only %d words.%n&quot;, i, words.length);           return;       }       System.out.printf(&quot;Word #%d is %s.%n&quot;, i, words[i]);   }}    Compile the application:    javac IthWord.java    (Optional) Test the application with some arbitrary argument to see the result:    java IthWord 1    The output should be:    Word #1 is bar.    Build a native executable from the class file along with a Build Report:    native-image IthWord --emit build-report    The command generates an executable file, ithword, in the current working directory.The Build Report file, ithword-build-report.html, is automatically created alongside the native executable.A link to the report is also listed in the Build artifacts section at the end of the build output.You can specify a different filename or path for the report by appending it to the build-report option, for example, --emit build-report=/tmp/custom-name-build-report.html.    (Optional) Run this executable with the same argument:    ./ithword 1    The output should be identical to the former one:    Word #1 is bar.        A Build Report is an HTML file. Open the report in a browser.First, you are greeted with the general summary about the image build. You can see the total image size above the Image Details chart in top-right:        The initial size looks as expected, but, for the reference, the size of a HelloWorld application is around 7 MB. So the difference is substantial, despite the fact that the code is quite straightforward.Continue with the investigation.        Go to the Code Area tab either by clicking its tab in the navigation or the corresponding bar in the chart.    The breakdown chart you see now visualizes how different packages relate to each other in terms of their bytecode size.Note that the shown packages contain only the methods found to be reachable by the static analysis.This means that the shown packages (and their classes) are the only ones that end up being compiled and are in the final binary.        The first conclusion you can draw is that the most of the code originates from either JDK or Native Image internal code — see that the IthWord class only contributes 0.013% of the total bytecode size of all the reachable methods.        Drill-down to the java package just by clicking it.Most of the reachable code (almost the half) comes from the java.util package.Also, you can notice that java.text and java.time packages contribute to almost 20% of the java package size.But does the application use these packages?            Drill-down to the text pacakge:        You now see that most of the reachable classes are used for text formatting (see the list of packages and classes below).By now, you can suspect that included formatting classes can only be reachable (although not actually used) from one place: System.out.printf.        Go back to the java package (by clicking the central circle or just the java name in the top of the chart).        Next drill-down to the time package:        Almost half of the package size comes from its format subpackage (similar to the situation in the java.text package).So, System.out.printf is your first opportunity for improving the binary size.    Go back to the initial application and simply switch from using System.out.printf to System.out.println:    public class IthWord {    public static String input = &quot;foo     t , t bar ,      baz&quot;;    public static void main(String[] args) {        if (args.length &amp;lt; 1) {            System.out.println(&quot;Word index is required, please provide one first.&quot;);            return;        }        int i = Integer.parseInt(args[0]);        // Extract the word at the given index.        String[] words = input.split(&quot;s+,s+&quot;);        if (i &amp;gt;= words.length) {            // Use System.out.println instead of System.out.printf.            System.out.println(&quot;Cannot get the word #&quot; + i + &quot;, there are only &quot; + words.length + &quot; words.&quot;);            return;        }        // Use System.out.println instead of System.out.printf.        System.out.println(&quot;Word #&quot; + i + &quot; is &quot; + words[i] + &quot;.&quot;);    }}        Repeat the steps 2-4 (compile the class file, build the native executable, and open the new report).        See in the Summary section that the total binary size got reduced by almost 40%:            Go to the Code Area tab again and drill-down to the java package.You can see that the initial assumption is correct: both java.text and java.time packages are not reachable anymore.        Continue to see if there is more reachable code that the application does not necessarily need.    As you may have guessed already, the other candidate resides in the java.util package, and is the regex subpackage.The package alone contributes nearly 15% of the java package size now.Notice that the regular expression (s+,s+) is used to split the original input into the words.Although very convenient, it makes the aforementioned regex package unnecessary dependency.The regular expression itself is not complex, and could be implemented differently.        Next go to the Image Heap tab to continue our exploration.The section provides a list of all object types that are part of the image heap: the heap that contains reachable objects such as static application data, metadata, and byte arrays for different purposes.In this case, the list looks as usual: most of the size comes from the raw string values stored in their dedicated byte array (around 20%), String and Class objects (around 20%), and also from code metadata (20%).        There are no specific object types that heavily contribute to the image heap in this application.But there is one unexpected entry: a small size contribution (~2%) is due to the resources that are embedded into the image heap.The application does not use any explicit resources, so this is unexpected.        Switch to the Resource tab to continue the investigation.This section provides a list of all the resources that are explicitly requested through the configuration file(s).There is also the option to toggle other kinds of resources (Missing resources, Injected resources, and Directory resources); however, this is beyond the scope of this guide.Learn more in Native Image Build Report.        To conclude this part, there is only one resource (java/lang/uniName.dat) that comes from the java.base module that also contributes to the image heap, but is not requested from the application code explicitly.You cannot do anything about this, but keep in mind that the JDK code (indirectly reachable from the user code) can also use the additional resources, which then adversely affect the size.    Now go back to the application code, and implement a new approach that does not use regular expressions.The following code uses String.substring and String.indexOf to preserve the semantics, but also keep the logic relatively simple:    public class IthWord {    public static String input = &quot;foo     t , t bar ,      baz&quot;;    public static void main(String[] args) {        if (args.length &amp;lt; 1) {           System.out.println(&quot;Word index is required, please provide one first.&quot;);           return;        }        int i = Integer.parseInt(args[0]);        // Extract the word at the given index using String.substring and String.indexOf.        String word = input;        int j = i, index;        while (j &amp;gt; 0) {           index = word.indexOf(&#39;,&#39;);           if (index &amp;lt; 0) {               // Use System.out.println instead of System.out.printf.               System.out.println(&quot;Cannot get the word #&quot; + i + &quot;, there are only &quot; + (i - j + 1) + &quot; words.&quot;);               return;           }           word = word.substring(index + 1);           j--;        }        index = word.indexOf(&#39;,&#39;);        if (index &amp;gt; 0) {           word = word.substring(0, word.indexOf(&#39;,&#39;));        }        word = word.trim();        // Use System.out.println instead of System.out.printf.        System.out.println(&quot;Word #&quot; + i + &quot; is &quot; + word + &quot;.&quot;);    }}        Repeat the steps 2-4 again (compile the class file, build the native executable, and open the new report).        Once more, you can see the improvement in the total binary size (around 15%) in the Summary section:        Additionally, a previously registered resource is not part of the generated binary anymore (see the Resources section again to confirm):      This guide demonstrated how to optimize the size of a native executable using Build Reports.Build Reports allow you to explore the contents of the generated native executables in greater detail.A better understanding of which code is reachable enables you to implement the application in a way that preserves its semantics while removing unnecessary JDK dependencies.Related Documentation  Native Image Build Report  Optimizations and Performance  Optimize a Native Executable for File Size",
          "url": " /latest/reference-manual/native-image/guides/optimize-native-executable-size-using-build-report/"
          },
          
          "latest-reference-manual-native-image-guides-optimize-native-executable-with-pgo":  {
          "title": "Optimize a Native Executable with Profile-Guided Optimization",
          "content": "Optimize a Native Executable with Profile-Guided OptimizationGraalVM Native Image offers quick startup and less memory consumption for a Java application, running as a native executable, by default. You can optimize this native executable even more for additional performance gain and higher throughput by applying Profile-Guided Optimization (PGO).With PGO you can collect the profiling data in advance, and then feed it to the native-image tool, which will use this information to optimize the performance of a native application.The general workflow is:  Build an instrumented native executable by passing the --pgo-instrument option to native-image.  Run the instrumented executable to generate a profile file. By default, the default.iprof file is generated in the current working directory and on application shutdown.  Build an optimized executable. The profile file with the default name and location will be picked up automatically. Alternatively, you can pass it to the native-image builder by specifying the file path: --pgo=myprofile.iprof.You can specify where to collect the profiles when running an instrumented native executable by passing the -XX:ProfilesDumpFile=YourFileName option at run time. You can also collect multiple profile files by specifying different filenames, and pass them to native-image at build time.Note that executing all relevant application code paths and giving the application enough time to collect profiles are essential for having complete profiling information and therefore the best performance.  Note: PGO is not available in GraalVM Community Edition.Find more information on this topic in the Profile-Guided Optimization reference documentation.Run a DemoFor the demo part, you will run a Java application performing queries implemented with the Java Streams API. A user is expected to provide two integer arguments: the number of iterations and the length of the data array. The application creates the data set with a deterministic random seed and iterates 10 times. The time taken for each iteration  and its checksum is printed to the console.Below is the stream expression to optimize:Arrays.stream(persons)   .filter(p -&amp;gt; p.getEmployment() == Employment.EMPLOYED)   .filter(p -&amp;gt; p.getSalary() &amp;gt; 100_000)   .mapToInt(Person::getAge)   .filter(age -&amp;gt; age &amp;gt; 40)   .average()   .getAsDouble();Follow these steps to build an optimized native executable using PGO.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.      Save the following code to the file named Streams.java:    import java.util.Arrays;import java.util.Random;public class Streams {  static final double EMPLOYMENT_RATIO = 0.5;  static final int MAX_AGE = 100;  static final int MAX_SALARY = 200_000;  public static void main(String[] args) {    int iterations;    int dataLength;    try {      iterations = Integer.valueOf(args[0]);      dataLength = Integer.valueOf(args[1]);    } catch (Throwable ex) {      System.out.println(&quot;Expected 2 integer arguments: number of iterations, length of data array&quot;);      return;    }    Random random = new Random(42);    Person[] persons = new Person[dataLength];    for (int i = 0; i &amp;lt; dataLength; i++) {      persons[i] = new Person(          random.nextDouble() &amp;gt;= EMPLOYMENT_RATIO ? Employment.EMPLOYED : Employment.UNEMPLOYED,          random.nextInt(MAX_SALARY),          random.nextInt(MAX_AGE));    }    long totalTime = 0;    for (int i = 1; i &amp;lt;= 20; i++) {      long startTime = System.currentTimeMillis();      long checksum = benchmark(iterations, persons);      long iterationTime = System.currentTimeMillis() - startTime;      totalTime += iterationTime;      System.out.println(&quot;Iteration &quot; + i + &quot; finished in &quot; + iterationTime + &quot; milliseconds with checksum &quot; + Long.toHexString(checksum));    }    System.out.println(&quot;TOTAL time: &quot; + totalTime);  }  static long benchmark(int iterations, Person[] persons) {    long checksum = 1;    for (int i = 0; i &amp;lt; iterations; ++i) {      double result = getValue(persons);      checksum = checksum * 31 + (long) result;    }    return checksum;  }  public static double getValue(Person[] persons) {    return Arrays.stream(persons)        .filter(p -&amp;gt; p.getEmployment() == Employment.EMPLOYED)        .filter(p -&amp;gt; p.getSalary() &amp;gt; 100_000)        .mapToInt(Person::getAge)        .filter(age -&amp;gt; age &amp;gt;= 40).average()        .getAsDouble();  }}enum Employment {  EMPLOYED, UNEMPLOYED}class Person {  private final Employment employment;  private final int age;  private final int salary;  public Person(Employment employment, int height, int age) {    this.employment = employment;    this.salary = height;    this.age = age;  }  public int getSalary() {    return salary;  }  public int getAge() {    return age;  }  public Employment getEmployment() {    return employment;  }}    Compile the application:    javac Streams.java    (Optional) Run the demo application, providing some arguments to observe performance.    java Streams 100000 200    Build a native executable from the class file, and run it to compare the performance:     native-image Streams    An executable file, streams, is created in the current working directory.  Now run it with the same arguments to see the performance:     ./streams 100000 200    This version of the program is expected to run slower than on GraalVM’s or any regular JDK.    Build an instrumented native executable by passing the --pgo-instrument option to native-image:     native-image --pgo-instrument Streams    Run it to collect the code-execution-frequency profiles:     ./streams 100000 20    Notice that you can profile with a much smaller data size. Profiles collected from this run are stored by default in the default.iprof file.    Finally, build an optimized native executable. The profile file has the default name and location, so it will be picked up automatically:     native-image --pgo Streams    Run this optimized native executable timing the execution to see the system resources and CPU usage:     time ./streams 100000 200    You should get the performance comparable to, or faster, than the Java version of the program. For example, on a machine with 16 GB of memory and 8 cores, the TOTAL time for 10 iterations reduced from ~2200 to ~270 milliseconds.  This guide showed how you can optimize native executables for additional performance gain and higher throughput.Oracle GraalVM offers extra benefits for building native executables, such as Profile-Guided Optimization (PGO). With PGO you “train” your application for specific workloads and significantly improve the performance.Related Documentation  Profile-Guided Optimization reference documentation  Optimize Cloud Native Java Apps with Oracle GraalVM PGO",
          "url": " /latest/reference-manual/native-image/guides/optimize-native-executable-with-pgo/"
          },
          
          "latest-reference-manual-polyglot-programming":  {
          "title": "Polyglot Programming",
          "content": "Polyglot Programming  Running Polyglot Applications  Polyglot Options  Passing Options for Language Launchers  Passing Options Programmatically  Passing Options Using JVM ArgumentsGraalVM allows users to write polyglot applications that seamlessly pass values from one language to another by means of the Truffle language implementation framework (henceforth “Truffle”).Truffle is a Java library for building programming languages implementations as interpreters for self-modifying Abstract Syntax Trees.When writing a language interpreter with Truffle, it will automatically use the Graal compiler as a just-in-time compiler for the language.By having access to this framework, a Ruby application, for example, can run on the same JVM as a Java application.Also, a host JVM-based language and a guest language can directly interoperate with each other and pass data back and forth in the same memory space.In order to provide foreign polyglot values in the languages implemented with Truffle, the so-called polyglot interoperability protocol has been developed.This interoperability protocol consists of a set of standardized messages that every language implements and uses for foreign polyglot values.The protocol allows GraalVM to support interoperability between any combination of languages without requiring them to know of each other.For more details, proceed to the High-Performance Cross-Language Interoperability in a Multi-Language Runtime paper.Throughout this section you learn how to combine multiple languages using GraalVM Polyglot APIs.Running Polyglot ApplicationsThe following examples are designed to get you started with a basic polyglot application.Select a section for your Start Language and then select a tab for the Target Language.The below examples are expected to work equally from a JVM or native standalone distribution.For native launchers and native executables using Java as a Target Language and accessing classes other than Java arrays, it is required to recompile the image and provide a reflection configuration file.Note: To start an application with LLVM as a Target Language, make sure to precompile the polyglot.c file provided below.Start from JavaScript / Node.jsCreate the file polyglot.js:              // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;)console.log(array[2]);// END-SNIPPET                        // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;)console.log(array[2]);// END-SNIPPET                        // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;)console.log(array[2]);// END-SNIPPET                        // BEGIN-SNIPPETvar array = new (Java.type(&quot;int[]&quot;))(4);array[2] = 42;console.log(array[2])// END-SNIPPET                        // BEGIN-SNIPPETvar cpart = Polyglot.evalFile(&quot;llvm&quot;, &quot;polyglot&quot;);cpart.main()// END-SNIPPET              R      Ruby      Python      Java      LLVM            Target Language      Run:js polyglot.js42node polyglot.js42Start Language RCreate the file polyglot.R:               # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;js&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                           # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                           # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;python&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                           # BEGIN-SNIPPETarray &amp;lt;- new(&quot;int[]&quot;, 4)array[3L] &amp;lt;- 42print(array[3L])# END-SNIPPET                           # BEGIN-SNIPPETcpart &amp;lt;- eval.polyglot(&quot;llvm&quot;, path=&quot;polyglot&quot;)cpart$main()# END-SNIPPET                JS      Ruby      Python      Java      LLVM            Target Language      Run:Rscript polyglot.R[1] 42Start Language RubyCreate the file polyglot.rb:              # BEGIN-SNIPPETarray = Polyglot.eval(&#39;js&#39;, &#39;[1,2,42,4]&#39;)puts array[2]# END-SNIPPET                          # BEGIN-SNIPPETarray = Polyglot.eval(&#39;R&#39;, &#39;c(1L,2L,42L,4L)&#39;)puts array[2]# END-SNIPPET                          # BEGIN-SNIPPETarray = Polyglot.eval(&#39;python&#39;, &#39;[1,2,42,4]&#39;)puts array[2]# END-SNIPPET                          # BEGIN-SNIPPETarray = Java.type(&#39;int[]&#39;).new(4)array[2] = 42print(array[2])# END-SNIPPET                          # BEGIN-SNIPPETcpart = Polyglot.eval_file(&#39;llvm&#39;, &#39;polyglot&#39;)cpart.main()# END-SNIPPET                JS      R      Python      Java      LLVM            Target Language      Run:ruby polyglot.rb42Start Language PythonCreate the file polyglot.py:              # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;js&quot;, string=&quot;[1,2,42,4]&quot;)print(array[2])# END-SNIPPET                        # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;R&quot;, string=&quot;c(1L,2L,42L,4L)&quot;)print(array[2])# END-SNIPPET                        # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;ruby&quot;, string=&quot;[1,2,42,4]&quot;)print(array[2])# END-SNIPPET                        # BEGIN-SNIPPETimport javaarray = java.type(&quot;int[]&quot;)(4)array[2] = 42print(array[2])# END-SNIPPET                        # BEGIN-SNIPPETimport polyglotcpart = polyglot.eval(language=&quot;llvm&quot;, path=&quot;polyglot&quot;)cpart.main()# END-SNIPPET              JS      R      Ruby      Java      LLVM            Target Language      Run:graalpy polyglot.py42Start Language JavaCreate the file Polyglot.java:              // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.create();        Value array = polyglot.eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                        // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        Value array = polyglot.eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                        // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        Value array = polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                        // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context context = Context.newBuilder().allowIO(true).build();        Value array = context.eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                        // BEGIN-SNIPPETimport java.io.*;import org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) throws IOException {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        File file = new File(&quot;polyglot&quot;);        Source source = Source.newBuilder(&quot;llvm&quot;, file).build();        Value cpart = polyglot.eval(source);        cpart.execute();    }}// END-SNIPPET              JS      R      Ruby      Python      LLVM            Target Language      Run:javac Polyglot.javajava Polyglot42Start Language CCreate the file polyglot.c:               // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                         // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                         // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                         // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                         // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 42);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET              JS      R      Ruby      Python      Java            Target Language      The example C code has to be compiled to LLVM bitcode using the LLVM frontend such as clang.A user can use clang from the pre-built LLVM toolchain shipped with the GraalVM LLVM runtime:export LLVM_TOOLCHAIN=$(lli --print-toolchain-path)Run:$LLVM_TOOLCHAIN/clang polyglot.c -lgraalvm-llvm -o polyglotlli polyglot42Polyglot OptionsYou can configure a language engine for better throughput or startup.  --engine.Mode=default configures the execution mode of the engine. The execution mode automatically tunes the polyglot engine towards latency or throughput.          throughput collects the maximum amount of profiling information and compiles using the  maximum number of optimizations. This mode results in slower application startup  but better throughput. This mode uses the compiler configuration community or  enterprise if not specified otherwise.      default uses a balanced engine configuration. This mode uses the compiler configuration community or enterprise if not specified otherwise.      latency collects only minimal profiling information and compiles as fast as possible  with less optimal-generated code. This mode results in faster application  startup but less optimal throughput. This mode uses the compiler configuration  economy if not specified otherwise.      Passing Options to Language LaunchersEvery language launcher has been extended with a set of so called polyglot options.Polyglot options allow users of any language launcher to access the options of other languages supported by GraalVM (implemented with the Truffle language implementation framework).The format is: --&amp;lt;languageID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.For example, the R launcher also supports the --js.atomics=true JavaScript option.Allowed values for the languageID are:  js: options for JavaScript  python: options for Python  r: options for R  ruby: options for Ruby  llvm: options for LLVMUse --help:languages to find out which options are available.Options for polyglot tools work in the same way with the following format: --&amp;lt;toolID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.Allowed values for &amp;lt;toolID&amp;gt; are:  inspect: allows debugging with Chrome DevTools  cpusampler: collects data about CPU usage  cputracer: captures trace information about CPU usage  memtracer: captures trace information about memory usageUse --help:tools to find out which options are available.Passing Options ProgrammaticallyOptions can also be passed programmatically using the Java polyglot API.Create a file called OptionsTest.java:import org.graalvm.polyglot.*;class OptionsTest {    public static void main(String[] args) {        Context polyglot = Context.newBuilder()            .allowExperimentalOptions(true)            .option(&quot;js.shared-array-buffer&quot;, &quot;true&quot;)            .build();        // the use of shared array buffer requires the &#39;js.shared-array-buffer&#39; option to be &#39;true&#39;        polyglot.eval(&quot;js&quot;, &quot;new SharedArrayBuffer(1024)&quot;);    }}Run:javac OptionsTest.javajava OptionsTest  Note: Tools options can be passed in the same way. Options cannot be modified after the context was created.Passing Options Using JVM ArgumentsEvery polyglot option can also be passed as a Java system property.Each available option translates to a system property with the polyglot. prefix.For example, -Dpolyglot.js.strict=true sets the default value for a strict interpretation for all JavaScript code that runs in the JVM.Options that were set programmatically take precedence over Java system properties.For languages the following format can be used: -Dpolyglot.&amp;lt;languageID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt; and for tools it is: -Dpolyglot.&amp;lt;toolID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.Create a file called SystemPropertiesTest.java:import org.graalvm.polyglot.*;class SystemPropertiesTest {    public static void main(String[] args) {        Context polyglot = Context.newBuilder()        .allowExperimentalOptions(true)        .build();        // the use of shared array buffer requires the &#39;js.shared-array-buffer&#39; option to be &#39;true&#39;        polyglot.eval(&quot;js&quot;, &quot;new SharedArrayBuffer(1024)&quot;);    }}Run:javac SystemPropertiesTest.javajava -Dpolyglot.js.strict=true SystemPropertiesTest  Note: System properties are read once when the polyglot context is created. Subsequent changes have no effect.Related Documentation  Learn more about a guest and Java host language interoperability from the Embedding Languages documentation",
          "url": " /latest/reference-manual/polyglot-programming/"
          },
          
          "latest-tools-vscode-graalvm-extension-polyglot-runtime":  {
          "title": "GraalVM Tools for Java",
          "content": "",
          "url": " /latest/tools/vscode/graalvm-extension/polyglot-runtime/"
          },
          
          "latest-security-guide-sandboxing":  {
          "title": "Sandboxing",
          "content": "SandboxingGraalVM allows a host application written in a JVM-based language to execute guest code written in Javascript or WebAssembly via the Polyglot API.Configured with a sandbox policy, a security boundary between a host application and guest code can be established.For example, host code can execute untrusted guest code using the UNTRUSTED policy.Host code can also execute multiple mutually distrusting instances of guest code that will be protected from one another.Used this way, sandboxing supports a multi-tenant scenario:Use cases that benefit from introducing a security boundary are:  Usage of third party code, i.e., pulling in a dependency. Third party code is typically trusted and scanned for vulnerabilities before use, but sandboxing them is an additional precaution against supply-chain attacks.  User plugins. Complex applications might allow users to install community-written plugins. Traditionally, those plugins are considered trusted and often run with full privileges, but ideally they should not be able to interfere with the application except when intended.  Server scripting. Allowing users to customize a server application with their own logic expressed in a general-purpose scripting language, for example, to implement custom data processing on a shared data source.Sandbox PoliciesDepending on the use case and the associated acceptable security risk, a SandboxPolicy can be chosen, ranging from TRUSTED to UNTRUSTED, enabling and configuring an increasing range of restrictions and mitigations.A SandboxPolicy serves two purposes: preconfiguration and validation of the final configuration.It preconfigures context and engine to comply to a policy by default.In case the configuration is further customized, validation of the policy will ensure that the custom configuration does not unacceptably weaken the policy.Trusted PolicyThe TRUSTED sandboxing policy is intended for guest code that is entirely trusted.This is the default mode.There are no restrictions to the context or engine configuration.Example:try (Context context = Context.newBuilder(&quot;js&quot;)                              .sandbox(SandboxPolicy.TRUSTED)                              .build();) {    context.eval(&quot;js&quot;, &quot;print(&#39;Hello JavaScript!&#39;);&quot;);}Constrained PolicyThe CONSTRAINED sandboxing policy is intended for trusted applications whose access to host resources should be regulated.The CONSTRAINED policy:  Requires the languages for a context to be set.  Disallows native access.  Disallows process creation.  Disallows system exit, prohibiting the guest code from terminating the entire VM where this is supported by the language.  Requires redirection of the standard output and error streams. This is to mitigate risks where external components, such as log processing, may be confused by unexpected writes to output streams by guest code.  Disallows host file or socket access. Only custom polyglot file system implementations are allowed.  Disallows environment access.  Restricts host access:          Disallows host class loading.      Disallows access to all public host classes and methods by default.      Disallows access inheritance.      Disallows implementation of arbitrary host classes and interfaces.      Disallows implementation of java.lang.FunctionalInterface.      Disallows host object mappings of mutable target types.The HostAccess.CONSTRAINED host access policy is preconfigured to fulfill the requirements for the CONSTRAINED sandboxing policy.      Example:try (Context context = Context.newBuilder(&quot;js&quot;)                              .sandbox(SandboxPolicy.CONSTRAINED)                              .out(new ByteArrayOutputStream())                              .err(new ByteArrayOutputStream())                              .build()) {    context.eval(&quot;js&quot;, &quot;print(&#39;Hello JavaScript!&#39;);&quot;);}Isolated PolicyThe ISOLATED sandboxing policy builds on top of the CONSTRAINED policy and is intended for trusted applications that may misbehave because of implementation bugs or processing of untrusted input.As the name already suggests, the ISOLATED policy enforces deeper isolation between host and guest code.In particular, guest code running with the ISOLATED policy will be executed in their own virtual machine, on a separate heap.This means that they no longer share runtime elements such as the JIT compiler or the garbage collector with the host application, making the host VM significantly more resilient against faults in the guest VM.In addition to the restrictions of the CONSTRAINED policy, the ISOLATED policy:  Requires method scoping to be enabled. This avoids cyclic dependencies between host and guest objects. The HostAccess.ISOLATED host access policy is preconfigured to fulfill the requirements for the ISOLATED sandboxing policy.  Requires setting the maximum isolate heap size. This is the heap size that will be used by the guest VM. If the engine is shared by multiple contexts, execution of these contexts will share the isolate heap.  Requires setting the host call stack headroom. This protects against host stack starving on upcalls to the host: the guest will be prohibited from performing an upcall if the remaining stack size drops below the specified value.  Requires setting the maximum CPU time limit. This restricts the workload to execute within the given time frame.Example:try (Context context = Context.newBuilder(&quot;js&quot;)                              .sandbox(SandboxPolicy.ISOLATED)                              .out(new ByteArrayOutputStream())                              .err(new ByteArrayOutputStream())                              .option(&quot;engine.MaxIsolateMemory&quot;, &quot;256MB&quot;)                              .option(&quot;sandbox.MaxCPUTime&quot;, &quot;2s&quot;)                              .build()) {    context.eval(&quot;js&quot;, &quot;print(&#39;Hello JavaScript!&#39;);&quot;);}Since Polyglot API version 23.1, the isolated and untrusted policy also requires isolated images of the languages to be specified on the class or module path.Isolated versions of the languages can be downloaded from Maven using the following dependency:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.polyglot&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;js-isolate&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.polyglot.version}&amp;lt;/version&amp;gt;    &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;/dependency&amp;gt;The Embedding Languages guide contains more details on using polyglot isolate dependencies.Untrusted PolicyThe UNTRUSTED sandboxing policy builds on top of the ISOLATED policy and is intended to mitigate risks from running actual untrusted code.The attack surface of GraalVM when running untrusted code consists of the entire guest VM that executes the code as well as the host entry points made available to guest code.In addition to the restrictions of the ISOLATED policy, the UNTRUSTED policy:  Requires redirection of the standard input stream.  Requires setting the maximum memory consumption of the guest code. This is a limit in addition to the maximum isolate heap size backed by a mechanism that keeps track of the size of objects allocated by the guest code on the guest VM heap. This limit can be thought of as a “soft” memory limit, whereas the isolate heap size is the “hard” limit.  Requires setting the maximum depth of any Abstract Syntax Tree (AST) of the guest code. This puts a bound on the stack space consumed by a single guest method.  Requires setting the maximum output and error stream sizes. As output and error streams have to be redirected, the receiving ends are on the host side. Limiting the output and error stream sizes protects against availability issues on the host.  Requires untrusted code mitigations to be enabled. Untrusted code mitigations address risks from JIT spraying and speculative execution attacks. They include constant blinding as well as masking memory accesses and use of speculative execution barriers.  Further restricts host access to ensure there are no implicit entry points to host code. This means that guest-code access to host arrays, lists, maps, buffers, iterables and iterators is disallowed. The reason is that there may be various implementations of these APIs on the host side, resulting in implicit entry points. In addition, direct mappings of guest implementations to host interfaces via HostAccess.Builder#allowImplementationsAnnotatedBy are disallowed. The HostAccess.UNTRUSTED host access policy is preconfigured to fulfill the requirements for the UNTRUSTED sandboxing policy.Example:try (Context context = Context.newBuilder(&quot;js&quot;)                              .sandbox(SandboxPolicy.UNTRUSTED)                              .in(new ByteArrayInputStream(&quot;foobar&quot;.getBytes()))                              .out(new ByteArrayOutputStream())                              .err(new ByteArrayOutputStream())                              .allowHostAccess(HostAccess.UNTRUSTED)                              .option(&quot;engine.MaxIsolateMemory&quot;, &quot;1024MB&quot;)                              .option(&quot;sandbox.MaxHeapMemory&quot;, &quot;128MB&quot;)                              .option(&quot;sandbox.MaxCPUTime&quot;,&quot;2s&quot;)                              .option(&quot;sandbox.MaxStatements&quot;,&quot;50000&quot;)                              .option(&quot;sandbox.MaxStackFrames&quot;,&quot;2&quot;)                              .option(&quot;sandbox.MaxThreads&quot;,&quot;1&quot;)                              .option(&quot;sandbox.MaxASTDepth&quot;,&quot;10&quot;)                              .option(&quot;sandbox.MaxOutputStreamSize&quot;,&quot;32B&quot;)                              .option(&quot;sandbox.MaxErrorStreamSize&quot;,&quot;0B&quot;);                              .build()) {    context.eval(&quot;js&quot;, &quot;print(&#39;Hello JavaScript!&#39;);&quot;);}For further information on how to set the resource limits, please refer to the corresponding guidance.Host AccessGraalVM allows exchanging objects between host and guest code and exposing host methods to guest code.When exposing host methods to less privileged guest code, these methods become part of the attack surface of the more privileged host code.Therefore the sandboxing policies already restrict host access in the CONSTRAINED policy to make host entry points explicit.HostAccess.CONSTRAINED is the predefined host access policy for the CONSTRAINED sandbox policy.To expose a host class method, it has to be annotated with @HostAccess.Export.This annotation is not inherited.Service providers such as Polyglot API FileSystem implementations or output stream recipients for standard output and error stream redirections are exposed to guest code invocations.Guest code can also implement a Java interface that has been annotated with @Implementable.Host code using such an interface directly interacts with guest code.Host code that interacts with guest code has to be implemented in a robust manner:  Input validation. All data passed from the guest, for example, via parameters to an exposed method, is untrusted and should be thoroughly validated by host code where applicable.  Reentrancy. Exposed host code should be reentrant as guest code may invoke it at any time. Do note that simply applying the synchronized keyword to a code block does not necessarily make it reentrant.  Thread-safety. Exposed host code should be thread-safe as guest code may invoke them from multiple threads at the same time.  Resource consumption. Exposed host code should be aware of its resource consumption. In particular, constructs that allocate memory based on untrusted input data, either directly or indirectly, for example, through recursion, should either be avoided altogether or implement limits.  Privileged functionality. Restrictions enforced by the sandbox can be entirely bypassed by exposing host methods that provide restricted functionality. For example, guest code with a CONSTRAINED sandbox policy cannot perform host file IO operations. However, exposing a host method to the context that allows writing to arbitrary files effectively bypasses this restriction.  Side channels. Depending on the guest language, guest code may have access to timing information. For example, in Javascript the Date() object provides fine-grained timing information. In the UNTRUSTED sandbox policy the granularity of Javascript timers is preconfigured to one second and can be lowered to 100 milliseconds. However, host code should be aware that guest code may time its execution, potentially discovering secret information if the host code performs secret-depending processing.Host code that is unaware of interacting with untrusted guest code should never be directly exposed to guest code without taking the aforementioned aspects into account.As an example, an antipattern would be to implement a third party interface and forwarding all method invocations to guest code.Resource LimitsThe ISOLATED and UNTRUSTED sandbox policies require setting resource limits for a context.Different configurations can be provided for each context.If a limit is exceeded, evaluation of the code fails and the context is cancelled with a PolyglotException which returns true for isResourceExhausted().At this point, no more guest code can be executed in the contextThe --sandbox.TraceLimits option allows you to trace guest code and record the maximum resource utilization.This can be used to estimate the parameters for the sandbox.For example, a web server’s sandbox parameters could be obtained by enabling this option and either stress-testing the server, or letting the server run during peak usage.When this option is enabled, the report is saved to the log file after the workload completes.Users can change the location of the log file by using --log.file=&amp;lt;path&amp;gt; with a language launcher or -Dpolyglot.log.file=&amp;lt;path&amp;gt; when using a java launcher.Each resource limit in the report can be passed directly to a sandbox option to enforce the limit.See, for example, how to trace limits for a Python workload:graalpy --log.file=limits.log --sandbox.TraceLimits=true workload.pylimits.log:Traced Limits:Maximum Heap Memory:                                        12MBCPU Time:                                                     7sNumber of statements executed:                           9441565Maximum active stack frames:                                  29Maximum number of threads:                                     1Maximum AST Depth:                                            15Size written to standard output:                              4BSize written to standard error output:                        0BRecommended Programmatic Limits:Context.newBuilder()            .option(&quot;sandbox.MaxHeapMemory&quot;, &quot;2MB&quot;)            .option(&quot;sandbox.MaxCPUTime&quot;,&quot;10ms&quot;)            .option(&quot;sandbox.MaxStatements&quot;,&quot;1000&quot;)            .option(&quot;sandbox.MaxStackFrames&quot;,&quot;64&quot;)            .option(&quot;sandbox.MaxThreads&quot;,&quot;1&quot;)            .option(&quot;sandbox.MaxASTDepth&quot;,&quot;64&quot;)            .option(&quot;sandbox.MaxOutputStreamSize&quot;,&quot;1024KB&quot;)            .option(&quot;sandbox.MaxErrorStreamSize&quot;,&quot;1024KB&quot;)            .build();Recommended Command Line Limits:--sandbox.MaxHeapMemory=12MB --sandbox.MaxCPUTime=7s --sandbox.MaxStatements=9441565 --sandbox.MaxStackFrames=64 --sandbox.MaxThreads=1 --sandbox.MaxASTDepth=64 --sandbox.MaxOutputStreamSize=1024KB --sandbox.MaxErrorStreamSize=1024KBRe-profiling may be required if the workload changes or when switching to a different major GraalVM version.Certain limits can be reset at any point of time during the execution.Limiting Active CPU TimeThe sandbox.MaxCPUTime option allows you to specify the maximum CPU time spent running guest code.CPU time spent depends on the underlying hardware.The maximum CPU time specifies how long a context can be active until it is automatically cancelled and the context is closed.By default the time limit is checked every 10 milliseconds.This can be customized using the sandbox.MaxCPUTimeCheckInterval option.As soon as the time limit is triggered, no further guest code can be executed with this context.It will continuously throw a PolyglotException for any method of the polyglot context that will be invoked.The used CPU time of a context includes time spent in callbacks to host code.The used CPU time of a context typically does not include time spent waiting for synchronization or IO.The CPU time of all threads will be added and checked against the CPU time limit.This can mean that if two threads execute the same context then the time limit will be exceeded twice as fast.The time limit is enforced by a separate high-priority thread that will be woken regularly.There is no guarantee that the context will be cancelled within the accuracy specified.The accuracy may be significantly missed, for example, if the host VM causes a full garbage collection.If the time limit is never exceeded then the throughput of the guest context is not affected.If the time limit is exceeded for one context then it may slow down the throughput for other contexts with the same explicit engine temporarily.Available units to specify time durations are ms for milliseconds, s for seconds, m for minutes, h for hours and d for days.Both maximum CPU time limit and check interval must be positive followed by a time unit.try (Context context = Context.newBuilder(&quot;js&quot;)                           .option(&quot;sandbox.MaxCPUTime&quot;, &quot;500ms&quot;)                       .build();) {    context.eval(&quot;js&quot;, &quot;while(true);&quot;);    assert false;} catch (PolyglotException e) {    // triggered after 500ms;    // context is closed and can no longer be used    // error message: Maximum CPU time limit of 500ms exceeded.    assert e.isCancelled();    assert e.isResourceExhausted();}Limiting the Number of Executed StatementsSpecifies the maximum number of statements a context may execute until it is cancelled.After the statement limit was triggered for a context, it is no longer usable and every use of the context will throw a PolyglotException that returns true for PolyglotException.isCancelled().The statement limit is independent of the number of threads executing.The limit may be set to a negative number to disable it.Whether this limit is applied internal sources only can be configured using sandbox.MaxStatementsIncludeInternal.By default the limit does not include statements of sources that are marked internal.If a shared engine is used then the same internal configuration must be used for all contexts of an engine.The complexity of a single statement may not be constant time depending on the guest language.For example, statements that execute Javascript builtins, like Array.sort, may account for a single statement, but its execution time is dependent on the size of the array.try (Context context = Context.newBuilder(&quot;js&quot;)                           .option(&quot;sandbox.MaxStatements&quot;, &quot;2&quot;)                           .option(&quot;sandbox.MaxStatementsIncludeInternal&quot;, &quot;false&quot;)                       .build();) {    context.eval(&quot;js&quot;, &quot;purpose = 41&quot;);    context.eval(&quot;js&quot;, &quot;purpose++&quot;);    context.eval(&quot;js&quot;, &quot;purpose++&quot;); // triggers max statements    assert false;} catch (PolyglotException e) {    // context is closed and can no longer be used    // error message: Maximum statements limit of 2 exceeded.    assert e.isCancelled();    assert e.isResourceExhausted();}AST Depth LimitA limit on the maximum expression depth of a guest language function.Only instrumentable nodes count towards the limit.The AST depth can give an estimate of the complexity of a function as well as its stack frame size.Limiting the Number of Stack FramesSpecifies the maximum number of frames a context can push onto the stack.A thread-local stack frame counter is incremented on function enter and decremented on function return.The stack frame limit in itself serves as a safeguard against infinite recursion.Together with the AST depth limit it can restrict total stack space usage.Limiting the Number of Active ThreadsLimits the number of threads that can be used by a context at the same point in time.Multithreading is not supported in the UNTRUSTED sandbox policy.Heap Memory LimitsThe sandbox.MaxHeapMemory option specifies the maximum heap memory guest code is allowed to retain during its run.Only objects residing in guest code count towards the limit - memory allocated during callbacks to host code does not.This is not a hard limit as the efficacy of this option (also) depends on the garbage collector used.This means that the limit may be exceeded by guest code.try (Context context = Context.newBuilder(&quot;js&quot;)                           .option(&quot;sandbox.MaxHeapMemory&quot;, &quot;100MB&quot;)                       .build()) {    context.eval(&quot;js&quot;, &quot;var r = {}; var o = r; while(true) { o.o = {}; o = o.o; };&quot;);    assert false;} catch (PolyglotException e) {    // triggered after the retained size is greater than 100MB;    // context is closed and can no longer be used    // error message: Maximum heap memory limit of 104857600 bytes exceeded. Current memory at least...    assert e.isCancelled();    assert e.isResourceExhausted();}The limit is checked by retained size computation triggered either based on allocated bytes or on low memory notification.The allocated bytes are checked by a separate high-priority thread that will be woken regularly.There is one such thread for each memory-limited context (one with sandbox.MaxHeapMemory set).The retained bytes computation is done by yet another high-priority thread that is started from the allocated bytes checking thread as needed.The retained bytes computation thread also cancels the context if the heap memory limit is exceeded.Additionally, when the low memory trigger is invoked, all memory-limited contexts are paused together with their allocation checkers.All individual retained size computations are cancelled.Retained bytes in the heap for each memory-limited context are computed by a single high-priority thread.The heap memory limit will not prevent the context from causing OutOfMemory errors.Guest code that allocates many objects in quick succession has a lower accuracy compared to code that allocates objects rarely.Retained size computation for a context can be customized using the expert options sandbox.AllocatedBytesCheckInterval, sandbox.AllocatedBytesCheckEnabled, sandbox.AllocatedBytesCheckFactor, sandbox.RetainedBytesCheckInterval, sandbox.RetainedBytesCheckFactor, and sandbox.UseLowMemoryTrigger described below.Retained size computation for a context is triggered when a retained bytes estimate exceeds a certain factor of specified sandbox.MaxHeapMemory.The estimate is based on heap memoryallocated by threads where the context has been active.More precisely, the estimate is the result of previous retained bytes computation, if available, plus bytes allocated since the start of the previous computation.By default the factor of sandbox.MaxHeapMemory is 1.0 and it can be customized by the sandbox.AllocatedBytesCheckFactor option.The factor must be positive.For example, let sandbox.MaxHeapMemory be 100MB and sandbox.AllocatedBytesCheckFactor be 0.5.The retained size computation is first triggered when allocated bytes reach 50MB.Let the computed retained size be 25MB, then the next retained size computation is triggered when additional 25MB is allocated, etc.By default, allocated bytes are checked every 10 milliseconds. This can be configured by sandbox.AllocatedBytesCheckInterval.The smallest possible interval is 1ms. Any smaller value is interpreted as 1ms.The beginnings of two retained size computations of the same context must be by default at least 10 milliseconds apart.This can be configured by the sandbox.RetainedBytesCheckInterval option. The interval must be positive.The allocated bytes checking for a context can be disabled by the sandbox.AllocatedBytesCheckEnabled option.By default it is enabled (“true”). If disabled (“false”), retained size checking for the context can be triggered only by the low memory trigger.When the total number of bytes allocated in the heap for the whole host VM exceeds a certain factor of the total heap memory of the VM, low memory notification is invoked and initiates the following process.The execution pauses for all execution contexts where the sandbox.MaxHeapMemory option is set. The execution is resumed only when retained bytes in the heap for each memory-limited context are computed and contexts exceeding their limits are cancelled.The default factor is 0.7. This can be configured by the sandbox.RetainedBytesCheckFactor option.The factor must be between 0.0 and 1.0. All contexts using the sandbox.MaxHeapMemory option must use the same value for sandbox.RetainedBytesCheckFactor.When the usage threshold or the collection usage threshold of any heap memory pool has already been set, then the low memory trigger cannot be used by default, because the limit specified by the sandbox.RetainedBytesCheckFactor cannot be implemented.However, when sandbox.ReuseLowMemoryTriggerThreshold is set to true and the usage threshold or the collection usage threshold of a heap memory pool has already been set, then the value of sandbox.RetainedBytesCheckFactor is ignored for that memory pool and whatever limit has already been set is used.That way the low memory trigger can be used together with libraries that also set the usage threshold or the collection usage threshold of heap memory pools.The described low memory trigger can be disabled by the sandbox.UseLowMemoryTrigger option.By default it is enabled (“true”). If disabled (“false”), retained size checking for the execution context can be triggered only by the allocated bytes checker.All contexts using the sandbox.MaxHeapMemory option must use the same value for sandbox.UseLowMemoryTrigger.The sandbox.UseLowMemoryTrigger option is not supported for the ISOLATED and UNTRUSTED sandbox policies as the polyglot engine runs in a native-image isolate for those policies. It is also not supported on a native-image host regardless of the policy. The option defaults to disabled (false) wherever it is not supported.Limiting the Amount of Data Written to Standard Output and Error StreamsLimits the size of the output that guest code writes to standard output or standard error output during runtime.Limiting the size of the output can serve as protection against denial-of-service attacks that flood the output.try (Context context = Context.newBuilder(&quot;js&quot;)                           .option(&quot;sandbox.MaxOutputStreamSize&quot;, &quot;100KB&quot;)                       .build()) {    context.eval(&quot;js&quot;, &quot;while(true) { console.log(&#39;Log message&#39;) };&quot;);    assert false;} catch (PolyglotException e) {    // triggered after writing more than 100KB to stdout    // context is closed and can no longer be used    // error message: Maximum output stream size of 102400 exceeded. Bytes written 102408.    assert e.isCancelled();    assert e.isResourceExhausted();}try (Context context = Context.newBuilder(&quot;js&quot;)                           .option(&quot;sandbox.MaxErrorStreamSize&quot;, &quot;100KB&quot;)                       .build()) {    context.eval(&quot;js&quot;, &quot;while(true) { console.error(&#39;Error message&#39;) };&quot;);    assert false;} catch (PolyglotException e) {    // triggered after writing more than 100KB to stderr    // context is closed and can no longer be used    // error message: Maximum error stream size of 102400 exceeded. Bytes written 102410.    assert e.isCancelled();    assert e.isResourceExhausted();}Resetting Resource LimitsIt is possible to reset the limits at any point in time using the Context.resetLimits method.This can be useful if a known and trusted initialization script should be excluded from limit.Only the statement, cpu time and output / error stream limits can be reset.try (Context context = Context.newBuilder(&quot;js&quot;)                           .option(&quot;sandbox.MaxCPUTime&quot;, &quot;500ms&quot;)                       .build();) {    context.eval(&quot;js&quot;, /*... initialization script ...*/);    context.resetLimits();    context.eval(&quot;js&quot;, /*... user script ...*/);    assert false;} catch (PolyglotException e) {    assert e.isCancelled();    assert e.isResourceExhausted();}Runtime DefensesThe main defense enforced by the ISOLATED and UNTRUSTED sandbox policy through the engine.SpawnIsolate option is that the Polyglot engine runs in a dedicated native-image isolate, moving execution of guest code to a VM-level fault domain separate from the host application, with its own heap, garbage collector and JIT compiler.Apart from setting a hard limit for the memory consumption of guest code via the guest’s heap size, it also allows to focus runtime defenses just on guest code and not cause performance degradation of host code.The runtime defenses are enabled by the engine.UntrustedCodeMitigation option.Constant BlindingJIT compilers allow users to provide source code and, given the source code is valid, compile it to machine code.From an attacker’s perspective, JIT compilers compile attacker-controlled inputs to predictable bytes in executable memory.In an attack called JIT spraying an attacker leverages the predictable compilation by feeding malicious input programs into the JIT compiler, thereby forcing it to emit code containing Return-Oriented Programming (ROP) gadgets.Constants in the input program are a particularly attractive target for such an attack, since JIT compilers often include them verbatim in the machine code.Constant blinding aims to invalidate an attacker’s predictions by introducing randomness into the compilation process.Specifically, constant blinding encrypts constants with a random key at compile time and decrypts them at runtime at each occurrence.Only the encrypted version of the constant appears verbatim in the machine code.Absent knowledge of the random key, the attacker cannot predict the encrypted constant value and, therefore, can no longer predict the resulting bytes in executable memory.GraalVM blinds all immediate values and data embedded in code pages of runtime compiled guest code down to a size of four bytes.Randomized Function Entry PointsA predictable code layout makes it easier for attackers to find gadgets that have been introduced, for example, via the aforementioned JIT spray attack.While runtime compiled methods are already placed in memory that is subject to address space layout randomization (ASLR) by the operating system, GraalVM additionally pads the starting offset of functions with a random number of trap instructions.Speculative Execution Attack MitigationsSpeculative execution attacks such as Spectre exploit the fact that a CPU may transiently execute instructions based on branch prediction information.In the case of a misprediction, the result of these instructions is discarded.However, the execution may have caused side effects in the micro-architectural state of a CPU.For example, data may have been pulled into the cache during transient execution - a side-channel that can be read by timing data access.GraalVM protects against Spectre attacks by applying masking to memory accesses in runtime compiled code.Since the masking operation is also effective during speculative execution, accesses protected by masks are always scoped to the isolate heap.For memory accesses where masking is not applicable, GraalVM inserts speculative execution barrier instructions to prevent attackers from crafting speculative execution gadgets.On AArch64 protection relies solely on speculative execution barrier instructions.Process IsolationAs an experimental feature, the dedicated native-image isolate that runs the Polyglot engine in the ISOLATED and UNTRUSTED policy can run in a separate process.The feature is enabled by setting engine.IsolateMode=external, experimental options have to be allowed:try (Context context = Context.newBuilder(&quot;js&quot;)                              .allowExperimentalOptions(true)                              .sandbox(SandboxPolicy.ISOLATED)                              .out(new ByteArrayOutputStream())                              .err(new ByteArrayOutputStream())                              .option(&quot;engine.MaxIsolateMemory&quot;, &quot;256MB&quot;)                              .option(&quot;engine.IsolateMode&quot;, &quot;external&quot;)                              .build()) {    context.eval(&quot;js&quot;, &quot;print(&#39;Hello JavaScript!&#39;);&quot;);}Executing guest code in a separate process further deepens the isolation between the host application and guest code by providing a separate address space and signal domain.This means that defenses against leaking sensitive data from the same address space are no longer necessary and fatal crashes of the native-image isolate no longer affect the host application.These properties come at the expense of slower startup performance of a corresponding Polyglot engine as well as an increased communication overhead between host and guest code.Under the hood, host and guest processes communicate via Unix Domain sockets, transparently hidden behind the Polyglot API.Sharing Execution EnginesGuest code of different trust domains has to be separated at the Polyglot engine level, that is, only guest code of the same trust domain should share an engine.When multiple context share an engine, all of them must have the same sandbox policy (the engine’s sandbox policy).Application developers may choose to share execution engines among execution contexts for performance reasons.While the context holds the state of the executed code, the engine holds the code itself.Sharing of an execution engine among multiple contexts needs to be set up explicitly and can increase performance in scenarios where a number of contexts execute the same code. In scenarios where contexts that share an execution engine for common code also execute sensitive (private) code, the corresponding source objects can opt out from code sharing with:Source.newBuilder(…).cached(false).build()Compatibility and LimitationsSandboxing is not available in GraalVM Community Edition.Depending on the sandboxing policy, only a subset of Truffle languages, instruments, and options are available.In particular, sandboxing is currently only supported for the runtime’s default version of ECMAScript (ECMAScript 2022).Sandboxing is also not supported from within GraalVM’s Node.js.Sandboxing is not compatible with modifications to the VM setup via (for example) system properties that change the behavior of the VM.The sandboxing policy is subject to incompatible changes across major GraalVM releases to maintain a secure-by-default posture.Sandboxing cannot protect against vulnerabilities in its operating environment, such as vulnerabilities in the operating system or the underlying hardware.We recommend to adopt the appropriate external isolation primitives to protect against corresponding risks.Differentiation with Java Security ManagerThe Java Security Manager is deprecated in Java 17 with JEP-411.The purpose of the security manager is stated as follows: “It allows an application to determine, before performing a possibly unsafe or sensitive operation, what the operation is and whether it is being attempted in a security context that allows the operation to be performed.”The goal of the GraalVM sandbox is to allow the execution of untrusted guest code in a secure manner, meaning untrusted guest code should not be able to compromise the confidentiality, integrity or availability of the host code and its environment.The GraalVM sandbox differs from Security Managers in the following aspects:  Security boundary: The Java Security Manager features a flexible security boundary that depends on the actual calling context of a method. This makes “drawing the line” complex and error prone. A security-critical code block first needs to inspect the current calling stack to determine whether all frames on the stack have the authority to invoke the code. In the GraalVM sandbox, there is a straightforward, clear security boundary: the boundary between host and guest code, with guest code running on top of the Truffle framework, similar to how typical computer architectures distinguish between user mode and (privileged) kernel mode.  Isolation: With the Java Security Manager, privileged code is almost on “equal footing” as untrusted code with respect to the language and runtime:  Shared language: With the Java Security Manager, untrusted code is written in the same language as privileged code, with the advantage of straightforward interoperability between the two. In contrast, the GraalVM sandbox a guest application written in a Truffle language needs to pass an explicit boundary to host code written in Java.  Shared runtime: With the Java Security Manager, untrusted code executes in the same JVM environment as trusted code, sharing JDK classes and runtime services such as the garbage collector or the compiler. In the GraalVM sandbox, untrusted code runs in dedicated VM instances (GraalVM isolates), separating services and JDK classes of host and guest by design.  Resource limits: The Java Security Manager cannot restrict the usage of computational resources such as CPU time or memory, allowing untrusted code to DoS the JVM. The GraalVM sandbox offers controls to set limits on several computational resources (CPU time, memory, threads, processes), guest code may consume to address availability concerns.  Configuration: Crafting a Java Security Manager policy was often found to be a complex and error-prone task, requiring a subject matter expert that knows exactly which parts of the program require what level of access. Configuring the GraalVM sandbox provides security profiles that focus on common sandboxing use cases and threat models.Reporting VulnerabilitiesIf you believe you have found a security vulnerability, please submit a report to secalert_us@oracle.com preferably with a proof of concept.Please refer to Reporting Vulnerabilities for additional information including our public encryption key for secure email.We ask that you do not contact project contributors directly or through other channels about a report.Related Documentation  Security Guide  Security Considerations in Native Image",
          "url": " /latest/security-guide/sandboxing/"
          },
          
          "community-assets":  {
          "title": "Presentation Materials",
          "content": "The GraalVM team regularly presents at various conferences and meetups. We are delighted to learn that you have taken interest in GraalVM and would like to share this interest with your network. Whether you are presenting at a conference, a meetup, or writing an article, you can use the images on this page in your creative work.These images are the intellectual property of the Oracle and cannot be altered without Oracle’s permission. Please use it responsibly. For the proper use guidelines please contact us: graalvm-users@oss.oracle.com.Please attribute them back to this website, so more people could find it. And please make sure to state your affiliation with the GraalVM project, whether you’re a part of the team or just a fan.GraalVM LogoGraalVM OverviewGraalVM supports many languages and runs in various environments.GraalVM ComponentsGraalVM functionality is enabled by several layers: it uses JVM as a platform, uses Java level compiler interface, JVMCI to integrate with it, uses the Truffle framework to run languages it has interpreters for, and through the LLVM bitcode interpreter, Sulong, it can run native code.Performance Comparison with Best Competition (2017)The Practical partial evaluation for high-performance dynamic language runtimes paper byThomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöß, Lukas Stadler, Chris Seaton, Gilles Duboscq, Doug Simon, Matthias Grimmer compared performance of GraalVM against other runtimes. Here is a one-image summary of the findings. For proper interpretation, please read the paper.Sample ApplicationsYou can find sample applications to play with on GitHub.",
          "url": " /community/assets/"
          },
          
          "latest-tools-profiling":  {
          "title": "Profiling Command Line Tools",
          "content": "Profiling Command Line ToolsGraalVM profiling command line tools help you optimize your code through analysis of CPU and memory usage.Most applications spend 80% of their runtime in 20% of the code.For this reason, to optimize the code, it is essential to know where the application spends its time.In this section, we use an example application to demonstrate the three main profiling capabilities that GraalVM offers: CPU Tracer, CPU Sampler, and Memory Tracer.This example application uses a basic prime number calculator based on the Sieve of Eratosthenesalgorithm.      Copy the following code into a new file named primes.js:     class AcceptFilter {     accept(n) {         return true     } } class DivisibleByFilter {     constructor(number, next) {         this.number = number;         this.next = next;     }     accept(n) {         var filter = this;         while (filter != null) {             if (n % filter.number === 0) {                 return false;             }             filter = filter.next;         }         return true;     } } class Primes {     constructor() {         this.number = 2;         this.filter = new AcceptFilter();     }     next() {         while (!this.filter.accept(this.number)) {             this.number++;         }         this.filter = new DivisibleByFilter(this.number, this.filter);         return this.number;     } } var primes = new Primes(); var primesArray = []; for (let i = 0; i &amp;lt; 5000; i++) {     primesArray.push(primes.next()); } console.log(`Computed ${primesArray.length} prime numbers. ` +             `The last 5 are ${primesArray.slice(-5)}.`);    Run js primes.js. The example application should print output as follows:     js primes.js Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611.    This program takes a moment to compute. Next you will check where the time is spent.    Run js --cpusampler primes.js to enable CPU sampling. CPU Sampler should print output for the example application as follows:     js --cpusampler primes.js Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ---------------------------------------------------------------------------------------------- Sampling Histogram. Recorded 250 samples with period 10ms.   Self Time: Time spent on the top of the stack.   Total Time: Time spent somewhere on the stack. ---------------------------------------------------------------------------------------------- Thread[main,5,main]  Name       ||             Total Time    ||              Self Time    || Location ----------------------------------------------------------------------------------------------  accept     ||             2150ms  86.0% ||             2150ms  86.0% || primes.js~13-22:191-419  next       ||             2470ms  98.8% ||              320ms  12.8% || primes.js~31-37:537-737  :program   ||             2500ms 100.0% ||               30ms   1.2% || primes.js~1-46:0-982 ----------------------------------------------------------------------------------------------    By default the sampler prints an execution time histogram for each JavaScript function.    You can produce a flame graph in SVG format by requesting that with the --cpusampler=flamegraph option:     js --cpusampler=flamegraph primes.js    It should produce a file called flamegraph.svg containing something like this:        You can zoom into the graph by clicking on elements.    By default, CPU sampling takes a sample every 10 milliseconds. From the result, we can see that roughly 89% of the time is spent in the DivisibleByFilter.accept function.     accept(n) {     var filter = this;     while (filter != null) {         if (n % filter.number === 0) {             return false;         }         filter = filter.next;     }     return true; }    See this blog post for more details.    Now use the CPU Tracer to collect execution counts of each statement:    Run js primes.js --cputracer --cputracer.TraceStatements --cputracer.FilterRootName=*accept to collect execution counts for all statements in methods ending with accept:     js primes.js --cputracer --cputracer.TraceStatements --cputracer.FilterRootName=accept Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ----------------------------------------------------------------------------------------- Tracing Histogram. Counted a total of 468336895 element executions.   Total Count: Number of times the element was executed and percentage of total executions.   Interpreted Count: Number of times the element was interpreted and percentage of total executions of this element.   Compiled Count: Number of times the compiled element was executed and percentage of total executions of this element. -----------------------------------------------------------------------------------------  Name     |          Total Count |    Interpreted Count |       Compiled Count | Location -----------------------------------------------------------------------------------------  accept   |     234117338  50.0% |        365660   0.2% |     233751678  99.8% | primes.js~15:245-258  accept   |     117053670  25.0% |        182582   0.2% |     116871088  99.8% | primes.js~16-18:275-348  accept   |     117005061  25.0% |        181001   0.2% |     116824060  99.8% | primes.js~19:362-381  accept   |         53608   0.0% |          1829   3.4% |         51779  96.6% | primes.js~14:211-227  accept   |         53608   0.0% |          1829   3.4% |         51779  96.6% | primes.js~13-22:191-419  accept   |         48609   0.0% |          1581   3.3% |         47028  96.7% | primes.js~17:322-334  accept   |          4999   0.0% |           248   5.0% |          4751  95.0% | primes.js~21:402-413  accept   |             1   0.0% |             1 100.0% |             0   0.0% | primes.js~2-4:25-61  accept   |             1   0.0% |             1 100.0% |             0   0.0% | primes.js~3:45-55 -----------------------------------------------------------------------------------------    The output shows execution counters for each statement, instead of timing information. Tracing histograms often provides insights into the behavior of the algorithm that needs optimization.    Run js primes.js --experimental-options --memtracer to display source code locations and counts of reported allocations. Note that the Memory Tracer tool for capturing allocations is currently an experimental feature in GraalVM. As such, --memtracer must be preceded by the --experimental-options command line option.     js primes.js --experimental-options --memtracer Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ------------------------------------------------------------ Location Histogram with Allocation Counts. Recorded a total of 5007 allocations.   Total Count: Number of allocations during the execution of this element.   Self Count: Number of allocations in this element alone (excluding sub calls).-------------------------------------------------------- Name     |      Self Count |     Total Count | Location-------------------------------------------------------- next     |     5000  99.9% |     5000  99.9% | primes.js~31-37:537-737 :program |        6   0.1% |     5007 100.0% | primes.js~1-46:0-982 Primes   |        1   0.0% |        1   0.0% | primes.js~25-38:424-739--------------------------------------------------------    This output shows the number of allocations which were recorded per function. For each prime number that was computed, the program allocates one object in next and one in constructor of DivisibleByFilter. Allocations are recorded independently of whether they could get eliminated by the compiler.    The GraalVM compiler is particularly powerful in optimizing allocations and can push allocations into infrequent branches to increase execution performance. The GraalVM team plans to add information about memory optimizations to the memory tracer in the future.  Tools OptionsUse the --help:tools option in all guest language launchers to display reference information for CPU Sampler, CPU Tracer, and Memory Tracer.The current set of available options is as follows.CPU Sampler Options  --cpusampler=true|false|&amp;lt;Output&amp;gt; : Enable/Disable the CPU sampler, or enable with specific Output - as specified by the Output option (default: false). Choosing an output with this options defaults to printing the output to std out, except for the flamegraph which is printed to a flamegraph.svg file.  --cpusampler.Delay=&amp;lt;ms&amp;gt; : Delay the sampling for this many milliseconds (default: 0).  --cpusampler.FilterFile=&amp;lt;filter&amp;gt; : Wildcard filter for source file paths. (for example, program.sl) (default: no filter).  --cpusampler.FilterLanguage=&amp;lt;languageId&amp;gt; : Only profile the language with given ID. (for example, js) (default: profile all).  --cpusampler.FilterMimeType=&amp;lt;mime-type&amp;gt; : Only profile the language with given mime-type. (for example, application/javascript) (default: profile all)  --cpusampler.FilterRootName=&amp;lt;filter&amp;gt; : Wildcard filter for program roots. (for example, Math.*) (default: no filter).  --cpusampler.GatherAsyncStackTrace=true|false : Try to gather async stack trace elements for each sample (default: true). Disabling this option may reduce sampling overhead.  --cpusampler.GatherHitTimes : Save a timestamp for each taken sample.  --cpusampler.MinSamples=[0, inf) : Remove elements from output if they have less samples than this value (default: 0)  --cpusampler.Output=histogram|calltree|json|flamegraph : Specify the output format to one of: histogram, calltree, json or flamegraph (default: histogram).  --cpusampler.OutputFile=&amp;lt;path&amp;gt; : Save output to the given file. Output is printed to output stream by default.  --cpusampler.Period=&amp;lt;ms&amp;gt; : Period in milliseconds to sample the stack (default: 10)  --cpusampler.SampleContextInitialization : Enables sampling of code executed during context initialization  --cpusampler.ShowTiers=true|false|0,1,2 : Specify whether to show compilation information for entries. You can specify ‘true’ to show all compilation information, ‘false’ for none, or a comma separated list of compilation tiers. Note: Interpreter is considered Tier 0. (default: false)  --cpusampler.StackLimit=[1, inf) : Maximum number of maximum stack elements (default: 10000).  --cpusampler.SummariseThreads : Print output as a summary of all ‘per thread’ profiles.CPU Tracer Options  --cputracer : Enable the CPU tracer (default: false).  --cputracer.FilterFile=&amp;lt;filter&amp;gt; : Wildcard filter for source file paths. (for example, program.sl) (default: no filter).  --cputracer.FilterLanguage=&amp;lt;languageId&amp;gt; : Only profile languages with given ID. (for example, js) (default: no filter).  --cputracer.FilterMimeType=&amp;lt;mime-type&amp;gt; : Only profile languages with mime-type. (for example, application/javascript) (default: no filter).  --cputracer.FilterRootName=&amp;lt;filter&amp;gt; : Wildcard filter for program roots. (for example, Math.*) (default: no filter).  --cputracer.Output=histogram|json : Print a ‘histogram’ or ‘json’ as output (default: histogram).  --cputracer.OutputFile=&amp;lt;path&amp;gt; : Save output to the given file. Output is printed to standard output stream by default.  --cputracer.TraceCalls : Capture calls when tracing (default: false).  --cputracer.TraceRoots=true|false : Capture roots when tracing (default: true).  --cputracer.TraceStatements : Capture statements when tracing (default: false).Memory Tracer OptionsThe memory tracer tool is currently an experimental tool. Make sure to prefix the --experimental-options flag to enable --memtracer.  --memtracer : Enable the Memory Tracer (default: false).  --memtracer.FilterFile=&amp;lt;filter&amp;gt; : Wildcard filter for source file paths. (for example, program.sl) (default: no filter).  --memtracer.FilterLanguage=&amp;lt;languageId&amp;gt; : Only profile languages with given ID. (for example js) (default: no filter).  --memtracer.FilterMimeType=&amp;lt;mime-type&amp;gt; : Only profile languages with mime-type. (for example, application/javascript). (default: no filter)  --memtracer.FilterRootName=&amp;lt;filter&amp;gt; : Wildcard filter for program roots. (for example, Math.*) (default: no filter).  --memtracer.Output=typehistogram|histogram|calltree : Print a ‘typehistogram’, ‘histogram’ or ‘calltree’ as output. (default: histogram)  --memtracer.StackLimit=[1, inf) : Maximum number of maximum stack elements. (default: 10000)  --memtracer.TraceCalls : Capture calls when tracing. (default: false)  --memtracer.TraceRoots=true|false : Capture roots when tracing. (default: true)  --memtracer.TraceStatements : Capture statements when tracing (default: false).",
          "url": " /latest/tools/profiling/"
          },
          
          "community-publications":  {
          "title": "Academic Publications",
          "content": "",
          "url": " /community/publications/"
          },
          
          "docs-quick-references":  {
          "title": "Quick References",
          "content": "",
          "url": " /docs/quick-references/"
          },
          
          "latest-reference-manual":  {
          "title": "Reference Manuals",
          "content": "Reference ManualsHere you will find the in-depth documentation for technologies offered by GraalVM.These manuals are aimed at software engineers and developers who already work with GraalVM, or are considering it as an environment for their workloads.  Learn more about GraalVM as a Java Virtual Machine and its optimizing just-in-time compiler, Graal Compiler.  Developers interested in embedding other languages into Java, proceed to Embedding Languages.  Developers interested in building interpreters for programming languages which then run on GraalVM, continue to the Truffle language implementation framework documentation.  To learn more about security considerations in GraalVM, check the Security Guide.If you are mostly interested in a specific language runtime on GraalVM, see the following:  Espresso  GraalJS  GraalPy  GraalWasm",
          "url": " /latest/reference-manual/"
          },
          
          "release-calendar":  {
          "title": "GraalVM Release Calendar",
          "content": "GraalVM Release CalendarAfter September 2025, the product is referred to as “GraalVM 25”. Before this, GraalVM aligned with the six-month JDK release cadence and used the JDK numbering scheme (for example, “GraalVM for JDK 21.0.3”).Feature ReleaseA new feature release supersedes all previous releases.Critical Patch Update (CPU)Critical Patch Updates (CPU) for Oracle GraalVM and GraalVM Community Edition follow the schedule for all Oracle CPU and OpenJDK CPU releases respectively.Critical Patch Updates are released on the third Tuesday of January, April, July, and October.All active releases receive patch updates.Long-Term-Support (LTS) ReleaseOracle GraalVM for JDK 21 is the current long-term support (LTS) release and will receive free updates under the GraalVM Free Terms and Conditions (GFTC) including License for Early Adopter Versions license until one full year after the subsequent LTS release, which is JDK 25.Oracle also provides customers of Oracle GraalVM and Oracle GraalVM Enterprise Edition with Oracle Premier Support.Planned Releases            Date      Type      Oracle GraalVM      GraalVM Community Edition      Graal Languages                  April 21, 2026      CPU      17.0.19, 21.0.11, 25.0.3      25.0.3      25.0.3              July 21, 2026      CPU      17.0.20, 21.0.12, 25.0.4      25.0.4      25.0.4              October 20, 2026      CPU      17.0.21, 21.0.13, 25.0.5      25.0.5      25.0.5              January 19, 2027      CPU      17.0.22, 21.0.14, 25.0.6      25.0.6      25.0.6              April 20, 2027      CPU      17.0.23, 21.0.15, 25.0.7      25.0.7      25.0.7      Previous Releases            Date      Type      Oracle GraalVM      GraalVM Community Edition      Graal Languages                  January 20, 2026.      CPU      17.0.18, 21.0.10, 25.0.2      25.0.2      25.0.2              October 21, 2025      CPU      17.0.17, 21.0.9, 25.0.1      25.0.1      25.0.1              September 16, 2025      Feature      25      25      25.0.0              July 15, 2025      CPU      17.0.16, 21.0.8, 24.0.2      24.0.2      24.2.2              April 15, 2025      CPU      17.0.15, 21.0.7, 24.0.1      24.0.1      24.2.1              March 18, 2025      Feature      24      24      24.2.0              January 21, 2025      CPU      17.0.14, 21.0.6, 23.0.2      23.0.2      24.1.2              October 15, 2024      CPU      17.0.13, 21.0.5, 23.0.1      23.0.1      24.1.1              September 17, 2024      Feature      23      23      24.1.0              July 16, 2024      CPU      17.0.12, 21.0.4, 22.0.2      22.0.2      24.0.2              April 16, 2024      CPU      17.0.11, 21.0.3, 22.0.1      22.0.1      24.0.1              March 19, 2024      Feature      22      22      24.0.0              January 16, 2024      CPU      17.0.10, 21.0.2      21.0.2      23.0.3, 23.1.2              October 24, 2023      CPU      17.0.9, 21.0.1      17.0.9, 21.0.1      23.0.2, 23.1.1              September 19, 2023      Feature (LTS)      21      21      23.1.0              July 25, 2023      CPU      17.0.8, 20.0.2      17.0.8, 20.0.2      -              June 13, 2023      Feature (LTS)      17.0.7, 20.0.1      17.0.7, 20.0.1      -      GraalVM Enterprise and Community Editions  Prior to 2023, GraalVM release numbering was based on the calendar year, for example, GraalVM Enterprise Edition 19.x, GraalVM Community Edition 20.x, and so on.            Date      Type      GraalVM Enterprise Edition      GraalVM Community Edition                  April 15, 2025      CPU      21.3.14      -              January 21, 2025      CPU      20.3.17, 21.3.13      -              October 15, 2024      CPU      20.3.16, 21.3.12      -              July 16, 2024      CPU      20.3.15, 21.3.11      -              April 16, 2024      CPU      20.3.14, 21.3.10      -              January 16, 2024      CPU      20.3.13, 21.3.9, 22.3.5      -              October 17, 2023      CPU      20.3.12, 21.3.8, 22.3.4      -              July 18, 2023      CPU      20.3.11, 21.3.7, 22.3.3      -              April 18, 2023      CPU      22.3.2, 21.3.6, 20.3.10      22.3.2              January 17, 2023      CPU      22.3.1, 21.3.5, 20.3.9      22.3.1              October 18, 2022      Feature, CPU      22.3.0, 21.3.4, 20.3.8      22.3.0              July 19, 2022      Feature, CPU      22.2.0, 21.3.3, 20.3.7      22.2.0, 21.3.3              April 19, 2022      Feature, CPU      22.1.0, 21.3.2, 20.3.6      22.1.0, 21.3.2, 20.3.6              January 18, 2022      Feature, CPU      22.0.0, 21.3.1, 20.3.5      22.0.0, 21.3.1, 20.3.5              October 19, 2021      Feature, CPU      21.3.0 (LTS), 20.3.4      21.3.0, 20.3.4              July 20, 2021      Feature, CPU      21.2.0, 20.3.3      21.2.0, 20.3.3              April 20, 2021      Feature, CPU      21.1.0, 20.3.2, 19.3.6      21.1.0, 20.3.2, 19.3.6              January 19, 2021      Feature, CPU      21.0.0, 20.3.1, 19.3.5      21.0.0, 20.3.1, 19.3.5              November 17, 2020      Feature      20.3.0 (LTS)      20.3.0              October 20, 2020      CPU      20.2.1, 19.3.4      20.2.1, 19.3.4              August 18, 2020      Feature      20.2.0      20.2.0              July 14, 2020      CPU      20.1.1, 19.3.3      20.1.1, 19.3.3              May 19, 2020      Feature      20.1.0      20.1.0              April 14, 2020      CPU      20.0.1, 19.3.2      20.0.1, 19.3.2              February 18, 2020      Feature      20.0.0      20.0.0              January 14, 2020      CPU      19.3.1      19.3.1              November 19, 2019      Feature      19.3.0      19.3.0              October 15, 2019      CPU      19.2.1      19.2.1              August 20, 2019      Feature      19.2.0      19.2.0              July 16, 2019      CPU      19.1.1      19.1.1              June 11, 2019      Feature      19.1.0      19.1.0              May 9, 2019      Early Access      19.0.0      19.0.0      For ContributorsConsult the GraalVM Community Roadmap on GitHub to discover what features are currently in development as well as what to expect from upcoming releases.Items on the roadmap are sorted by focus area and labels, and represented by GitHub issues that typically include goals, non-goals, and additional details.The information on this page for Oracle GraalVM is also available here.",
          "url": " /release-calendar/"
          },
          
          "release-notes-release-candidates":  {
          "title": "GraalVM Release Candidates",
          "content": "GraalVM Release Candidates1.0-RC16(2019-04-23)JavaWe addressed several benchmarks that had slower performance when running with the GraalVM compiler built as a native library, also known as libgraal, a mode selected as the default in the last release candidate. We fixed an issue causing a delay when shutting down the virtual machine process at the end of the execution of an application(see #1140).Native ImageWe improved the structure of the org.graalvm.nativeimage API: classes that canonly be used during image generation are now in the packageorg.graalvm.nativeimage.hosted, to clearly separate them from the classes thatcan be used at image run time. In order to stay backwards compatible, theoriginal classes are still present, but marked as deprecated. They will bedeleted in the next release candidate, so please update to the new classes.We fixed several bugs that were reported on GitHub, including anissue with the logging framework which materialized as an error that no instances of java.util.logging.SimpleFormatter are allowed in the image heap.As a result, native images work now correctly with Helidon, a Javaframework designed for writing microservices which recently announced theirsupport for GraalVM native images:Helidon flies faster with GraalVM.RubyA complete changelog for the Ruby component is available on GitHub. The highlights include:  Rounding modes have been implemented or improved for Float, Rational, BigDecimal classes (see #1509).  Added a pure-Ruby implementation of Foreign Function Interface (FFI) which passes almost all Ruby FFI specs (see #1529).  The KeyError raised from ENV#fetch and Hash#fetch now matches MRI’s message formatting (see #1633).JavaScriptA complete changelog for the JavaScript component is available on GitHub. The highlights include:  Loading JavaScript source code from URLs is now guarded by thejs.load-from-url command line option and prohibited by default.RA complete changelog for the R component is available on GitHub. The highlights include:  Allow parsing any letter in identifiersincluding, e.g., Japanese, with lexer starting from 1.0-RC16, which matchesGNU-R behavior.Python  Improved startup time of the graalpython native launcher.LLVM Runtime  The lli launcher now starts with the locale set to C.1.0-RC15(2019-04-05)JavaBy default,libgraal is nowused when running the java launcher or when using the --jvm mode for thelanguage launchers. The libgraal library is a version of the GraalVM compilerpre-compiled by native-image. In addition to improving startup time, libgraalcompletely prevents the GraalVM compiler from interfering with the heap usage andprofiles of application code. It has execution properties similar to othernative HotSpot compilers such as C1 and C2.JavaScript  Enabled Polyglot builtin based on Context.Builder.allowPolyglotAccess().  Added rest and spread properties support for foreign objects. For example, this spread syntax is now supported:    var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1 = [...arr1, ...arr2]; // arr1 is now [0, 1, 2, 3, 4, 5]  To see a complete list of changes, please refer to the project changelog.RNew Features  Implemented gzcon builtin for URL connections.Changes  Truffle interoperability API converts double values to int values if theyfit in the integer range.Bug Fixes  R incorrectly allowed Java interoperability when not started with --jvm.Starting from 1.0-RC15, --jvm flag is again necessary to enable interoperability with Java.A complete project changelog  is available on GitHub.RubyAn extensive list of changes is available on GitHub.Here is a short list of the most notable ones:Changes  Our experimental JRuby-compatible Java interop has been removed – use Polyglot and Java instead.  Process.clock_getres has been implemented.  debug, profile, profiler, which were already marked as unsupported, have been removed.Bug Fixes  autoload :C, &quot;path&quot;; require &quot;path&quot; now correctly triggers the autoload.  The shell standard library can now be require-d.Compatibility  Improved compatibility with MRI’s Float#to_s formatting #1626.  Added support for the base keyword argument to Dir.{[], glob}.PythonChanges  Migrated to the new Truffle libraries for interoperability support.  Added support for importing Java classes from the java namespace using normal Python import syntax, e.g., from java.util import ArrayList.  Implemented PEP 487 and PEP 560 to make the typing module work.More details can be found in the project changelog on GitHub.LLVM Interpreter  Added  a preliminary support for bitcode produced by LLVM 8.Native ImageBased on the feedback and bug reports, we improved the agent that traces reflectionand JNI usage on the JavaHotSpot VM. We also changed the implementation languageof the agent from C to Java. The agent is now a Native Image itself.The native-image-maven-plugin now supports multiline buildArgs andboolean parameter skip (skip image building if true).API changes for GraalVM integrators (SDK + Truffle)This version of GraalVM includes a major revision of the TruffleInteroperabilityAPIs.Most existing APIs for Truffle Interoperability were deprecated. Thecompatibility layer may cause significant performance reduction forinteroperability calls. Please see the Interop MigrationGuidefor an overview and individual @deprecated javadoc tags for guidance.We added Truffle Library API that allows language implementations to usepolymorphic dispatch for receiver types with support for implementation specificcaching/profiling with support for uncached dispatch. Please see the TruffleLibraryTutorialfor further details.The numerous changes were introduced to the GraalVM SDK Polyglot API as well:  Renamed Graal SDK to GraalVM SDK.  Experimental options now require --experimental-options on the command line tobe passed to the GraalVM language launchers, orContext.Builder#allowExperimentalOptions andEngine.Builder#allowExperimentalOptions to be set in other scenarios.For example, to diagnose the memory allocations of a JavaScript application with --memtracer profiling tool,you should prepend --experimental-options option:js --experimental-options --memtracer program.js.  Added a possibility to set an encoding in Source builder.  Added a new API for target type mappings using the new HostAccess API.We summarized all Truffle and SDK changes between GraalVM versions in separate changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsChrome Inspector  Object Preview feature added for GraalVM implementation of JavaScript.  Implemented a Custom Preview experimental feature for all languages supported by GraalVM.Ideal Graph Visualizer (IGV)Starting with 1.0-RC15 version of GraalVM, Ideal Graph Visualizer will beprovided as standalone download from Oracle Technology Network Downloads page. It is not part of GraalVM Community or Enterprise editions.1.0-RC14(2019-03-18)Introducing --vm.&amp;lt;option&amp;gt;We introduced a uniform --vm.&amp;lt;option&amp;gt; which allows to pass options in a uniform way, without knowing which VM mode (--jvm, or --native) will be used. It replaces  --jvm.&amp;lt;option&amp;gt; and --native.&amp;lt;option&amp;gt; command line options, e.g., the option to configure the maximum amount of memory used for the heap --jvm.Xmx=5G becomes --vm.Xmx=5G.This applies to all languages.JavalibgraalThis is the first release to include a prebuilt libgraal shared library. This shared library is produced by the native-image and contains a pre-compiled version of the GraalVM compiler. In addition to improving startup, libgraal completely avoids interfering with the heap usage and profiling of the application code. That is, it has execution properties similar to other native HotSpot compilers such as C1 and C2. To try it out, add -XX:+UseJVMCINativeLibrary to your java command line. Note that this is still a work in progress and we are focusing on improving its stability and ensuring it does not compromise peak performance.Default Failure BehaviorThe default behavior has changed for a failure (i.e., uncaught exception) duringthe compilation. These are now silently ignored and nothing is printed to theconsole. To get the old behavior of a message being printed to the console andfor collecting diagnostics about the failure, you now need to specify-Dgraal.CompilationFailureAction=Diagnose option.Native ImagesNew FeaturesWe introduced a tracing agent for the Java HotSpot VM that records usages of reflection and JNI that can then be converted to configuration files for the native image generator. This simplifies the process of getting new applications working as native images. For details, see the documentation.We improved support for the java.util.logging API. See the GitHub docs for details.The javax.script.ScriptEngine API is now supported. Please note that the Nashorn JavaScript engine does not work in native images and is therefore always excluded. However, Truffle based language implementations such as the GraalVM JavaScript engine are available when, e.g., the native image is built with the option --language:js.Implemented the Class.getSimpleName method for the native images (see 1020).Bugfixes      Fixed an NPE during native image generation at accessing annotations metadata on the classes opened for reflection (see 1048).        Fixed createTempFile() providing non-default file system and failing (see 1035).        Fixed a segfault due to incorrect socket address length value (see 1025).  JavaScriptHTML-like CommentsWe added support for HTML-like comments.var s = &quot;Introducing html-like comments&quot;;alert(s);&amp;lt;!-- this is a comment --&amp;gt;Changes  Renamed the option js.experimental-array-prototype to js.experimental-foreign-object-prototype.More details can be found in the project changelog on GitHub.RThe GraalVM implementation of R in this release comes with various bug fixes and improvements.Error PropagationAccording to the R semantics, errors are handled immediately at the point where they are raised. However, in language embedding or polyglot scenarios, it is more useful to have the errors propagate out of the R scope, so that they can be handled correctly. We changed the behavior of FastR in this regard so that now R errors are propagated. Note that this only happens if this is possible without causing unexpected side effect in R code,i.e., if there are no options(error = ...) or on.exit(...) handlers on the stack.Experimental OptionsAll specific options (NOT those GNU-R compatible like --save) are experimental except for --R.PrintErrorStacktracesToFile, which is an option that enables logging of FastR internal errors for bug reporting purposes. Experimental options can be unlocked using --experimental-options or with ContextBuilder#allowExperimentalOptions.To see a complete list of changes, please refer to the project changelog.RubyThis version of GraalVM features new methods implementations and other updates for Ruby implementation.New Features  Implemented Dir.children and Dir#children, String#delete_prefix, #delete_suffix and related methods.Changes  -Xlog= has been removed. Use --log.level= instead.  -J flag has been removed. Use --vm.* instead.  -J-cp lib.jar and similar have been removed. You should use --vm.cp=lib.jar or --vm.classpath=lib.jar instead.  The -X option now works as in MRI.An extensive list of changes is available on GitHub.PythonPython 3.7.0The standard library was updated to Python 3.7.0 from 3.6.5.Changes  Defined a subset of the graalpython launcher options as “stable”. All other options are subject to change and need to be unlocked explicitly on the command line.  Added the support for  -I flag to ignore the user environment and not add the working directory to sys.path.More details can be found in the project changelog on GitHub.LLVM Runtime  Various bug fixes.API Changes for GraalVM Integrators (SDK + Truffle)New Features  Added Context.Builder#allowExperimentalOptions to control whether experimental options can be passed to a Context.  Added Engine.Builder#allowExperimentalOptions to control whether experimental instrument and engine options can be passed.  The @Option annotation can now specify the stability of an option.  Added engine bound TruffleLogger for instruments. The engine bound logger can be used by threads executing without any context.Changes  Multiple deprecated elements were removed from  the Truffle language implementation framework, i.e., TruffleException.isTimeout, EventBinding.getFilter etc..We summarized GraalVM Truffle and GraalVM SDK changes between GraalVM versions in the separate changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC13(2019-03-05)ToolsIdeal Graph VisualizerWith GraalVM 1.0-RC13 release, there has been a significant change to theIdeal Graph Visualizer developer tool. The default behavior of the Dgraal.Dumpoption has changed in that IGV dumps are now written to the local file system by default.To get the old behavior of dumping straight to an IGV instance listening on 127.0.0.1:4445,you need to add -Dgraal.PrintGraph=Network option.If a network connection cannot be opened, dumping falls back to file system dumping.Graal VisualVMAnother developer tool, Graal VisualVM, now allows Heap monitoring of native-image processes.This functionality is available with Oracle GraalVM.R  R specific command line options are now passed as –R.PrintErrorStackTracesToFile=true instead of using JVM properties (–jvm.R:+PrintErrorStackTracesToFile). You can view available options with --help:languages.  Optional post installation script, configure_fastr, also regenerates etc/Renviron and etc/ldpaths files according to the target system.  R vectors are not writeable from other languages, because this would violate the R language semantics.A list of changes to GraalVM implementation of R is available on GitHub.JavaScript  Node.js updated from 10.15.0 to version 10.15.2.  Made JavaScript and Java interoperability available in native images. Note that you have to configure the accessible classes and methods at native image build time.  Node.js Worker class should be used instead of deprecated experimental Java.Worker API now.  A deprecated NashornJavaInterop mode was removed.More details can be found in the project changelog on GitHub.LLVM Runtime  Added the support for embedded bitcode in Mach-O files. We support bitcode in the __bitcode section of Mach-O object files, as well as bitcode files in an embedded xar archive in the __bundle section of executables or dylibs. For example, on OS X, you can compile your code with clang -fembed-bitcode -flto hello.c -o hello, creating a native executable with embedded bitcode. You can then run it natively (./hello) or with GraalVM ($JAVA_HOME/bin/lli ./hello).The full project changelog is available on GitHub.RubyThis release of GraalVM is rich in performance and compatibility improvements,multiple changes and bug fixes for Ruby implementation.An extensive list of all updates is available on  Github.  Here is a short list of most notable ones:New features:  Host interoperability with Java now works on SubstrateVM too.Changes:  -Xoptions has been deprecated and will be removed. Use --help:languages instead.  -Xlog= has been deprecated and will be removed. Use --log.level= instead.  -J has been deprecated and will be removed. Use --jvm. instead.  -J-cp lib.jar and so on have been deprecated and will be removed. Use--jvm.cp=lib.jar or --jvm.classpath=lib.jar instead.  -J-cmd, --jvm.cmd, JAVA_HOME, JAVACMD, and JAVA_OPTS do not work in any releasedconfiguration of TruffleRuby, so have been removed.  -Xoption=value has been deprecated and will be removed. Use --option=value instead.  TracePoint.trace and TracePoint#inspect have been implemented.Compatibility:  Improved the exception when an -S file is not found.  Removed the message from exceptions raised by bare raise to better match MRI #1487.  TracePoint now handles the :class event.Note that GraalVM 1.0-RC13 implementation of Ruby is built on Ruby 2.4.4, and itis still vulnerable to CVE-2018-16395. This will be fixed in the next release.PythonNew feature:  Allow installation of NumPy in a venv. Just run e.g., bin/graalpython -m venv numpy_env; source numpy_env/bin/activate; graalpython -m ginstall install numpy. Note that not all NumPy features work at the moment.To see a complete list of changes, please refer to the project changelog.API Changes for GraalVM Integrators (SDK + Truffle)  Added Debugger.getSessionCount() to return the number of active debugger sessions.  TruffleLanguage class now can register additional services. This change also deprecates the automatic registration of the language class as a service.  OptionCategory.DEBUG has been renamed to OptionCategory.INTERNAL for clarity.  Added static member to class objects that provides access to the class’s static members.  OptionStabilityhas been added for specifying the stability of an option.All GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC12(2019-02-04)Native Image GenerationNative images now check the remaining available stack size on every method call,and throw a StackOverflowError on stack overflows.We continued the work on the support of incomplete classpaths. There were no big changes,but only small bug fixes based on users feedback. The support for incomplete classpathsnow allows to run the native image generator with bytecode verification,i.e., the option --no-verify is no longer passed to the Java HotSpot VMwhen running the native image generator.RAn extensive list of changes to GraalVM implementation of R is available on GitHub. Here is a short list of most notable ones:  FastR now uses the R base function print to implement TruffleLanguage#toString, so that tools and debuggers (like the Chrome Dev Tools console) format values (e.g., data.frame objects) in a familiar, R-like, way.  GraalVM implementation of R provides GNU-R compatible parseData for expressions parsed via parse(...,keep.source=T), which enables packages that use this functionality (like lambda.r and plumber) to work.  Added a dummy implementation of the ALTREP framework to avoid linking problems.JavaScript  Updated Node.js from 10.9.0 to version 10.15.0.  A new option js.experimental-array-prototype added to set prototype of array-like non-JS objects (like ProxyArray or Java List) to Array.prototype. It makes it possible to use functions like map or forEach on these objects directly.More details can be found in the project changelog on GitHub.LLVM Runtime  In order to streamline the polyglot APIs in LLVM Runtime, we deprecated the truffle_* builtin functions. We also broke binary compatibility to bitcode compiled with polyglot.h from version 1.0.0-RC2 (or older).  Read-only globals are now placed in read-only memory. This was necessary to accommodate some changes in mac OS Mojave’s libc that raise errors when format strings are placed in the writable memory.The project changelog is available on GitHub.RubyThis version came with the compatibility improvements:  Change to a new system for handling Ruby objects in C extensions which greatly increases compatibility with MRI.  Support for BigDecimal#to_r was implemented (See #1521).A complete project changelog is available on GitHub.PythonTo see a complete list of changes, please refer to the project changelog.  Added support for the __class__ variable in the class scope.  Initial support of the venv standard-library tool, the built-in _bz2 module and the pandas package was started up.API Changes for GraalVM Integrators (SDK + Truffle)GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Added the ability to create native image heap dump directly from Graal VisualVM interface.  Improved heap dump support in the native image.1.0-RC11(2019-01-14)Native Image GenerationWe improved the handling of incomplete classpaths, i.e., code that references classes that are not provided on the classpath. The approach we took for RC10 caused problems in corner cases that would have been difficult to fix, therefore we implemented a different approach. Thanks to everyone who tried our initial approach and reported problems on GitHub. We attempted to verify that all reported problems are solved with the new approach.JavaScript  Graal.js only supports ECMAScript 5 (ES5) and newer, and enforces that rule.  Added support for sharing Java objects using the experimental Node.js Worker Threads API.  Added support for ScriptEngine GLOBAL_SCOPE bindings.  Added options to enable/disable several extension features e.g., print() or load().  Added options to disable features for security reasons e.g., eval().More details can be found in the project changelog on GitHub.LLVM RuntimeGraalVM now reports source filenames and line numbers for LLVM functions in stack traces if the bitcode is compiled with debug information, even if the original source is not available.Find a complete changelog on GitHub.RubyA complete project changelog is available on GitHub. Here is a short list of most notable changes:  Allowed signal 0 to be used with Process.kill (see #1474).  Implemented Dir.each_child.  Added missing support for the close_others option to exec and spawn.  Implemented the missing MatchData#named_captures method (see #1512).  Process::CLOCK_ constants have been given the same value as in standard Ruby.  All core files now make use of frozen String literals, reducing the number of String allocations for core methods.PythonThe changelog is available on GitHub.  Added the ginstall custom module to install known packages such as NumPy and setup tools using graalpython -m ginstall.  Added support for the yield from syntax.  Added more built-in methods to the time module.  Added support for the standard zipfile module.  Added the built-in _cvs module.  Various bug fixes and performance improvements.  Removed the exposure of internal languages through polyglot.eval.R  The R version was upgraded to R-3.5.1.  R does not print or log any details for internal errors unless it is run with  --jvm.DR:+PrintErrorStacktracesToFile.  Newly implemented R native API functions:  Rf_duplicated, Rf_setVar, norm_rand, exp_rand.  Numerous bug fixes.More details can be found in the project changelog on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)Please refer to the project changelogs for a list of APIs changes:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Added CPU monitoring of native-image processes.  Improved the search feature in text views - thread dumps, OQL console results, etc..  Heap viewer is now displaying JVM arguments, has improved performance and memory management.1.0-RC10(2018-12-05)Bug fixes and performance improvements across all GraalVM components.Native Image GenerationAdded a new option --allow-incomplete-classpath with GraalVM 1.0-rc10. By default (without specifying this option), classes that are reachable, but missing on the class path, are reported at native image generation time. When specifying this new option, missing classes are only reported at run time. The option provides support for, e.g., libraries that probe the existence of classes, catch the class loading error, and then fall back to a different behavior. This should result in more applications being able to compile to a GraalVM native image.JavaScriptThe project changelog is available on GitHub.  Added the ability to construct the Java classpath programmatically. If you know at runtime where the classes and jar files are located – you can add them to the classpath and use Java code from them.  Compatibility: added support for several proposals which might become parts of ECMAScript 2019: Array.prototype.{flat,flatMap}, well-formed JSON.stringify, globalThis.  Compatibility: moved several non-standard builtins behind flags (see the  changelog).LLVM Runtime  Improved the debugging experience: internal functions (originating from the GraalVM LLVM interpreter implementation) are now hidden in the stack traces by default and can be debugged with --inspect.Internal; and unhandled exceptions are now output to stderr instead of stdout.More details can be found in the project changelog on GitHub.RubyGraalVM 1.0-rc10 implementation of Ruby comes with several new features and multiple bug fixeswhich can be found in the project changelog on GitHub.  Compatibility: implemented the following API and added libraries:          The nkf and kconv standard libraries were added.      Queue and SizedQueue, #close and #closed?, have been implemented.      Kernel#clone(freeze) has been implemented.      Warning.warn has been implemented.      Thread.report_on_exception has been implemented.        Compatibility: ArgumentError messages now better match MRI.Python  Several users-facing improvements were made to the embedding interfaces: getting/setting the current working directory in Python now uses the appropriate Truffle APIs, Python will report side effects in the KEY_INFO message, and the KEYS message now responds with attributes and methods (not with dict keys).  The interactive help() builtin now works, including asking about language and syntax.A complete project changelog is available on GitHub.RMade important steps for compatibility with the R ecosystem:  Improved the support for popular packages: Rcpp modules, dplyr now mostly works,and FastR provides its own version of data.table (work in progress).  A new builtin function install.fastr.packages(pkgs) can be used to install FastR-specific versions of the rJava and data.table packages.  Fixed linking problems on macOS when installing R packages and using Fortran code.The full changelogis available on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVMSeveral quality of life improvements:  Added the display of system properties for SVM heap dumps.  Added support for the fields histogram and merged references for guest languages: JavaScript, Ruby, and so on.  Improved CPU Sampler accuracy.Ideal Graph Visualizer  The tool understands mx project structure now, e.g., the GraalVM compiler project when opening sources.  Improved performance when laying out large graphs.1.0-RC9(2018-11-05)GraalVM for Java Developers (GraalVM + compiler)  Updated based JDK to 8u192. You can find the JDK release notes at the Oracle Technology Network website.RubyGraalVM 1.0-rc9 implementation of Ruby features security updates and multiple bug fixeswhich can be found in the project changelog on GitHub.  Here is a short list of most notable changes:  LLVM for Oracle Linux 7 can now be installed without building from source.  The supported version of LLVM for Oracle Linux has been updated from 3.8 to 4.0.  mysql2 is now patched to avoid a bug in passing NULL to rb_scan_args, and now passes the majority of its test suite.  The post-install script now automatically detects if recompiling the OpenSSL C extension is needed. The post-install script should always be run in TravisCI as well, see the documentation.  Detect when the system libssl is incompatible more accurately and add instructions on how to recompile the extension.Python  Added the support help in the builtin Python shell.  Added readline to enable history and autocompletion in the Python shell.  Add support for the -q, -E, -s, and -S Python launcher flags.  Improved support for string and bytes regular expressions using our TRegex engine.  Started the initial support for the binascii module.A complete project changelog is available on GitHub.R  Various improvements in handling of foreign objects in R.  Added missing R builtins and C API: eapply builtin and rapply builtin.More details can be found in the project changelog on GitHub.JavaScriptA complete changelog is available on GitHub.LLVM RuntimeThe project changelog is available on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)  Added SourceElement.ROOT and StepConfig.suspendAnchors() to tune debugger stepping.  Added Context.Builder.logHandler and Engine.Builder.logHandler methods to install a logging handler writing into a given OutputStream.  Primitives, host and Proxy values can now be shared between multiple context and engine instances. They no longer throw an IllegalArgumentException when shared.The major GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Improved Python heapwalker by fixing class names and adding support for PString.  Fixed handling Page Up/Down in ProfilerTreeTable. See GH-109 for details.1.0-RC8(2018-10-19)GraalVM for Java Developers (GraalVM + compiler)  Added the support for Intel bit manipulation instructions. For more details, see #666.  Virtualize unsafe compare and swap calls on non-escaping objects. See #636.Maven Artifacts  The com.oracle.truffle group ID was renamed to org.graalvm.truffle.  The graal-sdk, launcher-common and polyglot-tck artifacts were moved from the org.graalvm group ID to org.graalvm.sdk.  New artifacts that are now available:          org.graalvm.compiler:compiler      org.graalvm.js:js      org.graalvm.js:js-launcher      org.graalvm.js:js-scriptengine      org.graalvm.regex:regex      org.graalvm.tools:chromeinspector      org.graalvm.tools:profiler      org.graalvm.truffle:truffle-nfi      com.oracle.substratevm:library-support      com.oracle.substratevm:objectfile      com.oracle.substratevm:pointsto      com.oracle.substratevm:svm-driver      com.oracle.substratevm:svm        The artifacts that are now modular JARs:          truffle-api      graal-sdk      js      js-scriptengine      compiler        The compiler artifact provides the jdk.internal.vm.compiler module and can be used to upgrade that module in JDK 11. Unlike the module present in the JDK, this version contains the optimizing Truffle runtime.Native Image Generation  The native image generator now has automatic support for services loaded using ServiceLoader.All service implementation classes, listed in the META-INF directory, are available automatically as soon as the service interface is used. This eliminates the need to manually register resources and reflection support for such classes. The automatic registration can be disabled with the -H:-UseServiceLoaderFeature option.  Finished the support for isolates (starting multiple independent VM instances at run time) and compressed references (to reduce memory footprint; Enterprise Edition only). More details are in an upcoming blog article.  A new Maven plugin allows native image generation from within a Maven build.  All components necessary for native image generation (Substrate VM and the GraalVM compiler) are now available on Maven Central. The dependency for that is:      &amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;com.oracle.substratevm&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;svm&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;1.0.0-rc8&amp;lt;/version&amp;gt;    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;  &amp;lt;/dependency&amp;gt;  JavaScript  Updated Node.js to version 10.9.0.A complete changelog is available on GitHub.LLVM RuntimeThe project changelog is available on GitHub.Ruby  Ubuntu 18.04 LTS, Fedora 28, and macOS 10.14 (Mojave) now supported.  Java.synchronized(object) { } and TruffleRuby.synchronized(object) { } methods have been added.  Added a TruffleRuby::AtomicReference class.  Performance of setting the last exception on a thread has now been improved.A complete project changelog is available on GitHub.Python  Python now supports the allocation profiler (--memtracer) to analyze the heap usage of applications.The changelog is available on GitHub.RGraalVM 1.0-rc8 implementation of R came up with multiple bug fixes which can be found in the project changelog on GitHub.ToolsGraal VisualVM  Introduced the CPU and Memory Sampler for guest languages.  Submitted improvements in the R language heapwalker.API Changes for GraalVM Integrators (SDK + Truffle)The major GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC7(2018-10-03)GraalVM for Java Developers (GraalVM + compiler)  Added the virtualization of Unsafe compare and swap calls, for more details see GH-636.Native Image Generation  Support for the Java security framework, see JCA-SECURITY-SERVICES.md for the details.  Support for https URL connections, see URL-PROTOCOLS.md for more details.JavaScript  Improved support for sharing of shapes between Contexts with the same Engine, which allows to reuse ASTs and objects across different manually created contexts.  Support for BigInteger typed TypedArrays.More details can be found in the project changelog on GitHub.LLVM RuntimeThe full changelog is available on GitHub.  New polyglot builtin polyglot_has_member.  Removed support for implicit polyglot types for local variables as the availability of type information is not guaranteed. Explicit polyglot casts are now strictly required (polyglot_as_typed). See theInteroperability guide for more details.  Support for IR-level (textual representation of bitcode files) tracing, i.e., creating an execution log of all bitcodes that were executed, for debugging purposes.  Preliminary support for LLVM 7.RubyThe complete changelog is available on GitHub. Here is a short list of most notable changes.  Useful inspect strings have been added for more foreign objects.  Added the rbconfig/sizeof native extension for better MRI compatibility.  Support for pg 1.1. The extension now compiles successfully, but may still have issues with some data types.  readline can now be interrupted by the interrupt signal (Ctrl+C). This fixes Ctrl+C to work in IRB.  Fixed version check preventing TruffleRuby from working with Bundler 2.0 and later.  Removed obsoleted patches for Bundler compatibility now that Bundler 1.16.5 has built-in support for TruffleRuby.  Fixed problem with Kernel.public_send not tracking its caller properlyrb_thread_call_without_gvl() no longer holds the C-extensions lock.  Fixed caller_locations when called inside method_added.  Fixed mon_initialize when called inside initialize_copy.Python  Added support for the re.split builtin.  Enhanced the java interop builtin module with introspection utility methods.  Changes in C extension interface to reduce overhead.The changelogis available on GitHub.R  AWT based graphics devices (jpg, png, X11, …) is supported when running FastR as a native image.  eval.polyglot: the parameter source was renamed to code.  New builtin as.data.frame.polyglot.value creates R data frames from Polyglot objects (KEYS are used as column names, the values must be homogenous arrays, e.g., respond to HAS_SIZE).  Paths in eval.polyglot are resolved relative to the current working directory.  Various fixes necessary to pass dplyr tests (GitHub version of dplyr).More details can be found in the project changelog on GitHub.ToolsIdeal Graph Visualizer  User can navigate to JavaScript (guest language) source from the graph nodes.  Ideal Graph Visualizer prompts to download plugins to support JavaScript editing.  Simple scripts (written in JavaScript) can be applied on graph data.API Changes for GraalVM Integrators (SDK + Truffle)  GraalVM SDK and Truffle license changes from GPL2 with Class Path Exception to the Universal Permissive License (UPL). Please refer to the license files for more information: GraalVM Truffle license, GraalVM SDK license.To see the list of changes to the APIs, please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC6(2018-08-31)GraalVM for Java Developers (GraalVM + compiler)  New optimization to remove unnecessary allocation in some calls to Enum.values().  See calls to Enum.values() don’t optimise away as expected for the details.Native Image Generation  Delay class initialization to runtime: By default, all classes that are seen asreachable for a native image are initialized during image building, i.e., theclass initialization method is executed during image building and is not seen asa reachable method at runtime. But for some classes, it is necessary to executethe class initialization method at runtime. This is now possible using the newoption --delay-class-initialization-to-runtime=&amp;lt;comma separate list of classnames&amp;gt; or using the new API RuntimeClassInitialization class.  Direct byte buffer are no longer allowed in the image heap: We added a new verification during image generation to ensure that no direct or mapped byte buffers (MappedByteBuffer instances) are in the image heap. Such buffers have either a pointer to C memory or reference a file descriptor, i.e., native resources that are available during image generation but no longer at image runtime. Using such a buffer would lead to a segfault at runtime. We discovered this issue because Netty has a few direct buffers that are created in class initializers. It is necessary to delay the initialization of such classes to runtime.  Better automatic discovery of classes, methods, and fields accessed via reflection. When String parameters of Class.forName, Class.getMethod, Class.getField, and other similar classes can be constant folded during image generation, then these classes, methods, and fields are automatically registered for reflection usage and do not need to be registered manually on the command line. Constant String parameters are a common pattern to support, e.g., different JDK versions or different library versions where a class, method, or field is not present in all cases and therefore cannot be used directly.LLVM RuntimeThe full changelogis available on GitHub.  Support for LLVM IR-level debugging, i.e., debugging at the level of *.ll instead of *.c files.  New polyglot cast functions for primitive array types, which allows object from other languages to be used like primitive arrays.  Support for function pointer members in polyglot_as_typed, which allows objects from other languages to be used in expressions like obj-&amp;gt;func(args).RubyThe complete changelog is available on GitHub. Here is a short list of most notable changes.  TruffleRuby is now usable as a JSR 223 (javax.script) language;  A migration guide from JRuby is now included.  The embedded configuration -Xembedded can now be set set on the launcher command line.  Polyglot.export can now be used with primitives and converts strings to Java, when Polyglot.import converts them from Java.  Foreign objects optimisations such as unboxing foreign strings on to_s, to_str, and inspect.  Optimized performance and keyword rest arguments (def foo(**kwrest)).  Multiple bug fixes from user reports.PythonThe full changelog is available on GitHub.  Improved compatibility with regular expressions by including CPython’s sre module as a fallback engine (in addition to Truffle’s regular expression engine).  C extension modules can now be compiled with LLVM 5+, which was prevented by internal incompatibilities before.  Introduced lazy string concatenation to significantly speed up code patterns that repeatedly concatenated strings.  Numerous C-API improvements to extend support for scikit-learn.  Extensions and fixes in various areas: behavior of function and code objects, collections, exception handling during import, type ids, documentation and generators.  Update standard library to CPython 3.6.5.  Enable reuse of ASTs in multiple Contexts (requires the contexts to be created in the same polyglot Engine).RThe full changelogis available on GitHub.  Support for reading/writing graphical parameters via par.  Added numerous builtins to the C API, enabling support for packages like RCurl, rjson, compare, naivebayes, etc.  Added support for formulas that include ....  Various bug fixes: attributes of NULL objects, of CR/LF handling in readLine, La_chol with pivot, warnings/errors in vector coercion.API Changes for GraalVM Integrators (SDK + Truffle)To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC5(2018-07-31)GraalVM 1.0-rc5 is the first release where we provide pre-built binaries for GraalVM Community on macOS. As always all binaries are available from the downloads page.KNOWN ISSUES  The GraalVM Community distribution for macOS currently depends on some libraries that are not installed by default on current macOS versions.This might cause issues with UI-related functionality:    Library not loaded: /usr/X11/lib/libfreetype.6.dylib    The necessary components can be added, e.g., by installing https://www.xquartz.org. We will remove this dependency in upcoming versions of GraalVM Community for macOS.  GraalVM for Java Developers (GraalVM + compiler)  1.0-RC5 includes JVMCI changes necessary to support compiling the GraalVM compiler ahead of time and deploying as a shared library alongside libjvm.so (i.e., libgraal). Note that the implementation of libgraal itself is not a part of this release as it is still under development.Native Image Generation  Added API that allows an application to distinguish between native image building, native image runtime, and regular Java execution. For more information and documentation, look at the class  ImageInfo.JavaScript  Removed legacy NashornExtensions option, use --js.nashorn-compat instead.  Added support for Symbol.prototype.description.  Added support for String.prototype.matchAll.More details can be found in the project changelog on GitHub.RubyThe full changelog is available in the GitHub repository, but here are some of the most notable changes.  Simpler installation on macOS: it is no longer needed to add LLVM (/usr/local/opt/llvm@4/bin) to PATH on macOS.  --log.ruby.level= can be used to set the log level from any language launcher.  String#unpack1 has been implemented.  Optimized required and optional keyword arguments.  -Dtruffleruby.log and TRUFFLERUBY_LOG have been removed - use -Dpolyglot.log.ruby.level.  The custom log levels PERFORMANCE and PATCH have been removed.Python  Generator expressions now properly evaluate their first iterator in the definition scope at definition time.  Fixes for embedders to ensure top scopes are stable and local scopes always contain TruffleObjects.  C-API improvements to support simple Cython modules.  Support recognition of Python source files with the polyglot launcher, so that now --language python is not necessary when starting Python scripts with the polyglot launcher (note that the polyglot launcher still needs to be rebuilt using bin/gu rebuild-images polyglot after installing Python).Full changelog is available on GitHub CHANGELOG.md.RSee CHANGELOG for the list of changes.LLVM RuntimeThe project changelog is available on GitHub.  Support the __builtin_debugtrap function based on LLVM’s @llvmn.debugtrap intrinsic, which can be used to drop into the debugger (e.g., Chrome Inspector).  Support “zero-length array at end of struct” pattern when accessing polyglot values as structs.  Improved performance of global variable access.  Improved support for vectorized bitcode operations generated by clang.API Changes for GraalVM Integrators (SDK + Truffle)  Added new execution listener API that allows for simple, efficient and fine-grained introspection of executed code.  Changed the default language context policy from SHARED to EXCLUSIVE, i.e. by default there is one exclusive language instance per polyglot or inner context. This can be configured by the language using the context policy.To see the full list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Graal VisualVM was added to the GraalVM Community distribution.1.0-RC4(2018-07-13)General RemarksWhile we provide updated components for all languages for this rc4 release, only the JavaScript component received fixes from its upstream repository. All other languages are unchanged in terms of functionality.The next release, rc5, is planned for the beginning of August and will provide updates for all components.JavaScriptThe GraalVM JavaScript component has been updated to provide better compatibility with the Nashorn engine. There now is a --nashorn-compat flag to enable backwards compatibility functionality. This flag is highly discouraged for new applications, but can simplify the migration from Nashorn to GraalVM for existing code.  Access getters and setters like fields  Provide Java.extend, Java.super, JavaImporter, JSAdapter  Allow to construct Interfaces or AbstractClasses      Provide top-level package globals java, javafx, javax, com, org, edu    Provide Java.isScriptFunction, Java.isScriptObject, Java.isJavaMethod and Java.isJavaFunctionSome global functions and objects have been added for the scripting mode and can be enabled with the --scripting flag:  Provide $EXEC, $ENV, $ARG, $OPTIONS1.0-RC3(2018-06-29)GraalVM for Java Developers (GraalVM + compiler)  Updated the underlying JDK version to “1.8.0_172” from “1.8.0_171”. You can find the JDK release notes at the Oracle Technology Network website.  Fixed a rare NullPointerException during JVMCI initialization.Native Image Generation  Added support for java.lang.reflect.Proxy supporting both automatic detection and manual configuration.  Added support for Classloader.getResource() and similar methods.  Added support for loading services through theServiceLoader.  Fixed a ClassCastException on generating native images for profile-guided-optimizations (with the --pgo-instrument command line option).JavaScript  Enabled code sharing between Contexts with the same Engine.  Added support for BigInt arithmetic expressions.  Added a flag for the Nashorn compatibility mode --js.nashorn-compat, for the details and migration from Nashorn please refer to the documentation.  Rename the flag for the V8 compatibility mode to js.v8-compat.More details can be found in the project changelog on GitHub.RubyThe full changelog is available in the GitHub repository, but here are some of the most notable changes.  Added ability to call is_a? on foreign objects.  Fixed: Qnil/Qtrue/Qfalse/Qundef can now be used as initial value for global variables in C extensions.  Fixed: SIGPIPE is correctly caught on SubstrateVM, and the corresponding write() raises Errno::EPIPE when the read end of a pipe or socket is closed.  Fixed determining the source encoding for eval() based on the magic encoding comment.Additionally, we implemented a number of performance improvements for stat() related calls, eval(), String substitutions, reading from IO and more.PythonGraalVM Python implementation is still in the early stages, but we’re making progress towards the goal of running applications which use SciPy.  Various C-API improvements allow to run simple NumPy examples.  Implemented buffered I/O and more encodings support, which enables working with files through the standard open function without having to force unbuffered access, and enables working with files that have encodings other than utf-8.  Most math module functions are now implemented and work correctly.  The random module substitute was removed and we now run the standard library random module to be fully compatible.  Improved thread-safety in the embedded scenarios when using Python contexts from multiple threads.More details are available in the project’s changelog on GitHub.R  Added more missing R builtins and C API functions, see CHANGELOG for a complete list.  Simplified installation, the script that configures FastR for the current system  jre/languages/R/bin/configure_fastr does not require Autotools anymore.  Added configuration files to allow users to build a native image of the FastR runtime, which reduces the startup time. Run jre/languages/R/bin/install_r_native_image to build the image.  Fixed an issue with the plotting window not displaying anything after it was closed and reopened.LLVM Runtime  New builtins polyglot_from_typed and polyglot_as_typed, which can be used to dynamically attach types to polyglot objects.  Implementers of TruffleObject can now respond to the GetDynamicType message to provide a type when an object is accessed from LLVM code.More details are available in the project changelog.API Changes for GraalVM Integrators (SDK + Truffle)  Added support for logging in Truffle languages and instruments.  Removed deprecated ResultVerifier.getDefaultResultVerifier API.To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVMWe improved memory footprint and introduced several UI improvements for cleaner more responsive experience of Graal VisualVM. In addition to that, there are the following improvements:  Added recognition of the LLVM Runtime processes.  Improved displaying logical values of guest languages’ objects.  Improved the Object Query Language (OQL) Console for inspecting memory dumps functionality — sorting, filtering, aggregation, unlimited number of results now work.Chrome inspector  Multiple inspector sessions for multiple polyglot engines can run on the same port now.1.0-RC2(2018-06-05)GraalVM for Java Developers  Updated the underlying JDK version to “1.8.0_171” from “1.8.0_161”. You can find the JDK release notes at the Oracle Technology Network website.  Improved support for the Java Microbenchmark harness. Since JMH 1.21, GraalVM is a recognized and supported JVM.  Fixed a StackOverflow exception an improved performance when recursively inlining of invokedynamic instructions.  Fixed a compiler error causing incorrect code generation while building the scalac compiler.Native Image Generation  Added support for building statically linked native images. Now you can pass --static, and if you have static libc and zlib installed, it generates a standalone executable that will not require libc for running.  Added Classpath exception to the license of SubstrateVM and the Graal compiler components to make sure all GraalVM code ending up in a native image is subject to this clause.  Fixed the handling of implicit exceptions (NullPointerExeption, ArrayIndexOutOfBoundsException, ClassCastException, …): all exceptions now have correct stack traces and can be caught as expected. Previously, implicit exceptions were sometimes not caught by an exception handler within the same method.  Fixed a number of exceptions during the generation of native images that were reported by early adopters.JavaScript  Updated Node.js to 8.11.1 (from 8.9.4), it is not a breaking change, but it brings numerous improvements, including CVE-listed security fixes.LLVM Runtime  Added a new API for accessing Java types and instantiating foreign objects from LLVM languages.Now it is possible to easily call Java code from native programs compiled to the LLVM bitcode. The example below shows how you can access Java’s BigInteger long math operations from C.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *bigInteger = polyglot_java_type(&quot;java.math.BigInteger&quot;);    void *(*BigInteger_valueOf)(long) = polyglot_get_member(bigInteger, &quot;valueOf&quot;);    void *bi = BigInteger_valueOf(2);    void *result = polyglot_invoke(bi, &quot;pow&quot;, 256);    char buffer[100];    polyglot_as_string(polyglot_invoke(result, &quot;toString&quot;),                       buffer,                       sizeof(buffer),                       &quot;ascii&quot;);    printf(&quot;%sn&quot;, buffer);}If we compile it to the LLVM bitcode, we can execute it with GraalVM. You can see that it computes the value of2^256 which isn’t that easy to do in C otherwise.# shelajev at shrimp.local in /tmp→ clang -c -O1 -emit-llvm -I$JAVA_HOME/jre/languages/llvm big-integer-demo.c# shelajev at shrimp.local in /tmp→ lli --jvm big-integer-demo.bc115792089237316195423570985008687907853269984665640564039457584007913129639936A more detailed list of changes to the LLVM interpreter can be found in the full changelog.Ruby  We are now compatible with Ruby 2.4.4.  Java.import name imports Java classes as top-level constants.  Coercion of foreign numbers to Ruby numbers now works.  to_s works on all foreign objects and calls the Java toString.  to_str will try to UNBOX and then re-try to_str, in order to provoke the unboxing of foreign strings.Much more details can be found in the full changelog.RAmong the other changes, we improved the stability of GraalVM’s R implementation.  Added a /jre/languages/R/bin/configure_fastr script that allows FastR’s native build scripts to adopt to the current system, which makes installing R packages much more stable.  The fastr_errors.log file was renamed to fastr_errors_pidXYZ.log and is stored in either initial working directory, the user home directory, /tmp, or the FastR home directory (picking the first location that is writeable). Please add it to the bug reports if you submit issues.Python  Added support for the Python unittest framework.  Python now supports breaking on exceptions and unwinding to stack frames in Chrome inspector.API Changes for GraalVM Integrators (SDK + Truffle)Both GraalVM SDK and Truffle are offering API for developers trying to build things on top of GraalVM, language implementations, embedding GraalVM, and so on.  Enabled code sharing between guest language Contexts with the same Engine, speeding up the repeated evaluation of the code.To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsVisualVM  Fixed the issues with loading polyglot heap dumps  fixed executing of scripts in R console  improved recognition of R REPL  fixed loop to nodes  fixed memory leak in child nodes  improved appearance on macOS  Applicability fixes  added roots histogram for classGraalVM Updater gu  The default operation mode changed from “install from local files” to “install from catalog”.  -c option for installing from the catalog, can be omitted (installing from the catalog the default), but specifying -c still works.  Use -F to install from local files, i.e. bin/gu -F /tmp/ruby-installable.jar.Chrome InspectorFixed a number of issues:  fixed the initial suspend of node scripts with no statement on the first line  fixed tooltip issues and representation of the functions  fixed issues with re-connection of Chrome inspector client",
          "url": " /release-notes/release-candidates/"
          },
          
          "release-notes":  {
          "title": "Release Notes",
          "content": "GraalVM Community Edition Release NotesHere you can find information about changes to GraalVM Community Edition between releases.GraalVM Community is comprised of different components, changes to which are listed separately.Release notes are grouped in descending order for usability reasons.  GraalVM 25  GraalVM for JDK 24  GraalVM for JDK 23  GraalVM for JDK 22  GraalVM for JDK 21  GraalVM for JDK 20  GraalVM for JDK 17  GraalVM 22.3.x  GraalVM 22.2.x  GraalVM 22.1.x  GraalVM 22.0.x  GraalVM 21.3.x  GraalVM 21.2.x  GraalVM 21.1.x  GraalVM 21.0.x  GraalVM 20.3.x  GraalVM 20.2.x  GraalVM 20.1.x  GraalVM 20.0.x  GraalVM 19.3.x  GraalVM 19.2.x  GraalVM 19.1.x  GraalVM 19.0.x  GraalVM Release CandidatesTo learn about the release model and updates cadence of GraalVM Community Edition, check the GraalVM Community Version Roadmap.",
          "url": " /release-notes/"
          },
          
          "ruby":  {
          "title": "Ruby",
          "content": "",
          "url": " /ruby/"
          },
          
          "docs-search":  {
          "title": "Search",
          "content": "",
          "url": " /docs/search/"
          },
          
          "latest-security-guide":  {
          "title": "Security Guide",
          "content": "Security GuideThis security guide provides information on the security model and features of GraalVM for developers and embedders who seek to build a secure application on top of it.It assumes that readers are familiar with the GraalVM architecture.This guide does not replace but rather supplements the Java security documentation such as the Secure Coding Guidelines for Java SE with aspects unique to GraalVM.Security ModelGraalVM is a shared runtime. It accepts instructions in a higher-levelprogramming language (or an intermediate representation thereof) as input, which is executed later.Developers that implement security controls for their applications (such as access control) in code that is being run by GraalVM can rely on the correct execution of instructions.Incorrect execution of security-critical code running on top of GraalVM that allows to bypass such a security control is regarded a security vulnerability.Debug features should only be used in a trusted environment as they provide privileged access to an application, allowing to inspect and change its state and behavior.They may further open network sockets to allow debug clients to connect.Experimental features in GraalVM are not for production use and may have security limitations not covered in the Security Guide.GraalVM enables execution of untrusted code in an appropriately configured polyglot execution context (see Sandboxing).We appreciate reports of bugs that break the security model via the processoutlined in the Reporting Vulnerabilities guide.Graal LanguagesEvery language runtime, generally available with a GraalVM release, provides a launcher, for example, an interactive shell.These launchers behave in the same way and come with the same security guarantees as their “original” counterparts.SandboxingSandboxing can establish a security boundary between privileged host code and unprivileged guest code, facilitated through the Polyglot API.For further information please refer to the Sandboxing documentation.ScriptEngine CompatibilityFor reasons of backward compatibility, certain Polyglot languages also support the Java Scripting API.For example, this allows the GraalVM Javascript runtime to be used as a drop-in replacement for Nashorn.However, to maintain compatibility, the Nashorn GraalVM JavaScript ScriptEngine interface will create a context with all privileges granted to the script and should be used with extreme caution and only for trusted code.Managed Execution of Native CodePolyglot embedding also supports LLVM intermediate representation (IR) guest code.Several native system programming languages, above all C/C++, can be compiled to LLVM IR with the LLVM compiler toolchain.Typically, these languages are not memory-safe unless using managed execution and it must be remembered that violations of memory safety are a frequent cause of security vulnerabilities.In managed mode, all access to unmanaged code including the operating system is mediated by the language runtime. In particular this means that:  In regards to temporal and spatial memory safety, memory is allocated from the Java heap. This means that memory allocations are managed objects and all accesses are performed in a memory-safe manner (no arbitrary pointer arithmetic and no unchecked out-of-bounds accesses).  Regarding type safety, it is not possible to reinterpret a data pointer into a function pointer and execute arbitrary instructions (since these are distinct pointer types for LLVM runtime).  System calls are intercepted and routed to the corresponding Truffle APIs. For example, file IO is mapped to the Truffle FileSystem API.The set of currently supported system calls is very limited—only syscalls that can safely be mapped to the Truffle API level are available. Since LLVM Runtime in managed mode always runs bitcode compiled for Linux/x86, it only needs to implement system calls for this platform.  All dependent libraries are executed in managed mode as well, removing all references to natively executed system libraries. This includes libraries that are provided by the LLVM Runtime, such as muslibc.Managed mode can be selected when creating a context (Context.create()) or when calling the bin/lli binary by specifying the --llvm.managed option. A “managed” context will adhere to any restrictions (for example, allowIO) passed during context creation and does not need the allowNativeAccess privilege.Native ImageWith GraalVM native image, an application’s state is captured after startup and all reachable code is compiled ahead of time to be bundled as a native executable.For further information please refer to the native image security guide.Security ManagerSecurity manager has been deprecated in JEP-411.GraalVM does not support untrusted code execution in Java.GraalVM Community Edition DowngradeSandboxing is not available in GraalVM Community Edition.Managed execution of native code is not available with GraalVM Community Edition.When downgrading to GraalVM Community Edition, native code execution is only possible with the allowNativeAccess privilege.This also applies to languages implemented with Truffle that allow for native code extensions, such as Python and Ruby.Related Documentation  Sandboxing  Security Considerations in Native Image",
          "url": " /latest/security-guide/"
          },
          
          "latest-reference-manual-espresso-continuations-serialization":  {
          "title": "Serialization of Continuations",
          "content": "Serialization of ContinuationsSee below a Java application using the Continuation API with serialization.This application persists its state by saving it to a file. Each time it runs, the program increments a counter, displays the updated value, and then exits.package com.oracle.truffle.espresso.test.continuations;import java.io.Serializable;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import org.graalvm.continuations.Continuation;import org.graalvm.continuations.ContinuationEntryPoint;import org.graalvm.continuations.SuspendCapability;/** * Application that persists its state by saving it to a file. * &amp;lt;p&amp;gt; * Each time the program is run, it increments the counter and prints out the new value before quitting. * &amp;lt;p&amp;gt; * By default, the state is persisted to a file named &quot;state.serial.bin&quot; in the current working directory, * but it can be changed by specifying a new path with the {@code &quot;-p &amp;lt;path&amp;gt;&quot;} option. * &amp;lt;p&amp;gt; * By default, standard Java serialization is used, but &quot;Kryo&quot; can be selected with the {@code &quot;-s kryo&quot;} option. * &amp;lt;p&amp;gt; * The continuation payload must implement `ContinuationEntryPoint`. * This class is also `Serializable` to work with Java serialization. */public class PersistentApp implements ContinuationEntryPoint, Serializable {    /**     * An interface for serializing/deserializing a continuation to the file system.     * Two implementations are showcased later: one for `Java` and one for `Kryo`.     */    public interface MySerializer {        Continuation load(Path storagePath) throws IOException, ClassNotFoundException;        void saveTo(Continuation continuation, Path storagePath) throws IOException;    }    private static final String DEFAULT_PATH = &quot;state.serial.bin&quot;;    int counter = 0;    /**     * Anything reachable from the stack in this method is persisted, including &#39;this&#39;.     * &amp;lt;p&amp;gt;     * Suspending a continuation requires access to this “suspend capability” object.     * By controlling who gets access to it, you can work out where a suspension might occur.     * If you do not want this, the capability can be stored it in a static `ThreadLocal` and let anything suspend.     */    @Override    public void start(SuspendCapability suspendCapability) {        while (true) {            counter++;            System.out.println(&quot;The counter value is now &quot; + counter);            doWork(suspendCapability);        }    }    private static void doWork(SuspendCapability suspendCapability) {        // Do something ...        /*         * The call to `suspend` causes control flow to return from the call to resume below.         * The state of the application will be written to the file system and it will carry on when the user starts the application again.         */        suspendCapability.suspend();        // Do something else ...    }    public static void main(String[] args) throws IOException, ClassNotFoundException {        checkSupported();        Path storagePath = getStoragePath(args);        MySerializer ser = getSerializer(args);        Continuation continuation = loadOrInit(storagePath, ser);        /*         * Control flow will either begin at `start` for the first program execution,         * or jump to after the call to `suspend` above for later executions.         */        continuation.resume();        ser.saveTo(continuation, storagePath);    }    private static void checkSupported() {        try {            if (!Continuation.isSupported()) {                System.err.println(&quot;Ensure you are running on an Espresso VM with the flags &#39;--experimental-options --java.Continuum=true&#39;.&quot;);                System.exit(1);            }        } catch (NoClassDefFoundError e) {            System.err.println(&quot;Please make sure you are using a VM that supports the Continuation API&quot;);            System.exit(1);        }    }    /////////////////////////////////////////////////////////////    // Code to load, save and resume the state of the program. //    /////////////////////////////////////////////////////////////    private static Path getStoragePath(String[] args) {        for (int i = 0; i &amp;lt; args.length; i++) {            String s = args[i];            if (s.equals(&quot;-p&quot;) &amp;amp;&amp;amp; (args.length &amp;gt; i + 1)) {                return Paths.get(args[i + 1]);            }        }        return Paths.get(DEFAULT_PATH);    }    private static Continuation loadOrInit(Path storagePath, MySerializer ser) throws IOException, ClassNotFoundException {        Continuation continuation;        if (!Files.exists(storagePath)) {            /*             * First execution of the program with the specified path: use a fresh continuation.             */            continuation = Continuation.create(new PersistentApp());        } else {            /*             * Program had been executed at least once with the specified path: restore the continuation from file.             */            continuation = ser.load(storagePath);        }        return continuation;    }    private static MySerializer getSerializer(String[] args) {        for (int i = 0; i &amp;lt; args.length; i++) {            String s = args[i];            if (s.equals(&quot;-s&quot;) &amp;amp;&amp;amp; (args.length &amp;gt; i + 1)) {                String key = args[i + 1];                if (key.equals(&quot;java&quot;)) {                    return new MyJavaSerializer();                }                if (key.equals(&quot;kryo&quot;)) {                    return new MyKryoSerializer();                }            }        }        return new MyJavaSerializer();    }}Note the MySerializer interface. We will be implementing that interface to showcase two different ways to serialize a continuation:  One using the standard Java serialization (using the built-in ObjectInputStream and ObjectOutputStream);  The other using the popular and fast Kryo library.JavaHere is the implementation of MySerializer that uses standard Java serialization::warning: Java object serialization requires everything reachable from the captured stack to implement the Serializable interface, and (ideally) be whitelisted by a serialization filter.This is less convenient than Kryo which will happily serialize anything.The format is also more verbose than Kryo’s, yielding continuations about double the size.However, it avoids the need for a separate dependency.import static java.nio.file.StandardOpenOption.*;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.nio.file.Files;import java.nio.file.Path;import org.graalvm.continuations.Continuation;class MyJavaSerializer implements PersistentApp.MySerializer {    @Override    public Continuation load(Path storagePath) throws IOException, ClassNotFoundException {        try (var in = new ObjectInputStream(Files.newInputStream(storagePath, READ))) {            return (Continuation) in.readObject();        }    }    @Override    public void saveTo(Continuation continuation, Path storagePath) throws IOException {        // Will overwrite previously existing file if any.        try (var out = new ObjectOutputStream(Files.newOutputStream(storagePath, CREATE, TRUNCATE_EXISTING, WRITE))) {            out.writeObject(continuation);        }    }}KryoHere is the implementation of MySerializer that uses the Kryo library:import static java.nio.file.StandardOpenOption.*;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import org.graalvm.continuations.Continuation;import org.graalvm.continuations.ContinuationSerializable;import org.objenesis.strategy.StdInstantiatorStrategy;import com.esotericsoftware.kryo.Kryo;import com.esotericsoftware.kryo.KryoException;import com.esotericsoftware.kryo.Serializer;import com.esotericsoftware.kryo.io.Input;import com.esotericsoftware.kryo.io.KryoObjectInput;import com.esotericsoftware.kryo.io.KryoObjectOutput;import com.esotericsoftware.kryo.io.Output;import com.esotericsoftware.kryo.util.DefaultInstantiatorStrategy;class MyKryoSerializer implements PersistentApp.MySerializer {    // We set up the Kryo engine here.    private static final Kryo kryo = setupKryo();    private static Kryo setupKryo() {        var kryo = new Kryo();        // The heap will have cycles, and Kryo requires us to opt in to support for that.        kryo.setReferences(true);        // We do not want to manually register everything, as heap contents are dynamic.        kryo.setRegistrationRequired(false);        // Be able to create objects even if they lack a no-arg constructor.        kryo.setInstantiatorStrategy(                new DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));        /*         * Register a custom serializer for continuation objects.         * All serialization-relevant classes in the Continuation API will extend the `ContinuationSerializable` class.         */        kryo.addDefaultSerializer(ContinuationSerializable.class, new ContinuationSerializer());        return kryo;    }        /**     * A custom Kryo `Serializer` for continuation objects.     */    static class ContinuationSerializer extends Serializer&amp;lt;ContinuationSerializable&amp;gt; {        public ContinuationSerializer() {            super(false, false);        }        @Override        public void write(Kryo kryo, Output output, ContinuationSerializable object) {            try {                ContinuationSerializable.writeObjectExternal(object, new KryoObjectOutput(kryo, output));            } catch (IOException e) {                throw new KryoException(e);            }        }        @Override        public ContinuationSerializable read(Kryo kryo, Input input, Class&amp;lt;? extends ContinuationSerializable&amp;gt; type) {            try {                /*                 * The continuation deserialization mechanism will use this classloader to load the classes present on the heap.                 * Kryo requires awareness of created objects in order to handle cycles in the serialized object graph.                 * Let Kryo know about the deserialized objects using kryo::reference.                 */                return ContinuationSerializable.readObjectExternal(type, new KryoObjectInput(kryo, input),                        kryo.getClassLoader(),                        kryo::reference);            } catch (IOException | ClassNotFoundException e) {                throw new KryoException(e);            }        }    }    @Override    public Continuation load(Path storagePath) throws IOException {        try (var in = new Input(Files.newInputStream(storagePath, READ))) {            return kryo.readObject(in, Continuation.class);        }    }    @Override    public void saveTo(Continuation continuation, Path storagePath) throws IOException {        try (var out = new Output(Files.newOutputStream(storagePath, CREATE, TRUNCATE_EXISTING, WRITE))) {            kryo.writeObject(out, continuation);        }    }}Further Reading  Continuation API",
          "url": " /latest/reference-manual/espresso/continuations/serialization/"
          },
          
          "slack-invitation":  {
          "title": "Join GraalVM Community in Slack",
          "content": "",
          "url": " /slack-invitation/"
          },
          
          "latest-reference-manual-native-image-guides-specify-class-initialization":  {
          "title": "Specify Class Initialization Explicitly",
          "content": "Specify Class Initialization ExplicitlyBy default, Native Image initializes application classes at run time, except for the classes that Native Image proves “safe” for initialization at build time.However, you can influence the default behavior by explicitly specifying the classes to be initialized at build-time or run time.For that, there are two command-line options: --initialize-at-build-time and --initialize-at-run-time.You can use these options to specify whole packages or individual classes.For example, if you have the classes p.C1, p.C2, … ,p.Cn, you can specify that all the classes in the package p are to be initialized at build time by passing the following option to native-image:--initialize-at-build-time=pIf you want only class C1 in package p to be initialized at run time, use:--initialize-at-run-time=p.C1You can also programmatically specify class initialization using the RuntimeClassInitialization class from the Native Image Feature interface.This guide demonstrates how to build a native executable by running the class initializer at run time (default behavior), and then at build time, and compares the two approaches.PrerequisiteMake sure you have installed a GraalVM JDK.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.Run a DemoFor the demo, run a simple Java application that parses some Java talks from 2023.The parser creates records and adds them to a List&amp;lt;Talk&amp;gt; collection.  Save the following Java source code in a file named TalkParser.java:     import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class TalkParser {   private static final List&amp;lt;Talk&amp;gt; TALKS = new ArrayList&amp;lt;&amp;gt;();   static {     Scanner s = new Scanner(&quot;&quot;&quot;         Asynchronous Programming in Java: Options to Choose from by Venkat Subramaniam         Anatomy of a Spring Boot App with Clean Architecture by Steve Pember         Java in the Cloud with GraalVM by Alina Yurenko         Bootiful Spring Boot 3 by Josh Long         &quot;&quot;&quot;);     while (s.hasNextLine()) {       TALKS.add(new Talk(s.nextLine()));     }     s.close();   }   public static void main(String[] args) {     System.out.println(&quot;Talks loaded using scanner:&quot;);     for (Talk talk : TALKS) {         System.out.println(&quot;- &quot; + talk.name());     }   } } record Talk (String name) {}    Compile the application:     javac TalkParser.java    Build a native executable, explicitly running the class initializer at run time:     native-image --initialize-at-run-time=TalkParser,Talk -o runtime-parser TalkParser    You can omit the --initialize-at-run-time=TalkParser,Talk option in this example because these classes are marked for initialization at run time by default. The -o option specifies the name of the output file.    Run and time the native application:     time ./runtime-parser    On a machine with 16 GB of memory and 8 cores, you should see a result similar to:     Talks loaded using scanner: - Asynchronous Programming in Java: Options to Choose from by Venkat Subramaniam - Anatomy of a Spring Boot App with Clean Architecture by Steve Pember - Java in the Cloud with GraalVM by Alina Yurenko - Bootiful Spring Boot 3 by Josh Long ./runtime-parser  0.00s user 0.00s system 52% cpu 0.010 total    The application parses the text block at run time.    Check the file size which should be around 13M:     du -sh runtime-parser    Next, build a native executable initializing TalkParser at build time, and providing a different name for the output file to differentiate it from the previous build. The Talk record has to be initialized explicitly too, so the objects of this type will be persisted in the image heap.    native-image --initialize-at-build-time=TalkParser,Talk -o buildtime-parser TalkParser    If your application adds additional types to the image heap, each type (or the corresponding package) needs to be marked for build-time initialization explicitly.An appropriate actionable error message will guide you through the process.    Run and time the second executable for comparison:     time ./buildtime-parser    This time you should see something similar to this:     Talks loaded using scanner: - Asynchronous Programming in Java: Options to Choose from by Venkat Subramaniam - Anatomy of a Spring Boot App with Clean Architecture by Steve Pember - Java in the Cloud with GraalVM by Alina Yurenko - Bootiful Spring Boot 3 by Josh Long ./buildtime-parser  0.00s user 0.00s system 53% cpu 0.016 total    Check the file size which should decrease to around 6.4M!     du -sh buildtime-parser    The file size change is because Native Image runs the static initializer at build time, parsing the text block, and persisting only the Talk records in the executable.    As a result, the majority of the scanning infrastructure does not become reachable when Native Image statically analyzes the application and is, therefore, not included in the executable.  Another valuable criterion for profiling applications more accurately is the number of instructions, which can be obtained using the Linux perf profiler.For example, for this demo application, the number of instructions decreased by almost 30% (from 11.8M to 8.6M) in the case of build-time class initialization:perf stat ./runtime-parserTalks loaded using scanner:- Asynchronous Programming in Java: Options to Choose from by Venkat Subramaniam(...) Performance counter stats for &#39;./runtime-parser&#39;:(...)        11,323,415      cycles                           #    3.252 GHz        11,781,338      instructions                     #    1.04  insn per cycle         2,264,670      branches                         #  650.307 M/sec            28,583      branch-misses                    #    1.26% of all branches(...)       0.003817438 seconds time elapsed       0.000000000 seconds user       0.003878000 seconds sysperf stat ./buildtime-parserTalks loaded using scanner:- Asynchronous Programming in Java: Options to Choose from by Venkat Subramaniam(...) Performance counter stats for &#39;./buildtime-parser&#39;:(...)         9,534,318      cycles                           #    3.870 GHz         8,609,249      instructions                     #    0.90  insn per cycle         1,640,540      branches                         #  665.818 M/sec            23,490      branch-misses                    #    1.43% of all branches(...)       0.003119519 seconds time elapsed       0.001113000 seconds user       0.002226000 seconds sysThis demonstrates how Native Image can shift work from run time to build time: when the class is initialized at build time, the text block is parsed when the executable is being built and only the parsed objects are included.This not only makes the executable smaller in file size, but also faster to run: when the executable runs, the Talk records already exist and only need to be printed.To ensure native executables built with Native Image are as compatible as possible with the HotSpot behavior, application classes that cannot be safely initialized at build time, are initialized at run time.You as a user, or a framework that you use, must explicitly request build-time initialization for certain classes to benefit from smaller file sizes and faster times to run.Include the right data structures to avoid the image size blowing up instead.We also recommend using --initialize-at-build-time with single classes only.It may be that you need to add a lot of --initialize-at-build-time entries.Note that incorrect build-time initialization can lead to problems that are to be avoided in production settings such as dysfunctional behavior or including sensitive data such as passwords or encryption keys.ConclusionThis guide demonstrated how you can influence the default native-image class initialization policy, and configure it to initialize a specific class at build time, depending on the use case.The benefits of the build-time versus run-time initialization are described in Class Initialization in Native Image, but, in short, build-time initialization can significantly decrease the overall file size and improve the runtime of your application when used correctly.Related Documentation  Class Initialization  Native Image Build Configuration",
          "url": " /latest/reference-manual/native-image/guides/specify-class-initialization/"
          },
          
          "support":  {
          "title": "GraalVM Support",
          "content": "GraalVM SupportAt its core, GraalVM is an open source project supported by a large community.Community-driven support channels include:  [GraalVM Documentation]({{ ‘/latest/docs/’ | relative_url }})Learn how to take advantage of GraalVM.  GraalVM on GitHubOpen issues for bug reports or feature requests, start discussions, and [contribute]({{ ‘/community/contributors/’ | relative_url }}) to GraalVM.  [GraalVM on Slack]({{ ‘/slack-invitation/’ | relative_url }})Chat with the people that build GraalVM, discuss your ideas, get help, and help others.  GraalVM mailing listSubscribe and post to graalvm-users@oss.oracle.com.Commercial SupportEnd of support for Oracle GraalVM in Java SE products: Oracle GraalVM for JDK 24 was the final version of Oracle GraalVM licensed and supported as part of Oracle Java SE products. Any entitled customers seeking patches or updates to previously released Oracle GraalVM versions should download them through MOS. More information is available here. Customers seeking additional information or assistance should contact MOS.Security VulnerabilitiesSecurity vulnerabilities of any kind in either Oracle GraalVM or GraalVM Community Edition should only be reported via email to secalert_us@oracle.com.",
          "url": " /support/"
          },
          
          "latest-reference-manual-tools":  {
          "title": "Tools for Graal Languages",
          "content": "Tools for Graal LanguagesHere you can find a set of tools for Graal languages, to debug and monitor deployed applications, as well as the GraalVM platform itself. Traditional tools may not be ready to diagnose polyglot applications.GraalVM tools, however, are implemented to inspect single or multi-language applications by debugging via numerous clients, profiling, statement counting, dynamic analysis, and much more.Learn more about each of the tools:  VisualVM  GraalVM Insight  Profiling Command Line Tools  Code Coverage Command Line Tool  Ideal Graph Visualizer  Chrome Debugger  Language Server Protocol  Debug Adapter Protocol",
          "url": " /latest/reference-manual/tools/"
          },
          
          "latest-reference-manual-native-image-guides-troubleshoot-run-time-errors":  {
          "title": "Troubleshoot Native Image Run-Time Errors",
          "content": "Troubleshoot Native Image Run-Time ErrorsA successful ahead-of-time compilation can still generate images that crash at run time or do not behave the same way as the application would behave on a Java VM. In this guide, some reasons for that are shown, along with the strategies to diagnose and resolve the issues.Note that sometimes upgrading to the latest version of GraalVM can already resolve an issue.1. Diagnose Missing Metadata RegistrationStart by diagnosing if there is any metadata configuration missing.Native Image requires all utilized classes to be known during the build.The static analysis tries to make predictions about the run-time behavior of your application.In some cases, you need to provide the analysis with configuration to make all dynamic feature calls visible to it.Failing to do so will result in an image that terminates at run-time with hard-to-diagnose errors once the dynamic feature is used in the application.This can be avoided by eagerly checking for missing metadata.      Pass the --exact-reachability-metadata option to the native-image tool and rebuild the application. If you want to do this only for a specific package, specify a package prefix --exact-reachability-metadata=[package prefix].          This option was introduced in GraalVM for JDK 23 for debugging purposes. In GraalVM versions prior to JDK 23, use the -H:ThrowMissingRegistrationErrors= build option instead.            Run the generated native executable passing the -XX:MissingRegistrationReportingMode=Warn option to find all places in your code where missing registrations occur.          -XX:MissingRegistrationReportingMode= was promoted to a run-time option in GraalVM for JDK 23. In GraalVM versions prior to JDK 23, use the -H:MissingRegistrationReportingMode=Warn build option instead.            If there is some missing metadata reported, make sure to add it to the reachability-metadata.json file. See how to do it in the Reachability Metadata documentation.          It is not always necessary to add all reported elements to reachability-metadata.json. The one causing the program failure is usually among the last listed.              In GraalVM versions prior to JDK 23, errors may be reported for elements already present in reachability-metadata.json. These can be safely ignored, as they result from the experimental nature of the -H:ThrowMissingRegistrationErrors= option.      Shared LibrariesFor diagnosing shared libraries built with Native Image, you can either:  specify -R:MissingRegistrationReportingMode=Exit when building a native shared library;  or specify -XX:MissingRegistrationReportingMode=Exit when the isolate is created. graal_create_isolate_params_t has argc (_reserved_1) and argv (_reserved_2) fields that can be used to pass C-style command-line options at run time. However, note that both fields are currently not public APIs.2. Set java.home ExplicitlyIf your application code uses the java.home property, set it explicitly with -Djava.home=&amp;lt;path&amp;gt; when running a native executable.Otherwise, the System.getProperty(&quot;java.home&quot;) call will return a null value.3. Enable URL ProtocolsTry enabling all URL protocols on-demand at build time: --enable-url-protocols=&amp;lt;protocols&amp;gt;.To enable the HTTPS support only, pass --enable-https.4. Include All Charsets and LocalesOther handy options are -H:+AddAllCharsets to add charsets support, and -H:+IncludeAllLocales to pre-initialize support for locale-sensitive behavior in the java.util and java.text packages. Pass those options at build time.This might increase the size of the resulting binary.5. Add Missing Security ProvidersIf your application is using Security Providers, try to pre-initialize security providers by passing the option -H:AdditionalSecurityProviders=&amp;lt;list-of-providers&amp;gt; at build time. Here is a list of all JDK security providers to choose from:sun.security.provider.Sun,sun.security.rsa.SunRsaSign,sun.security.ec.SunEC,sun.security.ssl.SunJSSE,com.sun.crypto.provider.SunJCE,sun.security.jgss.SunProvider,com.sun.security.sasl.Provider,org.jcp.xml.dsig.internal.dom.XMLDSigRI,sun.security.smartcardio.SunPCSC,sun.security.provider.certpath.ldap.JdkLDAP,com.sun.security.sasl.gsskerb.JdkSASL.6. File a Native Image Run-Time IssueOnly if you tried all the above suggestions, file a Native Image Run-Time Issue Report at GitHub, filling out the necessary information.To gather the required information for filing a proper and actionable ticket, it is recommended to run a native-image build with the diagnostics mode enabled. Pass the --diagnostics-mode option enabling diagnostics output for class initialization, substitutions, and so on.Related Documentation  Specifying Metadata with JSON",
          "url": " /latest/reference-manual/native-image/guides/troubleshoot-run-time-errors/"
          },
          
          "truffle":  {
          "title": "Truffle Language Implementation Framework",
          "content": "Truffle Language Implementation FrameworkThe Truffle Language Implementation Framework (Truffle) is an open-source library shipped with GraalVM to build fast interpreters for programming languages. Truffle simplifies the development process by allowing the automatic generation of high-performance code from interpreters. Truffle also enables the creation of language-agnostic tools like debuggers and profilers, making it a powerful platform for building both new languages and development tools.Learn more about Truffle from the reference documentation.A good way to start implementing your language with Truffle is to fork the SimpleLanguage project.SimpleLanguage is a relatively small language implementation, well-documented, and designed to demonstrate most of the Truffle features.",
          "url": " /truffle/"
          },
          
          "latest-reference-manual-ruby":  {
          "title": "TruffleRuby Documentation",
          "content": "",
          "url": " /latest/reference-manual/ruby/"
          },
          
          "latest-reference-manual-native-image-guides-use-graalvm-dashboard":  {
          "title": "Use GraalVM Dashboard to Optimize the Size of a Native Executable",
          "content": "GraalVM Dashboard was removed in GraalVM for JDK 22.Instead, use the Native Image Build Reports.The Native Image Build Reports provide useful visualizations and comprehensive insights into different metrics of your native executable and the build process itself.",
          "url": " /latest/reference-manual/native-image/guides/use-graalvm-dashboard/"
          },
          
          "latest-reference-manual-native-image-guides-use-sbom-support":  {
          "title": "Embed an SBOM in a Native Executable to Identify Its Dependencies",
          "content": "Embed an SBOM in a Native Executable to Identify Its DependenciesNative Image embeds a Software Bill of Materials (SBOM) into the resulting binary by default. (Not available in GraalVM Community Edition.)An SBOM is an inventory of all the components, libraries, and modules that make up your application.It provides detailed information about all open-source and proprietary libraries used by the application and their versions, and it supports the CycloneDX format by default.You can configure this behavior with the --enable-sbom option. See Software Bill of Materials (SBOM) in Native Image for more information.Prerequisites  Make sure you have installed Oracle GraalVM.The easiest way to get started is with SDKMAN!.For other installation options, visit the Downloads section.  SyftGenerate a Native ExecutableFor the demo application, you will use the jwebserver tool, and package it as a native executable with an embedded SBOM.  jwebserver is a minimal HTTP server for serving static files from a single directory hierarchy, included in the JDK. It was added in Java 18.  Save the following code to a file named index.html, so the web server has content to serve:     &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt;     &amp;lt;head&amp;gt;         &amp;lt;title&amp;gt;jwebserver&amp;lt;/title&amp;gt;     &amp;lt;/head&amp;gt;     &amp;lt;body&amp;gt;     &amp;lt;h2&amp;gt;Hello, GraalVM user!&amp;lt;p&amp;gt;     &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;    From the directory where you saved index.html, run the following command to create a native executable:     native-image -m jdk.httpserver -o jwebserver    Native Image compiles jwebserver from the jdk.httpserver module, provided with the JDK, by passing the -m option. It produces a native executable containing a GZIP format compressed SBOM.    (Optional) Run the compiled jwebserver executable and go to localhost:8000 in a browser:     ./jwebserver  Extract the Embedded SBOMThere are two possible ways to extract the compressed SBOM contents into a human-readable format:  using Syft  using the Native Image Utils ToolSyftSyft, syft, is an open source tool maintained by Anchore.Syft can extract an embedded SBOM which it can present in both a native Syft format or CycloneDX.Thanks to a contribution from the GraalVM team, syft can now extract an SBOM given within a native executable, built for Linux, macOS, or Windows.Run syft on the native executable to read its SBOM contents:syft jwebserverIt lists all of the Java libraries included in it.Native Image Utils ToolGraalVM Native Image provides the native-image-utils tool to retrieve an SBOM embedded in a native executable.The Utils Tool is a viable alternative if you prefer not to install syft.Run the following command to read the SBOM contents using the Utils Tool:$JAVA_HOME/bin/native-image-utils extract-sbom --image-path=&amp;lt;path_to_binary&amp;gt;To take it further, you can submit the SBOM to any available vulnerability scanner, and check if the recorded libraries have known security vulnerabilities.Vulnerability scanners cross-reference the components listed in an SBOM with CVEs in vulnerability databases.This guide demonstrated how you can get insights on your application supply chain to help assess risks associated with the third-party dependencies.Native Image can embed an SBOM into a native executable or shared library at build time.Related Documentation  Software Bill of Materials (SBOM) in Native Image  Security Considerations in Native Image",
          "url": " /latest/reference-manual/native-image/guides/use-sbom-support/"
          },
          
          "latest-reference-manual-native-image-guides-use-system-properties":  {
          "title": "Use System Properties in a Native Executable",
          "content": "",
          "url": " /latest/reference-manual/native-image/guides/use-system-properties/"
          },
          
          "use-cases":  {
          "title": "GraalVM Use Cases",
          "content": "",
          "url": " /use-cases/"
          },
          
          "latest-docs":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/"
          },
          
          "latest-tools-vscode-graalvm-extension-visualvm-integration":  {
          "title": "VisualVM and VS Code Integration",
          "content": "",
          "url": " /latest/tools/vscode/graalvm-extension/visualvm-integration/"
          },
          
          "latest-tools-visualvm":  {
          "title": "VisualVM",
          "content": "VisualVMGraalVM provides support for VisualVM, the all-in-one Java (and polyglot) monitoring and troubleshooting tool. VisualVM enables powerful yet easy-to-use Java tooling which includes heap analysis for the supported guest languages. The following languages and features are currently available:  Java: Heap Summary, Objects View, Threads View, OQL Console  JavaScript: Heap Summary, Objects View, Thread View  Python: Heap Summary, Objects View  Ruby: Heap Summary, Objects View, Threads View  R: Heap Summary, Objects ViewStarting VisualVM      Download the latest VisualVM from visualvm.github.io, unzip, and move it to the applications directory.        Double-click on the application icon to start.  Immediately after startup, the tool shows all locally running Java processes in the Applications area, including the VisualVM process, itself.Using VisualVM with GraalVM Native Executables  Note: VisualVM support for GraalVM native executables is not yet available on Windows.When using GraalVM Native Image, VisualVM support is disabled by default.VisualVM support can be enabled when building a native executable with the option --enable-monitoring=jvmstat,heapdump:native-image --enable-monitoring=jvmstat,heapdump JavaApplicationCapture a Heap DumpTo capture a heap dump for later analysis, start your application and let it run for a few seconds to warm up.Then right-click its process in VisualVM and invoke the Heap Dump action.Analyzing ObjectsInitially the Summary view for the Java heap is displayed.To analyze the Ruby heap, click the leftmost (Summary) dropdown in the Heap Viewer toolbar, choose the Ruby Heap scope and select the Objects view.Now the heap viewer displays all Ruby heap objects, aggregated by their type.Expand the Proc node in the Results view to see a list of objects of this type.Each object displays its logical value as provided by the underlying implementation.Expand the objects to access their variables and references, where available.Now enable the Preview, Variables, and References details by clicking the buttons in the toolbar, and select the individual ProcType objects.Where available, the Preview view shows the corresponding source fragment, the Variables view shows variables of the object, and the References view shows objects referring to the selected object.Last, use the Presets drop down list in the Heap Viewer toolbar to switch the view from All Objects to Dominators or GC Roots.To display the heap dominators, retained sizes must be computed first, which can take a few minutes for the server.rb example.Select the Objects aggregation in the toolbar to view the individual dominators or GC roots.Analyzing ThreadsClick the leftmost drop down list in the Heap Viewer toolbar and select the Threads view for the Ruby heap.The heap viewer now displays the Ruby thread stack trace, including local objects. The stack trace can alternatively be displayed textually by clicking the HTML toolbar button.Reading JFR SnapshotsThe VisualVM tool bundled with GraalVM 19.2.x and later has the ability to read JFR snapshots—snapshots taken with JDK Flight Recorder (previously Java Flight Recorder).JFR is a tool for collecting diagnostic and profiling data about a running Java application.It is integrated into the Java Virtual Machine (JVM) and causes almost no performance overhead, so it can be used even in heavily loaded production environments.To install the JFR support, released as a plugin:  Run $JAVA_HOME/bin/jvisualvm to start VisualVM;  Navigate to Tools &amp;gt; Plugins &amp;gt; Available Plugins to list all available plugins, then install the VisualVM-JFR andVisualVM-JFR-Generic modules.The JFR snapshots can be opened using either the File &amp;gt; Load action, or by double-clicking the JFR Snapshots node and adding the snapshot into the JFRrepository, permanently.Please follow the documentation for your Java version to create JFR snapshots.The JFR viewer reads all JFR snapshots created from Java 7 onward, and presents the data in typical VisualVM views familiar to the tool users.These views and functionality tabs are currently available:  Overview tab - displays the basic information about the recorded process such asits main class, arguments, JVM version and configuration, and system properties.This tab also provides access to the recorded thread dumps.  Monitor tab - shows the process uptime and basic telemetry: CPU usage, Heapand Metaspace utilization, number of loaded classes, and number of live &amp;amp; startedthreads.  Threads tab - reconstructs the threads timeline based on all events recorded inthe snapshot as precisely as possible, based on the recording configuration.  Locks tab - allows the user to analyze threads synchronization.  File IO tab - presents information on read and write events to the filesystem.  Socket IO tab - presents information on read and write events to the network.  Sampler tab - shows per-thread CPU utilization and memory allocations, and aheap histogram. There is also an experimental feature, “CPU sampler,” for building a CPUsnapshot from the recorded events. It does not provide an exact performanceanalysis but still helps to understand what was going on in the recordedapplication, and where the CPU bottleneck might be.  Browser tab - provides a generic browser of all events recorded in the snapshot.  Environment tab - gives an overview of the recording machine setup and conditionssuch as CPU model, memory size, operating system version, CPU utilization, memoryusage, and so on.  Recording tab - lists the recording settings and basic snapshot telemetry such asnumber of events, total recording time, etc.Note: The support of JDK Flight Recorder is currently experimental. Some advanced features such as analyzing JVM internals, showing event stack traces, or support for creating JFR snapshots from live processes are not available in this preview version and will be addressed incrementally in the following releases.",
          "url": " /latest/tools/visualvm/"
          },
          
          "vulnerability-advisories":  {
          "title": "GraalVM Vulnerability Advisories",
          "content": "GraalVM Vulnerability AdvisoriesOracle takes security vulnerabilities seriously. If you have discovered a security vulnerability in GraalVM, please report it according to the Oracle vulnerability disclosure process.This page provides information about security vulnerabilities that have been identified and addressed in GraalVM releases.Security UpdatesOctober 2025The following vulnerabilities were fixed in this release.                        CVE ID            Product            Component            Protocol            Remote Exploitwithout Auth.?            CVSS VERSION 3.1 RISK (see Risk Matrix Definitions)            Supported Versions Affected                            BaseScore            AttackVector            AttackComplex            PrivsRequired            UserInteraction            Scope            Confidentiality            Integrity            Availability                                    CVE-2025-53057            Oracle GraalVM,Oracle GraalVM Enterprise Edition            Security            Multiple            Yes            5.9            Network            High            None            None            Unchanged            None            High            None            Oracle GraalVM 25.0                Oracle GraalVM:                                      For JDK 21.0.8 (23.1.8)                    For JDK 17.0.16 (23.0.9)                                  Oracle GraalVM Enterprise Edition:                                      21.3.15                                                          CVE-2025-53066            Oracle GraalVM,Oracle GraalVM Enterprise Edition            JAXP            Multiple            Yes            4.8            Network            High            None            None            Unchanged            Low            None            Low            Oracle GraalVM 25.0                Oracle GraalVM:                                      For JDK 21.0.8 (23.1.8)                    For JDK 17.0.16 (23.0.9)                                  Oracle GraalVM Enterprise Edition:                                      21.3.15                                                          CVE-2025-61755            Oracle GraalVM            Compiler            Multiple            Yes            3.7            Network            High            None            None            Unchanged            Low            None            None            Oracle GraalVM 25.0                Oracle GraalVM:                                      For JDK 21.0.8 (23.1.8)                    For JDK 17.0.16 (23.0.9)                                                          CVE-2025-61748            Oracle GraalVM,Oracle GraalVM Enterprise Edition            Libraries            Multiple            Yes            3.7            Network            High            None            None            Unchanged            None            Low            None            Oracle GraalVM 25.0                Oracle GraalVM:                                      For JDK 21.0.8 (23.1.8)                                  Oracle GraalVM Enterprise Edition:                                      21.3.15                                          Staying InformedTo stay informed about GraalVM security updates:  Subscribe to Oracle Security Alerts: Sign up for notifications at Oracle Security Alerts  Monitor GraalVM Release Notes: Check the GraalVM Release Notes for security-related updates  Follow GraalVM Community: Join the GraalVM community for announcements",
          "url": " /vulnerability-advisories/"
          },
          
          "why-graalvm":  {
          "title": "Why GraalVM?",
          "content": "Why GraalVM?GraalVM compiles your Java applications ahead of time into standalone binaries that start instantly, provide peak performance with no warmup, and use fewer resources.The key GraalVM benefits are:  Low Resource Usage: Java applications compiled ahead-of-time by GraalVM require less memory and CPU to run. No memory or CPU cycles are spent on just-in-time compilation. As a result, your applications need fewer resources to run and are cheaper to operate at scale.  Fast Startup: With GraalVM, you can start your Java application faster by initializing some of its elements at build time instead of run time, and instantly achieve predictable peak performance with no warmup.  Compact Packaging: Java applications compiled ahead-of-time by GraalVM are small and can be easily packaged into lightweight container images for fast and efficient deployment.  Improved Security: GraalVM reduces the attack surface of your Java application by excluding the following from the binary: unreachable code (unused classes, methods, and fields), the just-in-time compilation infrastructure, and build-time initialized code.GraalVM’s closed world assumption prevents your application from loading unknown code by disabling dynamic features such as reflection, serialization, and so on at run time, and requires an explicit include list of such classes, methods, and fields at build time.GraalVM can embed a software bill of materials (SBOM) in your binary making it easier for you to use common security scanners to check your Java application binaries for published CVEs (Common Vulnerabilities and Exposures).  Easily Build Cloud Native Microservices: Popular microservices frameworks such as Spring Boot, Micronaut, Helidon, and Quarkus, and cloud platforms such as Oracle Cloud Infrastructure (OCI), Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure all support GraalVM.This makes it easy for you to build cloud native Java microservices, compiled as binaries, packaged in small containers, and run on cloud platforms - OCI, AWS, GCP and Azure.  Extend your Java Application with Python and Other Languages: With GraalVM you can embed languages such as Python, JavaScript, and others to extend your Java application.  Use Existing Development and Monitoring Tools: Your existing Java application development and monitoring tools work with GraalVM application binaries.GraalVM provides build plugins for Maven and Gradle, and GitHub Actions for CI/CD.GraalVM supports Java Flight Recorder (JFR), Java Management Extensions (JMX), heap dumps, VisualVM, and other monitoring tools.GraalVM works with existing Java editors/IDEs, and unit test frameworks such as JUnit.Run Java Faster on GraalVM JDKGraalVM is a full-scale JDK distribution that can make Java applications run faster with a new advanced just-in-time compiler (Graal). As a platform it uses the Java HotSpot VM, so all tools and libraries that work on OpenJDK, work the same way on GraalVM JDK. In this context, GraalVM replaces the last-tier optimizing compiler in the JVM (C2) with the Graal compiler. This compiler is the outcome of 10+ years of research at Oracle Labs and includes several new optimizations, such as advanced inlining, partial escape analysis, code duplication, and speculative optimizations. GraalVM is itself written in Java, rather than C/C++, which simplifies maintenance and helps us develop and deliver new optimizations much faster.Several companies, such as Oracle Cloud, Twitter, and Facebook are running large-scale Java applications on GraalVM JDK to increase performance, reduce resource usage, and lower deployment costs.GraalVM JDK can simply be used as a drop-in replacement for other JDKs — see how to get started.Build Native Executables of Java ApplicationsRunning applications on the JVM can come with startup and footprint costs.GraalVM includes Native Image: a technology which leverages the Graal compiler to produce native executables of Java applications, that are self-contained and thus no longer require the JVM.The image generation process employs static analysis to find all code reachable from the main Java method and then performs full ahead-of-time (AOT) compilation.At build time, it also performs snapshotting, so, at run time, the application starts much faster with pre-populated heap.The resulting native binary contains the whole program in machine code form that is ready for execution instantly at startup.Such native executables have the following features:  Instant startup due to pre-initializing the JDK and user code at build time  Reduced memory and CPU usage due to minimized code execution overhead  Small packaging due to the AOT approach and slim runtime components  Reduced attack surface due to code elimination and the AOT approachGive Native Image a try by building your first application.Work with Latest Industry Tools and PlatformsNative Image is a great deployment model for microservices and serverless Java applications. This is the reason why several major application frameworks, such as Spring Boot, Micronaut, Quarkus, and Helidon, offer Native Image support. There is an entire ecosystem of libraries, frameworks, and tools that you can use with Native Image out of the box — view the list here.All major cloud platforms also offer support for building applications with GraalVM Native Image. You can easily build applications with GraalVM on Oracle Cloud Infrastructure (and get access to Oracle GraalVM as a part of your subscription), leverage GraalVM support in Azure SDK for Java and Spring Cloud Azure, use Native Image in the AWS SDK for Java, and compile applications as native executables using Google Cloud’s Client Libraries for Java.As an example of how GraalVM can improve cloud Java deployments, take a look at Disney Streaming’s use case. While researching ways to mitigate the cold starts of their serverless Java workloads, they discovered that a function that took 3.6s to start on the JVM, started in under 100ms when compiled with GraalVM Native Image — so 36x faster! Even operating within minimal memory, such as 512 MB, a natively compiled application was still fully functional and started much faster than on the JVM.Extend Java with JavaScript, Python, and Other LanguagesWith GraalVM you can run JavaScript, Python, WebAssembly, and other languages, in the context of Java applications. It offers the ability to expose Java data structures to those languages with fine-grained host access filters. To get started, see how you can build your first polyglot Java application, define guest language functions as Java values, and access guest languages from Java.You can also use GraalVM and the Truffle framework as a platform for your languages and tools.It will automatically derive high-performance code from your language interpreter and provide access to the rich tooling ecosystem.Find out how to implement your own language or tool.",
          "url": " /why-graalvm/"
          },
          
          "latest-getting-started-windows":  {
          "title": "Installation on Windows Platforms",
          "content": "Installation on Windows PlatformsGraalVM is available for Windows on the x64 architecture.We recommend installing GraalVM on Windows from an archive.  Installing from an Archive  Prerequisites for Native Image on Windows  Other Installation OptionsInstalling from an Archive      Navigate to the GraalVM Downloads page. Select the Java version, Windows for the operating system, and download.        Change to the directory where you want to install GraalVM, then move the .zip archive file to it.        Unzip the archive to your file system.    There can be multiple JDKs installed on the machine. The next step is to configure the runtime environment. Setting environment variables via the command line will work the same way for Windows 8, 10, and 11.          Set the JAVA_HOME environment variable to resolve to the GraalVM installation directory, for example:         setx /M JAVA_HOME &quot;C:Progra~1Java&amp;lt;graalvm&amp;gt;&quot;            Set the value of the PATH environment variable to the GraalVM bin directory:         setx /M PATH &quot;C:Progra~1Java&amp;lt;graalvm&amp;gt;bin;%PATH%&quot;        Note that the /M flag, equivalent to -m, requires elevated user privileges.              Restart Command Prompt to reload the environment variables. Then use the following command to check whether the variables were set correctly:     echo %PATH% echo %JAVA_HOME%  Alternatively, you can set up environment variables through a Windows GUI:  Go to Windows Start Menu, then Settings, then Advanced.  Click Environment Variables. In the section “System Variables” find the JAVA_HOME variable and select it.  Click Edit.  Click New.  Click Browse to find the directory to add. Confirm by clicking OK.  Restart the Command Prompt to reload the environment variables.Repeat the same for the PATH environment variable.Prerequisites for Native Image on WindowsOn Windows, Native Image requires Visual Studio and Microsoft Visual C++(MSVC).Use Visual Studio 2022 version 17.6.0 or later.Install Visual Studio Build Tools and Windows SDK      Download the Visual Studio Build Tools 2022 or later (C development environment) from visualstudio.microsoft.com.        Start the installation by opening the file you downloaded, and then click Continue:            Select the Desktop development with C++ checkbox in the main window. On the right side under Installation Details, make sure that the two requirements, Windows 11 SDK and MSVC (…) C++ x64/x86 build tools, are selected. Continue by clicking Install.      You should now be able to build with GraalVM Native Image.Checking Existing Visual Studio InstallationsIf Visual Studio is already installed on your system, follow these steps to check that the correct components are installed.      Open the Visual Studio Installer:            Under the Installed tab, click Modify and choose Individual Components:            Then scroll to the bottom and confirm that the Windows 11 SDK and Visual Studio SDK checkboxes are selected. Now you can start using Native Image.  Start Using Native ImageNative Image sets up build environments automatically if it can find an appropriate Visual Studio installation in a known location.With the GraalVM JDK on your PATH, you can therefore now run the native-image utility in a Command Prompt (cmd) or a PowerShell (pwsh).To check the native-image version, run:C:&amp;gt; native-image.cmd --versionTo build a project using the Native Build Tools Maven plugin, run:mvnw.cmd native:compileTo build a project using the Native Build Tools Gradle plugin, run:gradlew.bat nativeCompileThis guide was written for Windows 11, but should be valid for Windows 8 and 10.Other Installation OptionsFor other installation options for Windows, visit the GraalVM Downloads page.",
          "url": " /latest/getting-started/windows/"
          },
          
          "assets-main-css":  {
          "title": "",
          "content": "@import “minima”;",
          "url": " /assets/main.css"
          },
          
          "21-3-release-notes-21-3":  {
          "title": "",
          "content": "",
          "url": " /21.3/release-notes/21_3/"
          },
          
          "22-0-release-notes-22-0":  {
          "title": "",
          "content": "",
          "url": " /22.0/release-notes/22_0/"
          },
          
          "22-1-release-notes-22-1":  {
          "title": "",
          "content": "",
          "url": " /22.1/release-notes/22_1/"
          },
          
          "22-2-release-notes-22-2":  {
          "title": "",
          "content": "",
          "url": " /22.2/release-notes/22_2/"
          },
          
          "22-3-release-notes-22-3":  {
          "title": "",
          "content": "",
          "url": " /22.3/release-notes/22_3/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-aot":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/AOT/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-aotoverview":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/AOTOverview/"
          },
          
          "reference-manual-native-image-agent":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/Agent/"
          },
          
          "reference-manual-native-image-metadata-automaticmetadatacollection":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/metadata/AutomaticMetadataCollection/"
          },
          
          "latest-reference-manual-native-image-agent":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/Agent/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-auxiliaryenginecachingenterprise":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/AuxiliaryEngineCachingEnterprise/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-branchinstrumentation":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/BranchInstrumentation/"
          },
          
          "reference-manual-native-image-buildconfiguration":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/BuildConfiguration/"
          },
          
          "reference-manual-native-image-overview-buildconfiguration":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/BuildConfiguration/"
          },
          
          "latest-reference-manual-native-image-buildconfiguration":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/BuildConfiguration/"
          },
          
          "reference-manual-native-image-overview-buildoptions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/BuildOptions/"
          },
          
          "reference-manual-native-image-options":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/Options/"
          },
          
          "reference-manual-native-image-guides-use-system-properties":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/use-system-properties/"
          },
          
          "reference-manual-native-image-overview-options":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/Options/"
          },
          
          "latest-reference-manual-native-image-overview-buildoptions":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/overview/BuildOptions/"
          },
          
          "latest-reference-manual-native-image-options":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/Options/"
          },
          
          "latest-reference-manual-native-image-guides-use-system-properties":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/guides/use-system-properties/"
          },
          
          "reference-manual-native-image-buildoutput":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/BuildOutput/"
          },
          
          "reference-manual-native-image-overview-buildoutput":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/BuildOutput/"
          },
          
          "latest-reference-manual-native-image-buildoutput":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/BuildOutput/"
          },
          
          "reference-manual-native-image-build-overview":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/Build-Overview/"
          },
          
          "reference-manual-native-image-overview-build-overview":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/Build-Overview/"
          },
          
          "latest-reference-manual-native-image-build-overview":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/Build-Overview/"
          },
          
          "reference-manual-native-image-build-report":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/build-report/"
          },
          
          "reference-manual-native-image-overview-build-report":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/build-report/"
          },
          
          "latest-reference-manual-native-image-build-report":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/build-report/"
          },
          
          "reference-manual-native-image-overview-bundles":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/Bundles/"
          },
          
          "reference-manual-native-image-c-api":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/C-API/"
          },
          
          "reference-manual-native-image-native-code-interoperability-c-api":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/native-code-interoperability/C-API/"
          },
          
          "latest-reference-manual-native-image-c-api":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/C-API/"
          },
          
          "reference-manual-native-image-certificatemanagement":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/CertificateManagement/"
          },
          
          "reference-manual-native-image-dynamic-features-certificatemanagement":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/CertificateManagement/"
          },
          
          "latest-reference-manual-native-image-certificatemanagement":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/CertificateManagement/"
          },
          
          "reference-manual-native-image-classinitialization":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/ClassInitialization/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-classinitialization":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/ClassInitialization/"
          },
          
          "latest-reference-manual-native-image-classinitialization":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/ClassInitialization/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-closeongc":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/CloseOnGc/"
          },
          
          "reference-manual-native-image-codestyle":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/CodeStyle/"
          },
          
          "reference-manual-native-image-contributing-codestyle":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/contributing/CodeStyle/"
          },
          
          "latest-reference-manual-native-image-codestyle":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/CodeStyle/"
          },
          
          "reference-manual-llvm-compatibility":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/llvm/Compatibility/"
          },
          
          "reference-manual-native-image-limitations":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/Limitations/"
          },
          
          "reference-manual-native-image-arm64":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/ARM64/"
          },
          
          "reference-manual-native-image-metadata-compatibility":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/metadata/Compatibility/"
          },
          
          "latest-reference-manual-native-image-limitations":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/Limitations/"
          },
          
          "latest-reference-manual-native-image-arm64":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/ARM64/"
          },
          
          "reference-manual-llvm-compiling":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/llvm/Compiling/"
          },
          
          "reference-manual-native-image-contributing":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/contributing/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-dslguidelines":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/DSLGuidelines/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-dslnodeobjectinlining":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/DSLNodeObjectInlining/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-dslwarnings":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/DSLWarnings/"
          },
          
          "reference-manual-native-image-debuginfo":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/DebugInfo/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-debuginfo":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/DebugInfo/"
          },
          
          "latest-reference-manual-native-image-debuginfo":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/DebugInfo/"
          },
          
          "reference-manual-llvm-debugging":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/llvm/Debugging/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/"
          },
          
          "reference-manual-java-on-truffle-demos":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java-on-truffle/demos/"
          },
          
          "reference-manual-espresso-demos":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/demos/"
          },
          
          "latest-reference-manual-java-on-truffle-demos":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java-on-truffle/demos/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-deoptcyclepatterns":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/DeoptCyclePatterns/"
          },
          
          "reference-manual-native-image-dynamic-features":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-dynamicobjectmodel":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/DynamicObjectModel/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-exit":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/Exit/"
          },
          
          "reference-manual-native-image-experimentalagentoptions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/ExperimentalAgentOptions/"
          },
          
          "reference-manual-native-image-metadata-experimentalagentoptions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/metadata/ExperimentalAgentOptions/"
          },
          
          "latest-reference-manual-native-image-experimentalagentoptions":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/ExperimentalAgentOptions/"
          },
          
          "reference-manual-java-on-truffle-faq":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java-on-truffle/faq/"
          },
          
          "reference-manual-espresso-faq":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/faq/"
          },
          
          "latest-reference-manual-java-on-truffle-faq":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java-on-truffle/faq/"
          },
          
          "reference-manual-js-faq":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/FAQ/"
          },
          
          "reference-manual-native-image-dynamic-features-ffm-api":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/ffm-api/"
          },
          
          "reference-manual-native-image-native-code-interoperability-ffm-api":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/native-code-interoperability/ffm-api/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-ffm-api":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/dynamic-features/ffm-api/"
          },
          
          "reference-manual-native-image-native-code-interoperability-foreign-interface":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/native-code-interoperability/foreign-interface/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-hostoptimization":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/HostOptimization/"
          },
          
          "reference-manual-native-image-hostedvsruntimeoptions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/HostedvsRuntimeOptions/"
          },
          
          "reference-manual-native-image-overview-hostedvsruntimeoptions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/overview/HostedvsRuntimeOptions/"
          },
          
          "latest-reference-manual-native-image-hostedvsruntimeoptions":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/HostedvsRuntimeOptions/"
          },
          
          "reference-manual-java-on-truffle-hotswap-plugin":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java-on-truffle/hotswap-plugin/"
          },
          
          "reference-manual-java-on-truffle-hotswap":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java-on-truffle/hotswap/"
          },
          
          "reference-manual-espresso-hotswap":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/hotswap/"
          },
          
          "latest-reference-manual-java-on-truffle-hotswap-plugin":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java-on-truffle/hotswap-plugin/"
          },
          
          "latest-reference-manual-java-on-truffle-hotswap":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java-on-truffle/hotswap/"
          },
          
          "reference-manual-java-on-truffle-implementation":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java-on-truffle/implementation/"
          },
          
          "reference-manual-espresso-implementation":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/implementation/"
          },
          
          "latest-reference-manual-java-on-truffle-implementation":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java-on-truffle/implementation/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-inlining":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/Inlining/"
          },
          
          "tools-graalvm-insight-embedding":  {
          "title": "",
          "content": "",
          "url": " /tools/graalvm-insight/embedding/"
          },
          
          "tools-graalvm-insight-manual":  {
          "title": "",
          "content": "",
          "url": " /tools/graalvm-insight/manual/"
          },
          
          "tools-graalvm-insight-tracing":  {
          "title": "",
          "content": "",
          "url": " /tools/graalvm-insight/tracing/"
          },
          
          "reference-manual-native-image-inspect":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/inspect/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-inspecttool":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/InspectTool/"
          },
          
          "latest-reference-manual-native-image-inspect":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/inspect/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-interopmigration":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/InteropMigration/"
          },
          
          "reference-manual-native-image-implementingnativemethodsinjavawithsvm":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/ImplementingNativeMethodsInJavaWithSVM/"
          },
          
          "reference-manual-native-image-native-code-interoperability":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/native-code-interoperability/"
          },
          
          "latest-reference-manual-native-image-implementingnativemethodsinjavawithsvm":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/ImplementingNativeMethodsInJavaWithSVM/"
          },
          
          "reference-manual-java-on-truffle-interoperability":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java-on-truffle/interoperability/"
          },
          
          "reference-manual-espresso-interoperability":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/interoperability/"
          },
          
          "latest-reference-manual-java-on-truffle-interoperability":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java-on-truffle/interoperability/"
          },
          
          "reference-manual-llvm-interoperability":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/llvm/Interoperability/"
          },
          
          "reference-manual-native-image-features-jcasecurityservices":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/features/JCASecurityServices/"
          },
          
          "reference-manual-native-image-jcasecurityservices":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/JCASecurityServices/"
          },
          
          "reference-manual-native-image-dynamic-features-jcasecurityservices":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/JCASecurityServices/"
          },
          
          "latest-reference-manual-native-image-features-jcasecurityservices":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/features/JCASecurityServices/"
          },
          
          "latest-reference-manual-native-image-jcasecurityservices":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/JCASecurityServices/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-jcmd":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/jcmd/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-jdwp":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/JDWP/"
          },
          
          "reference-manual-native-image-jfr":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/JFR/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-jfr":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/JFR/"
          },
          
          "latest-reference-manual-native-image-jfr":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/JFR/"
          },
          
          "reference-manual-native-image-jni":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/JNI/"
          },
          
          "reference-manual-native-image-dynamic-features-jni":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/JNI/"
          },
          
          "latest-reference-manual-native-image-jni":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/JNI/"
          },
          
          "reference-manual-native-image-implementingnativemethodsinjavawithsvm":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/ImplementingNativeMethodsInJavaWithSVM/"
          },
          
          "reference-manual-native-image-native-code-interoperability-jniinvocationapi":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/"
          },
          
          "latest-reference-manual-native-image-implementingnativemethodsinjavawithsvm":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/ImplementingNativeMethodsInJavaWithSVM/"
          },
          
          "reference-manual-js-javainteroperability":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/JavaInteroperability/"
          },
          
          "reference-manual-js-javascriptcompatibility":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/JavaScriptCompatibility/"
          },
          
          "security-guide-native-image-jipher":  {
          "title": "",
          "content": "",
          "url": " /security-guide/native-image/Jipher/"
          },
          
          "reference-manual-native-image-llvmbackend":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/LLVMBackend/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-languagetutorial":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/LanguageTutorial/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-languages":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/Languages/"
          },
          
          "reference-manual-native-image-memorymanagement":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/MemoryManagement/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-memorymanagement":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/MemoryManagement/"
          },
          
          "latest-reference-manual-native-image-memorymanagement":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/MemoryManagement/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-migration-to-java-modules":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/migration-to-java-modules/"
          },
          
          "reference-manual-js-modules":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/Modules/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-splitting-monomorphization":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/Monomorphization/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-splitting-monomorphizationusecases":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/MonomorphizationUseCases/"
          },
          
          "reference-manual-js-multithreading":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/Multithreading/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-nfi":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/NFI/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-nmt":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/NMT/"
          },
          
          "reference-manual-js-nashornmigrationguide":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/NashornMigrationGuide/"
          },
          
          "reference-manual-llvm-nativeexecution":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/llvm/NativeExecution/"
          },
          
          "reference-manual-native-image-basics":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/basics/"
          },
          
          "reference-manual-js-nodejs":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/NodeJS/"
          },
          
          "reference-manual-js-nodejsvsjavascriptcontext":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/NodeJSvsJavaScriptContext/"
          },
          
          "security-guide-native-image-obfuscation":  {
          "title": "",
          "content": "",
          "url": " /security-guide/native-image/obfuscation/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-objectheadersize":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/ObjectHeaderSize/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-onstackreplacement":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/OnStackReplacement/"
          },
          
          "reference-manual-java-operations":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java/operations/"
          },
          
          "reference-manual-compiler-operations":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/compiler/operations/"
          },
          
          "latest-reference-manual-java-operations":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java/operations/"
          },
          
          "reference-manual-js-operatoroverloading":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/OperatorOverloading/"
          },
          
          "reference-manual-native-image-optimizations-and-performance":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-optimizing":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/Optimizing/"
          },
          
          "reference-manual-java-options":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java/options/"
          },
          
          "reference-manual-llvm-options":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/llvm/Options/"
          },
          
          "reference-manual-js-options":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/Options/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-options":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/Options/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo-basic-usage":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/basic-usage/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo-build-reports":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/build-reports/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo-faq":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/faq/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo-iprof-file-format":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/iprof-file-format/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo-lcov":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/LCOV/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo-merging-profiles":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/merging-profiles/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo-profile-quality":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/profile-quality/"
          },
          
          "reference-manual-native-image-optimizations-and-performance-pgo":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/optimizations-and-performance/PGO/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-perf-profiler":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/perf-profiler/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-profiling":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/Profiling/"
          },
          
          "community-publications":  {
          "title": "",
          "content": "",
          "url": " /community/publications/"
          },
          
          "reference-manual-java-on-truffle":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java-on-truffle/"
          },
          
          "reference-manual-espresso":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/"
          },
          
          "latest-reference-manual-java-on-truffle":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/java-on-truffle/"
          },
          
          "reference-manual-java":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java/"
          },
          
          "reference-manual-llvm":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/llvm/"
          },
          
          "reference-manual-native-image":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/"
          },
          
          "reference-manual-js":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/"
          },
          
          "tools-graalvm-insight":  {
          "title": "",
          "content": "",
          "url": " /tools/graalvm-insight/"
          },
          
          "tools-vscode-graalvm-extension":  {
          "title": "",
          "content": "",
          "url": " /tools/vscode/graalvm-extension/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/"
          },
          
          "reference-manual-native-image-dynamic-features-resources":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/Resources/"
          },
          
          "reference-manual-native-image-dynamic-features-reflection":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/Reflection/"
          },
          
          "reference-manual-native-image-dynamic-features-dynamicproxy":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/DynamicProxy/"
          },
          
          "reference-manual-native-image-metadata":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/metadata/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-resources":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/dynamic-features/Resources/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-reflection":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/dynamic-features/Reflection/"
          },
          
          "latest-reference-manual-native-image-dynamic-features-dynamicproxy":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/dynamic-features/DynamicProxy/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-splitting-reportingpolymorphism":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/ReportingPolymorphism/"
          },
          
          "reference-manual-js-rhinomigrationguide":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/RhinoMigrationGuide/"
          },
          
          "reference-manual-js-runonjdk":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/RunOnJDK/"
          },
          
          "security-guide-native-image-sbom":  {
          "title": "",
          "content": "",
          "url": " /security-guide/native-image/sbom/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-safepoint":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/Safepoint/"
          },
          
          "reference-manual-js-scriptengine":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/js/ScriptEngine/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-specializationhistogram":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/SpecializationHistogram/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-specializationtesting":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/SpecializationTesting/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-splitting-splitting":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/Splitting/"
          },
          
          "reference-manual-native-image-reports":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/Reports/"
          },
          
          "reference-manual-native-image-debugging-and-diagnostics-staticanalysisreports":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/debugging-and-diagnostics/StaticAnalysisReports/"
          },
          
          "latest-reference-manual-native-image-reports":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/Reports/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-staticobjectmodel":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/StaticObjectModel/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-tck":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/TCK/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-traversingcompilationqueue":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/TraversingCompilationQueue/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-trufflelibraries":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/TruffleLibraries/"
          },
          
          "graalvm-as-a-platform-language-implementation-framework-trufflestrings":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/language-implementation-framework/TruffleStrings/"
          },
          
          "reference-manual-native-image-urlprotocols":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/URLProtocols/"
          },
          
          "reference-manual-native-image-dynamic-features-urlprotocols":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/dynamic-features/URLProtocols/"
          },
          
          "latest-reference-manual-native-image-urlprotocols":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/URLProtocols/"
          },
          
          "reference-manual-native-image-workshops":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/workshops/"
          },
          
          "reference-manual-native-image-properties":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/Properties/"
          },
          
          "reference-manual-native-image-guides-access-environment-variables":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/access-environment-variables/"
          },
          
          "latest-reference-manual-native-image-properties":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/Properties/"
          },
          
          "reference-manual-native-image-logging":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/Logging/"
          },
          
          "reference-manual-native-image-guides-add-logging-to-native-executable":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/add-logging-to-native-executable/"
          },
          
          "latest-reference-manual-native-image-logging":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/Logging/"
          },
          
          "reference-manual-native-image-guides-build-and-run-native-executable-with-jfr":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-and-run-native-executable-with-jfr/"
          },
          
          "reference-manual-native-image-guides-build-and-run-native-executable-with-remote-jmx":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-and-run-native-executable-with-remote-jmx/"
          },
          
          "reference-manual-native-image-guides-build-java-modules-into-native-executable":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-java-modules-into-native-executable/"
          },
          
          "reference-manual-native-image-guides-build-native-executable-from-jar":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-native-executable-from-jar/"
          },
          
          "reference-manual-native-image-guides-build-native-shared-library":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-native-shared-library/"
          },
          
          "reference-manual-native-image-guides-build-polyglot-native-executable":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-polyglot-native-executable/"
          },
          
          "reference-manual-native-image-guides-build-spring-boot-app-into-native-executable":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-spring-boot-app-into-native-executable/"
          },
          
          "reference-manual-native-image-staticimages":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/StaticImages/"
          },
          
          "reference-manual-native-image-guides-build-static-executables":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-static-executables/"
          },
          
          "latest-reference-manual-native-image-staticimages":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/StaticImages/"
          },
          
          "reference-manual-native-image-guides-build-with-reflection":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/build-with-reflection/"
          },
          
          "reference-manual-native-image-guides-configure-with-tracing-agent":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/configure-with-tracing-agent/"
          },
          
          "latest-reference-manual-native-image-guides-build-with-reflection":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/guides/build-with-reflection/"
          },
          
          "docs-tools-chrome-debugger":  {
          "title": "",
          "content": "",
          "url": " /docs/tools/chrome-debugger/"
          },
          
          "tools-chrome-debugger":  {
          "title": "",
          "content": "",
          "url": " /tools/chrome-debugger/"
          },
          
          "latest-docs-tools-chrome-debugger":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/tools/chrome-debugger/"
          },
          
          "getting-started-oci-cloud-shell":  {
          "title": "",
          "content": "",
          "url": " /getting-started/oci/cloud-shell/"
          },
          
          "tools-code-coverage":  {
          "title": "",
          "content": "",
          "url": " /tools/code-coverage/"
          },
          
          "getting-started-oci-code-editor":  {
          "title": "",
          "content": "",
          "url": " /getting-started/oci/code-editor/"
          },
          
          "docs-reference-manual-compatibility":  {
          "title": "",
          "content": "",
          "url": " /docs/reference-manual/compatibility/"
          },
          
          "reference-manual-compiler":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/compiler/"
          },
          
          "reference-manual-java-compiler":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/java/compiler/"
          },
          
          "latest-reference-manual-compiler":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/compiler/"
          },
          
          "reference-manual-native-image-guides-configure-dynamic-proxies":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/configure-dynamic-proxies/"
          },
          
          "reference-manual-native-image-guides-containerise-native-executable-and-run-in-docker-container":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/containerise-native-executable-and-run-in-docker-container/"
          },
          
          "reference-manual-espresso-continuations":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/continuations/"
          },
          
          "reference-manual-native-image-nativeimageheapdump":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/NativeImageHeapdump/"
          },
          
          "reference-manual-native-image-guides-create-heap-dump":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/create-heap-dump/"
          },
          
          "latest-reference-manual-native-image-nativeimageheapdump":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/NativeImageHeapdump/"
          },
          
          "tools-dap":  {
          "title": "",
          "content": "",
          "url": " /tools/dap/"
          },
          
          "reference-manual-native-image-guides-debug-native-image-process":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/debug-native-image-process/"
          },
          
          "reference-manual-native-image-guides-debug-native-image-process-with-python-helper-script":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/debug-native-image-process-with-python-helper-script/"
          },
          
          "reference-manual-embed-languages":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/embed-languages/"
          },
          
          "reference-manual-r":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/r/"
          },
          
          "reference-manual-r-extensionssupport":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/r/ExtensionsSupport/"
          },
          
          "latest-reference-manual-r-extensionssupport":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/r/ExtensionsSupport/"
          },
          
          "reference-manual-espresso-continuations-generators":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/continuations/generators/"
          },
          
          "docs-getting-started":  {
          "title": "",
          "content": "",
          "url": " /docs/getting-started/"
          },
          
          "getting-started":  {
          "title": "",
          "content": "",
          "url": " /getting-started/"
          },
          
          "latest-docs-getting-started":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/getting-started/"
          },
          
          "reference-manual-python":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/"
          },
          
          "docs-reference-manual-python":  {
          "title": "",
          "content": "",
          "url": " /docs/reference-manual/python/"
          },
          
          "reference-manual-python-embedding-build-tools":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Embedding-Build-Tools/"
          },
          
          "reference-manual-python-embedding-permissions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Embedding-Permissions/"
          },
          
          "reference-manual-python-osinterface":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/OSInterface/"
          },
          
          "reference-manual-python-interoperability":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Interoperability/"
          },
          
          "reference-manual-python-native-extensions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Native-Extensions/"
          },
          
          "reference-manual-python-native-applications":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/native-applications/"
          },
          
          "reference-manual-python-native-image":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/native-image/"
          },
          
          "reference-manual-python-performance":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Performance/"
          },
          
          "reference-manual-python-parserdetails":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/ParserDetails/"
          },
          
          "reference-manual-python-modern-python-on-jvm":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Modern-Python-on-JVM/"
          },
          
          "reference-manual-python-jython":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Jython/"
          },
          
          "reference-manual-python-python-runtime":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Python-Runtime/"
          },
          
          "reference-manual-python-packages":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Packages/"
          },
          
          "reference-manual-python-standalone-binaries":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/standalone-binaries/"
          },
          
          "reference-manual-python-standalone-applications":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/standalone-applications/"
          },
          
          "reference-manual-python-tooling":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/Tooling/"
          },
          
          "reference-manual-python-faq":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/python/FAQ/"
          },
          
          "python-docs":  {
          "title": "",
          "content": "",
          "url": " /python/docs/"
          },
          
          "latest-reference-manual-python":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/"
          },
          
          "latest-docs-reference-manual-python":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/reference-manual/python/"
          },
          
          "latest-reference-manual-python-embedding-build-tools":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Embedding-Build-Tools/"
          },
          
          "latest-reference-manual-python-embedding-permissions":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Embedding-Permissions/"
          },
          
          "latest-reference-manual-python-osinterface":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/OSInterface/"
          },
          
          "latest-reference-manual-python-interoperability":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Interoperability/"
          },
          
          "latest-reference-manual-python-native-extensions":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Native-Extensions/"
          },
          
          "latest-reference-manual-python-native-applications":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/native-applications/"
          },
          
          "latest-reference-manual-python-native-image":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/native-image/"
          },
          
          "latest-reference-manual-python-performance":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Performance/"
          },
          
          "latest-reference-manual-python-parserdetails":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/ParserDetails/"
          },
          
          "latest-reference-manual-python-modern-python-on-jvm":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Modern-Python-on-JVM/"
          },
          
          "latest-reference-manual-python-jython":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Jython/"
          },
          
          "latest-reference-manual-python-python-runtime":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Python-Runtime/"
          },
          
          "latest-reference-manual-python-packages":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Packages/"
          },
          
          "latest-reference-manual-python-standalone-binaries":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/standalone-binaries/"
          },
          
          "latest-reference-manual-python-standalone-applications":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/standalone-applications/"
          },
          
          "latest-reference-manual-python-tooling":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/Tooling/"
          },
          
          "latest-reference-manual-python-faq":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/python/FAQ/"
          },
          
          "docs-graalvm-as-a-platform":  {
          "title": "",
          "content": "",
          "url": " /docs/graalvm-as-a-platform/"
          },
          
          "graalvm-as-a-platform":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/"
          },
          
          "latest-docs-graalvm-as-a-platform":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/graalvm-as-a-platform/"
          },
          
          "docs-getting-started-container-images":  {
          "title": "",
          "content": "",
          "url": " /docs/getting-started/container-images/"
          },
          
          "getting-started-container-images":  {
          "title": "",
          "content": "",
          "url": " /getting-started/container-images/"
          },
          
          "latest-docs-getting-started-container-images":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/getting-started/container-images/"
          },
          
          "getting-started-oci":  {
          "title": "",
          "content": "",
          "url": " /getting-started/oci/"
          },
          
          "docs-graalvm-updater":  {
          "title": "",
          "content": "",
          "url": " /docs/graalvm-updater/"
          },
          
          "reference-manual-graalvm-updater":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/graalvm-updater/"
          },
          
          "latest-docs-graalvm-updater":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/graalvm-updater/"
          },
          
          "reference-manual-wasm":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/wasm/"
          },
          
          "docs-reference-manual-wasm":  {
          "title": "",
          "content": "",
          "url": " /docs/reference-manual/wasm/"
          },
          
          "webassembly-docs":  {
          "title": "",
          "content": "",
          "url": " /webassembly/docs/"
          },
          
          "latest-reference-manual-wasm":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/wasm/"
          },
          
          "latest-docs-reference-manual-wasm":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/reference-manual/wasm/"
          },
          
          "native-image-guides":  {
          "title": "",
          "content": "",
          "url": " /native-image/guides/"
          },
          
          "reference-manual-native-image-guides":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/"
          },
          
          "guides":  {
          "title": "",
          "content": "",
          "url": " /guides/"
          },
          
          "latest-native-image-guides":  {
          "title": "",
          "content": "",
          "url": " /latest/native-image/guides/"
          },
          
          "latest-reference-manual-native-image-guides":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/guides/"
          },
          
          "tools-igv":  {
          "title": "",
          "content": "",
          "url": " /tools/igv/"
          },
          
          "docs-graalvm-as-a-platform-implement-instrument":  {
          "title": "",
          "content": "",
          "url": " /docs/graalvm-as-a-platform/implement-instrument/"
          },
          
          "graalvm-as-a-platform-implement-instrument":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/implement-instrument/"
          },
          
          "latest-docs-graalvm-as-a-platform-implement-instrument":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/graalvm-as-a-platform/implement-instrument/"
          },
          
          "docs-graalvm-as-a-platform-implement-language":  {
          "title": "",
          "content": "",
          "url": " /docs/graalvm-as-a-platform/implement-language/"
          },
          
          "graalvm-as-a-platform-implement-language":  {
          "title": "",
          "content": "",
          "url": " /graalvm-as-a-platform/implement-language/"
          },
          
          "latest-docs-graalvm-as-a-platform-implement-language":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/graalvm-as-a-platform/implement-language/"
          },
          
          "reference-manual-native-image-guides-use-reachability-metadata-repository-gradle":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/use-reachability-metadata-repository-gradle/"
          },
          
          "reference-manual-native-image-guides-use-reachability-metadata-repository-maven":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/use-reachability-metadata-repository-maven/"
          },
          
          "reference-manual-native-image-guides-include-resources":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/include-resources/"
          },
          
          "getting-started-oci-compute-instance":  {
          "title": "",
          "content": "",
          "url": " /getting-started/oci/compute-instance/"
          },
          
          "getting-started-oci-devops-build-pipeline":  {
          "title": "",
          "content": "",
          "url": " /getting-started/oci/devops-build-pipeline/"
          },
          
          "docs-introduction":  {
          "title": "",
          "content": "",
          "url": " /docs/introduction/"
          },
          
          "introduction":  {
          "title": "",
          "content": "",
          "url": " /introduction/"
          },
          
          "latest-docs-introduction":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/introduction/"
          },
          
          "reference-manual-languages":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/languages/"
          },
          
          "docs-getting-started-linux":  {
          "title": "",
          "content": "",
          "url": " /docs/getting-started/linux/"
          },
          
          "getting-started-linux":  {
          "title": "",
          "content": "",
          "url": " /getting-started/linux/"
          },
          
          "latest-docs-getting-started-linux":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/getting-started/linux/"
          },
          
          "tools-lsp":  {
          "title": "",
          "content": "",
          "url": " /tools/lsp/"
          },
          
          "docs-getting-started-macos":  {
          "title": "",
          "content": "",
          "url": " /docs/getting-started/macos/"
          },
          
          "getting-started-macos":  {
          "title": "",
          "content": "",
          "url": " /getting-started/macos/"
          },
          
          "latest-docs-getting-started-macos":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/getting-started/macos/"
          },
          
          "community-meetup":  {
          "title": "",
          "content": "",
          "url": " /community/meetup/"
          },
          
          "use-cases-mle-oracle":  {
          "title": "",
          "content": "",
          "url": " /use-cases/mle-oracle/"
          },
          
          "security-guide-native-image":  {
          "title": "",
          "content": "",
          "url": " /security-guide/native-image/"
          },
          
          "reference-manual-native-image-guides-optimize-for-file-size":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/optimize-for-file-size/"
          },
          
          "reference-manual-native-image-guides-optimize-memory-footprint":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/optimize-memory-footprint/"
          },
          
          "reference-manual-native-image-guides-optimize-native-executable-size-using-build-report":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/optimize-native-executable-size-using-build-report/"
          },
          
          "reference-manual-native-image-pgo":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/PGO/"
          },
          
          "reference-manual-native-image-guides-optimize-native-executable-with-pgo":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/optimize-native-executable-with-pgo/"
          },
          
          "latest-reference-manual-native-image-pgo":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/native-image/PGO/"
          },
          
          "docs-polyglot-programming":  {
          "title": "",
          "content": "",
          "url": " /docs/polyglot-programming/"
          },
          
          "reference-manual-polyglot-programming":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/polyglot-programming/"
          },
          
          "latest-docs-polyglot-programming":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/polyglot-programming/"
          },
          
          "tools-vscode-graalvm-extension-polyglot-runtime":  {
          "title": "",
          "content": "",
          "url": " /tools/vscode/graalvm-extension/polyglot-runtime/"
          },
          
          "security-guide-polyglot-sandbox":  {
          "title": "",
          "content": "",
          "url": " /security-guide/polyglot-sandbox/"
          },
          
          "reference-manual-embed-languages-sandbox-resource-limits":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/embed-languages/sandbox-resource-limits/"
          },
          
          "security-guide-sandboxing":  {
          "title": "",
          "content": "",
          "url": " /security-guide/sandboxing/"
          },
          
          "latest-security-guide-polyglot-sandbox":  {
          "title": "",
          "content": "",
          "url": " /latest/security-guide/polyglot-sandbox/"
          },
          
          "latest-reference-manual-embed-languages-sandbox-resource-limits":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/embed-languages/sandbox-resource-limits/"
          },
          
          "tools-profiling":  {
          "title": "",
          "content": "",
          "url": " /tools/profiling/"
          },
          
          "docs-reference-manual":  {
          "title": "",
          "content": "",
          "url": " /docs/reference-manual/"
          },
          
          "reference-manual":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/"
          },
          
          "latest-docs-reference-manual":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/reference-manual/"
          },
          
          "version-roadmap":  {
          "title": "",
          "content": "",
          "url": " /version-roadmap/"
          },
          
          "release-notes-version-roadmap":  {
          "title": "",
          "content": "",
          "url": " /release-notes/version-roadmap/"
          },
          
          "latest-release-notes":  {
          "title": "",
          "content": "",
          "url": " /latest/release-notes/"
          },
          
          "dev-release-notes":  {
          "title": "",
          "content": "",
          "url": " /dev/release-notes/"
          },
          
          "22-3-release-notes":  {
          "title": "",
          "content": "",
          "url": " /22.3/release-notes/"
          },
          
          "22-2-release-notes":  {
          "title": "",
          "content": "",
          "url": " /22.2/release-notes/"
          },
          
          "22-1-release-notes":  {
          "title": "",
          "content": "",
          "url": " /22.1/release-notes/"
          },
          
          "22-0-release-notes":  {
          "title": "",
          "content": "",
          "url": " /22.0/release-notes/"
          },
          
          "21-3-release-notes":  {
          "title": "",
          "content": "",
          "url": " /21.3/release-notes/"
          },
          
          "docs-security-guide":  {
          "title": "",
          "content": "",
          "url": " /docs/security-guide/"
          },
          
          "security-guide":  {
          "title": "",
          "content": "",
          "url": " /security-guide/"
          },
          
          "latest-docs-security-guide":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/security-guide/"
          },
          
          "reference-manual-espresso-continuations-serialization":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/espresso/continuations/serialization/"
          },
          
          "reference-manual-native-image-guides-specify-class-initialization":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/specify-class-initialization/"
          },
          
          "community-support":  {
          "title": "",
          "content": "",
          "url": " /community/support/"
          },
          
          "tools":  {
          "title": "",
          "content": "",
          "url": " /tools/"
          },
          
          "reference-manual-tools":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/tools/"
          },
          
          "latest-tools":  {
          "title": "",
          "content": "",
          "url": " /latest/tools/"
          },
          
          "reference-manual-native-image-guides-troubleshoot-run-time-errors":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/troubleshoot-run-time-errors/"
          },
          
          "reference-manual-ruby-compatibility":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Compatibility/"
          },
          
          "reference-manual-ruby-debugging":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Debugging/"
          },
          
          "reference-manual-ruby-runtimeconfigurations":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/RuntimeConfigurations/"
          },
          
          "reference-manual-ruby-installinggraalvm":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/InstallingGraalVM/"
          },
          
          "reference-manual-ruby-installinglibssl":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Installinglibssl/"
          },
          
          "reference-manual-ruby-installinglibyaml":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/InstallingLibYAML/"
          },
          
          "reference-manual-ruby-installingllvm":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/InstallingLLVM/"
          },
          
          "reference-manual-ruby-installingzlib":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Installingzlib/"
          },
          
          "reference-manual-ruby-jrubymigration":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/JRubyMigration/"
          },
          
          "reference-manual-ruby-options":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Options/"
          },
          
          "reference-manual-ruby-polyglot":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Polyglot/"
          },
          
          "reference-manual-ruby-rubymanagers":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/RubyManagers/"
          },
          
          "reference-manual-ruby-standalonedistribution":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/StandaloneDistribution/"
          },
          
          "reference-manual-ruby-tools":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Tools/"
          },
          
          "reference-manual-ruby-trufflerubyadditions":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/TruffleRubyAdditions/"
          },
          
          "reference-manual-ruby-utf8locale":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/UTF8Locale/"
          },
          
          "reference-manual-ruby-reportingperformanceproblems":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/ReportingPerformanceProblems/"
          },
          
          "reference-manual-ruby-knowncves":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/KnownCVEs/"
          },
          
          "reference-manual-ruby-optcarrot":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/Optcarrot/"
          },
          
          "reference-manual-ruby-faq":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/FAQ/"
          },
          
          "reference-manual-ruby":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/ruby/"
          },
          
          "latest-reference-manual-ruby-compatibility":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Compatibility/"
          },
          
          "latest-reference-manual-ruby-debugging":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Debugging/"
          },
          
          "latest-reference-manual-ruby-runtimeconfigurations":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/RuntimeConfigurations/"
          },
          
          "latest-reference-manual-ruby-installinggraalvm":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/InstallingGraalVM/"
          },
          
          "latest-reference-manual-ruby-installinglibssl":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Installinglibssl/"
          },
          
          "latest-reference-manual-ruby-installinglibyaml":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/InstallingLibYAML/"
          },
          
          "latest-reference-manual-ruby-installingllvm":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/InstallingLLVM/"
          },
          
          "latest-reference-manual-ruby-installingzlib":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Installingzlib/"
          },
          
          "latest-reference-manual-ruby-jrubymigration":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/JRubyMigration/"
          },
          
          "latest-reference-manual-ruby-options":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Options/"
          },
          
          "latest-reference-manual-ruby-polyglot":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Polyglot/"
          },
          
          "latest-reference-manual-ruby-rubymanagers":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/RubyManagers/"
          },
          
          "latest-reference-manual-ruby-standalonedistribution":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/StandaloneDistribution/"
          },
          
          "latest-reference-manual-ruby-tools":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Tools/"
          },
          
          "latest-reference-manual-ruby-trufflerubyadditions":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/TruffleRubyAdditions/"
          },
          
          "latest-reference-manual-ruby-utf8locale":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/UTF8Locale/"
          },
          
          "latest-reference-manual-ruby-reportingperformanceproblems":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/ReportingPerformanceProblems/"
          },
          
          "latest-reference-manual-ruby-knowncves":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/KnownCVEs/"
          },
          
          "latest-reference-manual-ruby-optcarrot":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/Optcarrot/"
          },
          
          "latest-reference-manual-ruby-faq":  {
          "title": "",
          "content": "",
          "url": " /latest/reference-manual/ruby/FAQ/"
          },
          
          "reference-manual-native-image-guides-use-graalvm-dashboard":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/use-graalvm-dashboard/"
          },
          
          "reference-manual-native-image-guides-use-sbom-support":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/use-sbom-support/"
          },
          
          "reference-manual-native-image-guides-use-system-properties":  {
          "title": "",
          "content": "",
          "url": " /reference-manual/native-image/guides/use-system-properties/"
          },
          
          "tools-vscode-graalvm-extension-visualvm-integration":  {
          "title": "",
          "content": "",
          "url": " /tools/vscode/graalvm-extension/visualvm-integration/"
          },
          
          "tools-visualvm":  {
          "title": "",
          "content": "",
          "url": " /tools/visualvm/"
          },
          
          "docs-why-graal":  {
          "title": "",
          "content": "",
          "url": " /docs/why-graal/"
          },
          
          "docs-getting-started-windows":  {
          "title": "",
          "content": "",
          "url": " /docs/getting-started/windows/"
          },
          
          "getting-started-windows":  {
          "title": "",
          "content": "",
          "url": " /getting-started/windows/"
          },
          
          "latest-docs-getting-started-windows":  {
          "title": "",
          "content": "",
          "url": " /latest/docs/getting-started/windows/"
          },
          
          "redirects-json":  {
          "title": "",
          "content": "{“/21.3/release-notes/21_3/”:”https://www.graalvm.org/release-notes/21_3/”,”/22.0/release-notes/22_0/”:”https://www.graalvm.org/release-notes/22_0/”,”/22.1/release-notes/22_1/”:”https://www.graalvm.org/release-notes/22_1/”,”/22.2/release-notes/22_2/”:”https://www.graalvm.org/release-notes/22_2/”,”/22.3/release-notes/22_3/”:”https://www.graalvm.org/release-notes/22_3/”,”/graalvm-as-a-platform/language-implementation-framework/AOT/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/AOT/”,”/graalvm-as-a-platform/language-implementation-framework/AOTOverview/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/AOTOverview/”,”/reference-manual/native-image/Agent/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/”,”/reference-manual/native-image/metadata/AutomaticMetadataCollection/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/”,”/latest/reference-manual/native-image/Agent/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/”,”/graalvm-as-a-platform/language-implementation-framework/AuxiliaryEngineCachingEnterprise/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/AuxiliaryEngineCachingEnterprise/”,”/graalvm-as-a-platform/language-implementation-framework/BranchInstrumentation/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/BranchInstrumentation/”,”/reference-manual/native-image/BuildConfiguration/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildConfiguration/”,”/reference-manual/native-image/overview/BuildConfiguration/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildConfiguration/”,”/latest/reference-manual/native-image/BuildConfiguration/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildConfiguration/”,”/reference-manual/native-image/overview/BuildOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/”,”/reference-manual/native-image/Options/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/”,”/reference-manual/native-image/guides/use-system-properties/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/use-system-properties/”,”/reference-manual/native-image/overview/Options/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/”,”/latest/reference-manual/native-image/overview/BuildOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/”,”/latest/reference-manual/native-image/Options/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/”,”/latest/reference-manual/native-image/guides/use-system-properties/”:”https://github.com/graalvm/graalvm-demos/tree/master/native-image/use-system-properties”,”/reference-manual/native-image/BuildOutput/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildOutput/”,”/reference-manual/native-image/overview/BuildOutput/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildOutput/”,”/latest/reference-manual/native-image/BuildOutput/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildOutput/”,”/reference-manual/native-image/Build-Overview/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Build-Overview/”,”/reference-manual/native-image/overview/Build-Overview/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Build-Overview/”,”/latest/reference-manual/native-image/Build-Overview/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Build-Overview/”,”/reference-manual/native-image/build-report/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/build-report/”,”/reference-manual/native-image/overview/build-report/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/build-report/”,”/latest/reference-manual/native-image/build-report/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/build-report/”,”/reference-manual/native-image/overview/Bundles/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/Bundles/”,”/reference-manual/native-image/C-API/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/C-API/”,”/reference-manual/native-image/native-code-interoperability/C-API/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/C-API/”,”/latest/reference-manual/native-image/C-API/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/C-API/”,”/reference-manual/native-image/CertificateManagement/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/CertificateManagement/”,”/reference-manual/native-image/dynamic-features/CertificateManagement/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/CertificateManagement/”,”/latest/reference-manual/native-image/CertificateManagement/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/CertificateManagement/”,”/reference-manual/native-image/ClassInitialization/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/ClassInitialization/”,”/reference-manual/native-image/optimizations-and-performance/ClassInitialization/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/ClassInitialization/”,”/latest/reference-manual/native-image/ClassInitialization/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/ClassInitialization/”,”/graalvm-as-a-platform/language-implementation-framework/CloseOnGc/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/CloseOnGc/”,”/reference-manual/native-image/CodeStyle/”:”https://www.graalvm.org/latest/reference-manual/native-image/contributing/CodeStyle/”,”/reference-manual/native-image/contributing/CodeStyle/”:”https://www.graalvm.org/latest/reference-manual/native-image/contributing/CodeStyle/”,”/latest/reference-manual/native-image/CodeStyle/”:”https://www.graalvm.org/latest/reference-manual/native-image/contributing/CodeStyle/”,”/reference-manual/llvm/Compatibility/”:”https://www.graalvm.org/latest/reference-manual/llvm/Compatibility/”,”/reference-manual/native-image/Limitations/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/Compatibility/”,”/reference-manual/native-image/ARM64/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/Compatibility/”,”/reference-manual/native-image/metadata/Compatibility/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/Compatibility/”,”/latest/reference-manual/native-image/Limitations/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/Compatibility/”,”/latest/reference-manual/native-image/ARM64/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/Compatibility/”,”/reference-manual/llvm/Compiling/”:”https://www.graalvm.org/latest/reference-manual/llvm/Compiling/”,”/reference-manual/native-image/contributing/”:”https://www.graalvm.org/latest/reference-manual/native-image/contributing/”,”/graalvm-as-a-platform/language-implementation-framework/DSLGuidelines/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/DSLGuidelines/”,”/graalvm-as-a-platform/language-implementation-framework/DSLNodeObjectInlining/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/DSLNodeObjectInlining/”,”/graalvm-as-a-platform/language-implementation-framework/DSLWarnings/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/DSLWarnings/”,”/reference-manual/native-image/DebugInfo/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/”,”/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/”,”/latest/reference-manual/native-image/DebugInfo/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/”,”/reference-manual/llvm/Debugging/”:”https://www.graalvm.org/latest/reference-manual/llvm/Debugging/”,”/reference-manual/native-image/debugging-and-diagnostics/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/”,”/reference-manual/java-on-truffle/demos/”:”https://www.graalvm.org/latest/reference-manual/espresso/demos/”,”/reference-manual/espresso/demos/”:”https://www.graalvm.org/latest/reference-manual/espresso/demos/”,”/latest/reference-manual/java-on-truffle/demos/”:”https://www.graalvm.org/latest/reference-manual/espresso/demos/”,”/graalvm-as-a-platform/language-implementation-framework/DeoptCyclePatterns/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/DeoptCyclePatterns/”,”/reference-manual/native-image/dynamic-features/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/”,”/graalvm-as-a-platform/language-implementation-framework/DynamicObjectModel/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/DynamicObjectModel/”,”/graalvm-as-a-platform/language-implementation-framework/Exit/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/Exit/”,”/reference-manual/native-image/ExperimentalAgentOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/ExperimentalAgentOptions/”,”/reference-manual/native-image/metadata/ExperimentalAgentOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/ExperimentalAgentOptions/”,”/latest/reference-manual/native-image/ExperimentalAgentOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/ExperimentalAgentOptions/”,”/reference-manual/java-on-truffle/faq/”:”https://www.graalvm.org/latest/reference-manual/espresso/faq/”,”/reference-manual/espresso/faq/”:”https://www.graalvm.org/latest/reference-manual/espresso/faq/”,”/latest/reference-manual/java-on-truffle/faq/”:”https://www.graalvm.org/latest/reference-manual/espresso/faq/”,”/reference-manual/js/FAQ/”:”https://www.graalvm.org/latest/reference-manual/js/FAQ/”,”/reference-manual/native-image/dynamic-features/ffm-api/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/ffm-api/”,”/reference-manual/native-image/native-code-interoperability/ffm-api/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/ffm-api/”,”/latest/reference-manual/native-image/dynamic-features/ffm-api/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/ffm-api/”,”/reference-manual/native-image/native-code-interoperability/foreign-interface/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/foreign-interface/”,”/latest/reference-manual/native-image/native-code-interoperability/foreign-interface/”:”https://www.graalvm.org/reference-manual/native-image/native-code-interoperability/ffm-api/”,”/graalvm-as-a-platform/language-implementation-framework/HostOptimization/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/HostOptimization/”,”/reference-manual/native-image/HostedvsRuntimeOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/HostedvsRuntimeOptions/”,”/reference-manual/native-image/overview/HostedvsRuntimeOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/HostedvsRuntimeOptions/”,”/latest/reference-manual/native-image/HostedvsRuntimeOptions/”:”https://www.graalvm.org/latest/reference-manual/native-image/overview/HostedvsRuntimeOptions/”,”/latest/reference-manual/native-image/overview/HostedvsRuntimeOptions/”:”https://www.graalvm.org/reference-manual/native-image/overview/Options/”,”/reference-manual/java-on-truffle/hotswap-plugin/”:”https://www.graalvm.org/latest/reference-manual/espresso/hotswap/”,”/reference-manual/java-on-truffle/hotswap/”:”https://www.graalvm.org/latest/reference-manual/espresso/hotswap/”,”/reference-manual/espresso/hotswap/”:”https://www.graalvm.org/latest/reference-manual/espresso/hotswap/”,”/latest/reference-manual/java-on-truffle/hotswap-plugin/”:”https://www.graalvm.org/latest/reference-manual/espresso/hotswap/”,”/latest/reference-manual/java-on-truffle/hotswap/”:”https://www.graalvm.org/latest/reference-manual/espresso/hotswap/”,”/reference-manual/java-on-truffle/implementation/”:”https://www.graalvm.org/latest/reference-manual/espresso/implementation/”,”/reference-manual/espresso/implementation/”:”https://www.graalvm.org/latest/reference-manual/espresso/implementation/”,”/latest/reference-manual/java-on-truffle/implementation/”:”https://www.graalvm.org/latest/reference-manual/espresso/implementation/”,”/graalvm-as-a-platform/language-implementation-framework/Inlining/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/Inlining/”,”/tools/graalvm-insight/embedding/”:”https://www.graalvm.org/latest/tools/graalvm-insight/embedding/”,”/tools/graalvm-insight/manual/”:”https://www.graalvm.org/latest/tools/graalvm-insight/manual/”,”/tools/graalvm-insight/tracing/”:”https://www.graalvm.org/latest/tools/graalvm-insight/tracing/”,”/reference-manual/native-image/inspect/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/InspectTool/”,”/reference-manual/native-image/debugging-and-diagnostics/InspectTool/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/InspectTool/”,”/latest/reference-manual/native-image/inspect/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/InspectTool/”,”/graalvm-as-a-platform/language-implementation-framework/InteropMigration/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/InteropMigration/”,”/reference-manual/native-image/ImplementingNativeMethodsInJavaWithSVM/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/”,”/reference-manual/native-image/native-code-interoperability/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/”,”/latest/reference-manual/native-image/ImplementingNativeMethodsInJavaWithSVM/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/”,”/reference-manual/java-on-truffle/interoperability/”:”https://www.graalvm.org/latest/reference-manual/espresso/interoperability/”,”/reference-manual/espresso/interoperability/”:”https://www.graalvm.org/latest/reference-manual/espresso/interoperability/”,”/latest/reference-manual/java-on-truffle/interoperability/”:”https://www.graalvm.org/latest/reference-manual/espresso/interoperability/”,”/reference-manual/llvm/Interoperability/”:”https://www.graalvm.org/latest/reference-manual/llvm/Interoperability/”,”/reference-manual/native-image/features/JCASecurityServices/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JCASecurityServices/”,”/reference-manual/native-image/JCASecurityServices/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JCASecurityServices/”,”/reference-manual/native-image/dynamic-features/JCASecurityServices/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JCASecurityServices/”,”/latest/reference-manual/native-image/features/JCASecurityServices/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JCASecurityServices/”,”/latest/reference-manual/native-image/JCASecurityServices/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JCASecurityServices/”,”/reference-manual/native-image/debugging-and-diagnostics/jcmd/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/jcmd/”,”/reference-manual/native-image/debugging-and-diagnostics/JDWP/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/JDWP/”,”/reference-manual/native-image/JFR/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/JFR/”,”/reference-manual/native-image/debugging-and-diagnostics/JFR/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/JFR/”,”/latest/reference-manual/native-image/JFR/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/JFR/”,”/reference-manual/native-image/JNI/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JNI/”,”/reference-manual/native-image/dynamic-features/JNI/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JNI/”,”/latest/reference-manual/native-image/JNI/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JNI/”,”/reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/”:”https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/”,”/reference-manual/js/JavaInteroperability/”:”https://www.graalvm.org/latest/reference-manual/js/JavaInteroperability/”,”/reference-manual/js/JavaScriptCompatibility/”:”https://www.graalvm.org/latest/reference-manual/js/JavaScriptCompatibility/”,”/security-guide/native-image/Jipher/”:”https://www.graalvm.org/latest/security-guide/native-image/Jipher/”,”/latest/security-guide/native-image/Jipher/”:”https://docs.oracle.com/en/java/java-components/jipher/10/jipher-user-guide/what-is-oracle-jipher.html”,”/reference-manual/native-image/LLVMBackend/”:”https://www.graalvm.org/latest/reference-manual/native-image/LLVMBackend/”,”/latest/reference-manual/native-image/LLVMBackend/”:”https://github.com/oracle/graal/blob/master/substratevm/src/com.oracle.svm.core.graal.llvm/src/com/oracle/svm/core/graal/llvm/LLVMBackend.md”,”/graalvm-as-a-platform/language-implementation-framework/LanguageTutorial/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/LanguageTutorial/”,”/graalvm-as-a-platform/language-implementation-framework/Languages/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/Languages/”,”/reference-manual/native-image/MemoryManagement/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/”,”/reference-manual/native-image/optimizations-and-performance/MemoryManagement/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/”,”/latest/reference-manual/native-image/MemoryManagement/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/”,”/graalvm-as-a-platform/language-implementation-framework/migration-to-java-modules/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/migration-to-java-modules/”,”/reference-manual/js/Modules/”:”https://www.graalvm.org/latest/reference-manual/js/Modules/”,”/graalvm-as-a-platform/language-implementation-framework/splitting/Monomorphization/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/splitting/Monomorphization/”,”/graalvm-as-a-platform/language-implementation-framework/splitting/MonomorphizationUseCases/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/splitting/MonomorphizationUseCases/”,”/reference-manual/js/Multithreading/”:”https://www.graalvm.org/latest/reference-manual/js/Multithreading/”,”/graalvm-as-a-platform/language-implementation-framework/NFI/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/NFI/”,”/reference-manual/native-image/debugging-and-diagnostics/NMT/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/NMT/”,”/reference-manual/js/NashornMigrationGuide/”:”https://www.graalvm.org/latest/reference-manual/js/NashornMigrationGuide/”,”/reference-manual/llvm/NativeExecution/”:”https://www.graalvm.org/latest/reference-manual/llvm/NativeExecution/”,”/reference-manual/native-image/basics/”:”https://www.graalvm.org/latest/reference-manual/native-image/basics/”,”/reference-manual/js/NodeJS/”:”https://www.graalvm.org/latest/reference-manual/js/NodeJS/”,”/reference-manual/js/NodeJSvsJavaScriptContext/”:”https://www.graalvm.org/latest/reference-manual/js/NodeJSvsJavaScriptContext/”,”/security-guide/native-image/obfuscation/”:”https://www.graalvm.org/latest/security-guide/native-image/obfuscation/”,”/reference-manual/native-image/optimizations-and-performance/ObjectHeaderSize/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/ObjectHeaderSize/”,”/graalvm-as-a-platform/language-implementation-framework/OnStackReplacement/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/OnStackReplacement/”,”/reference-manual/java/operations/”:”https://www.graalvm.org/latest/reference-manual/compiler/operations/”,”/reference-manual/compiler/operations/”:”https://www.graalvm.org/latest/reference-manual/compiler/operations/”,”/latest/reference-manual/java/operations/”:”https://www.graalvm.org/latest/reference-manual/compiler/operations/”,”/reference-manual/js/OperatorOverloading/”:”https://www.graalvm.org/latest/reference-manual/js/OperatorOverloading/”,”/reference-manual/native-image/optimizations-and-performance/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/”,”/graalvm-as-a-platform/language-implementation-framework/Optimizing/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/Optimizing/”,”/reference-manual/java/options/”:”https://www.graalvm.org/latest/reference-manual/java/options/”,”/reference-manual/llvm/Options/”:”https://www.graalvm.org/latest/reference-manual/llvm/Options/”,”/reference-manual/js/Options/”:”https://www.graalvm.org/latest/reference-manual/js/Options/”,”/graalvm-as-a-platform/language-implementation-framework/Options/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/Options/”,”/reference-manual/native-image/optimizations-and-performance/PGO/basic-usage/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/basic-usage/”,”/reference-manual/native-image/optimizations-and-performance/PGO/build-reports/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/build-reports/”,”/reference-manual/native-image/optimizations-and-performance/PGO/faq/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/faq/”,”/reference-manual/native-image/optimizations-and-performance/PGO/iprof-file-format/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/iprof-file-format/”,”/reference-manual/native-image/optimizations-and-performance/PGO/LCOV/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/LCOV/”,”/reference-manual/native-image/optimizations-and-performance/PGO/merging-profiles/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/merging-profiles/”,”/reference-manual/native-image/optimizations-and-performance/PGO/profile-quality/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/profile-quality/”,”/reference-manual/native-image/optimizations-and-performance/PGO/”:”https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/PGO/”,”/reference-manual/native-image/debugging-and-diagnostics/perf-profiler/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/perf-profiler/”,”/graalvm-as-a-platform/language-implementation-framework/Profiling/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/Profiling/”,”/community/publications/”:”https://www.graalvm.org/latest/community/publications/”,”/reference-manual/java-on-truffle/”:”https://www.graalvm.org/latest/reference-manual/espresso/”,”/reference-manual/espresso/”:”https://www.graalvm.org/latest/reference-manual/espresso/”,”/latest/reference-manual/java-on-truffle/”:”https://www.graalvm.org/latest/reference-manual/espresso/”,”/reference-manual/java/”:”https://www.graalvm.org/latest/reference-manual/java/”,”/reference-manual/llvm/”:”https://www.graalvm.org/latest/reference-manual/llvm/”,”/reference-manual/native-image/”:”https://www.graalvm.org/latest/reference-manual/native-image/”,”/reference-manual/js/”:”https://www.graalvm.org/latest/reference-manual/js/”,”/tools/graalvm-insight/”:”https://www.graalvm.org/latest/tools/graalvm-insight/”,”/tools/vscode/graalvm-extension/”:”https://www.graalvm.org/latest/tools/vscode/graalvm-extension/”,”/graalvm-as-a-platform/language-implementation-framework/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/”,”/reference-manual/native-image/dynamic-features/Resources/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/”,”/reference-manual/native-image/dynamic-features/Reflection/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/”,”/reference-manual/native-image/dynamic-features/DynamicProxy/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/”,”/reference-manual/native-image/metadata/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/”,”/latest/reference-manual/native-image/dynamic-features/Resources/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/”,”/latest/reference-manual/native-image/dynamic-features/Reflection/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/”,”/latest/reference-manual/native-image/dynamic-features/DynamicProxy/”:”https://www.graalvm.org/latest/reference-manual/native-image/metadata/”,”/graalvm-as-a-platform/language-implementation-framework/splitting/ReportingPolymorphism/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/splitting/ReportingPolymorphism/”,”/reference-manual/js/RhinoMigrationGuide/”:”https://www.graalvm.org/latest/reference-manual/js/RhinoMigrationGuide/”,”/reference-manual/js/RunOnJDK/”:”https://www.graalvm.org/latest/reference-manual/js/RunOnJDK/”,”/security-guide/native-image/sbom/”:”https://www.graalvm.org/latest/security-guide/native-image/sbom/”,”/graalvm-as-a-platform/language-implementation-framework/Safepoint/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/Safepoint/”,”/reference-manual/js/ScriptEngine/”:”https://www.graalvm.org/latest/reference-manual/js/ScriptEngine/”,”/graalvm-as-a-platform/language-implementation-framework/SpecializationHistogram/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/SpecializationHistogram/”,”/graalvm-as-a-platform/language-implementation-framework/SpecializationTesting/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/SpecializationTesting/”,”/graalvm-as-a-platform/language-implementation-framework/splitting/Splitting/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/splitting/Splitting/”,”/reference-manual/native-image/Reports/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/StaticAnalysisReports/”,”/reference-manual/native-image/debugging-and-diagnostics/StaticAnalysisReports/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/StaticAnalysisReports/”,”/latest/reference-manual/native-image/Reports/”:”https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/StaticAnalysisReports/”,”/graalvm-as-a-platform/language-implementation-framework/StaticObjectModel/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/StaticObjectModel/”,”/graalvm-as-a-platform/language-implementation-framework/TCK/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/TCK/”,”/graalvm-as-a-platform/language-implementation-framework/TraversingCompilationQueue/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/TraversingCompilationQueue/”,”/graalvm-as-a-platform/language-implementation-framework/TruffleLibraries/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/TruffleLibraries/”,”/graalvm-as-a-platform/language-implementation-framework/TruffleStrings/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/language-implementation-framework/TruffleStrings/”,”/reference-manual/native-image/URLProtocols/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/URLProtocols/”,”/reference-manual/native-image/dynamic-features/URLProtocols/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/URLProtocols/”,”/latest/reference-manual/native-image/URLProtocols/”:”https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/URLProtocols/”,”/reference-manual/native-image/workshops/”:”https://www.graalvm.org/latest/reference-manual/native-image/workshops/”,”/reference-manual/native-image/Properties/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/access-environment-variables/”,”/reference-manual/native-image/guides/access-environment-variables/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/access-environment-variables/”,”/latest/reference-manual/native-image/Properties/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/access-environment-variables/”,”/reference-manual/native-image/Logging/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/add-logging-to-native-executable/”,”/reference-manual/native-image/guides/add-logging-to-native-executable/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/add-logging-to-native-executable/”,”/latest/reference-manual/native-image/Logging/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/add-logging-to-native-executable/”,”/reference-manual/native-image/guides/build-and-run-native-executable-with-jfr/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-and-run-native-executable-with-jfr/”,”/reference-manual/native-image/guides/build-and-run-native-executable-with-remote-jmx/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-and-run-native-executable-with-remote-jmx/”,”/reference-manual/native-image/guides/build-java-modules-into-native-executable/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-java-modules-into-native-executable/”,”/reference-manual/native-image/guides/build-native-executable-from-jar/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-native-executable-from-jar/”,”/reference-manual/native-image/guides/build-native-shared-library/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-native-shared-library/”,”/reference-manual/native-image/guides/build-polyglot-native-executable/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-polyglot-native-executable/”,”/reference-manual/native-image/guides/build-spring-boot-app-into-native-executable/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-spring-boot-app-into-native-executable/”,”/reference-manual/native-image/StaticImages/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-static-executables/”,”/reference-manual/native-image/guides/build-static-executables/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-static-executables/”,”/latest/reference-manual/native-image/StaticImages/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/build-static-executables/”,”/reference-manual/native-image/guides/build-with-reflection/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/”,”/reference-manual/native-image/guides/configure-with-tracing-agent/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/”,”/latest/reference-manual/native-image/guides/build-with-reflection/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/”,”/docs/tools/chrome-debugger/”:”https://www.graalvm.org/latest/tools/chrome-debugger/”,”/tools/chrome-debugger/”:”https://www.graalvm.org/latest/tools/chrome-debugger/”,”/latest/docs/tools/chrome-debugger/”:”https://www.graalvm.org/latest/tools/chrome-debugger/”,”/getting-started/oci/cloud-shell/”:”https://www.graalvm.org/latest/getting-started/oci/cloud-shell/”,”/tools/code-coverage/”:”https://www.graalvm.org/latest/tools/code-coverage/”,”/getting-started/oci/code-editor/”:”https://www.graalvm.org/latest/getting-started/oci/code-editor/”,”/docs/reference-manual/compatibility/”:”https://www.graalvm.org/compatibility/”,”/reference-manual/compiler/”:”https://www.graalvm.org/latest/reference-manual/java/compiler/”,”/reference-manual/java/compiler/”:”https://www.graalvm.org/latest/reference-manual/java/compiler/”,”/latest/reference-manual/compiler/”:”https://www.graalvm.org/latest/reference-manual/java/compiler/”,”/reference-manual/native-image/guides/configure-dynamic-proxies/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-dynamic-proxies/”,”/latest/reference-manual/native-image/guides/configure-dynamic-proxies/”:”https://www.graalvm.org/reference-manual/native-image/metadata/#reflection”,”/reference-manual/native-image/guides/containerise-native-executable-and-run-in-docker-container/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/containerise-native-executable-and-run-in-docker-container/”,”/reference-manual/espresso/continuations/”:”https://www.graalvm.org/latest/reference-manual/espresso/continuations/”,”/reference-manual/native-image/NativeImageHeapdump/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/create-heap-dump/”,”/reference-manual/native-image/guides/create-heap-dump/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/create-heap-dump/”,”/latest/reference-manual/native-image/NativeImageHeapdump/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/create-heap-dump/”,”/tools/dap/”:”https://www.graalvm.org/latest/tools/dap/”,”/dashboard/”:”https://www.graalvm.org/jdk22/reference-manual/native-image/optimizations-and-performance/PGO/build-reports/”,”/reference-manual/native-image/guides/debug-native-image-process/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/debug-native-image-process/”,”/reference-manual/native-image/guides/debug-native-image-process-with-python-helper-script/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/debug-native-image-process-with-python-helper-script/”,”/reference-manual/embed-languages/”:”https://www.graalvm.org/latest/reference-manual/embed-languages/”,”/native-image/error-report/”:”https://github.com/oracle/graal/issues/new?labels=bug%2C+native-image&amp;amp;template=1_issues_native_image_error_report.md”,”/r/”:”https://github.com/oracle/fastr?tab=readme-ov-file#fastr”,”/reference-manual/r/”:”https://www.graalvm.org/latest/reference-manual/r/”,”/reference-manual/r/ExtensionsSupport/”:”https://www.graalvm.org/latest/reference-manual/r/”,”/latest/reference-manual/r/ExtensionsSupport/”:”https://www.graalvm.org/latest/reference-manual/r/”,”/latest/reference-manual/r/”:”https://github.com/oracle/fastr?tab=readme-ov-file#fastr”,”/reference-manual/espresso/continuations/generators/”:”https://www.graalvm.org/latest/reference-manual/espresso/continuations/generators/”,”/docs/getting-started/”:”https://www.graalvm.org/latest/getting-started/”,”/getting-started/”:”https://www.graalvm.org/latest/getting-started/”,”/latest/docs/getting-started/”:”https://www.graalvm.org/latest/getting-started/”,”/reference-manual/python/”:”https://www.graalvm.org/latest/python/docs/”,”/docs/reference-manual/python/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Embedding-Build-Tools/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Embedding-Permissions/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/OSInterface/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Interoperability/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Native-Extensions/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/native-applications/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/native-image/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Performance/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/ParserDetails/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Modern-Python-on-JVM/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Jython/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Python-Runtime/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Packages/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/standalone-binaries/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/standalone-applications/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/Tooling/”:”https://www.graalvm.org/latest/python/docs/”,”/reference-manual/python/FAQ/”:”https://www.graalvm.org/latest/python/docs/”,”/python/docs/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/docs/reference-manual/python/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Embedding-Build-Tools/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Embedding-Permissions/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/OSInterface/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Interoperability/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Native-Extensions/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/native-applications/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/native-image/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Performance/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/ParserDetails/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Modern-Python-on-JVM/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Jython/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Python-Runtime/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Packages/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/standalone-binaries/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/standalone-applications/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/Tooling/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/reference-manual/python/FAQ/”:”https://www.graalvm.org/latest/python/docs/”,”/latest/python/docs/”:”https://www.graalvm.org/python/docs/”,”/docs/graalvm-as-a-platform/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/”,”/graalvm-as-a-platform/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/”,”/latest/docs/graalvm-as-a-platform/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/”,”/docs/getting-started/container-images/”:”https://www.graalvm.org/latest/getting-started/container-images/”,”/getting-started/container-images/”:”https://www.graalvm.org/latest/getting-started/container-images/”,”/latest/docs/getting-started/container-images/”:”https://www.graalvm.org/latest/getting-started/container-images/”,”/getting-started/oci/”:”https://www.graalvm.org/latest/getting-started/oci/”,”/docs/graalvm-updater/”:”https://www.graalvm.org/latest/reference-manual/graalvm-updater/”,”/reference-manual/graalvm-updater/”:”https://www.graalvm.org/latest/reference-manual/graalvm-updater/”,”/latest/docs/graalvm-updater/”:”https://www.graalvm.org/latest/reference-manual/graalvm-updater/”,”/reference-manual/wasm/”:”https://www.graalvm.org/latest/webassembly/docs/”,”/docs/reference-manual/wasm/”:”https://www.graalvm.org/latest/webassembly/docs/”,”/webassembly/docs/”:”https://www.graalvm.org/latest/webassembly/docs/”,”/latest/reference-manual/wasm/”:”https://www.graalvm.org/latest/webassembly/docs/”,”/latest/docs/reference-manual/wasm/”:”https://www.graalvm.org/latest/webassembly/docs/”,”/latest/webassembly/docs/”:”https://www.graalvm.org/webassembly/docs/”,”/native-image/guides/”:”https://www.graalvm.org/latest/guides/”,”/reference-manual/native-image/guides/”:”https://www.graalvm.org/latest/guides/”,”/guides/”:”https://www.graalvm.org/latest/guides/”,”/latest/native-image/guides/”:”https://www.graalvm.org/latest/guides/”,”/latest/reference-manual/native-image/guides/”:”https://www.graalvm.org/latest/guides/”,”/tools/igv/”:”https://www.graalvm.org/latest/tools/igv/”,”/docs/graalvm-as-a-platform/implement-instrument/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/implement-instrument/”,”/graalvm-as-a-platform/implement-instrument/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/implement-instrument/”,”/latest/docs/graalvm-as-a-platform/implement-instrument/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/implement-instrument/”,”/docs/graalvm-as-a-platform/implement-language/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/implement-language/”,”/graalvm-as-a-platform/implement-language/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/implement-language/”,”/latest/docs/graalvm-as-a-platform/implement-language/”:”https://www.graalvm.org/latest/graalvm-as-a-platform/implement-language/”,”/reference-manual/native-image/guides/use-reachability-metadata-repository-gradle/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/use-reachability-metadata-repository-gradle/”,”/reference-manual/native-image/guides/use-reachability-metadata-repository-maven/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/use-reachability-metadata-repository-maven/”,”/reference-manual/native-image/guides/include-resources/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/include-resources/”,”/getting-started/oci/compute-instance/”:”https://www.graalvm.org/latest/getting-started/oci/compute-instance/”,”/getting-started/oci/devops-build-pipeline/”:”https://www.graalvm.org/latest/getting-started/oci/devops-build-pipeline/”,”/docs/introduction/”:”https://www.graalvm.org/latest/introduction/”,”/introduction/”:”https://www.graalvm.org/latest/introduction/”,”/latest/docs/introduction/”:”https://www.graalvm.org/latest/introduction/”,”/pages/javadocs/jdk17.html”:”https://www.graalvm.org/23.0/javadoc/sdk/”,”/jdk17/introduction/”:”https://www.graalvm.org/jdk17/docs/introduction/”,”/jdk17/getting-started/”:”https://www.graalvm.org/jdk17/docs/getting-started/”,”/pages/javadocs/jdk21.html”:”https://www.graalvm.org/23.1/javadoc/sdk/”,”/jdk21/introduction/”:”https://www.graalvm.org/jdk21/docs/introduction/”,”/jdk21/getting-started/”:”https://www.graalvm.org/jdk21/docs/getting-started/”,”/pages/javadocs/jdk25.html”:”https://www.graalvm.org/25.0/javadoc/sdk/”,”/reference-manual/languages/”:”https://www.graalvm.org/latest/reference-manual/languages/”,”/docs/getting-started/linux/”:”https://www.graalvm.org/latest/getting-started/linux/”,”/getting-started/linux/”:”https://www.graalvm.org/latest/getting-started/linux/”,”/latest/docs/getting-started/linux/”:”https://www.graalvm.org/latest/getting-started/linux/”,”/tools/lsp/”:”https://www.graalvm.org/latest/tools/lsp/”,”/docs/getting-started/macos/”:”https://www.graalvm.org/latest/getting-started/macos/”,”/getting-started/macos/”:”https://www.graalvm.org/latest/getting-started/macos/”,”/latest/docs/getting-started/macos/”:”https://www.graalvm.org/latest/getting-started/macos/”,”/community/meetup/”:”https://www.graalvm.org/community/summit/”,”/use-cases/mle-oracle/”:”https://www.graalvm.org/js/mle-oracle-db/”,”/native-image/”:”https://www.graalvm.org/”,”/security-guide/native-image/”:”https://www.graalvm.org/latest/security-guide/native-image/”,”/community/opensource/”:”https://github.com/graalvm”,”/reference-manual/native-image/guides/optimize-for-file-size/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/optimize-for-file-size/”,”/reference-manual/native-image/guides/optimize-memory-footprint/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/optimize-memory-footprint/”,”/reference-manual/native-image/guides/optimize-native-executable-size-using-build-report/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/optimize-native-executable-size-using-build-report/”,”/reference-manual/native-image/PGO/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/optimize-native-executable-with-pgo/”,”/reference-manual/native-image/guides/optimize-native-executable-with-pgo/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/optimize-native-executable-with-pgo/”,”/latest/reference-manual/native-image/PGO/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/optimize-native-executable-with-pgo/”,”/docs/polyglot-programming/”:”https://www.graalvm.org/latest/reference-manual/polyglot-programming/”,”/reference-manual/polyglot-programming/”:”https://www.graalvm.org/latest/reference-manual/polyglot-programming/”,”/latest/docs/polyglot-programming/”:”https://www.graalvm.org/latest/reference-manual/polyglot-programming/”,”/tools/vscode/graalvm-extension/polyglot-runtime/”:”https://www.graalvm.org/latest/tools/vscode/graalvm-extension/polyglot-runtime/”,”/latest/tools/vscode/graalvm-extension/polyglot-runtime/”:”https://www.graalvm.org/tools/vscode/graalvm-extension/”,”/security-guide/polyglot-sandbox/”:”https://www.graalvm.org/latest/security-guide/sandboxing/”,”/reference-manual/embed-languages/sandbox-resource-limits/”:”https://www.graalvm.org/latest/security-guide/sandboxing/”,”/security-guide/sandboxing/”:”https://www.graalvm.org/latest/security-guide/sandboxing/”,”/latest/security-guide/polyglot-sandbox/”:”https://www.graalvm.org/latest/security-guide/sandboxing/”,”/latest/reference-manual/embed-languages/sandbox-resource-limits/”:”https://www.graalvm.org/latest/security-guide/sandboxing/”,”/tools/profiling/”:”https://www.graalvm.org/latest/tools/profiling/”,”/docs/reference-manual/”:”https://www.graalvm.org/latest/reference-manual/”,”/reference-manual/”:”https://www.graalvm.org/latest/reference-manual/”,”/latest/docs/reference-manual/”:”https://www.graalvm.org/latest/reference-manual/”,”/version-roadmap/”:”https://www.graalvm.org/release-calendar/”,”/release-notes/version-roadmap/”:”https://www.graalvm.org/release-calendar/”,”/latest/release-notes/”:”https://www.graalvm.org/release-notes/”,”/dev/release-notes/”:”https://www.graalvm.org/release-notes/”,”/22.3/release-notes/”:”https://www.graalvm.org/release-notes/”,”/22.2/release-notes/”:”https://www.graalvm.org/release-notes/”,”/22.1/release-notes/”:”https://www.graalvm.org/release-notes/”,”/22.0/release-notes/”:”https://www.graalvm.org/release-notes/”,”/21.3/release-notes/”:”https://www.graalvm.org/release-notes/”,”/ruby/”:”https://truffleruby.dev/”,”/docs/security-guide/”:”https://www.graalvm.org/latest/security-guide/”,”/security-guide/”:”https://www.graalvm.org/latest/security-guide/”,”/latest/docs/security-guide/”:”https://www.graalvm.org/latest/security-guide/”,”/reference-manual/espresso/continuations/serialization/”:”https://www.graalvm.org/latest/reference-manual/espresso/continuations/serialization/”,”/slack-invitation/”:”https://join.slack.com/t/graalvm/shared_invite/zt-36w5ym09c-NlRn1rICzySSOg9oD~VE5A”,”/reference-manual/native-image/guides/specify-class-initialization/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/specify-class-initialization/”,”/community/support/”:”https://www.graalvm.org/support/”,”/tools/”:”https://www.graalvm.org/latest/reference-manual/tools/”,”/reference-manual/tools/”:”https://www.graalvm.org/latest/reference-manual/tools/”,”/latest/tools/”:”https://www.graalvm.org/latest/reference-manual/tools/”,”/reference-manual/native-image/guides/troubleshoot-run-time-errors/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/troubleshoot-run-time-errors/”,”/reference-manual/ruby/Compatibility/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/Debugging/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/RuntimeConfigurations/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/InstallingGraalVM/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/Installinglibssl/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/InstallingLibYAML/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/InstallingLLVM/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/Installingzlib/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/JRubyMigration/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/Options/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/Polyglot/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/RubyManagers/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/StandaloneDistribution/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/Tools/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/TruffleRubyAdditions/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/UTF8Locale/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/ReportingPerformanceProblems/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/KnownCVEs/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/Optcarrot/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/FAQ/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/reference-manual/ruby/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Compatibility/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Debugging/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/RuntimeConfigurations/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/InstallingGraalVM/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Installinglibssl/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/InstallingLibYAML/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/InstallingLLVM/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Installingzlib/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/JRubyMigration/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Options/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Polyglot/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/RubyManagers/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/StandaloneDistribution/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Tools/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/TruffleRubyAdditions/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/UTF8Locale/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/ReportingPerformanceProblems/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/KnownCVEs/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/Optcarrot/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/FAQ/”:”https://www.graalvm.org/latest/reference-manual/ruby/”,”/latest/reference-manual/ruby/”:”https://github.com/oracle/truffleruby/?tab=readme-ov-file#getting-started”,”/reference-manual/native-image/guides/use-graalvm-dashboard/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/use-graalvm-dashboard/”,”/reference-manual/native-image/guides/use-sbom-support/”:”https://www.graalvm.org/latest/reference-manual/native-image/guides/use-sbom-support/”,”/tools/vscode/graalvm-extension/visualvm-integration/”:”https://www.graalvm.org/latest/tools/vscode/graalvm-extension/visualvm-integration/”,”/latest/tools/vscode/graalvm-extension/visualvm-integration/”:”https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.visualvm-vscode”,”/tools/visualvm/”:”https://www.graalvm.org/latest/tools/visualvm/”,”/docs/why-graal/”:”https://www.graalvm.org/why-graalvm/”,”/docs/getting-started/windows/”:”https://www.graalvm.org/latest/getting-started/windows/”,”/getting-started/windows/”:”https://www.graalvm.org/latest/getting-started/windows/”,”/latest/docs/getting-started/windows/”:”https://www.graalvm.org/latest/getting-started/windows/”}",
          "url": " /redirects.json"
          },
          
          "sitemap-xml":  {
          "title": "",
          "content": "{% if page.xsl %}{% endif %}{% assign collections = site.collections | where_exp:&#39;collection&#39;,&#39;collection.output != false&#39; %}{% for collection in collections %}{% assign docs = collection.docs | where_exp:&#39;doc&#39;,&#39;doc.sitemap != false&#39; %}{% for doc in docs %}{{ doc.url | replace:&#39;/index.html&#39;,&#39;/&#39; | absolute_url | xml_escape }}{% if doc.last_modified_at or doc.date %}{{ doc.last_modified_at | default: doc.date | date_to_xmlschema }}{% endif %}&amp;lt;/url&amp;gt;{% endfor %}{% endfor %}{% assign pages = site.html_pages | where_exp:’doc’,’doc.sitemap != false’ | where_exp:’doc’,’doc.url != “/404.html”’ %}{% for page in pages %}{{ page.url | replace:&#39;/index.html&#39;,&#39;/&#39; | absolute_url | xml_escape }}{% if page.last_modified_at %}{{ page.last_modified_at | date_to_xmlschema }}{% endif %}&amp;lt;/url&amp;gt;{% endfor %}{% assign static_files = page.static_files | where_exp:’page’,’page.sitemap != false’ | where_exp:’page’,’page.name != “404.html”’ %}{% for file in static_files %}{{ file.path | replace:&#39;/index.html&#39;,&#39;/&#39; | absolute_url | xml_escape }}{{ file.modified_time | date_to_xmlschema }}&amp;lt;/url&amp;gt;{% endfor %}&amp;lt;/urlset&amp;gt;",
          "url": " /sitemap.xml"
          },
          
          };
        </script>

      <div role="button" class="menu-btn menu-btn--sidebar js-show-sidebar" title="sweet hamburger">
        <div class="hamburger">
          <div class="inner"></div>
        </div>
      </div>
    </div>
  </div>
</article>

<!-- JavaScript libraries -->
<script src="/resources/js/lunr.min.js"></script>
<script src="/resources/lib/jquery/jquery-3.6.1.min.js"></script>
</div>

      </main>
      <!-- Connect with us -->
<section class="content-section socials">
  <div class="container-fluid container-fluid--custom-sm">
    <div class="row-socials">
      <div class="title">
        <h2 class="title-section">Connect with us</h2>
      </div>
      <div class="social-icons">
        <div class="wider-logo">
          <a href="https://github.com/oracle/graal" target="_blank" title="github social media link">
            <svg class="social-icon" width="24" height="24" viewBox="0 0 24 24" fill="none"
              xmlns="http://www.w3.org/2000/svg" alt="github social media icon">
              <path
                d="M12 0C5.374 0 0 5.373 0 12C0 17.302 3.438 21.8 8.207 23.387C8.806 23.498 9 23.126 9 22.81V20.576C5.662 21.302 4.967 19.16 4.967 19.16C4.421 17.773 3.634 17.404 3.634 17.404C2.545 16.659 3.717 16.675 3.717 16.675C4.922 16.759 5.556 17.912 5.556 17.912C6.626 19.746 8.363 19.216 9.048 18.909C9.155 18.134 9.466 17.604 9.81 17.305C7.145 17 4.343 15.971 4.343 11.374C4.343 10.063 4.812 8.993 5.579 8.153C5.455 7.85 5.044 6.629 5.696 4.977C5.696 4.977 6.704 4.655 8.997 6.207C9.954 5.941 10.98 5.808 12 5.803C13.02 5.808 14.047 5.941 15.006 6.207C17.297 4.655 18.303 4.977 18.303 4.977C18.956 6.63 18.545 7.851 18.421 8.153C19.191 8.993 19.656 10.064 19.656 11.374C19.656 15.983 16.849 16.998 14.177 17.295C14.607 17.667 15 18.397 15 19.517V22.81C15 23.129 15.192 23.504 15.801 23.386C20.566 21.797 24 17.3 24 12C24 5.373 18.627 0 12 0Z"
                fill="#171F26" />
            </svg>
          </a>
        </div>
        <div class="wider-logo">
          <a href="https://x.com/graalvm" target="_blank" title="x social media link">
            <svg class="social-icon" width="24" height="24" viewBox="0 0 1200 1227" fill="none" xmlns="http://www.w3.org/2000/svg" alt="X social media icon">
              <path d="M714.2 507.9L1167 0H1060.1L661.8 460.4L343.9 0H0L475.4 690.3L0 1227H106.9L531.8 738.5L875.6 1227H1219.5L714.2 507.9ZM582.6 675.5L537.9 611.2L144.6 80.6H288.5L598.8 530.5L643.5 594.8L1048.5 1146.4H904.6L582.6 675.5Z" fill="#171F26"/>
            </svg>
          </a>
        </div>
        <div class="wider-logo">
          <a href="https://www.linkedin.com/company/graalvm/" target="_blank" title="linkedin social media link">
            <svg class="social-icon" width="24" height="24" viewBox="0 0 24 24" fill="none"
              xmlns="http://www.w3.org/2000/svg" alt="linkedin social media icon">
              <path
                d="M12 0C5.3736 0 0 5.3736 0 12C0 18.6264 5.3736 24 12 24C18.6264 24 24 18.6264 24 12C24 5.3736 18.6264 0 12 0ZM8.51294 18.1406H5.59039V9.34808H8.51294V18.1406ZM7.05176 8.14746H7.03271C6.052 8.14746 5.41772 7.47235 5.41772 6.6286C5.41772 5.76581 6.07141 5.10938 7.07117 5.10938C8.07092 5.10938 8.68616 5.76581 8.7052 6.6286C8.7052 7.47235 8.07092 8.14746 7.05176 8.14746ZM19.051 18.1406H16.1288V13.4368C16.1288 12.2547 15.7057 11.4485 14.6483 11.4485C13.8409 11.4485 13.3601 11.9923 13.1488 12.5173C13.0715 12.7051 13.0527 12.9677 13.0527 13.2305V18.1406H10.1303C10.1303 18.1406 10.1686 10.173 10.1303 9.34808H13.0527V10.593C13.441 9.9939 14.1359 9.14172 15.6865 9.14172C17.6093 9.14172 19.051 10.3984 19.051 13.099V18.1406Z"
                fill="#171F26" />
            </svg>
          </a>
        </div>
        <div class="wider-logo">
          <a href="https://medium.com/graalvm" target="_blank" title="medium social media link">
            <svg class="social-icon" width="24" height="24" viewBox="0 0 24 24" fill="none"
              xmlns="http://www.w3.org/2000/svg" alt="medium social media icon">
              <path fill-rule="evenodd" clip-rule="evenodd"
                d="M12 0C5.374 0 0 5.372 0 12C0 18.627 5.374 24 12 24C18.627 24 24 18.627 24 12C24 5.372 18.627 0 12 0ZM18.974 17.557V17.322L17.882 16.25C17.786 16.177 17.738 16.056 17.758 15.937V8.063C17.738 7.944 17.786 7.823 17.882 7.75L19 6.678V6.443H15.131L12.373 13.323L9.235 6.443H5.176V6.678L6.484 8.253C6.612 8.368 6.678 8.538 6.66 8.71V14.898C6.698 15.121 6.628 15.349 6.471 15.512L5 17.296V17.531H9.17V17.296L7.699 15.512C7.541 15.349 7.466 15.123 7.497 14.898V9.546L11.157 17.531H11.582L14.725 9.546V15.911C14.725 16.081 14.725 16.113 14.614 16.224L13.484 17.322V17.557H18.974Z"
                fill="#171F26" />
            </svg>
          </a>
        </div>
        <div class="wider-logo">
          <a href="https://bsky.app/profile/graalvm.org" target="_blank" title="blue sky social media link">
            <svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g clip-path="url(#clip0_2442_17265)">
              <path d="M6.6075 3.99362C9.59982 6.25419 12.8184 10.8377 14.0001 13.2975C15.1819 10.8379 18.4003 6.25415 21.3927 3.99362C23.5518 2.36248 27.0501 1.1004 27.0501 5.11641C27.0501 5.91846 26.5931 11.8541 26.3251 12.8177C25.3935 16.1679 21.9986 17.0224 18.9789 16.5052C24.2574 17.4093 25.6002 20.4037 22.7002 23.3982C17.1927 29.0853 14.7843 21.9713 14.1669 20.1484C14.0537 19.8143 14.0008 19.6579 14 19.7909C13.9992 19.6579 13.9463 19.8143 13.8332 20.1484C13.216 21.9713 10.8077 29.0855 5.29983 23.3982C2.39985 20.4037 3.74261 17.4091 9.0212 16.5052C6.00134 17.0224 2.60645 16.1679 1.67495 12.8177C1.40692 11.854 0.949951 5.91837 0.949951 5.11641C0.949951 1.1004 4.44834 2.36248 6.60735 3.99362H6.6075Z" fill="#171F26"/>
              </g>
              <defs>
              <clipPath id="clip0_2442_17265">
              <rect width="27" height="24" fill="white" transform="translate(0.5 2)"/>
              </clipPath>
              </defs>
              </svg>
          </a>
        </div>
        <div class="wider-logo">
          <a href="/slack-invitation/" title="slack social media link">
            <svg class="social-icon" width="40" height="40" viewBox="0 0 40 40" fill="none"
              xmlns="http://www.w3.org/2000/svg" alt="slack social media icon">
              <path
                d="M13.0009 23.1698C12.9989 23.6678 12.8495 24.154 12.5714 24.5671C12.2933 24.9802 11.899 25.3017 11.4384 25.4909C10.9777 25.6801 10.4714 25.7285 9.98319 25.6302C9.49502 25.5318 9.04693 25.291 8.6955 24.9382C8.34408 24.5854 8.10506 24.1363 8.00863 23.6478C7.91221 23.1592 7.96269 22.6531 8.15371 22.1932C8.34474 21.7333 8.66773 21.3403 9.08193 21.0638C9.49612 20.7874 9.98294 20.6398 10.4809 20.6398H13.0009V23.1698ZM14.2709 29.4798C14.3636 30.0763 14.6665 30.6201 15.125 31.0128C15.5835 31.4055 16.1672 31.6214 16.7709 31.6214C17.3746 31.6214 17.9584 31.4055 18.4168 31.0128C18.8753 30.6201 19.1782 30.0763 19.2709 29.4798V23.1698C19.327 22.8091 19.3043 22.4404 19.2044 22.0893C19.1045 21.7381 18.9299 21.4127 18.6923 21.1354C18.4548 20.8582 18.1601 20.6356 17.8284 20.483C17.4968 20.3304 17.136 20.2514 16.7709 20.2514C16.4058 20.2514 16.0451 20.3304 15.7134 20.483C15.3817 20.6356 15.087 20.8582 14.8495 21.1354C14.612 21.4127 14.4373 21.7381 14.3374 22.0893C14.2375 22.4404 14.2149 22.8091 14.2709 23.1698V29.4798ZM19.2709 13.0398V10.5198C19.2806 10.0137 19.1382 9.51621 18.8622 9.09184C18.5861 8.66746 18.1891 8.33567 17.7224 8.13936C17.2558 7.94305 16.741 7.89125 16.2445 7.99067C15.7481 8.09009 15.293 8.33615 14.9379 8.69703C14.5829 9.05791 14.3442 9.51701 14.2529 10.015C14.1616 10.5129 14.2217 11.0268 14.4256 11.4902C14.6295 11.9536 14.9677 12.3452 15.3965 12.6143C15.8253 12.8835 16.325 13.0177 16.8309 12.9998L19.2709 13.0398ZM10.4309 14.3098C9.8344 14.4025 9.29069 14.7054 8.89796 15.1639C8.50523 15.6224 8.28938 16.2061 8.28938 16.8098C8.28938 17.4135 8.50523 17.9973 8.89796 18.4557C9.29069 18.9142 9.8344 19.2171 10.4309 19.3098H16.7409C17.1017 19.3659 17.4703 19.3432 17.8215 19.2433C18.1726 19.1434 18.498 18.9688 18.7753 18.7312C19.0526 18.4937 19.2751 18.199 19.4278 17.8673C19.5804 17.5357 19.6594 17.1749 19.6594 16.8098C19.6594 16.4447 19.5804 16.084 19.4278 15.7523C19.2751 15.4206 19.0526 15.1259 18.7753 14.8884C18.498 14.6509 18.1726 14.4762 17.8215 14.3763C17.4703 14.2765 17.1017 14.2538 16.7409 14.3098H10.4309ZM26.8709 19.3098H29.3909C29.8984 19.3379 30.4027 19.2124 30.8378 18.9497C31.273 18.6871 31.619 18.2994 31.8307 17.8373C32.0424 17.3752 32.1099 16.86 32.0246 16.3589C31.9392 15.8578 31.7049 15.3941 31.3522 15.0281C30.9995 14.6621 30.5447 14.4108 30.0471 14.307C29.5495 14.2032 29.0322 14.2517 28.5626 14.4461C28.093 14.6406 27.6928 14.972 27.4142 15.3972C27.1357 15.8224 26.9916 16.3216 27.0009 16.8298L26.8709 19.3098ZM25.6009 10.4698C25.5605 9.82762 25.2769 9.22495 24.8078 8.78447C24.3387 8.34399 23.7194 8.0988 23.0759 8.0988C22.4324 8.0988 21.8131 8.34399 21.3441 8.78447C20.875 9.22495 20.5914 9.82762 20.5509 10.4698V16.7798C20.5292 17.1248 20.5784 17.4705 20.6955 17.7957C20.8125 18.1209 20.995 18.4187 21.2316 18.6707C21.4682 18.9226 21.7539 19.1234 22.0711 19.2607C22.3883 19.398 22.7303 19.4688 23.0759 19.4688C23.4216 19.4688 23.7635 19.398 24.0807 19.2607C24.3979 19.1234 24.6837 18.9226 24.9203 18.6707C25.1568 18.4187 25.3393 18.1209 25.4564 17.7957C25.5734 17.4705 25.6226 17.1248 25.6009 16.7798V10.4698ZM20.6409 26.9998V29.5198C20.6389 30.0206 20.7856 30.5108 21.0624 30.9281C21.3392 31.3455 21.7337 31.6713 22.1958 31.8644C22.6579 32.0574 23.1669 32.1089 23.6583 32.0124C24.1498 31.9159 24.6015 31.6758 24.9563 31.3223C25.3112 30.9689 25.5531 30.5181 25.6516 30.0271C25.75 29.536 25.7005 29.0268 25.5093 28.564C25.3181 28.1011 24.9938 27.7054 24.5775 27.4269C24.1613 27.1485 23.6717 26.9998 23.1709 26.9998H20.6409ZM29.4809 25.7298C30.1231 25.6894 30.7258 25.4058 31.1663 24.9367C31.6068 24.4676 31.8519 23.8483 31.8519 23.2048C31.8519 22.5613 31.6068 21.942 31.1663 21.473C30.7258 21.0039 30.1231 20.7203 29.4809 20.6798H23.1709C22.826 20.6581 22.4802 20.7073 22.155 20.8244C21.8298 20.9414 21.532 21.1239 21.2801 21.3605C21.0281 21.5971 20.8273 21.8828 20.69 22.2C20.5528 22.5172 20.4819 22.8592 20.4819 23.2048C20.4819 23.5505 20.5528 23.8924 20.69 24.2096C20.8273 24.5268 21.0281 24.8126 21.2801 25.0492C21.532 25.2858 21.8298 25.4682 22.155 25.5853C22.4802 25.7023 22.826 25.7515 23.1709 25.7298H29.4809Z"
                fill="#171F26" />
            </svg>
          </a>
        </div>
        <div class="wider-logo">
          <a href="https://www.youtube.com/graalvm" target="_blank" title="youtube social media link">
            <svg class="social-icon" width="35" height="24" viewBox="0 0 35 24" fill="none"
              xmlns="http://www.w3.org/2000/svg" alt="youtube social media icon">
              <path
                d="M18.1713 23.9692L11.0316 23.839C8.71989 23.7937 6.40246 23.8843 4.13616 23.4143C0.688425 22.7121 0.444187 19.2692 0.188588 16.3812C-0.163569 12.321 -0.0272501 8.18716 0.637305 4.16095C1.01218 1.90151 2.48897 0.553774 4.77232 0.406542C12.48 -0.125756 20.2388 -0.0634659 27.9295 0.185695C28.7417 0.208346 29.5597 0.332927 30.3605 0.474496C34.3138 1.16535 34.4103 5.06699 34.6659 8.35138C34.9215 11.6698 34.8136 15.0051 34.3251 18.3008C33.9332 21.0303 33.1835 23.318 30.0197 23.5389C26.0551 23.8277 22.1814 24.0599 18.2054 23.9862C18.2054 23.9692 18.1827 23.9692 18.1713 23.9692ZM13.9738 17.0607C16.9615 15.3505 19.8924 13.6687 22.863 11.9699C19.8696 10.2597 16.9445 8.57789 13.9738 6.87907V17.0607Z"
                fill="#171F26" />
            </svg>
          </a>
        </div>
      </div>
    </div>
  </div>
</section>

<footer class="footer footer__mobile">
  <div class="container-fluid container-fluid--custom-sm">
    <div class="row footer-content">
      <div class="footer__getstarted">
        <div class="rubber-footer">
          <p class="title-footer quickstart">Get started with GraalVM</p>
          <p class="footer-desc">Available for Linux, macOS, and Windows platforms</p>
          <a href="/latest/docs/getting-started/" class="btn btn-primary">Get Started</a>
        </div>
      </div>
      <div class="footer__columns">
        <div class="footer__columns-item">
          <h6 class="title-footer" onclick="fadeInAndOut(this)">Learn</h6>
          <div class="grow">
            <ul class="footer-list">
              <li class="footer-list__item"><a href="/guides/">Guides</a></li>
              <li class="footer-list__item"><a href="/latest/docs/">Documentation</a></li>
              <li class="footer-list__item">
                SDK Javadoc for JDK
                <a href="https://www.graalvm.org/23.1/javadoc/sdk/" class="javadoc" target="_blank">21</a> or
                <a href="https://www.graalvm.org/25.0/javadoc/sdk/" class="javadoc" target="_blank">25</a>
              </li>
              <li class="footer-list__item"><a href="https://medium.com/graalvm" target="_blank">Blog</a></li>
              <li class="footer-list__item"><a href="https://github.com/graalvm/workshops" target="_blank">Workshops</a></li>
              <li class="footer-list__item"><a href="https://github.com/graalvm/graalvm-demos" target="_blank">Demos</a></li>
            </ul>
          </div>
        </div>
        <div class="footer__columns-item">
          <h6 class="title-footer" onclick="fadeInAndOut(this)">Resources</h6>
          <div class="grow">
            <ul class="footer-list">
              <li class="footer-list__item"><a href="https://www.oracle.com/java/graalvm/" target="_blank">Oracle
                  GraalVM</a></li>
              <li class="footer-list__item"><a href="https://www.oracle.com/developer/" target="_blank">Oracle
                  Developers</a></li>
              <li class="footer-list__item"><a href="https://docs.oracle.com/en/graalvm/index.html"
                  target="_blank">Oracle Help Center</a></li>
              <li class="footer-list__item"><a href="https://labs.oracle.com/" target="_blank">Oracle Labs</a></li>
              <li class="footer-list__item"><a href="/graalvm-brand-guidelines/">Brand
                  Guidelines</a></li>
            </ul>
          </div>
        </div>
        <div class="footer__columns-item">
          <h6 class="title-footer" onclick="fadeInAndOut(this)">More</h6>
          <div class="grow">
            <ul class="footer-list">
              <li class="footer-list__item"><a href="/why-graalvm/">Why GraalVM?</a></li>
              <li class="footer-list__item"><a href="/release-calendar/">Release Calendar</a>
              </li>
              <li class="footer-list__item"><a href="/release-notes/">Release Notes</a></li>
              <li class="footer-list__item"><a href="/faq/">FAQs</a></li>
              <li class="footer-list__item"><a href="/support/">Support</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="col-12 col-sm-12 col-md-12 col-lg-12">
      <div class="row">
        <div class="col-sm-12">
          <p class="copyright">
            Copyright © 2018, 2026, Oracle and/or its affiliates. All rights reserved. Oracle and Java are
            registered trademarks. Other names may be trademarks of their respective owners.
          </p>
        </div>
      </div>
    </div>
  </div>
</footer>

<script>
  function fadeInAndOut(thz) {
    var elmt = thz.nextElementSibling;//Get the element that is below the button that
    //was just clicked
    if (elmt.clientHeight) {
      elmt.style.height = 0;
    } else {
      var wrapper = elmt.querySelector('ul');
      elmt.style.height = wrapper.clientHeight + "px";
    }
  }
</script>
    </div>
    <div class="overlay"></div>
    <script src='/resources/lib/slick-slider/slick.min.js'></script>
    <script src='/resources/js/main.js'></script>
    <script src='/resources/js/download.js'></script>
    <script src='/resources/js/sidebar.js'></script>
    <script src='/resources/js/favicon.js'></script>
  </body>
</html>
