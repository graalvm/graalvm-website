<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:image" content="/resources/img/graalvm.png" />
  <meta name="twitter:widgets:border-color" content="#55acee">

  <title>
    
      GraalVM
    
  </title>
  <meta name="description" content="GraalVM is a high-performance JDK distribution designed to accelerate the execution of applications written in Java and other JVM languages along with suppor..."/>
  <link rel="apple-touch-icon" sizes="180x180" href="/resources/img/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/resources/img/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/resources/img/favicon/favicon-16x16.png">
  <link rel="manifest" href="/resources/img/favicon/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/assets/main.css">
  <!-- <link rel="stylesheet" href="https://elocation.oracle.com/mapviewer/jslib/v2.3/css/oraclemapsv2.css> -->

  <link rel="canonical" href="https://www.graalvm.org/docs/search/">
  <!-- <script src="/resources/lib/jquery/jquery-3.2.1.min.js"></script> -->
  <script src="https://maps.oracle.com/mapviewer/jslib/v2.3/oraclemapsv2.js"></script>
  <link rel="stylesheet" href="https://elocation.oracle.com/mapviewer/jslib/v2.3/css/oraclemapsv2.css">
  <script src="/resources/lib/bootstrap/js/bootstrap.min.js"></script>
  <script src="/resources/lib/sticky-sidebar/resizeSensor.js"></script>
  <script src="/resources/lib/sticky-sidebar/sticky-sidebar.min.js"></script>
  <script src="/resources/lib/highlight/highlight.pack.js"></script>
  <script src="/resources/lib/purl/purl.js"></script>
  <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>


  <body class="preload">
    <!-- Start SiteCatalyst code -->
   <script language="JavaScript" src="https://www.oracle.com/us/assets/metrics/ora_otn.js"></script>
   <!-- End SiteCatalyst code -->
    <svg aria-hidden="true" style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <defs>
    <symbol id="icon-social-network" viewBox="0 0 32 32">
      <title>social-network</title>
      <path d="M28.8 0h-25.6c-1.76 0-3.2 1.44-3.2 3.2v25.6c0 1.76 1.44 3.2 3.2 3.2h25.6c1.76 0 3.2-1.44 3.2-3.2v-25.6c0-1.76-1.44-3.2-3.2-3.2zM25.12 11.68c-0.16 7.36-4.8 12.48-11.84 12.8-2.88 0.16-4.96-0.8-6.88-1.92 2.080 0.32 4.8-0.48 6.24-1.76-2.080-0.16-3.36-1.28-4-3.040 0.64 0.16 1.28 0 1.76 0-1.92-0.64-3.2-1.76-3.36-4.32 0.48 0.32 1.12 0.48 1.76 0.48-1.44-0.8-2.4-3.84-1.28-5.76 2.080 2.24 4.64 4.16 8.8 4.48-1.12-4.48 4.96-6.88 7.36-3.84 1.12-0.16 1.92-0.64 2.72-0.96-0.32 1.12-0.96 1.76-1.76 2.4 0.8-0.16 1.6-0.32 2.24-0.64-0.16 0.8-0.96 1.44-1.76 2.080z"></path>
    </symbol>
    <symbol id="icon-algorithm" viewBox="0 0 32 32">
      <title>algorithm</title>
      <path d="M30.109 7.692v-3.943h-3.758v1.875h1.883v2.068c-1.091 0.387-1.875 1.429-1.875 2.651s0.784 2.264 1.875 2.651v2.068h-1.891v1.875h3.766v-3.943c1.091-0.387 1.875-1.429 1.875-2.651s-0.784-2.264-1.875-2.651z"></path>
      <path d="M5.656 16.938v-1.875h-3.766v3.943c-1.091 0.387-1.875 1.429-1.875 2.651s0.784 2.264 1.875 2.651v3.943h3.758v-1.875h-1.883v-2.068c1.091-0.387 1.875-1.429 1.875-2.651s-0.784-2.264-1.875-2.651v-2.068h1.891z"></path>
      <path d="M7.516 0v9.375h17v-9.375h-17zM13.203 5.625h-1.875v-1.875h1.875v1.875zM16.953 5.625h-1.875v-1.875h1.875v1.875zM20.703 5.625h-1.875v-1.875h1.875v1.875z"></path>
      <path d="M7.516 11.313v9.375h17v-9.375h-17zM13.203 16.938h-1.875v-1.875h1.875v1.875zM16.953 16.938h-1.875v-1.875h1.875v1.875zM20.703 16.938h-1.875v-1.875h1.875v1.875z"></path>
      <path d="M7.516 22.625v9.375h17v-9.375h-17zM13.203 28.25h-1.875v-1.875h1.875v1.875zM16.953 28.25h-1.875v-1.875h1.875v1.875zM20.703 28.25h-1.875v-1.875h1.875v1.875z"></path>
    </symbol>
    <symbol id="icon-blogger" viewBox="0 0 32 32">
      <title>blogger</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M31.916 13.508c0-0.788-0.639-1.427-1.427-1.427v-0l-1.435 0c-0.917 0.001-1.86-0.031-2.261-0.394-0.567-0.524-0.652-1.465-0.823-2.737-0.321-2.47-0.524-2.598-0.909-3.432-1.401-2.972-5.196-5.207-7.805-5.517h-7.067c-5.56 0-10.104 4.555-10.104 10.114v11.793c0 5.549 4.544 10.093 10.104 10.093h11.611c5.56 0 10.071-4.544 10.104-10.093 0 0 0.013-8.378 0.013-8.399zM10.316 8.264h5.602c1.069 0 1.935 0.866 1.935 1.925s-0.866 1.935-1.935 1.935h-5.602c-1.069 0-1.935-0.877-1.935-1.935s0.866-1.925 1.935-1.925zM21.703 23.682h-11.386c-1.069 0-1.935-0.877-1.935-1.924 0-1.059 0.866-1.925 1.935-1.925h11.386c1.059 0 1.925 0.866 1.925 1.925 0 1.048-0.866 1.924-1.925 1.924z"></path>
    </symbol>
    <symbol id="icon-cloud-download" viewBox="0 0 32 32">
      <title>cloud-download</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M25.867 13.333c-0.933-4.533-4.933-8-9.867-8-3.867 0-7.2 2.133-8.8 5.333-4.133 0.533-7.2 3.867-7.2 8 0 4.4 3.6 8 8 8h17.333c3.733 0 6.667-2.933 6.667-6.667 0-3.467-2.8-6.4-6.133-6.667zM22.667 17.333l-6.667 6.667-6.667-6.667h4v-5.333h5.333v5.333h4z"></path>
    </symbol>
    <symbol id="icon-computing" viewBox="0 0 32 32">
      <title>computing</title>
      <path d="M25.867 19.577c1.773-0.141 3.106-0.678 4.051-1.634 1.668-1.687 1.975-4.439 1.929-8.332l-0.013-1.097h-12.044c-0.191-1.121-0.796-1.797-1.259-2.314-0.47-0.524-0.753-0.84-0.753-1.572s0.283-1.048 0.753-1.572l-1.654-1.482c-0.557 0.622-1.32 1.473-1.32 3.054s0.763 2.433 1.32 3.054c0.275 0.307 0.485 0.543 0.613 0.832h-2.586c-0.191-1.121-0.796-1.797-1.259-2.314-0.47-0.524-0.753-0.84-0.753-1.572s0.283-1.048 0.753-1.572c0.557-0.622 1.32-1.473 1.32-3.054h-2.221c0 0.732-0.283 1.048-0.753 1.572-0.557 0.622-1.32 1.473-1.32 3.054s0.763 2.433 1.32 3.054c0.275 0.307 0.485 0.543 0.613 0.832h-12.587v4.725c0 2.938 0.913 5.746 2.641 8.122l3.432 4.719h-6.443v2.961c0 1.633 1.328 2.961 2.961 2.961h22.206c1.633 0 2.961-1.328 2.961-2.961v-2.961h-6.443l3.432-4.719c0.415-0.57 0.782-1.166 1.102-1.782zM27.406 13.237v-2.504h2.223c-0.025 2.671-0.3 4.646-1.29 5.648-0.371 0.375-0.865 0.641-1.506 0.806 0.378-1.27 0.573-2.596 0.573-3.95zM25.556 28.299v0.74c0 0.408-0.332 0.74-0.74 0.74h-22.206c-0.408 0-0.74-0.332-0.74-0.74v-0.74h23.687zM18.587 26.078h-9.75l-4.382-6.025c-1.45-1.994-2.216-4.351-2.216-6.816v-2.504h22.947v2.504c0 2.465-0.766 4.822-2.216 6.816l-4.382 6.025z"></path>
      <path d="M17.824 14.908l-1.57 1.57 1.88 1.88-1.88 1.88 1.57 1.57 3.45-3.45z"></path>
      <path d="M11.31 16.478l-1.57-1.57-3.45 3.45 3.45 3.45 1.57-1.57-1.88-1.88z"></path>
      <path d="M13.707 13.324l-2.119 10.067h2.269l2.119-10.067z"></path>
    </symbol>
    <symbol id="icon-conversation" viewBox="0 0 32 32">
      <title>conversation</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M8.467 5.924h-1.891c1.349-0.292 2.36-1.491 2.36-2.928 0-1.655-1.341-2.996-2.996-2.996s-2.996 1.341-2.996 2.996c0 1.436 1.011 2.636 2.36 2.928h-1.891c-1.884 0-3.412 1.528-3.412 3.412v10.365h2.943v12.3h5.992v-12.3h2.943v-10.365c0-1.884-1.528-3.412-3.412-3.412z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M28.588 5.923h-1.891c1.349-0.292 2.36-1.491 2.36-2.928 0-1.655-1.341-2.996-2.996-2.996s-2.996 1.341-2.996 2.996c0 1.436 1.011 2.636 2.36 2.928h-1.891c-1.884 0-3.412 1.528-3.412 3.412v10.365h2.943v12.3h5.992v-12.3h2.943v-10.365c0-1.884-1.528-3.412-3.412-3.412z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M18.159 0.869l-1.55 1.056 1.309 1.921-1.309 1.921 1.55 1.056 2.028-2.977z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M15.391 1.924l-1.55-1.056-2.028 2.977 2.028 2.977 1.55-1.056-1.309-1.921z"></path>
    </symbol>
    <symbol id="icon-document" viewBox="0 0 32 32">
      <title>document</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M16 0c-8.836 0-16 7.164-16 16s7.163 16 16 16 16-7.164 16-16c-0-8.837-7.164-16-16-16zM23.169 23.169c0 1.074-0.87 1.944-1.944 1.944h-10.45c-1.074 0-1.944-0.87-1.944-1.944v-14.338c0-1.074 0.87-1.944 1.944-1.944h8.202v3.888h4.192v12.394zM19.807 9.945v-3.058l3.362 3.058h-3.362z"></path>
    </symbol>
    <symbol id="icon-github-sign" viewBox="0 0 32 32">
      <title>github-sign</title>
      <path d="M11.542 25.729c-0.223 0.041-0.32 0.146-0.292 0.312s0.153 0.222 0.375 0.167c0.223-0.055 0.32-0.153 0.292-0.292-0.028-0.153-0.153-0.215-0.375-0.187z"></path>
      <path d="M10.354 25.896c-0.222 0-0.333 0.076-0.333 0.229 0 0.181 0.118 0.257 0.354 0.229 0.222 0 0.334-0.076 0.334-0.229 0-0.18-0.118-0.257-0.354-0.229z"></path>
      <path d="M8.729 25.833c-0.055 0.153 0.035 0.257 0.271 0.313 0.208 0.083 0.34 0.041 0.396-0.125 0.042-0.153-0.049-0.263-0.271-0.333-0.208-0.055-0.34-0.007-0.396 0.146z"></path>
      <path d="M30.239 1.76c-1.174-1.173-2.587-1.76-4.24-1.76h-20c-1.653 0-3.066 0.587-4.24 1.76s-1.76 2.587-1.76 4.24v20c0 1.653 0.587 3.066 1.76 4.239s2.587 1.76 4.24 1.76h4.667c0.305 0 0.535-0.011 0.687-0.031s0.305-0.111 0.458-0.271c0.153-0.16 0.229-0.392 0.229-0.698 0-0.041-0.004-0.514-0.011-1.417s-0.011-1.618-0.011-2.146l-0.479 0.083c-0.306 0.055-0.691 0.080-1.156 0.073s-0.948-0.055-1.448-0.146c-0.5-0.090-0.965-0.299-1.396-0.625s-0.736-0.754-0.917-1.281l-0.208-0.48c-0.139-0.319-0.357-0.673-0.656-1.062s-0.601-0.653-0.906-0.792l-0.146-0.104c-0.097-0.069-0.187-0.153-0.271-0.25s-0.146-0.195-0.187-0.292c-0.042-0.097-0.007-0.177 0.104-0.24s0.312-0.093 0.604-0.093l0.417 0.062c0.278 0.055 0.621 0.222 1.031 0.5s0.746 0.639 1.010 1.083c0.32 0.57 0.705 1.003 1.156 1.302s0.906 0.448 1.364 0.448 0.854-0.035 1.188-0.104c0.333-0.070 0.646-0.174 0.937-0.313 0.125-0.93 0.465-1.646 1.021-2.146-0.792-0.083-1.503-0.208-2.135-0.375s-1.285-0.437-1.958-0.813c-0.674-0.375-1.233-0.84-1.677-1.396s-0.809-1.285-1.094-2.188c-0.285-0.903-0.427-1.945-0.427-3.125 0-1.68 0.549-3.111 1.646-4.292-0.514-1.264-0.465-2.68 0.146-4.25 0.403-0.125 1-0.031 1.792 0.281s1.371 0.58 1.74 0.802 0.663 0.41 0.886 0.563c1.292-0.361 2.625-0.542 4-0.542s2.708 0.181 4 0.542l0.792-0.5c0.542-0.333 1.181-0.639 1.917-0.917s1.299-0.354 1.688-0.229c0.625 1.57 0.681 2.986 0.166 4.25 1.097 1.181 1.646 2.611 1.646 4.292 0 1.181-0.142 2.226-0.427 3.135s-0.652 1.639-1.104 2.188c-0.451 0.549-1.014 1.010-1.687 1.385s-1.326 0.646-1.959 0.812c-0.632 0.167-1.344 0.292-2.135 0.376 0.722 0.625 1.083 1.611 1.083 2.958v4.979c0 0.236 0.034 0.427 0.104 0.573s0.181 0.246 0.334 0.302c0.153 0.055 0.288 0.090 0.407 0.104s0.288 0.021 0.51 0.021h4.667c1.653 0 3.066-0.587 4.239-1.76s1.76-2.587 1.76-4.24v-19.999c-0-1.653-0.587-3.066-1.76-4.24z"></path>
      <path d="M6.333 23.292c-0.097 0.069-0.083 0.18 0.042 0.333 0.139 0.139 0.25 0.16 0.333 0.062 0.097-0.069 0.083-0.18-0.042-0.333-0.139-0.125-0.25-0.146-0.333-0.062z"></path>
      <path d="M5.646 22.771c-0.042 0.097 0.007 0.181 0.146 0.25 0.111 0.070 0.202 0.056 0.271-0.041 0.042-0.097-0.007-0.181-0.146-0.25-0.139-0.042-0.229-0.028-0.271 0.042z"></path>
      <path d="M6.979 24.104c-0.125 0.069-0.125 0.195 0 0.375s0.243 0.229 0.354 0.146c0.125-0.097 0.125-0.229 0-0.396-0.111-0.18-0.229-0.222-0.354-0.125z"></path>
      <path d="M7.708 25.041c-0.125 0.111-0.097 0.243 0.083 0.396 0.166 0.166 0.305 0.187 0.416 0.062 0.111-0.111 0.083-0.243-0.083-0.396-0.166-0.166-0.305-0.187-0.417-0.063z"></path>
    </symbol>
    <symbol id="icon-home-icon-silhouette" viewBox="0 0 32 32">
      <title>home-icon-silhouette</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M31.463 14.567l-4.85-4.85v-5.602c0-1.013-0.821-1.834-1.835-1.834-1.012 0-1.833 0.821-1.833 1.834v1.934l-3.611-3.611c-1.785-1.784-4.889-1.781-6.671 0.003l-12.126 12.126c-0.716 0.717-0.716 1.878 0 2.594s1.879 0.717 2.595 0l12.125-12.126c0.395-0.393 1.091-0.393 1.484-0.001l12.127 12.127c0.36 0.359 0.828 0.537 1.297 0.537s0.939-0.179 1.298-0.537c0.716-0.716 0.716-1.877-0-2.594z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M16.637 8.516c-0.352-0.352-0.923-0.352-1.274 0l-10.666 10.663c-0.168 0.168-0.264 0.398-0.264 0.638v7.777c0 1.825 1.48 3.305 3.305 3.305h5.281v-8.178h5.962v8.178h5.281c1.825 0 3.305-1.48 3.305-3.305v-7.777c0-0.24-0.095-0.47-0.264-0.638l-10.665-10.663z"></path>
    </symbol>
    <symbol id="icon-icon-github" viewBox="0 0 32 32">
      <title>icon-github</title>
      <path d="M15.998 0.862c-8.57 0-15.52 6.948-15.52 15.522 0 6.856 4.446 12.674 10.614 14.726 0.776 0.142 1.060-0.336 1.060-0.748 0-0.368-0.014-1.344-0.020-2.64-4.318 0.938-5.228-2.080-5.228-2.080-0.706-1.792-1.724-2.27-1.724-2.27-1.41-0.962 0.106-0.944 0.106-0.944 1.558 0.11 2.378 1.6 2.378 1.6 1.384 2.372 3.632 1.686 4.516 1.29 0.142-1.004 0.542-1.686 0.986-2.074-3.446-0.394-7.068-1.724-7.068-7.672 0-1.694 0.604-3.080 1.598-4.164-0.16-0.394-0.694-1.972 0.152-4.108 0 0 1.304-0.418 4.268 1.592 1.238-0.346 2.564-0.518 3.884-0.524 1.318 0.006 2.646 0.178 3.886 0.522 2.964-2.008 4.264-1.592 4.264-1.592 0.846 2.136 0.314 3.714 0.154 4.108 0.994 1.084 1.596 2.47 1.596 4.164 0 5.962-3.628 7.274-7.086 7.658 0.558 0.48 1.054 1.426 1.054 2.874 0 2.074-0.020 3.748-0.020 4.258 0 0.416 0.28 0.898 1.068 0.746 6.162-2.056 10.604-7.87 10.604-14.724 0-8.57-6.95-15.52-15.522-15.52z"></path>
    </symbol>
    <symbol id="icon-icon-twitter" viewBox="0 0 32 32">
      <title>icon-twitter</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M31.938 6.116c-1.172 0.52-2.434 0.872-3.756 1.030 1.35-0.81 2.388-2.090 2.876-3.618-1.264 0.75-2.664 1.294-4.152 1.586-1.192-1.272-2.892-2.066-4.774-2.066-3.612 0-6.54 2.928-6.54 6.54 0 0.512 0.058 1.012 0.17 1.49-5.436-0.27-10.256-2.874-13.482-6.83-0.562 0.966-0.884 2.088-0.884 3.286 0 2.268 1.154 4.27 2.91 5.444-1.074-0.034-2.082-0.328-2.964-0.818 0 0.028 0 0.054 0 0.082 0 3.168 2.254 5.812 5.246 6.412-0.548 0.15-1.126 0.23-1.722 0.23-0.422 0-0.832-0.042-1.23-0.118 0.832 2.598 3.248 4.49 6.11 4.542-2.238 1.754-5.058 2.8-8.122 2.8-0.528 0-1.048-0.030-1.56-0.092 2.894 1.856 6.332 2.938 10.026 2.938 12.030 0 18.608-9.966 18.608-18.608 0-0.284-0.006-0.566-0.018-0.846 1.272-0.92 2.382-2.072 3.258-3.384z"></path>
    </symbol>
    <symbol id="icon-logo" viewBox="0 0 92 32">
      <title>logo</title>
      <path fill="#00758f" style="fill: var(--color2, #00758f)" d="M11.654 23.706c-3.31 0-5.268-2.365-5.268-7.44 0-5.206 2.537-7.895 5.847-7.895 1.634 0.026 3.080 0.81 4.004 2.015l0.009 0.012-1.034 1.014c-0.768-0.669-1.764-1.094-2.858-1.144l-0.010-0c-2.117 0-3.489 1.875-3.489 5.578 0 4.282 1.262 5.937 3.199 5.937 0.026 0.001 0.057 0.001 0.088 0.001 0.717 0 1.378-0.242 1.905-0.648l-0.007 0.005v-4.213h-1.931v-1.765h4.303v6.792c-1.229 1.088-2.854 1.752-4.635 1.752-0.043 0-0.086-0-0.129-0.001l0.006 0zM24.59 14.57c-0.275-0.086-0.593-0.143-0.922-0.158l-0.009-0c-0.641 0-1.234 0.49-2.317 1.834v7.24h-2.268v-10.991h1.875l0.193 1.875c1.193-1.544 1.944-2.069 2.758-2.069 0.356 0.005 0.691 0.096 0.984 0.254l-0.011-0.006zM32.595 23.485l-0.179-1.193c-0.882 0.841-2.075 1.363-3.389 1.379l-0.003 0c-2.165 0-3.31-1.103-3.31-3.048 0-2.248 1.744-3.751 5.599-3.751h0.793v-0.958c0-1.324-0.689-1.965-2.275-1.965-1.166 0.032-2.268 0.265-3.286 0.664l0.066-0.023-0.331-1.379c1.215-0.561 2.636-0.893 4.133-0.903l0.004-0c2.758 0 3.93 1.324 3.93 3.33v7.86zM32.105 18.362h-0.945c-2.503 0-3.192 0.834-3.192 1.986-0.005 0.048-0.008 0.103-0.008 0.159 0 0.857 0.695 1.551 1.551 1.551 0.054 0 0.107-0.003 0.16-0.008l-0.007 0.001c0.955-0.079 1.802-0.485 2.442-1.104l-0.001 0.001zM43.31 23.485l-0.172-1.193c-0.885 0.84-2.080 1.362-3.396 1.379l-0.003 0c-2.165 0-3.31-1.103-3.31-3.048 0-2.248 1.744-3.751 5.606-3.751h0.793v-0.958c0-1.324-0.69-1.965-2.275-1.965-1.166 0.032-2.268 0.265-3.286 0.664l0.066-0.023-0.331-1.379c1.215-0.56 2.636-0.892 4.133-0.903l0.004-0c2.758 0 3.923 1.324 3.923 3.33v7.86zM42.827 18.362h-0.945c-2.537 0-3.199 0.841-3.199 1.986-0.005 0.045-0.007 0.098-0.007 0.152 0 0.861 0.698 1.558 1.558 1.558 0.051 0 0.102-0.002 0.152-0.007l-0.006 0c0.958-0.076 1.808-0.482 2.449-1.104l-0.001 0.001zM49.722 23.637c-1.379 0-2.006-0.4-2.006-2.186v-13.611h2.317v12.735c0 1.282 0.159 1.482 0.793 1.482 0.2 0 0.441 0 0.6 0l0.11 1.379c-0.461 0.13-0.99 0.205-1.536 0.205-0.083 0-0.165-0.002-0.247-0.005l0.012 0z"></path>
      <path fill="#f29111" style="fill: var(--color3, #f29111)" d="M59.472 23.485h-2.827c-1.514-4.012-2.988-8.994-4.133-14.101l-0.149-0.792h2.606c0.772 3.972 2.027 8.184 3.289 12.411 1.067-3.33 2.092-7.508 2.857-11.776l0.094-0.635h2.365c-1.116 5.758-2.534 10.753-4.322 15.568l0.219-0.675zM77.675 23.485c-0.090-4.33-0.4-8.805-0.689-11.873v0l-3.751 11.873h-1.965l-3.792-11.873c-0.283 3.289-0.483 7.543-0.552 11.873h-2.268c0.131-4.827 0.483-10.039 1.076-14.893h3.137l3.572 10.942 3.579-10.942h2.972c0.572 4.827 1.014 10.060 1.145 14.893zM81.867 21.968h-0.538v-0.303h1.469v0.29h-0.538v1.517h-0.393zM83.184 21.665h0.634l0.386 1.324 0.414-1.324h0.621v1.82h-0.393v-1.531l-0.49 1.558h-0.324l-0.483-1.558v1.558h-0.365z"></path>
    </symbol>
    <symbol id="icon-screwdriver-and-wrench-crossed" viewBox="0 0 43 32">
      <title>screwdriver-and-wrench-crossed</title>
      <path d="M6.204 26.885c-1.171 1.171-1.171 3.067 0 4.238 0.585 0.585 1.353 0.877 2.12 0.877s1.535-0.292 2.12-0.877l9.841-9.843-4.24-4.236-9.841 9.841z"></path>
      <path d="M30.799 8.646l4.286-2.216 2.244-4.338-2.092-2.092-4.336 2.246-2.22 4.282-5.213 5.219 2.114 2.118z"></path>
      <path d="M31.738 20.021l-0.404-0.040c-0.731 0-1.425 0.15-2.072 0.39l-12.303-12.304c0.24-0.647 0.39-1.341 0.39-2.072l-0.040-0.404c-0.212-3.119-2.781-5.591-5.954-5.591-0.923 0-1.788 0.226-2.57 0.599l3.982 3.982c0.21 0.21 0.354 0.458 0.45 0.719 0.262 0.707 0.12 1.535-0.45 2.106-0.39 0.39-0.901 0.585-1.413 0.585-0.236 0-0.47-0.052-0.693-0.136-0.262-0.1-0.51-0.24-0.719-0.452l-3.982-3.98c-0.374 0.781-0.599 1.646-0.599 2.57 0 3.173 2.472 5.743 5.591 5.954l0.404 0.040c0.731 0 1.425-0.15 2.072-0.388l12.3 12.302c-0.236 0.647-0.386 1.341-0.386 2.072l0.042 0.404c0.208 3.121 2.779 5.591 5.952 5.591 0.923 0 1.79-0.222 2.57-0.599l-3.982-3.982c-0.208-0.208-0.354-0.458-0.454-0.717-0.262-0.707-0.12-1.537 0.454-2.108 0.386-0.39 0.901-0.585 1.413-0.585 0.236 0 0.468 0.050 0.695 0.136 0.262 0.098 0.511 0.238 0.717 0.45l3.982 3.982c0.376-0.783 0.599-1.646 0.599-2.57-0.002-3.173-2.474-5.743-5.593-5.954z"></path>
    </symbol>
    <symbol id="icon-speed-meter" viewBox="0 0 43 32">
      <title>speed-meter</title>
      <path d="M12.212 11.373c0.009-0.137-0.037-0.272-0.128-0.375l-4.101-4.666c-0.091-0.103-0.218-0.166-0.356-0.175s-0.272 0.037-0.375 0.128c-1.884 1.657-3.449 3.61-4.649 5.806-0.066 0.121-0.081 0.262-0.043 0.394s0.128 0.243 0.248 0.309l5.451 2.98c0.079 0.043 0.164 0.064 0.248 0.064 0.183 0 0.361-0.097 0.455-0.269 0.794-1.452 1.828-2.743 3.075-3.839 0.103-0.090 0.166-0.218 0.175-0.355z"></path>
      <path d="M14.042 9.645c0.093 0.175 0.272 0.275 0.458 0.275 0.082 0 0.165-0.019 0.242-0.060 1.461-0.775 3.033-1.28 4.672-1.503 0.283-0.038 0.482-0.299 0.443-0.583l-0.835-6.156c-0.038-0.283-0.3-0.482-0.583-0.443-2.489 0.338-4.875 1.105-7.093 2.282-0.252 0.134-0.349 0.447-0.215 0.7l2.911 5.488z"></path>
      <path d="M7.373 17.976l-5.995-1.627c-0.132-0.036-0.274-0.018-0.393 0.051s-0.206 0.181-0.242 0.314c-0.493 1.817-0.743 3.7-0.743 5.596 0 0.325 0.008 0.65 0.024 0.996 0.013 0.277 0.242 0.494 0.517 0.494 0.008 0 0.016-0 0.024-0.001l6.205-0.287c0.137-0.006 0.266-0.067 0.359-0.168s0.141-0.236 0.135-0.373c-0.011-0.233-0.016-0.449-0.016-0.661 0-1.256 0.165-2.5 0.49-3.699 0.075-0.276-0.088-0.56-0.364-0.635z"></path>
      <path d="M30.579 3.088c-2.259-1.089-4.673-1.764-7.174-2.006-0.137-0.014-0.273 0.028-0.379 0.116s-0.173 0.213-0.186 0.35l-0.599 6.183c-0.028 0.285 0.181 0.538 0.465 0.565 1.649 0.16 3.238 0.604 4.726 1.321 0.071 0.034 0.148 0.051 0.225 0.051 0.058 0 0.115-0.010 0.171-0.029 0.13-0.045 0.236-0.14 0.296-0.264l2.697-5.596c0.124-0.257 0.016-0.567-0.241-0.691z"></path>
      <path d="M39.704 11.772c0.033-0.133 0.013-0.274-0.058-0.392-1.285-2.149-2.923-4.041-4.868-5.624-0.107-0.087-0.243-0.127-0.38-0.113s-0.262 0.082-0.349 0.188l-3.92 4.819c-0.087 0.107-0.127 0.243-0.113 0.38s0.082 0.262 0.188 0.349c1.287 1.047 2.371 2.298 3.22 3.72 0.097 0.162 0.269 0.252 0.445 0.252 0.090 0 0.182-0.024 0.265-0.073l5.332-3.187c0.118-0.070 0.203-0.185 0.236-0.318z"></path>
      <path d="M41.684 15.926c-0.086-0.273-0.376-0.425-0.649-0.339l-5.928 1.857c-0.273 0.085-0.425 0.376-0.339 0.649 0.425 1.358 0.641 2.777 0.641 4.216 0 0.212-0.005 0.428-0.016 0.661-0.006 0.137 0.042 0.271 0.135 0.373s0.221 0.162 0.359 0.168l6.205 0.287c0.008 0 0.016 0.001 0.024 0.001 0.275 0 0.504-0.216 0.517-0.494 0.016-0.345 0.024-0.671 0.024-0.996-0-2.176-0.327-4.323-0.973-6.383z"></path>
      <path d="M21.31 21.21c-0.089 0-0.178 0.003-0.267 0.008l-8.409-4.962c-0.206-0.122-0.467-0.091-0.64 0.074s-0.214 0.425-0.101 0.636l4.587 8.598c-0.017 0.166-0.026 0.333-0.026 0.501 0 1.297 0.505 2.516 1.422 3.433s2.136 1.422 3.433 1.422 2.516-0.505 3.433-1.422c0.917-0.917 1.422-2.136 1.422-3.433s-0.505-2.516-1.422-3.433c-0.917-0.917-2.136-1.422-3.433-1.422z"></path>
    </symbol>
    <symbol id="icon-linux" viewBox="0 0 32 32">
      <title>linux</title>
      <path d="M28.817 25.693c-0.938-0.384-1.34-0.894-1.301-1.655 0.040-0.888-0.464-1.539-0.703-1.796 0.145-0.552 0.567-2.463 0-4.122-0.609-1.776-2.468-4.489-4.386-7.156-0.785-1.095-0.822-2.286-0.865-3.664-0.041-1.315-0.087-2.805-0.821-4.462-0.797-1.804-2.397-2.838-4.389-2.838-1.185 0-2.402 0.37-3.338 1.016-1.917 1.323-1.663 4.207-1.496 6.116 0.023 0.261 0.045 0.508 0.057 0.719 0.112 1.869 0.010 2.854-0.123 3.154-0.086 0.196-0.509 0.753-0.957 1.342-0.463 0.61-0.988 1.301-1.418 1.945-0.513 0.775-0.928 1.96-1.329 3.105-0.293 0.838-0.57 1.63-0.84 2.103-0.511 0.91-0.384 1.759-0.278 2.151-0.193 0.134-0.473 0.399-0.709 0.898-0.285 0.609-0.864 0.936-2.067 1.167-0.553 0.113-0.934 0.346-1.134 0.691-0.29 0.503-0.132 1.134 0.012 1.566 0.213 0.635 0.080 1.036-0.161 1.765-0.056 0.168-0.119 0.359-0.183 0.569-0.101 0.332-0.064 0.633 0.108 0.896 0.454 0.695 1.78 0.94 3.145 1.101 0.815 0.097 1.707 0.423 2.57 0.738 0.845 0.309 1.719 0.628 2.514 0.725 0.121 0.015 0.24 0.023 0.356 0.023 1.2 0 1.742-0.796 1.914-1.123 0.431-0.088 1.917-0.37 3.449-0.407 1.529-0.044 3.009 0.258 3.428 0.352 0.132 0.252 0.479 0.828 1.033 1.125 0.304 0.166 0.728 0.262 1.162 0.262 0 0 0 0 0 0 0.463 0 1.345-0.11 2.042-0.843 0.696-0.737 2.434-1.679 3.704-2.366 0.283-0.153 0.548-0.297 0.781-0.427 0.713-0.395 1.102-0.96 1.068-1.55-0.029-0.49-0.353-0.919-0.846-1.121zM13.030 25.551c-0.089-0.625-0.893-1.245-1.825-1.964-0.762-0.587-1.625-1.253-1.863-1.816-0.492-1.163-0.104-3.207 0.572-4.26 0.334-0.527 0.607-1.326 0.87-2.1 0.285-0.835 0.579-1.698 0.909-2.076 0.522-0.59 1.004-1.738 1.089-2.642 0.488 0.466 1.246 1.058 1.946 1.058 0.108 0 0.212-0.014 0.312-0.042 0.479-0.138 1.183-0.545 1.864-0.939 0.587-0.339 1.311-0.758 1.584-0.796 0.467 0.671 3.182 6.679 3.459 8.608 0.22 1.527-0.012 2.789-0.129 3.283-0.094-0.013-0.206-0.023-0.323-0.023-0.756 0-0.956 0.413-1.008 0.659-0.134 0.64-0.148 2.688-0.15 3.148-0.273 0.347-1.656 1.983-3.641 2.277-0.809 0.117-1.564 0.177-2.244 0.177-0.582 0-0.953-0.045-1.107-0.068l-0.998-1.141c0.393-0.194 0.787-0.604 0.683-1.343zM14.296 6.73c-0.031 0.013-0.062 0.028-0.092 0.043-0.003-0.068-0.010-0.136-0.021-0.205-0.109-0.627-0.525-1.082-0.988-1.082-0.034 0-0.069 0.003-0.107 0.008-0.276 0.046-0.492 0.253-0.611 0.547 0.104-0.645 0.469-1.122 0.902-1.122 0.509 0 0.939 0.686 0.939 1.497 0 0.102-0.007 0.204-0.023 0.313zM18.25 7.214c0.047-0.148 0.072-0.309 0.072-0.476 0-0.736-0.467-1.312-1.063-1.312-0.582 0-1.056 0.589-1.056 1.312 0 0.049 0.002 0.099 0.007 0.148-0.031-0.012-0.061-0.023-0.090-0.035-0.067-0.203-0.101-0.415-0.101-0.631 0-0.88 0.562-1.596 1.254-1.596s1.254 0.716 1.254 1.596c0 0.366-0.101 0.715-0.276 0.993zM17.74 8.927c-0.010 0.044-0.031 0.064-0.266 0.186-0.118 0.062-0.266 0.138-0.45 0.251l-0.123 0.075c-0.495 0.3-1.654 1.003-1.969 1.044-0.214 0.029-0.346-0.054-0.643-0.256-0.067-0.046-0.138-0.094-0.214-0.143-0.536-0.352-0.88-0.739-0.919-0.89 0.175-0.135 0.608-0.473 0.829-0.673 0.45-0.418 0.903-0.7 1.127-0.7 0.012 0 0.023 0.001 0.034 0.003 0.263 0.046 0.913 0.306 1.387 0.495 0.219 0.088 0.409 0.163 0.542 0.211 0.42 0.144 0.639 0.329 0.665 0.398zM21.511 28.48c0.237-1.068 0.51-2.521 0.465-3.378-0.010-0.195-0.027-0.406-0.044-0.611-0.031-0.383-0.077-0.952-0.030-1.121 0.009-0.004 0.020-0.008 0.032-0.011 0.002 0.49 0.108 1.467 0.89 1.807 0.233 0.102 0.499 0.153 0.791 0.153 0.783 0 1.651-0.384 2.007-0.74 0.209-0.209 0.386-0.466 0.509-0.669 0.027 0.079 0.044 0.182 0.035 0.315-0.046 0.722 0.305 1.681 0.973 2.034l0.097 0.051c0.238 0.125 0.87 0.457 0.88 0.614-0 0-0.005 0.019-0.041 0.051-0.158 0.145-0.716 0.429-1.254 0.704-0.956 0.488-2.039 1.041-2.526 1.553-0.685 0.721-1.46 1.205-1.928 1.205-0.056 0-0.108-0.007-0.153-0.022-0.508-0.158-0.927-0.892-0.702-1.937zM4.188 25.755c-0.052-0.243-0.093-0.434-0.049-0.62 0.032-0.137 0.71-0.285 1-0.348 0.407-0.088 0.829-0.18 1.104-0.347 0.373-0.226 0.574-0.642 0.752-1.009 0.129-0.266 0.262-0.54 0.42-0.63 0.009-0.005 0.023-0.011 0.049-0.011 0.297 0 0.919 0.624 1.278 1.182 0.091 0.141 0.259 0.423 0.454 0.749 0.583 0.976 1.381 2.312 1.798 2.759 0.376 0.403 0.984 1.177 0.834 1.84-0.11 0.515-0.693 0.934-0.83 1.027-0.050 0.011-0.112 0.017-0.184 0.017-0.798 0-2.378-0.664-3.226-1.021l-0.126-0.053c-0.474-0.199-1.248-0.324-1.996-0.445-0.595-0.096-1.411-0.228-1.546-0.348-0.11-0.123 0.018-0.522 0.13-0.875 0.081-0.253 0.164-0.515 0.21-0.789 0.065-0.437-0.011-0.793-0.072-1.079z"></path>
    </symbol>
    <symbol id="icon-mac-os-logo" viewBox="0 0 32 32">
      <title>mac-os-logo</title>
      <path d="M24.734 17.002c-0.042-4.055 3.306-5.996 3.455-6.093-1.88-2.747-4.806-3.125-5.852-3.167-2.488-0.255-4.86 1.465-6.125 1.465-1.261 0-3.213-1.431-5.279-1.393-2.717 0.042-5.219 1.581-6.619 4.011-2.822 4.897-0.723 12.149 2.026 16.125 1.345 1.943 2.949 4.125 5.052 4.048 2.026-0.081 2.791-1.312 5.242-1.312s3.139 1.312 5.282 1.273c2.182-0.042 3.561-1.982 4.894-3.93 1.544-2.256 2.179-4.442 2.219-4.551-0.051-0.028-4.25-1.635-4.294-6.476z"></path>
      <path d="M20.704 5.11c1.115-1.352 1.871-3.234 1.665-5.11-1.611 0.065-3.557 1.069-4.714 2.423-1.036 1.199-1.938 3.111-1.697 4.95 1.795 0.141 3.631-0.913 4.746-2.263z"></path>
    </symbol>
    <symbol id="icon-windows-logo" viewBox="0 0 32 32">
      <title>windows-logo</title>
      <svg version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 305 305" style="enable-background:new 0 0 305 305;" xml:space="preserve">
        <path d="M139.999,25.775v116.724c0,1.381,1.119,2.5,2.5,2.5H302.46c1.381,0,2.5-1.119,2.5-2.5V2.5
        c0-0.726-0.315-1.416-0.864-1.891c-0.548-0.475-1.275-0.687-1.996-0.583L142.139,23.301
        C140.91,23.48,139.999,24.534,139.999,25.775z"></path>
        <path d="M122.501,279.948c0.601,0,1.186-0.216,1.644-0.616c0.544-0.475,0.856-1.162,0.856-1.884V162.5
        c0-1.381-1.119-2.5-2.5-2.5H2.592c-0.663,0-1.299,0.263-1.768,0.732c-0.469,0.469-0.732,1.105-0.732,1.768l0.006,98.515
        c0,1.25,0.923,2.307,2.16,2.477l119.903,16.434C122.274,279.94,122.388,279.948,122.501,279.948z"></path>
        <path d="M2.609,144.999h119.892c1.381,0,2.5-1.119,2.5-2.5V28.681c0-0.722-0.312-1.408-0.855-1.883
        c-0.543-0.475-1.261-0.693-1.981-0.594L2.164,42.5C0.923,42.669-0.001,43.728,0,44.98l0.109,97.521
        C0.111,143.881,1.23,144.999,2.609,144.999z"></path>
        <path d="M302.46,305c0.599,0,1.182-0.215,1.64-0.613c0.546-0.475,0.86-1.163,0.86-1.887l0.04-140
        c0-0.663-0.263-1.299-0.732-1.768c-0.469-0.469-1.105-0.732-1.768-0.732H142.499c-1.381,0-2.5,1.119-2.5,2.5v117.496
        c0,1.246,0.918,2.302,2.151,2.476l159.961,22.504C302.228,304.992,302.344,305,302.46,305z"></path>
      </svg>
    </symbol>
    <symbol id="icon-icon" viewBox="0 0 32 32">
      <title>icon</title>
      <path d="M9.502 25.749c0 1.795-1.455 3.251-3.251 3.251s-3.251-1.455-3.251-3.251c0-1.795 1.455-3.251 3.251-3.251s3.251 1.455 3.251 3.251z"></path>
      <path d="M7.894 19.253c2.689 0 4.875 2.186 4.875 4.878h3.252c0-4.482-3.646-8.131-8.126-8.131v3.253z"></path>
      <path d="M7.872 12.75c6.272 0 11.376 5.107 11.376 11.381h3.252c0-8.068-6.561-14.631-14.628-14.631v3.25z"></path>
      <path d="M7.872 6.25c9.858 0 17.878 8.020 17.878 17.881h3.25c0-11.654-9.476-21.131-21.127-21.131v3.25z"></path>
    </symbol>
    <symbol id="icon-customer-review" viewBox="0 0 32 32">
      <title>customer-review</title>
      <path d="M28.848 8.872c-1.942-1.409-4.504-2.184-7.214-2.184s-5.272 0.776-7.213 2.184c-2.032 1.474-3.151 3.46-3.151 5.593 0 1.99 1.003 3.884 2.825 5.332 1.681 1.336 3.926 2.179 6.345 2.386 2.611 1.899 6.441 2.97 6.727 3.048 0.141 0.040 0.288 0.060 0.435 0.060 0.597 0 1.145-0.325 1.428-0.843 0.364-0.66 0.229-1.479-0.333-1.991-0.712-0.647-1.092-1.154-1.294-1.518 1.269-0.631 2.338-1.467 3.12-2.444 0.966-1.207 1.477-2.6 1.477-4.030 0-2.132-1.119-4.118-3.152-5.593zM25.102 17.108h-6.935c-0.518 0-0.938-0.42-0.938-0.938s0.42-0.938 0.938-0.938h6.935c0.518 0 0.938 0.42 0.938 0.938s-0.42 0.938-0.938 0.938zM25.102 13.968h-6.935c-0.518 0-0.938-0.42-0.938-0.938s0.42-0.938 0.938-0.938h6.935c0.518 0 0.938 0.42 0.938 0.938s-0.42 0.938-0.938 0.938z"></path>
      <path d="M9.402 14.319c0-1.488 0.42-2.922 1.217-4.227-0.67-0.125-1.362-0.19-2.065-0.19-2.228 0-4.335 0.639-5.934 1.799-1.689 1.226-2.62 2.882-2.62 4.664 0 1.194 0.425 2.357 1.228 3.363 0.613 0.767 1.437 1.428 2.411 1.939-0.17 0.26-0.45 0.602-0.913 1.023-0.513 0.469-0.638 1.22-0.305 1.824 0.262 0.48 0.765 0.778 1.313 0.778 0.136 0 0.271-0.019 0.401-0.055 0.261-0.072 3.326-0.934 5.45-2.461 1.453-0.13 2.811-0.534 3.967-1.164-0.162-0.117-0.322-0.236-0.477-0.36-2.368-1.883-3.673-4.345-3.673-6.933z"></path>
    </symbol>
    <symbol id="icon-newspaper" viewBox="0 0 32 32">
      <title>newspaper</title>
      <path d="M26.359 3.25h-17.531c-1.32 0-2.391 1.069-2.391 2.391v1.594h-0.797c-1.32 0-2.391 1.069-2.391 2.391v15.938c0 1.76 1.427 3.188 3.188 3.188h19.125c1.76 0 3.188-1.427 3.188-3.188v-19.922c0-1.321-1.071-2.391-2.391-2.391zM27.156 25.563c0 0.878-0.716 1.594-1.594 1.594h-19.125c-0.879 0-1.594-0.716-1.594-1.594v-15.938c0-0.44 0.357-0.797 0.797-0.797h0.797v15.938c0 0.441 0.356 0.797 0.797 0.797s0.797-0.356 0.797-0.797v-19.125c0-0.44 0.357-0.797 0.797-0.797h17.531c0.439 0 0.797 0.357 0.797 0.797v19.922z"></path>
      <path d="M18.787 13.613h6.375c0.221 0 0.398-0.178 0.398-0.398s-0.178-0.398-0.398-0.398h-6.375c-0.219 0-0.398 0.178-0.398 0.398s0.179 0.398 0.398 0.398z"></path>
      <path d="M18.787 11.223h6.375c0.221 0 0.398-0.178 0.398-0.398s-0.178-0.398-0.398-0.398h-6.375c-0.219 0-0.398 0.178-0.398 0.398s0.179 0.398 0.398 0.398z"></path>
      <path d="M18.787 8.832h6.375c0.221 0 0.398-0.178 0.398-0.398s-0.178-0.398-0.398-0.398h-6.375c-0.219 0-0.398 0.178-0.398 0.398s0.179 0.398 0.398 0.398z"></path>
      <path d="M16.398 24.769h-6.375c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.178-0.398-0.398-0.398z"></path>
      <path d="M16.398 22.378h-6.375c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.178-0.398-0.398-0.398z"></path>
      <path d="M16.398 19.988h-6.375c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.178-0.398-0.398-0.398z"></path>
      <path d="M25.164 24.769h-6.375c-0.221 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 22.378h-6.375c-0.221 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 19.988h-6.375c-0.221 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 15.206h-15.141c-0.22 0-0.398 0.178-0.398 0.398s0.178 0.398 0.398 0.398h15.141c0.219 0 0.398-0.178 0.398-0.398s-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 17.597h-15.141c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h15.141c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M10.422 13.609h5.578c0.441 0 0.797-0.356 0.797-0.797v-5.575c0-0.441-0.356-0.797-0.797-0.797h-5.578c-0.441 0-0.797 0.356-0.797 0.797v5.575c0 0.44 0.356 0.797 0.797 0.797zM11.219 8.031h3.984v3.984h-3.984v-3.984z"></path>
    </symbol>
    <symbol id="icon-megaphone" viewBox="0 0 32 32">
      <title>megaphone</title>
      <path d="M3.535 12.756v4.826c-0.007 1.083 0.866 1.966 1.948 1.973h0.42v-8.788h-0.395c-1.091 0.001-1.974 0.885-1.974 1.976z"></path>
      <path d="M12.064 20.552h-5.029l1.958 6.392c0.155 0.515 0.513 0.945 0.993 1.189 0.477 0.243 1.033 0.28 1.538 0.101 0.972-0.347 1.515-1.381 1.249-2.378-0.424-1.558-0.672-3.434-0.709-5.304z"></path>
      <path d="M6.9 10.767h5.173v8.788h-5.173z"></path>
      <path d="M13.071 10.751v8.836c3.054 0.129 6.003 1.412 7.964 2.497 0.998 0.554 1.961 1.17 2.881 1.846v-17.544c-0.959 0.682-1.958 1.306-2.991 1.871-2.85 1.553-5.486 2.391-7.854 2.495z"></path>
      <path d="M26.689 3.659c-0.983 0.002-1.778 0.8-1.776 1.783v19.449c0 0.981 0.795 1.776 1.776 1.776s1.776-0.795 1.776-1.776v-19.446c0.004-0.983-0.79-1.783-1.773-1.787z"></path>
    </symbol>
    <symbol id="icon-slack" viewBox="0 0 32 32">
<title>slack</title>
<path fill="rgba(255, 255, 255, 0.8)" style="fill: var(--color1, rgba(255, 255, 255, 0.8))" d="M3.556 32h24.889c1.964 0 3.556-1.592 3.556-3.556v-24.889c0-1.964-1.592-3.556-3.556-3.556h-24.889c-1.964 0-3.556 1.592-3.556 3.556v24.889c0 1.964 1.592 3.556 3.556 3.556z"></path>
<path fill="#fff" style="fill: var(--color2, #fff)" d="M25.774 13.068c-2.199-7.331-5.375-9.041-12.706-6.841s-9.041 5.375-6.841 12.706c2.199 7.33 5.376 9.041 12.706 6.841s9.041-5.376 6.841-12.706zM22.066 17.826l-1.382 0.463 0.479 1.431c0.194 0.579-0.118 1.205-0.697 1.399-0.126 0.043-0.254 0.061-0.379 0.057-0.452-0.012-0.869-0.301-1.020-0.755l-0.479-1.43-2.85 0.955 0.479 1.43c0.194 0.579-0.118 1.206-0.697 1.4-0.126 0.042-0.254 0.060-0.379 0.057-0.452-0.011-0.869-0.301-1.020-0.754l-0.479-1.431-1.382 0.463c-0.126 0.042-0.255 0.060-0.38 0.057-0.451-0.011-0.868-0.301-1.020-0.755-0.194-0.579 0.118-1.205 0.697-1.399l1.383-0.463-0.919-2.743-1.382 0.463c-0.126 0.042-0.254 0.060-0.38 0.057-0.451-0.011-0.868-0.301-1.020-0.755-0.194-0.579 0.119-1.205 0.697-1.399l1.383-0.463-0.479-1.43c-0.194-0.579 0.118-1.206 0.697-1.399s1.206 0.118 1.4 0.697l0.479 1.43 2.851-0.955-0.479-1.43c-0.194-0.579 0.119-1.206 0.697-1.4s1.206 0.119 1.4 0.697l0.479 1.431 1.383-0.463c0.579-0.194 1.205 0.119 1.399 0.697s-0.118 1.206-0.697 1.4l-1.382 0.463 0.919 2.744 1.383-0.463c0.579-0.193 1.205 0.119 1.399 0.697s-0.118 1.206-0.697 1.4zM14.115 15.106l0.919 2.743 2.851-0.955-0.919-2.743-2.851 0.955z"></path>
</symbol>
  </defs>
</svg>


    <div  class="wrapper wrapper--nofooter" >

      <header  class="header header--content"  role="banner">

  

  

<!-- <section class="dev-survey">
  <div class="d-flex justify-content-center">
         <p>Tell us what you want to see in GraalVM!
           <a href="https://ora-gcp1.custhelp.com/ci/documents/detail/5/2913/12/57581a41ab42a5ec14bbc1c2a4fdf93e6ccc47f1" class="right-arrow" target="_blank">Fill this quick survey &#8594;
           </a>
         </p>
    </div>
</section> -->

<div class="d-flex">
    <nav class="menu">
        <div class="menu__logo">
          <a href="/">
            <img src="/resources/img/logo-colored.svg" alt="GraalVM logo">
          </a>
        </div>

          <ul class="menu__list">
            <li class="menu__item">
              <a href="/docs/getting-started/" class="menu__link menu__link--active">Getting Started</a>
            </li>
            <li class="menu__item">
              <a href="/docs/introduction/" class="menu__link">Docs</a>
            </li>
            <li class="menu__item">
              <a href="/downloads/" class="menu__link">Downloads</a>
            </li>
            <li class="menu__item">
              <a href="/community/" class="menu__link">Community</a>
            </li>
            <li class="menu__item">
              <a href="/videos/" class="menu__link">Videos</a>
            </li>
            <li class="menu__item">
              <a href="/blog/" class="menu__link">Blog</a>
            </li>
            <li class="menu__item icons">
              <a class="menu__link menu__link--iconed" href="https://github.com/oracle/graal">
                <svg class="icon icon-github-sign"><use xlink:href="#icon-github-sign"></use></svg>
              </a>
            </li>
            <li class="menu__item icons">
              <a class="menu__link menu__link--iconed" href="https://twitter.com/graalvm">
                <svg class="icon icon-social-network"><use xlink:href="#icon-social-network"></use></svg>
              </a>
            </li>
            <li class="menu__item icons" tabindex="0">
              <span class="github-widget">
                <a tabindex="-1" class="github-button" href="https://github.com/oracle/graal" data-icon="octicon-star" data-show-count="true" aria-label="Star oracle/graal on GitHub">Star</a>
              </span>
            </li>
            <!-- <li class="menu__item" tabindex="-1">
              <a href="/downloads/" class="btn btn-try btn-primary">Try graalvm</a>
            </li> -->
        </ul>

    <div role="button" class="menu-btn menu-btn--menu js-show-menu" tabindex="-1" title="sweet hamburger">
      <div class="hamburger"><div class="inner"></div></div>
    </div>
    <button class="btn btn-mobile-menu js-show-menu"><div class="inner"></div></button>
  </nav>
</div>
  
</header>


      <main  class="content"   aria-label="Content">
        <div class="wrapper wrapper-content">
  <article class="docs">

  <div class="container-fluid container-fluid--custom-sm">
    <div class="row">
      <div class="col-12 col-sm-12 col-md-12 col-lg-10 offset-lg-1">
          <div class="row d-flex flex-wrap">
            <div class="col-sm-3 col-bg">
              <div class="sidebar-wrap">
                <div class="sidebar">
                  
<div class="toc-floating">


<script>
var sidebar = document.currentScript.parentElement;

// 
//   $(document).ready(function(){
//     $('.sidebar-wrap').stickySidebar({
//       topSpacing: 74,
//       bottomSpacing: 40
//     });
//   });
//
// 


$(document).ready(function(){
  var header = $('.header').height();
  var invisibleBlock;

  $("#content-wrapper h1, #content-wrapper h2").each(function() {
    invisibleBlock = $(this).before("<div class='anchor' id="+ $(this).attr("id") +"></div>");
  });

  $(window).scroll(function() {
    var lastitem = null;
    $("#content-wrapper h1, #content-wrapper h2").each(function() {
      var heading = $(this);
      var position = (heading.position().top - heading.height()) - $(window).scrollTop();
      var listitem = $(sidebar).find("li").filter(function() {
        return $(this).find("a").attr("href") == "#" + heading.attr("id");
      });
      listitem.removeClass("toc-bullets-focused");
      if (position <= 0) {
        lastitem = listitem;
      }
    });
    if (lastitem != null) lastitem.addClass("toc-bullets-focused");
  });
});

</script>

<ul class="toc-bullets">

  
    

    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/why-graalvm/">
            Why GraalVM?
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/getting-started/">
            Getting Started
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/getting-started/container-images/">
            Container Images
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/guides/">
            Guides
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/examples/">
            Examples
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/reference-manual/">
            Reference Manuals
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/tools/">
            Debugging and Monitoring Tools
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/graalvm-as-a-platform/">
            GraalVM as a Platform
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/security-guide/">
            Security Guide
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/compatibility/">
            Compatibility
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/release-notes/">
            Release Notes
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/support/">
            Support
          </a>
        </li>

        
        


        
        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/faq/">
            FAQ
          </a>
        </li>

        
        


        
        
      
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

</ul>
<!-- Search form -->
<form class="search-container" action="/docs/search" autocomplete="on" method="get">
  <input type="text" id="search-box" name="query" placeholder="Search">
  <button type="submit" class="searchbttn"></button>
</form>

</div>

                </div>
              </div>
            </div>

            <div class="col-sm-9">
              <div id="content-wrapper" class="docs-content docs-content--with-sidebar">
                <h2 class="additional-item__title">Search Results</h2>

                <!-- Placeholder for displaying results -->
                <div class="search-results">
                  <ul id="search-results"></ul>
                </div>
              </div>
              <!-- JSON output of all the content we want to search on  -->
              <script>
                window.store = {
                  
                  "downloads-19":  {
                    "title": "",
                    "content": "",
                    "url": " /downloads/19/"
                  },
                  
                  "release-notes-19-0":  {
                    "title": "",
                    "content": "19.0.2(2019-06-13)This is a bug fix release for 19.0 and we recommend upgrading for all 19.0.x users.Java  Improved compilation performance of scheduler phase.  Support retrieving annotations from class initializers (see 1320).  Fixed problems related to the freetype library: 1269, 1270, 1305.  Fixed Version string reporting (it was missing 64-Bit in the string).Native image  Fixed IllegalArgumentException: Cannot create Method for class initializer (see 1320).  Fixed an issue when the build would loop forever if META-INF/native-image/native-image.properties contains --force-fallback.  Fixed the issue where fallback image generation would not respect the --no-server argument.  Fix native-image-agent=restrict configuration detection.  Added -agentlib:native-image-agent=build configuration option.LLVM interpreterAllow LLVM interpreter Context to run without allowIO(true).19.0.0(2019-05-09)Early Adopter Windows SupportThe early adopter builds for Windows are available for GraalVM. These includethe JDK with the GraalVM compiler enabled, the Native Image capabilities,GraalVM’s JavaScript engine and the developer tools: Chrome inspector baseddebugger, Profiler etc.. Currently there is no gu utility or the ability toadd support for the other GraalVM languages.Java  We updated the base JDK to 8u212. You can find the JDK release notes at the Oracle Technology Network website.Native ImageNative Image was extracted from the base GraalVM distribution. Currently it isavailable as an early adopter plugin. To install it, run: gu installnative-image. After this additional step, the native-image executable will bein the bin directory, as for the previous releases.There was a change in how classes are initialized in a native-image. Now, we initialize application classes at run time by default. The policy for initialization is as follows:  All JDK classes are initialized at build time.  We prove the safety of application static initializers after the analysis and initialize the safe classes.  We provide the following flags to control class initialization in a fine-grained way: --initialize-at-build-time and --initialize-at-run-time.The performance and startup impact of this change is negligible on all benchmarks that we have.This change was made to improve user experience: there is no need to writesubstitutions and to deal with instances of unsupported classes ending up in theimage heap. Their applications, given the right configuration for reflection,proxies, etc., should work without performance degradation.To allow framework authors and end users to keep the startup time at minimum weimproved functionality of --initialize-at-build-time and--initialize-at-run-time. These flags allow to specify a policy for wholepackages or individual classes. For example, if we have classes p.C1, p.C2,… , p.Cn, we can eagerly initialize this package with--initalize-at-build-time=p. If we want to delay one of the classes in packagep we can simply add --initialize-at-run-time=p.C1.The whole class hierarchy can be initialized at build time by simply passing --initalize-at-build-time on the command line.We also introduced the flag -H:+PrintClassInitialization which allows you to track what class initialization does during the image build. This flag will help you configure the build to work as intended.What should I do if I am a library author?  To get your tests back in check you can use --intialize-at-build-time which will revert to the previous behaviour.  Then use the flag -H:+PrintClassInitialization to see when classes get initialized. Based on this output you can make the proper configuration.  Configure your native-image.properties by passing --intialize-at-build-time=&amp;lt;csv-of-classes-or-packages&amp;gt; to it.  Submit a pull request to the downstream libraries with the configuration you believe works well. That way your native-image.properties will be concerned only with the classes from your framework.  There is a known issue with lambdas being initialized at build time. If your lambda inherits an interface with a default method and static fields, those fields will get pulled into the image. We will provide a fix to this bug in the next two weeks.JavaScript  Fixed various bugs that address compilation problems.R  Fixed a fatal error on Linux platforms when sending SIGINT during long computations.  Fixed issues with the installation to protected locations: the default Renviron file sets the R_LIBS_USER to a directory inside the current user’s home. Users still have to create this directory manually. Alternatively, the configure_fastr script creates the directory, but for the current user only.  Implemented missing C API: S_realloc.Ruby  Various bug fixes. Most notably fixes around OpenSSL C extension compilation.  Renamed methods in the TruffleRuby object.Ideal Graph Visualizer (IGV)  Fixed the issue with the ASTs and call trees not showing up.",
                    "url": " /release-notes/19_0/"
                  },
                  
                  "release-notes-19-1":  {
                    "title": "",
                    "content": "19.1.1(2019-07-16)This is a Critical Patch Update (CPU) release for the 19.1.0 GraalVM releaseinduced by the update to OracleJDK 8u221 and OpenJDK 8u222 as the base JDKs.More details can be foundhereand here. We recommend upgradingto it from the 19.1.x and older releases.This CPU release includes fixes for the following CVEs:  CVE-2019-2813  CVE-2019-2862For more information please see the Oracle July 2019 Security Advisory.Critical fixes to GraalVM Native Image listed below went also into this version:      Fixed Reflection.getCallerClass methods sometimes failing to acquire the correct frame in the native images (#1479).        Fixed an issue that could cause header files not being generated in the working directory when compiling shared libraries ahead-of-time.  19.1.0(2019-07-02)This is a feature release, we recommend upgrading to it from the 19.0.x releases.Java  Improved speed of just-in-time (JIT) compilation in GraalVM, which significantlyimproves the performance on medium length workloads.  Applied profile-guided optimization (PGO) when building the ahead-of-time (AOT) image of the compiler. This enables more aggressive optimization of the compiler itself providing better compilation throughput.Native imageWe fixed many issues that were reported on GitHub. You can browse the full list here.JavaScript  Added an experimental option js.locale to set the default locale for locale-sensitive operations.  Allow making evaluated sources internal using the sourceURL directive by prefixing the URL with internal:, e.g., //# sourceURL=internal:myname.js.  Improved code sharing across threads. Prior to this one context had to be closed before the code in it could be reused in another context , now for JavaScript contexts one can share code using ContextPolicy.SHARED without closing the context.In the following example the source code is shared between context1 and context2:public static void main(String[] args) {        try (Engine engine = Engine.create()) {            Source source = Source.create(&quot;js&quot;, &quot;21 + 21&quot;);            try (              Context context1 = Context.newBuilder().engine(engine).build();              Context context2 = Context.newBuilder().engine(engine).build()) {                context1.eval(source).asInt();                context2.eval(source).asInt();            }        }    }LLVM interpreter  Calling exit(...) in an embedded context is now a catchable PolyglotException.  Skip source path entries that we are not allowed to access. Previously, whenrunning in an embedded context with restricted access to the file system, theLLVM engine threw an exception when it could not read the source files, even ifno debugger was attached. Now it will still run. Only when a debugger isattached, an error is reported when the source file can’t be accessed.RubyThe GraalVM Ruby implementation in this version targets performance and compatibility improvements, new features implementations and multiple bug fixes. The most notable include:  Interactive sources (like the GraalVM polyglot shell) now all share the same binding (#1695).  Hash code calculation has been improved to reduce hash collisions for Hash and other cases.  eval(code, binding) for a fixed code containing blocks is now much faster. This improves the performance of rendering ERB templates containing loops.  rb_str_cat is faster due to the C string now being concatenated without first being converted to a Ruby string or having its encoding checked.A complete changelog for the Ruby component is available on GitHub.R  Strings -Inf, +NaN, and -NaN are correctly parsed to doubles including ignoring leading and trailing whitespaces.  For loop creates and initializes the control variable even if there are no iterations (#77).  Updated the output of the capabilities builtin (#78).  is.function returns true for foreign executables.The complete project changelog is available on GitHub.Python  Updated Python standard library files from 3.7.0 to 3.7.3.  Improved performance of exceptions that do not escape.  Fixed caching of core sources in a native image with a preinitialized contextfor pre-built images and libpolyglot fast startup.  Implemented support for pwd.getpwuid, os.exec, os.execv, and os.execl modules.To see a complete list of changes, please refer to the project changelog.",
                    "url": " /release-notes/19_1/"
                  },
                  
                  "release-notes-19-2":  {
                    "title": "",
                    "content": "19.2.1(2019-10-15)This is a Critical Patch Update (CPU) for GraalVM Enterprise and CommunityEditions following a regular Oracle CPUs cycle. The updateis to address security vulnerabilities announced in the October 2019 Oracle Critical Patch Update Advisory. The 19.2.1 version is a full distribution and and it is recommended to upgrade to it from older GraalVM versions.Oracle GraalVM Enterprise Edition 19.2.1 includes all the Java security fixes released as part of that CPU and mentioned in the Java SE 8 Release notes.  It also includes the following:  Update GraalVM Enterprise base Java to the 8u231 Oracle JDK version  Update GraalVM Community base Java to the 8u232 OpenJDK version  Update Node.js to 10.16.3Listed below are critical fixes that also went into this version:  Fixed a problem that prevented creating a native image including the GraalVM JavaScript engine combined with java.lang.CharSequence implementations that have non-trivial implementations of the length and charAt methods (see #1625).  Fixed a problem that could allow an exception to propagate past a catch clause that should handle it.Oracle Cloud Infrastructure customers can use GraalVM Enterprise environment in their cloud instances by simply installing it with yum. For more details, please seeGraalVM on OCI. Note: We currently do not recommend macOS users to upgrade to Catalina – a next majorrelease of macOS desktop operating system. We can not guarantee completecompatibility with GraalVM 19.2.1 or older versions yet.19.2.0.1(2019-09-13)We prepared a high severity update for GraalVM to address the following issues:  Fixed a critical compiler bug that caused String.indexOf to be executed incorrectly on older machines that do not support the TZCNT instruction. The problem causes incorrect string operations and typically shows up as truncated string values.  Fixed a bug causing the bounds check in Native Image’s implementation of System.arraycopy to overflow with large indices which typically causes process termination.  Fixed a bounds check for System.arraycopy in cases where the array is “virtualized” (i.e., can be in registers and stack slots instead of on the heap).  Removed declaration of otherwise unused SIOCGSTAMP symbol in Native Image. This allows use of Native Image on any Linux distro using a 5.2.x kernel such as the latest versions of Fedora, Ubuntu (except LTS release users), Arch, openSUSE (tumbleweed).19.2.0(2019-08-20)This is a GraalVM feature release, we recommend upgrading to it from the 19.1.x or older releases.Native ImageWe simplified the process of collecting data for profile-guided optimizations (PGO) for GraalVM Enterprise native images. PGO allows to optimize performance of native images by analyzing collected profiles during the image generation process. Since 19.2.0 you can collect data for PGO while running your application in a just-in-time (JIT) compiled mode:$ /graal-ee-19.2.0/bin/java -Dgraal.PGOInstrument=myclass.iprof MyClass$ /graal-ee-19.2.0/bin/native-image --pgo=myclass.iprof MyClass$ ./myclassPerformanceWe improved throughput for native image in GraalVM Enterprise when no profiles are available. Running the Micronaut GraalVM example shows spending ~10% less CPU time and achieving a ~10% higher throughput of requests per CPU second in 19.2.We also solved a common usability problem when a class marked forinitialization at runtime gets inadvertently initialized at build time. The flag -H:+TraceClassInitialization was introduced to help tracing what classes got initialized at runtime.JavaScript  We added support for date, time, timezone, instant and duration interoperabilitytypes to distinguish date-like objects from multiplelanguages in polyglot contexts (see changes to GraalVM SDK and Truffle APIs).  Added Context.Builder.timeZone to set the time zone.  We implemented the Numeric separators TC39 proposal. It isavailable in ECMAScript 2020 mode (--js.ecmascript-version=2020).  We moved ICU data for internationalization APIs, e.g., date and time formatting, number formatting, collation for each individual supported language, previously distributed as separate files in &amp;lt;GRAALVM_HOME&amp;gt;/jre/languages/js/icu4j/icudt to the executable of JavaScript (js).More changes are listed in the JavaScript component changelog.LLVM InterpreterWe added preliminary support for compiling native programs to bitcode usingthe LLVM toolchain. The LLVM toolchain is a set of tools and APIs for compilingnative projects, such as C and C++, to bitcode that can be executed with theGraalVM LLVM runtime. It is aimed to simplify ahead-of-time compilation forusers and language implementers who want to use the GraalVM LLVM runtime. To doso, we provide launchers that invoke the C/C++ compiler with special flags toproduce results that can be executed by the GraalVM LLVM runtime. For moredetails, please consult the LLVM reference documentation.The toolchain is an experimental feature in this release.A complete list of changes to GraalVM LLVM runtime can be found in thechangelog.RubyA comprehensive list of changes to Ruby language component is available on GitHub. Major changes include:  Implemented support for Fiddle – an extension to translate a foreign function interface (FFI) and libffi wrapper for Ruby.  In terms of compatibility, Thread.report_on_exception is now true by defaultlike MRI 2.5+; BigDecimal compatibility has been generally improved in severalways.  Improved the performance by optimizing String methods to use the vectorinstructions when searching for a single-byte character in a String.  Fixed several bugs reported by community:          Set RbConfig::CONFIG[&#39;ruby_version&#39;] to the same value as the TruffleRuby version. This fixes reusing C extensions between different versions of TruffleRuby with Bundler (#1715).      Improved errors when interacting with single-threaded languages (#1709).      R  Added a new fastRCluster package that allows to run FastR inside GNU-R:          install in GNU-R or RStudio with: devtools::install_github(&#39;oracle/fastr/com.oracle.truffle.r.pkgs/fastRCluster&#39;);      use ?fastRCluster to learn more.        The problem that SET_ATTRIB does not validate the attributes as expected was resolved.The changelog is available on GitHub.PythonThe GraalVM Python implementation is still experimental and we are working towards improving completeness.  Implemented PyStructSequence_* C API – standard structured prediction functions.  Added support for more C API functions as PyEval_InitThreads and PyEval_ThreadsInitialized, type attributes i.e. nb_remainder, nb_subtract, overflowed and recursion_depth thread state fields.  Fixed printing of errors in the REPL and full paths in tracebacks.More details are available in the project changelog on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)We implemented the ability to configure custom polyglot access configuration withPolyglotAccess.newBuilder(). It allows to configure fine-grained accesscontrol for polyglot bindings and between polyglot languages. For example, givena TruffleObject as a value, there is a need to determine language and type ofthat object. This feature is significant for GraalVM execution inside OracleRDBMS.GraalVM 19.2.0 release also added support for date, time, timezone, durationvalues in polyglot APIs, and introduced the Context.Builder.timeZone(ZoneId)class to configure the default timezone of polyglot contexts.The major GraalVM SDK and Truffle APIs changes between the versions are summarized in:  GraalVM SDK changelog  GraalVM Truffle changelogToolsA preview version of Java Flight Recorder (JFR) support has been released as a plugin for the VisualVM tool bundled with GraalVM 19.2.0. The plugin reads all JFR snapshots created from Java 7 and newer and presents the data in typical VisualVM views familiar for its users.To install the JFR support, download GraalVM 19.2.0 from graalvm.org/downloads, unzip it and run /bin/jvisualvm to start VisualVM.Use `Tools | Plugins | Available Plugins` to list all available plugins and install the VisualVM-JFR and VisualVM-JFR-Generic modules.The JFR snapshots can be opened using either the File | Load… action or by double-clicking the JFR Snapshots node and adding the snapshot into the JFR repository permanently.Please follow the documentation of your Java installation how to create JFR snapshots.JFR support is currently anexperimentalfeature. Some advanced features like analyzing JVM internals, showing eventstack traces or support for creating JFR snapshots from live processes are notavailable in the preview version and will be addressed incrementally in thefollowing releases.GraalVM Updater UtilityWe fixed an issue where GraalVM Enterprise would by default download the GraalVM Community components from GitHub. If you are using GraalVM Community – nothing changes, you can still install the components as before, and the gu will locate the necessary jar files on GitHub and correctly install them:gu install native-image ruby R pythonIf you are using GraalVM Enterprise, you can install R and llvm-toolchain components from GitHub, for example:gu install RThe other components are available from the OTN page, and can be installed from a manually downloaded file, for example to install native-image support run:gu -L install native-image-installable-svm-svmee-darwin-amd64-19.2.0.jarVersion CalendarYou can now refer to GraalVM version calendar to learn more about the GraalVM release model and prepare for upcoming releases.",
                    "url": " /release-notes/19_2/"
                  },
                  
                  "release-notes-19-3":  {
                    "title": "",
                    "content": "19.3.6(2021-04-20)GraalVM Community Edition 19.3.6 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 19.3.x.Please note that this is the last release of GraalVM Community Edition 19.3.x.It also includes:  update to 8u292 for Java 8 based GraalVM Community, please see OpenJDK 8u292 Updates  update to 11.0.11 for Java 11 based GraalVM Community, please see OpenJDK 11.0.11 Updates  Node.js runtime update to 12.22.1 which contains all security fixes mentioned in April 2021 Security Releases19.3.5(2021-01-19)GraalVM Community Edition 19.3.5 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous releases of GraalVM 19.3.x.It also includes the following:  Update to OpenJDK version 8u282 for Java 8 based GraalVM Community, please see please see OpenJDK 8u282 Updates  Update to OpenJDK version 11.0.10 for Java 11 based GraalVM Community, please see OpenJDK 11.0.10 Updates19.3.4(2020-11-03)GraalVM Community Edition 19.3.4 is a Critical Patch Update (CPU) and contains fixes to security vulnerabilities and critical bugs.GraalVM Community Edition 19.3.4 is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU. It is a full distribution and supersedes all previous releases of GraalVM 19.3.containsOther changes that went into the release:  Update Java to 8u272 for Java 8 based GraalVM, please see OpenJDK 8u272 Release notes  Update Java to 11.0.9 for Java 11 based GraalVM, please see OpenJDK 11.0.9 Release notes19.3.3(2020-08-04)GraalVM Community Edition 19.3.3 is a Critical Patch Update (CPU) and contains fixes to security vulnerabilities and critical bugs.GraalVM Community Edition 19.3.3 is based on OpenJDK CPU and will include all the OpenJDK security fixes released as part of that CPU. It is a full distribution and supersedes all previous releases of GraalVM 19.3.Other changes that went into the release:  Update Java to 8u262 for Java 8 based GraalVM, please see OpenJDK 8u262 Release notes  Update Java to 11.0.8 for Java 11 based GraalVM, please see OpenJDK 11.0.7 Release notes19.3.2(2020-05-12)GraalVM Community Edition 19.3.2 is a Critical Patch Update (CPU) that only contains security and bug fixes, and supersedes all previous releases of GraalVM 19.3.The release includes:  Java update to 8u252 for Java 8 based GraalVM, please see [OpenJDK 8u252 Release notes]https://adoptopenjdk.net/release_notes.html#jdk8u252).  Java update to 11.0.7 for Java 11 based GraalVM, please see OpenJDK 11.0.7 Release notes.Other critical bug fixes that went into this version:  Made Chrome debugger call getter functions several times to test for side-effects.  Fixed a problem when LLVM context could send user directory information into the image heap by not caching System.getenv() for a single usage.  Substitute missing native methods in DynamicHub with @Delete (see #2054).  Added tests for JNI getFieldID and getMethodID method to ensure the class is initialized.19.3.1(2020-01-14)This is a Critical Patch Update (CPU) for GraalVM Enterprise and CommunityEditions. The 19.3.1 release contains fixes to security vulnerabilities,critical bugs, and other fixes as identified in the January 2020 Oracle Critical Patch Update Advisory. OracleGraalVM Enterprise Edition 19.3.1 includes all the Java security fixes releasedas part of that CPU.The 19.3.1 version also includes the following:  Update Java to 8u241 for Java 8 based GraalVM, please see Java SE 8 Release notes.  Update Java to 11.0.6 for Java 11 based GraalVM, please see Java SE 11 Release notes.  Update Ruby to 2.6.5, please see Ruby 2.6.5 release notes.  Update Node.js to 12.14.0, please see Node.js 12.14.0 release notes.For more information about Oracle Critical Patch Updates and Security Alerts, please visit the announcements list.Please note that for GraalVM Enterprise Edition on Java 11, java -version incorrectly reports aversion based on 11.0.6+1 where as it is actually 11.0.6+8. This issue inthe GraalVM build process will be remedied in future releases.Listed below are issues addressed in this release:  Resolved the issue of NullPointerException being thrown with SecurityServicesFeature when the application uses non-JDK related services (#1893).  Made efforts to turn Code coverage command line tool more reliable (#1800).  Prevented linking errors in Unsafe and ClassLoader by substituting all native methods (#1920).  Made dynamically generate On_Load_* function call for static libraries so all libraries are known before the image generation to prevent -Djava.net.preferIPv6Addresses=true returning an incorrect value (#1937).  Fixed ProcessHandle properties not providing useful values when running a native image (#2001).  Fixed an unsynchronized java.util.WeakHashMap.get access when single engine isshared between several thread local polyglot contexts (#1916).  Fixed an issue of JDK 11  GraalVM build not being recognized by macOS /usr/libexec/java_home -V (#801).  Implemented a new C APIs used by JSON 2.3.0 (#1857).  Ensured that GraalVM Native Image does  not have references to native methods from java.lang.reflect.Proxy (#1971).  Ensured that all native methods of core classes would be substituted to prevent reflection configuration issues (#1848).  Fixed an issue leading to JavaFX applications misbehave with GraalArithmeticStubs (#1867).  Ensured that DynamicProxySupport classes being called from multiple threads are thread safe (#1927).  Prevent static field values changing during a native image generation (#1945).  Fixed the issue with the native linking step at image writing phase when the image uses functions from unsupported static JDK libraries (#1875).19.3.0.2(2019-12-24)This is a bugfix update including fixes to the JVM Compiler Interface (JVMCI) and necessary updates to the JDK 11 support.The following issues were addressed:  Approached the issue of DynamicProxySupport being not thread safe when DynamicProxySupport.addProxyClass is called from multiple threads (see #1927).  Resolved a problem leading to a wrong execution of the code produced with the GraalVM native-image builder at optimization level 2 -H:Optimize=2 (see #1995).  Fixed a problem when JavaFX applications misbehave with GraalArithmeticStubs (see #1867).  Resolved an issue of VM crashing when run with Serial GC (see #1892).  ReduceInitialCardMarks is unsafe with OptBulkAllocation in JDK 11 (see #1915).  Fixed a transient crash while building native images with GraalVM based on JDK11 (see #1906).19.3.0(2019-11-19)GraalVM 19.3 is the first planned Medium-Term Support (MTS) release built fromthe main line of the project. This is also a major feature release and it is arecommended upgrade to it. The MTS status assures that stability, security, andperformance fixes will be backported from the current branch for the next 18months.GraalVM JDK 11 Based BuildsWith the major update to the 19.3 version, we announce the first release ofGraalVM based on JDK 11! This represents a substantial milestone given thedifferences between JDK 8 and JDK 11. In particular, the Java Platform ModuleSystem (JPMS) introduced in JDK 9 means GraalVM now uses module encapsulation to isolate code such as JVMCI, the GraalVM compiler and the Truffle API from application code. In addition, it means GraalVM on JDK 11 includes all theJDK changes since JDK 8. These are detailed in the release notes for JDK 9,JDK 10and JDK 11.In terms of languages, GraalVM on JDK11 supports all JVM languages (Java, Scala etc.) aswell as all guest languages currently supported in GraalVM on JDK8.Due to the modular structure of the base JDK, there is no more $GRAALVM_HOME/jre/ directoryin the GraalVM package based on JDK 11. This has an impact on the path to the languages location,e.g., $GRAALVM_HOME/jre/languages/js now becomes $GRAALVM_HOME/languages/js):GraalVM Native Imageon JDK 11 allows usage of all JDK 8 command line options. Currently the nativeimage builder ($GRAALVM_HOME/bin/native-image) does not support the JavaPlatform Module System (JPMS) and has no module introspection at image run time.Pease note, at present GraalVM Updater cannot rebuild images ($GRAALVM_HOME/bin/gu rebuild-images) with GraalVM Enterprise and Community editions on JDK 11. Even if GraalVM Native Image is installed, a user will encounter the following error while rebuilding:$ $GRAALVM_HOME/bin/gu rebuild-images rubyError: rebuild-images utility is not available. You may need to install &quot;native-image&quot; component.Please refer to documentation for the details.A possible workaround is to rebuild images invoking rebuild-images command directly, e.g.:$GRAALVM_HOME/bin/rebuild-images rubyPlease be informed, to have GraalVM JDK 11 based build on macOS listed by /usr/libexec/java_home -V you need to:  extract the GraalVM archive to /Library/Java/JavaVirtualMachines/ location  mkdir /Library/Java/JavaVirtualMachines/graalvm-ce-java11-19.3.0/Contents/MacOS  cd /Library/Java/JavaVirtualMachines/graalvm-ce-java11-19.3.0/Contents/MacOS  ln -s ../Home/lib/jli/libjli.dylibThis issue will be fixed in the next release.GraalVM JDK 11 on ARM64We provide a preview of GraalVM Community Edition on JDK 11 for ARM64architecture. It includes the support for all JVM languages. The support for theother languages should follow soon after. This distribution includes GraalVMNative Image off the shelf to build instantly starting applications whichconsume less memory in ARM64 environments.There are some known limitations with this distribution at the moment:  npm and node do not support runtime code installation (Trufflecompilations). To avoid failing with java.lang.NullPointerException, disableTruffle compilations with npm --vm.Dgraal.TruffleCompilation=false or node--vm.Dgraal.TruffleCompilation=false.  npm and node crash with  a free(): invalid pointer error.Native ImageGraalVM 19.3 switched to using the JDK native code instead of manualsubstitutions. For GraalVM Native Image this switch to Java Native Interface(JNI) platform enabled the possibility to provide support for JDK 11 andextended support for Windows OS. It has no impact on startup time or memoryfootprint, and eliminates the need for shipping JDK libraries such aslibsunec.so along with native images that use Java crypto services. GraalVMnow ships with statically linkable version of the JDK libraries.Note that the sunec native library of SunEC provider gets statically linkedinto an image if required (see#951). Thus native images do notdepend on the sunec shared library anymore at runtime. However, if SunECprovider gets statically linked into an image on Linux and macOS the image willdepend on libstdc++.Native Image Maven PluginSupport for using GraalVM Native Image with Maven was introduced with theNative Image Maven Plugin. It means auser can build a project and its native image directly with Maven using the mvnpackage command. As of the GraalVM version 19.3, the Maven &amp;lt;groupId&amp;gt; for theGraalVM Native Image related artifacts, including the plugin, changed fromcom.oracle.substratevm to org.graalvm.nativeimage:&amp;lt;plugin&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.nativeimage&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;native-image-maven-plugin&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;19.3.0&amp;lt;/version&amp;gt;    &amp;lt;executions&amp;gt;        &amp;lt;execution&amp;gt;            &amp;lt;goals&amp;gt;                &amp;lt;goal&amp;gt;native-image&amp;lt;/goal&amp;gt;            &amp;lt;/goals&amp;gt;            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;        &amp;lt;/execution&amp;gt;    &amp;lt;/executions&amp;gt;    &amp;lt;configuration&amp;gt;        &amp;lt;skip&amp;gt;false&amp;lt;/skip&amp;gt;        &amp;lt;buildArgs&amp;gt;            --no-fallback        &amp;lt;/buildArgs&amp;gt;    &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;To use the plugin make sure GraalVM home is set as your JAVA_HOME environment and Native Image is installed. Using the plugin without GraalVM is not recommend.GraalVM Compiler  We have improved System.arraycopy to eliminate store checks when copying toObject[]. That improvement fixes slowdowns (versus C2) on some EclipseCollections benchmarks.  A performance regression when creating List values in Scala has been fixed bymore optimized inlining.  Fixed an issue that could prevent a method from being compiled that contains the JSR bytecode produced by older javac versions (see #1699).JavaScriptThe Node.js runtime available with GraalVM was updated to the 12.10.0 version, which brought some breaking changes.Additional proposals for ECMAScript 2020 have been implemented (Promise.allSettled and Nullish coalescing) and are available in ECMAScript 2020 mode (--js.ecmascript-version=2020).To provide better compatibility with the ECMAScript specification, some extensions are now disabled by default, some depending on the launcher (js, node, or via GraalVM Polyglot Context). This includes the print and printErr functions (the js.print flag), the global built-in (superseded by globalThis, use the js.global-property flag to reenable), or the performance global property (the js.performance flag).More details can be found in the project changelog on GitHub.LLVM InterpreterIn GraalVM 19.3 clang and other LLVM tools are no longer required to beinstalled for building the GraalVM LLVM runtime. The LLVM toolchain bundled with GraalVM is used.Also the LLVM toolchain is not an “experimental” feature any more and is used by other languages.For example, save this native code demonstrating the interoperability with Java as a polyglot.c file:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 42);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}Now you can compile it using GraalVM drop-in replacement of traditional clang:$GRAALVM_HOME/jre/languages/llvm/native/bin/clang polyglot.c -o polyglotThen run the executable (polyglot) with its dependencies encoded in GraalVM LLVM runtime:lli polyglotList of features that have also been added:  Preliminary support for parsing bitcode produced by LLVM 9  Added intrinsics for pthread thread management functions  Support for pthreads LLVM bitcodeRefer to the component changelog on GitHub.Python  Updated Python standard library to 3.7.4.  Implemented support for NumPy 1.16.4 and Pandas 0.25.0, that can be installed with:$ graalpython -m ginstall install numpy$ graalpython -m ginstall install pandas  With the help of Weblogic Scripting Team in conversion of Jython into GraalVM Python,added Jython compatibility (enabled with --python.EmulateJython) that allows importing ofJava classes and catching of Java exceptions in Python the same way Jython allows it.$ graalpython --jvm --experimental-option --python.EmulateJython&amp;gt;&amp;gt;&amp;gt; import sun.misc.Signal&amp;gt;&amp;gt;&amp;gt; from java.lang import Integer, NumberFormatException&amp;gt;&amp;gt;&amp;gt; try:...   Integer.parseInt(&quot;99&quot;, 8)... except NumberFormatException as e:...   pass  Added support for basic sockets. Note that SSL is not implemented, thus there is no https yet:import urllib.requestprint(urllib.request.urlopen(&quot;http://google.com&quot;).read())  Implemented missing functions and fixed bugs to run various modules (timeit, socket, pytest).  Improved performance of Java interoperability, exceptions that do not escape,various C API functions, and the parser. The parser is ~20% faster now, sometimes upto ~40%, the performance in micro benchmarks is 5x faster, micro benchmarks forC API are 5x faster, but there is no change to NumPy performance numbers.To see a complete list of changes, please refer to the project changelog.R  FastR has been updated to R version 3.6.1.  In this release, FastR does not ship with GCC runtime libraries. Use the following commands to install the necessary dependencies:          Ubuntu 18.04 and 19.04: apt-get install libgfortran3 libgomp1      Oracle Linux 7: yum install libgfortran libgomp      Oracle Linux 8: yum install compat-libgfortran-48      MacOS: brew install gcc@4.9        Preview of support for LLVM based execution of R native extensions.          FastR is configured to use the GraalVM LLVM toolchain to compile the C/C++ and Fortran code of R packages. The resulting binarieswill contain both the native code and the LLVM bitcode. The R packages that are shipped with FastR were also compiledusing the GraalVM LLVM toolchain and their binaries contain the LLVM bitcode.      FastR loads and runs the R extensions native code by default, but when run with the option --R.BackEnd=llvm,it will load and run the LLVM bitcode if available. You can use the LLVM backend selectively for specific R packages via --R.BackEndLLVM=pkg1,pkg2.      If you encounter any issues when installing R packages, you can switch back from the GraalVM LLVM toolchainto the native toolchain by running fastr.setToolchain(&quot;native&quot;) or by manually editing the $FASTR_HOME/etc/Makeconf file.        Fixed memory leaks reported on GitHub.  Fixed failures when working with large vectors (&amp;gt;1GB).  Implemented grepRaw, but only for fixed=T.We encourage the users to experiment with the new LLVM support and report anyissues to GitHub. To see thecomplete list of changes, please refer to the projectchangelog.RubyA comprehensive list of changes to the Ruby language component is available on GitHub.The focus has been on improving compatibility with Ruby on Rails applications.Major changes include:  Compilation of C extensions is now done with an internal LLVM toolchain producing both native code and bitcode. This means more C extensions should compile out of the box and this should resolve most linker-related issues.  It is no longer necessary to install LLVM for installing C extensions on TruffleRuby.  It is no longer necessary to install libc++ and libc++abi for installing C++ extensions on TruffleRuby.  On macOS, it is no longer necessary to install the system headers package (#1417).  License updated to EPL 2.0/GPL 2.0/LGPL 2.1 like recent JRuby.  Installing sassc now works due to using the LLVM toolchain (#1753).  Include executables of default gems, needed for rails new in Rails 6.ToolsCode Coverage Command Line ToolAs of version 19.3 GraalVM provides a code coverage command line tool to recordand analyze the source code coverage of a particular execution of code forlanguages implemented with the Truffle framework. Enable it with --codecoverageoption, for example js --codecoverage. Visit the tool reference documentation for moreinformation.GraalVM VisualVM  Previously, to view the JFR files you had to install a plugin. Now GraalVM VisualVM contains the viewer in the tool core. Other JFR viewer improvements include new views for Exceptions and GC, improved performance and accuracy.  The tool is now able to monitor and profile AArch64 Java and Java 13 processes.Debugger  Enabled support for functional breakpoints and memory tools in Chrome Inspector.Visual Studio Code ExtensionsVSCode extensions are provided as VSIX packages. GraalVM team created the firstVSIX extension based on Python implementation. The extension installs with npmpackage manager and upon the extension installation, the user is requested topoint the PATH environment variable to GraalVM home directory.Changes for GraalVM Embedders (SDK)  Added new APIs for statement count resource limits:ResourceLimits.newBuilder()ResourceLimits.newBuilder()    .statementLimit(1000, null)    .build();              Duration.ofMillis(10))    .statementLimit(1000, null).build();try (Context context = Context.newBuilder()                .resourceLimits(limits).build()) {    context.eval(&quot;js&quot;, &quot;while(true);&quot;);    assert false;} catch (PolyglotException e) {    assert e.isCancelled();}  The default temporary directory can now be configured by FileSystem. A getTempDirectory()method of the FileSystem interface will return the default temporary directory.  Added the org.graalvm.home.Version version utility that allows to create, validate and compare GraalVM versions.  Added support for detecting and mapping polyglot exception values. Exceptions can be detected using Value.isException().  Added default target type mapping from guest language exceptions to PolyglotException.Proceed to the GraalVM SDK changelog for the complete list of changes.Changes for GraalVM Language or Tool Implementers (Truffle)  Added standard block node for language implementations. The block node usage allows the optimizingruntime to group elements of a block into multiple block compilation units. This optimization may beenabled using --engine.PartialBlockCompilation (on by default) and configuredusing --engine.PartialBlockCompilationSize (default 3000).  Merged new experimental inlining heuristic. Inlining budgets are now based on Graal IR nodecounts and no longer Truffle Node counts.  Support boolean literals in Truffle DSL expressions. Use true or false in expressions,e.g., isFunction(value) == false.  Added support for temporary files and directories.  Threads created by the embedder may now be collected by the GC before they canbe disposed. If languages hold onto thread objects exposed viainitializeThread they now need to do so with WeakReference. This avoidsleaking thread instances.  Added the new execute method to LoopNode, which allows loops to return values.To see the full list of changes to the APIs, proceed to theGraalVM Truffle changelog.",
                    "url": " /release-notes/19_3/"
                  },
                  
                  "downloads-20":  {
                    "title": "",
                    "content": "",
                    "url": " /downloads/20/"
                  },
                  
                  "release-notes-20-0":  {
                    "title": "",
                    "content": "20.0.0(2020-02-18)GraalVM Platform UpdatesGraalVM 20.0 improves significantly on the previously available GraalVM buildsfor Windows platforms. Windows is no longer an experimental platform in the GraalVM ecosystem.Windows builds now contain the functional gu utility to install thecomponents. GraalVM Native Image component needs to be installedwith gu as on other platforms. JavaScript engine is now included in the GraalVM Windows distribution. Node.js support on the Windows platform is scheduled to be included in the next GraalVM release (20.1).GraalWasm, the WebAssembly component, is distributed through the usual component distribution channels.The GraalVM distribution for AArch64 now includes a functional node.js runtime (both in --jvm and native modes).Java  GraalVM Community Editions are based on OpenJDK version 1.8.0_242 and OpenJDK version 11.0.6.  GraalVM Enterprise Editions are based on Oracle JDK version 1.8.0_241 and Oracle JDK version 11.0.6. You can find the JDK release notes at the Oracle Technology Network website.  Added mitigation of Jump Conditional Code (JCC) Erratum (see #1829).  GraalVM has a default setting of ThreadPriorityPolicy=1, which means thread priorities set in Java are reflected by native operating sytstem thread priorities. This may affect Java application performance.Native Image  Native Image support on Windows has significantly advanced. Please report issues if you find any problems.  Native images built with GraalVM Enterprise can now include a G1-based low-latency garbage collector that reduces stop-the-world pauses and improves latency. It is an experimental feature that can be enabled at image build time with -H:+UseLowLatencyGC. For more details, please refer to the documentation.  Fixed several Java Native Interface (JNI) and JDK11 related issues, please refer to GitHub for more information.JavaScript  Updated Node.js to 12.15.0, please see Node.js 12.15.0 release notes.  Added the js.commonjs-require option to load npm-compatible CommonJS modules from plain JavaScript. This is an experimental feature. See NodeJSVSJavaScriptContext.md for details.  Added the js.load-from-classpath option to allow loading files from the classpath via the classpath: pseudo URLs (disabled by default). Its usage is not recommended with untrusted code.  Added the implementation of the String.prototype.replaceAll proposal. It is available in ECMAScript 2020 mode (--js.ecmascript-version=2020).  Updated String.prototype.matchAll to be available only in ECMAScript 2020 mode (--js.ecmascript-version=2020).  Added the js.bind-member-functions option for the implicit binding of unbound functions returned by Value.getMember to the receiver. The preferred way of calling members is using Value.invokeMember.  Made the support for Nashorn pseudo URLs available only in the Nashorn compatibility mode (--js.nashorn-compat).  Implemented support for public and private class fields, including static fields. This feature can be enabled using the experimental option js.class-fields and is available by default in Node.js.  Added the js.global-arguments option with true as a default value for the non-standard arguments global property.More details can be found in the project changelog on GitHub.LLVM Runtime  The toolchain is now based on LLVM 9.0.0.  Support accessing llvm-ar, llvm-nm, llvm-objcopy, llvm-objdump, llvm-ranlib, llvm-readelf, llvm-readobj and llvm-strip via the toolchain.For more details refer to the component changelog on GitHub.Python  Improved Jython Compatibility by implementing syntax from JavaType import * to import all static members of a Java class, and by enabling import of Python code from inside JAR files by adding path/to/jarfile.jar!path/inside/jar to sys.path.  Added support for date and time interop.  Added support for setting the time zone via Context.Builder.timeZone.  Implemented PEP 570 - Python Positional-Only Parameters.To see a complete list of changes, please refer to the project changelog.R  On Linux, the required version of libgfortran changed from 3 to 5. See the requirements section for details.  Implemented subsetting an array by numeric and/or string matrix.  Fixed an issue where polyglot value is not an object (see #123).  Fixed an issue with the incorrect formatting for sprintf %g and %G (trailing zeroes, see #126).  Added  R builtins and C APIs:          Ported all external C functions used by nlm (see #100) and fisher.test from the stats base package.      Added Rf_asS4 C API function (see #118).      More details can be found in the project changelog on GitHub.RubyA detailed changelog for the Ruby component is available on GitHub.  Updated to Ruby 2.6.5 (see #1749).  Updated the internal LLVM toolchain to LLVM 9 and reduce its download size.  Automatically set PKG_CONFIG_PATH as needed for compiling OpenSSL on macOS (see #1830).  Performance improvements related to sockets and RSTRING_PTR.  100+ compatibility and bug fixes, please refer to the changelog.Changes for GraalVM Embedders (SDK)  The deprecated graalvm.home and graalvm.version system properties have been removed, use the HomeFinder instead.  Added EventContext.createError which allows to introduce guest application errors in execution listeners/nodes.  Added Context.Builder.currentWorkingDirectory to set the current working directory used by the guest application to resolve relative paths.  The algorithm used to generate a unique URI for a Source built without an URI was changed to SHA-256.  All Truffle Graal runtime options (-Dgraal.) will be deprecated with 20.1. The Truffle runtime options are no longer specified as Graal options (-Dgraal.). The Graal options must be replaced by corresponding engine options specified using the polyglot API. The TRUFFLE_STRICT_OPTION_DEPRECATION environment variable can be used to detect usages of deprecated GraalVM options. When the TRUFFLE_STRICT_OPTION_DEPRECATION is set to true and the deprecated Graal option is used, the Truffle runtime throws an exception listing the used deprecated options and corresponding replacements.More details are in the SDK and Truffle changelogs.Tooling  Added an option for gu to install all available components from a local directory, for example: gu install -C /path/to/downloaded/20.0-components/ native-image llvm-toolchain ruby r python wasm.  Added a JDK Flight Recorder Data Viewer to VisualVM.  Added an integration of T-trace instrumentation framework with OpenTracing.  Added LLVM languages support to T-trace instrumentation framework  Added a Technology Preview of the Language Server Protocol implementation for GraalVM languages and its support to GraalVM VSCode Extensions.",
                    "url": " /release-notes/20_0/"
                  },
                  
                  "release-notes-20-1":  {
                    "title": "",
                    "content": "20.1.0(2020-05-19)Java  GraalVM Community Edition is based on OpenJDK version 1.8.0_252 and OpenJDK version 11.0.7.  Oracle GraalVM Enterprise Edition is based on Oracle JDK version 1.8.0_251 andOracle JDK version 11.0.7. You can find Oracle JDK release notes for theseversions at the Oracle Technology Network website.  Added support for compiling classes with irreducible loops in the bytecode. Theseoften occur in Kotlin applications using coroutines with loops. The supportboth improves performance of such applications and enables their ahead-of-time compilation.  [GraalVM Enterprise] Added new TuneInlinerExploration option to increase or decrease the time spentexploring inlining opportunities. Tuning this option helps to achieve betterpeak performance or limit time to reach (potentially lower) peak performancewhich might improve overall speed of the program. This option is only aheuristic and should be tuned for a specific application.  Added support to optimize away some redundant clone operations. For example, incode patterns similar to the one below, the GraalVM compiler will avoid creatingthe array clone:new int[length].clone().length      Added support for visualizing libgraal memory usage in VisualVM:    The mitigation of the Intel JumpConditional Code (JCC) Erratum is now only enabled for CPUs that need it.  Significantly improved performance for some benchmarks on JDK 11 due to fixes inthe area of synchronization. The most notable improvement isRenaissance:reactorswhich shows approximately 50% better results.Native Image  Improved scalability of the static analysis. The static analysis time wasinfeasible for some large applications. We added a new mechanism, called“saturated type flows”, to make the analysis faster. The new analysis isdisabled by default for GraalVM 20.1, but we plan to enable it by default in afuture release. We encourage all users to try it out using the image builderoption -H:+RemoveSaturatedTypeFlows. According to our measurements theprecision of the static analysis is comparable, but if you have an applicationwhere many more classes or methods are reachable with this option please create an issue on GitHub.  Added new option for the image generator to exit handlers on terminationsignals: --install-exit-handlers. This improves the user experience whenrunning a native image in a Docker container as the init process, since Linuxdoes not install a default signal handler for the process with id “1” and thenative image is therefore not reacting to a shutdown request from Docker.  Improved support for soft references. Before 20.1, soft references (the JavaSoftReference class) were cleared immediately at every GC like weakreferences. Now they are cleared based on a policy that takes the last accessand the memory pressure into account.  Added survivor spaces to the GC. Disabled by default until a proper policy isimplemented, see this GitHub issue for ideas and tasks aroundGC in native images.  Added generation of Dwarf debug information.  Improved support for timezones: information about all timezones is now includedin every image, and the default timezone is correctly initialized at imagestartup and no longer fixed at image generation time.  Improved checking that the native compiler toolchain is correct, for example,whether the compiler version on Windows is correct. This avoids strange errors dueto known incompatible compiler versions.Many more compatibility improvements and bug fixes can be found on GitHub. Forexample, here is a list of fixed issues relevant for Spring framework support.JavaScript  Enabled ECMAScript 2020 mode features by default.  Implemented several ECMAScript proposals, including Optional Chaining, HashbangGrammar, FinalizationRegistry, private class methods, RegExp Match Indices,export * as ns from &quot;mod&quot;, Intl.Locale, Intl.DisplayNames, Intl.DateTimeFormatdateStyle and timeStyle.  Added npx (npm package runner) utility into GraalVM distributions.  Removed the JOni RegExp-engine and the use-tregex option. TRegex engine is now the default regex engine.  Removed our SIMD.js implementation.LLVM Runtime  [GraalVM Enterprise] Added a preliminary support for running C++ code in managed mode.  [GraalVM Enterprise] Updated musl libc to version 1.1.24.  Both libc++ and libc++abi are now shipped as bitcode libraries.  Improved C++ support, libsulong++ is loaded only if libc++ is loaded. Theexecutables (ELF, Mach-O) compiled with the toolchain usually have a dependencyon this library and will continue to work. Plain bitcode files, which do notallow specification of dependencies, may fail with an error similar to thefollowing:    Global variable ZNSt3_15ctypeIcE2idE is declared but not defined.    This can be solved, for example, by specifying the dependency on the commandline lli --lib libc++.so.1 ... on Linux or lli --lib libc++.1.dylib onmacOS.    Changed module initialization order to be only based on the dependenciesrecorded in the ELF/Mach-O file (instead of looking at imported symbols). Thismight change the order in which plain bitcode files are initialized since theydo not allow recording dependencies. If the initialization order is important,the suggested approach is to use ELF/Mach-O files. See theToolchaindocumentation for more details.  Added support for on-stack-replacement of loops during bitcode execution, now itcan compile long-running loops before the surrounding function is compiled.Python  Updated to Python 3.8.2.  Improved tuples with primitive elements performance.  Improved performance of sequences, sets, dicts, and list expressions.  Added support of cProfile and trace modules through the GraalVM CPU sampler and coverage, respectively.  Added support of NumPy on macOS.  Added support of setuptools-scm and pytz.timezone.  Added support of a new syntax for iterable unpacking from yield and return statements.  Fixed issues with inspection and printing of non-Python numbers in the Chrome debugger.  Fixed issues with AST sharing across different contexts when these contexts run concurrently on multiple threads.  Fixed passing non-ASCII strings to gethostbyname.  Improved Jython compatibility mode: treat Java null as identical to Python None when comparing with the is operator.  Improved Jython compatibility mode: isinstance now works with Java classes and objects.  Moved all GraalPython specific functions on sys or builtins to the _graalpython_ module.To see a complete list of changes, please refer to the project changelog.R  Preview of improved graphical support based on the graphics, grDevices, and JavaGD packages          Use --R.UseInternalGridGraphics=false to activate this feature.      Our custom grid package re-implementation, which is currently the default, will be first deprecated and then removed in future releases.        Included GCC runtime libraries for supported systems (Linux and macOS)  Removed GFortran as a requirement to run FastR.  The GFortran runtime libraries versions are 4.8.5 on Linux and 8.3.0 on macOS. When compiling additional R packages with Fortran code, one must use GFortran of the same or higher version.          There’s a known issue: the libgomp.1.dylib library is not distributed with FastR on MacOS. To workaround this issue: install GCC with the package manager of your choice, e.g., brew install gcclocate file libgomp.1.dylib. Variable $GOMPLIB will denote full path to this library and $R_HOMEthe path to R installation:$GRAALVM_HOME/jre/languages/R on JDK8 based builds$GRAALVM_HOME/languages/R on JDK11 based buildsexecute these two commands:install_name_tool -change /cm/shared/apps/gcc/8.3.0/lib/libgomp.1.dylib $GOMPLIB $R_HOME/lib/libRblas.dylibinstall_name_tool -change /cm/shared/apps/gcc/8.3.0/lib/libgomp.1.dylib $GOMPLIB $R_HOME/lib/libRlapack.dylib        GFortran is now the default Fortran compiler even in the LLVM toolchain configuration.  Added support for traceback() to show frames from other GraalVM languages and C/C++ when run in the LLVM mode (--R.BackEnd=llvm).  Improved interoperability with other languages: “@” and “$” can be used to access members of foreign polyglot objects.A detailed list of the changes and bug fixes is available in the project changelog.Ruby  Added nightly builds, see the README for details.  ||= will not compile the right-hand-side if it is only executed once, to match the idiomatic lazy-initialization use-case (see the blog post).  Optimized performance of bundle install.  Added the --metrics-profile-require option to profile searching, parsing, translating and loading files.  Changed the C API type VALUE to be defined as unsigned long as on MRI. This enables using switch (VALUE) and other expressions which rely on VALUE being an integer type.  Removed deprecated Truffle::System.full_memory_barrier, Truffle::Primitive.logical_processors, and Truffle::AtomicReference.  Improved interoperability with other languages: hash keys are no longer reported as polyglot members.  Added Truffle::Interop.hash_keys_as_members to treat a Ruby Hash as a polyglot object with the Hash keys as members.Other 56 bug fixes and 52 compatibility improvements, see a detailed changelog.ToolingChrome Inspector  Implemented the display of asynchronous stack traces in debugger, in Chrome Inspector and in exception traces.Language Server Protocol  Improved stability of GraalVM Language Server and GraalVM VSCode Extensions.  Changed to start GraalVM Language Server in the native mode for better startup performance.  Stabilized support for LSP in R and Ruby.VisualVM  Enabled VisualVM to monitor libgraal memory usage.  Implemented showing compiled and interpreter time in the GraalVM sampler.  Improved JFR viewer to display stack traces for JFR events.Ideal Graph Visualizer      Added grouping of graph dumps by session:    Added an action to go to compiler classes.  Improved stability of IGV to no longer hang on some graph layout.GraalVM Updater gu  Added support for wildcards when GraalVM Updater installs from a directory (-C).Updates for Polyglot Embedders  Added Value.isMetaObject(), Value.getMetaQualifiedName(), Value.getMetaSimpleName() and Value.isMetaInstance(Object) to allow language agnostic access to meta-objects like classes or types.  The result of Value.getMetaObject() will always return meta-objects. It is recommended but not required to change uses of meta-objects to use Value.getMetaQualifiedName() instead of Value.toString() to return a type name.  Added OptionDescriptor.getDeprecationMessage returning the option deprecation reason. Added OptionDescriptor.Builder.deprecationMessage() to set the option deprecation reason.  Added Context.Builder.hostClassLoader to allow an embedder to specify a context ClassLoader for code execution.More changes can be found in the GraalVM SDK changelog.Updates for Language and Tool Implementers  engine.Mode is now a supported option and no longer experimental.  Added new meta-data APIs to InteropLibrary:          has/getLanguage(Object receiver) to access the original language of an object      has/getSourceLocation(Object receiver) to access the source location of an object (e.g., a function or classes)      has/toDisplayString(Object receiver, boolean allowsSideEffect) to produce a human-readable string      has/getMetaObject(Object receiver) to access the meta-object of an object      isMetaObject(Object receiver) to find out whether an object is a meta-object (e.g., Java class)      getMetaQualifiedName(Object receiver) to get the qualified name of a meta-object      getMetaSimpleName(Object receiver) to get the simple name of a the meta-object      isMetaInstance(Object receiver, Object instance) to check whether an object is an instance of a meta-object        Added TruffleLanguage.getLanguageView that allows to wrap values to add language specific information for primitive and foreign values.  Added TruffleLanguage.getScopedView that allows to wrap values to add scoping and visibility to language values.  Added TruffleInstrument.Env.getScopedView and TruffleInstrument.Env.getLanguageView to access language and scoped views from instruments.  Added TruffleInstrument.Env.getLanguageInfo to convert language classes to LanguageInfo.  Added @GenerateLibrary(dynamicDispatchEnabled = false) that allows to disable dynamic dispatch semantics for a library. The default is true.  Added ability to load external default exports for libraries using a service provider. See GenerateLibrary(defaultExportLookupEnabled = true).  Added @ExportLibrary(transitionLimit=&quot;3&quot;) that allows the accepts condition of exported libraries to transition from true to false for a library created for a receiver instance. This is, for example, useful to export messages for array strategies.  Added support for asynchronous stack traces for languages and tools to allow debuggers to show them.To see a full list of changes to APIs, proceed to theGraalVM Truffle changelog.",
                    "url": " /release-notes/20_1/"
                  },
                  
                  "release-notes-20-2":  {
                    "title": "",
                    "content": "20.2.0(2020-08-18)Java  GraalVM Community Edition is based on OpenJDK version 1.8.0_262 and OpenJDK version 11.0.8.  [GraalVM Enterprise] Oracle GraalVM Enterprise Edition is based on Oracle JDK version 1.8.0_261 and Oracle JDK version 11.0.8.0.2. You can find Oracle JDK release notes for these versions at the Oracle Technology Network website.  Added the ability to release the memory used by libgraal to the OS when an application enters a stable phase and compilation goes idle. This is achieved by attaching each compiler thread to a libgraal isolate. The number of compiler threads that can be attached to an isolate is controlled by the jvmci.ThreadsPerNativeLibraryRuntime system property. The default is all threads attached to a single isolate. Isolates are initialized on demand to handle extra compiler threads. When a compiler thread becomes idle (idleness delay is configurable by jvmci.CompilerIdleDelay), it detaches itself from its isolate. As the last thread detaches from an isolate, it is shutdown and its memory (i.e., the libgraal heap) is released to the OS. This feature has the following of advantages:          It can reduce the RSS memory footprint of a GraalVM process. If the compiler is not being used, it uses no resources.      [GraalVM Enterprise] If multiple isolates are used, it mitigates interference between complier threads. For example, there is less contention on shared objects and a garbage collection in one isolate will not pause threads in other isolates.        [GraalVM Enterprise] Improved the optimization responsible for removing redundant read/write, array clone() and accesses to the cloned arrays operations. Workloads that heavily use array read/write operations, especially inside loops, in combination with allocations may benefit from this optimization. As a result of the enhanced read/write optimization, the speedups of up to 2.5x on the JetStream benchmarks were seen with GraalVM JavaScript engine.  [GraalVM Enterprise] Added an experimental partial loop unrolling optimization. Partial loop unrolling is an extended form of traditional loop unrolling optimization that works for arbitrary counted loops with an unknown upper bound of loop iterations i. The optimization is not enabled by default, you can experiment with the optimization by enabling it with -Dgraal.EnterprisePartialUnroll=true. Note, the optimization is still experimental and thus may lead to unknown errors.  Fixed an error in code generation which was leading to incorrect behaviour of programs using the Apache commons-compress BZip2 implementation (see #2534).  Improved excessive compile time of certain programs (see #2548).  Improved error reporting with libgraal. Fatal errors in libgraal now produce a hs-err crash log that can substantially improve triaging and debugging such errors. Likewise, low level libgraal output, such as libgraal GC messages produced by -Dlibgraal.PrintGC=true are routed to HotSpot’s log stream. That is, libgraal error handling and logging is unified with HotSpot support for these features and thus configurable by options such as -XX:LogFile and -XX:OnError.  Renamed the MitigateSpeculativeExecutionAttacks compiler option to SpectrePHTBarriers (e.g., use -Dgraal.SpectrePHTBarriers=AllTargets for java or --vm.Dgraal.SpectrePHTBarriers=AllTargets for js).Native Image  [GraalVM Enterprise] Improved the G1GC-like garbage collection for workloads where Native Image requires smaller GC pauses. More details are in the documentation on how to enable and configure it documentation on how to enable and configure it.  Improved generation of native images statically linked against muslc. If you have musl-gcc on the path, you can now generate a native image statically linked against muslc with the following options: --static --libc=musl. More information about this is available in the documentation.  Added an option to create “mostly static” native images which link statically everything except libc. Native images built this way are convenient to use in small docker images, for example, based on distroless/static. Enable nearly static native image generation with the following option: -H:+StaticExecutableWithDynamicLibC.  Enabled -H:+RemoveSaturatedTypeFlows by default, which should result in faster native image generation and use less memory for the generation.  Changed the class initialization strategy to initialize at build time only a small part of the JDK library. To get the previous behaviour back, use --initialize-at-build-time option for necessary packages.  Many other improvements and bug fixes can be found in the repository.JavaScript  Updated Node.js to version 12.18.0. Notable changes in this release are available from the Node.JS project website.  Updated ICU4J library to version 67.1.  Implemented the Intl.NumberFormat Unified API proposal.  Implemented the Logical Assignment Operators proposal.  Implemented the Top-level Await proposal.  Implemented the Promise.any proposal. It is available in ECMAScript 2021 mode (--js.ecmascript-version=2021).  Implemented support for async stack traces.  Fixed Date.toLocaleString and Intl.DateTimeFormat to use the context’s default time zone rather than the system default if no explicit time zone is requested.  Improved js.timezone option to validate the time zone ID and support zone offsets like “-07:00”.Updates for Language and Tool Implementers  Enabled by default the new inlining heuristic in which inlining budgets are based on Graal IR node counts and not on Truffle Node counts. More information can be found in the Inlining guide.  Added support for subclassing DynamicObject so that guest languages can directly base their object class hierarchy on it, add fields and use @ExportLibrary on subclasses.  Added new DynamicObjectLibrary API for accessing and mutating properties and the shape of DynamicObject instances. More information can be found in the Dynamic Object Model guide.  Added new identity APIs to InteropLibrary:          hasIdentity(Object receiver) to find out whether an object specifies identity      isIdentical(Object receiver, Object other, InteropLibrary otherLib) to compare the identity of two object      isIdenticalOrUndefined(Object receiver, Object other) to specify the identity of an object      identityHashCode(Object receiver) to implement maps that depend on identity        Added Truffle DSL @Bind annotation to common out expression for use in guards and specialization methods.  Added the ability to disable adoption for DSL cached expressions with type node using @Cached(value =&quot;...&quot;, weak = true).  Added an option not to adopt the parameter annotated by @Cached, using @Cached(value =&quot;...&quot;, adopt = false).  Added CompilerDirectives.shouldNotReachHere() as a short-cut for languages to indicate that a path should not be reachable neither in compiled nor interpreted code paths.More details are available from the changelog.Updates for Polyglot Embedders  Added Context.parse(Source) to parse but not evaluate a source. Parsing the source allows to trigger e.g., syntax validation prior to executing the code.  Added PolyglotException.isResourceExhausted() to determine if an error was caused by a resource limit (e.g., OutOfMemoryError) that was exceeded.  Added a factory method creating a FileSystem based on the host Java NIO. The obtained instance can be used as a delegate in a decorating filesystem.  Added optional FileSystem.isSameFile method testing if the given paths refer to the same physical file. The method can be overridden by the FileSystem implementer with a more efficient test.More details are available from the changelog.ToolingVS Code  Updated Language Server Protocol (LSP) implementation to support the latest protocol version 3.15.  Updated VSCode extension by merging into one. More details about Visual Studio Code Extension.  Added showing code coverage from GraalVM LSP in VS Code.VisualVM  Updated VisualVM to use NetBeans platform 11.3.  Added GoToSource from VisualVM to your preferred IDE.Ideal Graph Visualizer[GraalVM Enterprise]  Implemented usability improvements for graphs identification in IGV (IGV graph now displays a dump ID and a user label with Graph name).  Added Go To Type and Attach Debugger actions.  IGV updated to NetBeans platform to 11.3.LLVM Runtime  Added support for InteropLibrary.isIdentical and related messages.  Added the --print-toolchain-api-identifier, --print-toolchain-api-tool &amp;lt;tool-name&amp;gt; and --print-toolchain-api-paths &amp;lt;path-name&amp;gt; arguments to the lli launcher. These can be used to query the Toolchain API from the command line.  Added support for requesting locations via the #getPaths() method to the Java API of the Toolchain. For example, the location of the toolchain executables or libraries.  Added llvm/api/toolchain.h header for accessing the Toolchain from C code.  Added ability to read and write bigger values to a polyglot i8 array. For example, when reading an i64 from a foreign value that is typed as i8 array, the LLVM runtime will read 8 i8 values and combine them to an i64 result.  Removed the --llvm.sourcePath option (deprecated since 19.0). Use --inspect.SourcePath instead.  Removed support for the application/x-llvm-ir-bitcode-base64 mime-type (deprecated since 19.0).Python  Improved reference counting for native extensions to prevent memory leaks.  Added code serialization to .pyc files (.pyc files persistently store the Python bytecode compiled from the source .py files).  Fixed warning in pandas about size of the datetime objects.  Improved compatibility (more CPython unittests pass for core types).  Added support for parsing requests with arguments for embedding Python.  Added support for the basic usage of tox – a Python testing wrapper.  Removed support for iterables as arrays in polyglot applications.  [GraalVM Enterprise] Added a faster implementation of _struct.R  Improved SVG support activated with the --R.UseInternalGridGraphics=false flag.  Improved FastR user experience: FastR should have no requirements on both Linux and macOS i.e., installing GCC or GFortran should not be necessary to run FastR, but it may be necessary to install some third party R packages.RubyNew features:  Updated to Ruby 2.6.6.  Configured Ruby to always show core library files in backtraces.  The Java stacktrace is now shown when sending SIGQUIT to the process, also on TruffleRuby Native, see Debugging for details.  Use InteropLibrary#toDisplayString() to better display objects from other languages.  foreign_object.to_s now uses InteropLibrary#toDisplayString() (and still asString() if isString()).  foreign_object.inspect has been improved to be more useful (include the language and meta object).  foreign_object.name = value will now call Interoplibrary#writeMember(&quot;name&quot;, value) instead of invokeMember(&quot;name=&quot;, value).  Calls to foreign objects with a block argument will now pass the block as the last argument.  foreign.name will now use invokeMember if invocable and if not use readMember. See doc/contrib/interop_implicit_api.md for details.Bug fixes:  Fix #class_exec, #module_exec, #instance_eval, and instance_exec to use activated refinements (@ssnickolay).  Use upgraded default gems when installed.  The output for --engine.TraceCompilation is now significantly easier to read, by having shorter method names and source names.  Fixed indentation for squiggly heredoc syntax with single quotes.  Fixed missing flushing when printing an exception at top-level with a custom backtrace, which caused no output to be shown.Compatibility:  Implemented Ripper by using the C extension.  Implemented ObjectSpace::WeakMap.  Supported #refine for Module (@ssnickolay).  Fixed refine + super compatibility (@ssnickolay)  Implemented UnboundMethod#bind_call.  RUBY_REVISION is now the full commit hash used to build TruffleRuby, similar to MRI 2.7+.  Changed the lookup methods to achieve Refinements specification (@ssnickolay)Performance:  Enabled lazy translation from the parser AST to the Truffle AST for user code by default. This should improve application startup time.  instance variable ... not initialized and similar warnings are now optimized to have no peak performance impact if they are not printed (depends on $VERBOSE).  Implemented integer modular exponentiation using BigInteger#mod_pow ( @skateman).  Fixed a performance issue when computing many substrings of a given non-leaf String with non-US-ASCII characters.  Speedup native handle to Ruby object lookup for C extensions.Changes:  RubyGems gem commands updated to use the --no-document option by default.",
                    "url": " /release-notes/20_2/"
                  },
                  
                  "release-notes-20-3":  {
                    "title": "",
                    "content": "20.3.2(2021-04-20)GraalVM Community Edition 20.3.2 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community Edition 20.3.x.It also includes:  update to 8u292 for Java 8 based GraalVM Community, please see OpenJDK 8u292 Updates  update to 11.0.11 for Java 11 based GraalVM Community, please see OpenJDK 11.0.11 Updates  Node.js runtime update to 12.22.1 which contains all security fixes mentioned in April 2021 Security Releases20.3.1.2(2021-02-11)This is a bug fix release for the GraalVM 20.3.x branch.It contains operational changes to GraalVM Updater - a tool for installing optional GraalVM language runtimes and utilities, and for updating your local GraalVM installation.  Enhanced the upgrading policies to prevent components not being upgraded when migrating from GraalVM Community to GraalVM Enterprise Edition (gu upgrade --edition ee).  Improved handling the license acceptance by gu when a user is prompted to accept “Oracle GraalVM Enterprise Edition Native Image License”.20.3.1(2021-01-19)GraalVM Community Edition 20.3.1 is a Critical Patch Update (CPU) release.It is based on OpenJDK CPU and includes all the OpenJDK security fixes released as part of that CPU.It is a full distribution and supersedes the previous release of GraalVM Community 20.3.0.It also includes the following:  Update to OpenJDK version 8u282 for Java 8 based GraalVM Community, please see please see OpenJDK 8u282 Updates  Update to OpenJDK version 11.0.10 for Java 11 based GraalVM Community, please see OpenJDK 11.0.10 Updates20.3.0(2020-11-17)Java  GraalVM Community Edition is based on OpenJDK version 1.8.0_272 and OpenJDK version 11.0.9.  [GraalVM Enterprise] Oracle GraalVM Enterprise Edition isbased on Oracle JDK version 1.8.0_271 and Oracle JDK version 11.0.9. You canfind Oracle JDK release notes for these versions at the Oracle Technology Network website.  Improved eliminating or delaying class loading from libgraal until after itsinitialization. This improves performance on workloads with very shortiterations (in milliseconds). It also fixes problems related to VM assumptionsabout the JIT compiler not loading classes, which could lead to races andsometimes deadlocks.  [GraalVM Enterprise] Improved conditional moveoptimization: GraalVM Enterprise contains an optimization that uses the CPU’sconditional move (CMOV) instruction to implement certain conditionalstatements. In this release we have improved this optimization to give higherand more predictable performance for workloads sensitive to conditional moveinstructions.  [GraalVM Enterprise] Improved heuristics in GraalVMEnterprise for loop peeling optimization for workloads where the first iterationinitializes array objects lazily. This is a common pattern in GraalVM’s Pythonruntime of Python iterators. It results in performance improvements for microPython benchmarks of up to 40%.  [GraalVM Enterprise] Improved code generated by GraalVMEnterprise for initializing newly allocated arrays, fixing a performance issuewhere large array allocations were initialized twice.  [GraalVM Enterprise] Improved the heuristics for the codeduplication optimization in GraalVM Enterprise which gives a peak performanceimprovement of up to 17% on some LLVM workloads and a 5% increase on some Javaworkloads.Native image  Improved container awareness: on Linux, the resource limits - processor count,memory size -  are read from cgroup V1 and V2 configurations. The processorcount can also be overridden on the command line using the option-XX:ActiveProcessorCount=.  Improved the “isolated compilation” that separates applications and theruntime compiler from each other, which improves performance by reducinginterference between them, for example, due to garbage collection.  [GraalVM Enterprise] The G1 garbage collector now also supportsnative images that use runtime-compiled code. It can be enabled at image buildtime using the option --gc=G1. G1 support is currently limited to Linux onAMD64. Windows and macOS support will be available in future releases. G1 nowalso supports performance counters (when the image is built with-H:+AllowVMInspection).  Improved the options to enable and disable assertions which now support the fullsyntax to specify package and class names. Assertions need to be configured atimage build time, using the options -ea / -da / -esa / -dsa. Thedefinition of “system assertions” is expanded to not only include assertions inthe JDK, but also in the Native Image runtime system, for example, in the garbagecollector implementation.  Added basic debug information generation on Windows (developed in collaboration with Red Hat).  Added many small performance and memory footprint optimizations. In particular,a new implementation of type checks improves the performance ofClass.isInstance and Class.isAssignableFrom with less type data in the imageheap.  Added support for method handles that represent a call to a single methodaccessible by the Reflection API, with no transformations applied through theMethod Handles API, such as calls to MethodHandle.bindTo() orMethodHandle.asType(). To enable this feature use--report-unsupported-elements-at-runtime.  Many other bug fixes and improvements which can be found in the GitHub repository.Updates for Language and Tool Implementers  Enabled by default the elastic allocation of the compiler threads dependingon the number of available processors, in both JVM and native modes. The oldbehaviour, 1 or 2 compiler threads, can be explicitly enabled with--engine.CompilerThreads=0.  Added ThreadsActivationListener to listen to the thread enter and leave events in instruments.  Added new flags to inspect the expansion during partial evaluation:--engine.TraceMethodExpansion=truffleTier,--engine.TraceNodeExpansion=truffleTier,--engine.MethodExpansionStatistics=truffleTier and--engine.NodeExpansionStatistics=truffleTier. Language implementations areencouraged to run with these flags enabled and investigate their output forunexpected results. See Optimizing.md for details.  Added TruffleInstrument.Env.getOptions(TruffleContext) to retrieve contextspecific options for an instrument and TruffleInstrument.getContextOptions()to describe them. This is useful if an instrument wants to be configured percontext.  Added the ability to create context and context thread locals in languages and instruments. See ContextLocal and ContextThreadLocal classes for details.  Added NodeLibrary, which provides guest language information associated with aparticular Node location, the local scope mainly and TruffleLanguage.getScopeand TruffleInstrument.Env.getScope, which provides a top scope object of a guestlanguage.  Added ByteArraySupport: a helper class providing safe multi-byte primitive type accesses from byte arrays.  Added a new base class for the exceptions, see AbstractTruffleException. The original TruffleException has been deprecated. Added new interop messages for exception handling replacing the deprecated TruffleException methods.  Added new specialization utility to print detailed statistics about specialization instances and execution count. See Specialization Statistics for details on how to use it.  More details are available from the changelog.Updates for Polyglot Embedders  Added Context.interrupt(Duration) to interrupt a polyglot Context execution. The interrupt is non-destructive meaning that the polyglot Context can still be used for further execution.  Added the ability to specify a TargetMappingPrecedence of target type mappings for HostAccess configurations that influence conversion order and precedence in relation to default mappings and other target type mappings.  Added a log.file option that allows redirection of all languages, instrument or engine logging to a file. The handler configured with the Context.Builder.logHandler method has precedence over the new option.  [GraalVM Enterprise] Added experimental sandbox resource limits for languages implemented on top of the Truffle language implementation framework.  More details are available from the changelog.JavaScript  Updated Node.js to version 12.18.4.  Fixed field/getter/setter access order in a Nashorn compatibility mode, see #343.  Fixed “Multiple applicable overloads found” error in a Nashorn compatibility mode, see #286.  Enabled low precedence lossy number, string-to-boolean, and number-to-boolean conversions in a Nashorn compatibility mode.  Fixed Java.extend to respect HostAccess.Builder.allowImplementations, see #294.  Added Java host interoperability support for mapping JavaScript objects to abstract classes (if HostAccess allows it).  Added js.foreign-object-prototype as a supported option to set JavaScript prototypes for foreign objects mimicing JavaScript types. It was renamed from js.experimental-foreign-object-prototype.  Changed ToPrimitive abstract operation to follow the specification for foreign objects. InteropLibrary.toDisplayString is not used by ToPrimitive/ToString conversions anymore.Ruby  Added handling foreign null object as falsy value (#1902).  Improve reliability of the post install hook by disabling RubyGems (#2075).  Fixed the top level exception handler to print exception cause (#2013).  Fixed handling of post arguments for super() (#2111).  Fixed constant/identifier detection in lexer for non-ASCII encodings (#2079, #2102).  Fixed parsing of --jvm as an application argument (#2108).  Added checking bounds for FFI::Pointer accesses when the size of the memory behind is known.  Implemented negative line numbers for eval (#1482).  Migrated from JLine 2 to JLine 3 for the readline standard library.  Added various warmup improvements, notably much less splitting and more operations are done inline, without a call.  Improved setting and access to the special variables $~ and $_ which has been refactored to require less splitting.  More details are available from the changelog.R  Improved compatibility with a preliminary implementation of the ALTREP framework: http://homepage.stat.uiowa.edu/~luke/talks/uiowa-2018.pdf  Exposed native function match5, which is necessary for R package fastmatch.  Added a few more smaller compatibility fixes and implemented missing APIs.  More details are available from the changelog.Python  Updated Python to version 3.8.5.  Added the experimental new HPy native API, so it is possible run piconumpy through HPy now.  The standalone graalpython version can now be installed through pyenv.  Many fixes to pass the unittests of standard library types and modules:complex, bytes, bytearray, subclassing of special descriptors, type layouts, float, generators, modules, argument passing corner cases, string literals and encodings, import and importlib, decimal, glob, the builtin module, json, math, operator, numeric tower, sys, warnings, random, f-strings, struct, itertools, super.LLVM runtime  Added support for code sharing in the GraalVM LLVM runtime. This allows the AST and compiled code of common bitcode libraries to be shared between multiple contexts within a single engine improving performance.  Updated LLVM toolchain to version 10.0.0.  Improved for va_list / varargs handling across language boundaries. Using va_start in an LLVM function that was called from a foreign language no longer forces all arguments into native memory. The resulting va_list object can be passed to code written in other languages, and accessed there using standard interop APIs.  Introduced the Handles API for storing managed pointers in native memory.  Moved polyglot.h to graalvm/llvm/polyglot.h and llvm/api/toolchain.h to graalvm/llvm/toolchain-api.h. The old header locations are deprecated, and will be removed in a future release.  Renamed libpolyglot-mock.so to libgraalvm-llvm.so. The old name is deprecated and will be removed in a future release.ToolingVisual Studio Code Extensions  Enhanced a VSCode GraalVM Extension with:          Java syntax highlighting      Java code completion      Installation wizard to download and install GraalVM Community or GraalVM Enterprise from the UI      Integrated Java debugger with all the features you would expect from a full featured IDE debugger like the Netbeans IDE      Integrated Polyglot debugger allowing to debug Javascript, Python, R, Ruby and other GraalVM languages        Implemented a VS Code Micronaut extension which:          Leverages all the great features of the Graal VS Code Extension for Java      Includes a Micronaut project wizard for creating new Micronaut applications      Includes Gradle and Maven support      Includes support to easily create a native executable from a Micronaut Gradle application using GraalVM Native Image      GraalVM Dashboard  Re-implemented GraalVM Dashboard with OracleJET.  Updated GraalVM Dashboard to accept new in Native Image dump format in BGV.",
                    "url": " /release-notes/20_3/"
                  },
                  
                  "downloads-21":  {
                    "title": "",
                    "content": "",
                    "url": " /downloads/21/"
                  },
                  
                  "release-notes-21-0":  {
                    "title": "",
                    "content": "21.0.0.2(2021-02-11)This is a bug fix release for the GraalVM 21.0.x branch.It contains operational changes to GraalVM Updater - a tool for installing optional GraalVM language runtimes and utilities, and for updating your local GraalVM installation.  Enhanced the upgrading policies to prevent components not being upgraded when migrating from GraalVM Community to GraalVM Enterprise Edition (gu upgrade --edition ee).  Improved handling the license acceptance by gu when a user is prompted to accept “Oracle GraalVM Enterprise Edition Native Image License”.21.0.0(2021-01-19)JavaUpdated the underlying JDK GraalVM is built on:  GraalVM Community Edition is based on OpenJDK version 1.8.0_282 and OpenJDK version 11.0.10.  [GraalVM Enterprise] Oracle GraalVM Enterprise Edition is based on Oracle JDK version 1.8.0_281 and Oracle JDK version 11.0.10. You can find Oracle JDK release notes for these versions at Oracle Java SE Downloads.Java on Truffle  Added an experimental Java Virtual Machine implementation based on a Truffle interpreter. Read more here.Container ImagesGraalVM Community images for Docker containers changed the location and now are available from GitHub Container Registry. See the guide.Platforms SupportAs of this version, we provide GraalVM distributions for Linux on ARM 64-bit system.All components including the GraalVM core are experimental.GraalVM Enterprise Edition is based on Oracle JDK11 for AArch64, and GraalVM Community Edition on OpenJDK 11 for AArch64 architecture accordingly.Native Image  Added serialization support for Native Image. The serialization support ensures constructors for classes are contained in a native image, so that they can be deserialized in the first place. These classes should be whitelisted in an additional specific configuration file, similar to the Reflection continuation, as some classes cannot be deserialized, including classes that might be part of the native image, but not listed in the configuration file. You can either create a configuration file manually or apply a Tracing Agent, provided with GraalVM, to help writing the configuration files.  Added method handle invocation support for Native Image (see #2761). Methods and fields accessed through method handles have to be registered in the Reflection configuration file. Also added method handles support to the Tracing agent to automatically generate the configuration for the native image build. Most use cases of method handles are supported. VarHandles that are not stored in static fields are still not supported.  Added AWT and Swing support for the Linux platform (configuration collection with the Tracing agent is necessary).  Added the experimental -H:+InlineBeforeAnalysis option to reduce the number of required configuration entries and lessen the image size.  Improved the Tracing agent: it now captures instances of Class.getClasses and Class.getDeclaredClasses.  Improved the ServiceLoaderFeature class to scan for services declared using modules.  Disallowed the instances of Random in the native image heap.  Improved GC performance (less time spent in GC).Updates for Language and Tool Implementers Using Truffle API  Fixed many issues related to multi-tier compilation. Multi-tier compilation (--engine.MultiTier) will be enabled by default in 21.1.  Added HostCompilerDirectives for directives that guide the host compilations of the Truffle interpreters:  HostCompilerDirectives.BytecodeInterpreterSwitchto denote methods that contain the instruction-dispatch switch in bytecode interpreters  HostCompilerDirectives.BytecodeInterpreterSwitchBoundary to denote methods that do not need to be inlined into the bytecode interpreter switch  Truffle DSL generated nodes are no longer limited to 64 state bits. Use these state bits responsibly.  More changes are listed in the changelog.Updates for Polyglot Embedders  Added support for explicitly selecting a host method overload using the signature in the form of comma-separated fully qualified parameter type names enclosed by parentheses (e.g., methodName(f.q.TypeName,java.lang.String,int,int[])).  Deprecated the host method selection by JNI mangled signature, replaced by the aforementioned new form. Scheduled for removal in 21.2.JavaScript  Updated Node.js to version 12.20.1.  Enabled the following ECMAScript 2021 mode/features by default:          Class fields      Promise.any      String.prototype.replaceAll      Logical Assignment Operators        Adopted a new interop exception handling and made JS exceptions extend the AbstractTruffleException class.  Exposed Graal.versionECMAScript instead of Graal.versionJS.  Implemented the relative indexing method proposal. It is available in ECMAScript 2022 mode (--js.ecmascript-version=2022).Python  Added the jarray module for compatiblity with Jython.  Improved the support for Pandas and added the initial support for the Matplotlib visualization library.  Provided fixes to avoid possible memory leaks and crashes when running NumPy in a shared engine.  Fixed an infinite continuation prompt in REPL when pasting snippets.More details can be found in the changelog.Ruby  The new IRB is quite slow when copy/paste code into it. This is due to an inefficient io/console implementation which will be addressed in the next release. A workaround is to use irb --readline, which disables some IRB features but is much faster for copy/pasting code.New features:  Updated to Ruby 2.7.2. Most Ruby 2.7 features and changes are implemented (see #2004).Bug fixes:  Fixed setting of special variables in enumerators and enumerables (issue #1484).  Fixed issue with Method#to_proc and special variable storage (issue #2156).Compatibility:  **kwargs now accept non-Symbol keys like Ruby 2.7.Performance:  Refactor and implement more performant MatchData#length (see #2147).  Refactor and implement more performant Array#sample (see #2148).  String#inspect is now more efficient.Changes:  All InteropLibrary messages are now exposed consistently as methods on Truffle::Interop (see #2139). Some methods were renamed to match the scheme described in the documentation.  More details are available from the changelog.R  Fixed AssertionError when trying to install the R validate package (issue #169).LLVM runtime  Improved the AST sharing, and support for the auxiliary engine caching. On top of the regular AST sharing that allows sharing code between multiple contexts in a single engine, this allows persisting of shared code across process boundaries.  Added support for the current major release of macOS (macOS Big Sur).Deprecations:  Added a deprecation warning for the old header files locations polyglot.h and llvm/api/toolchain.h. These header files have been already deprecated in 20.3.0, but without a warning.GraalWasm  This release included a large number of bugfixes in semantics, linking and in-module validation. GraalVM’s WebAssembly interpreter now passes almost all tests from the official specification test suite.  Exposed Polyglot bindings that are needed for the JS-to-WebAssembly Interface API.  Optimized the GraalWasm interpreter, leading to warmup and an overall 20x peak performance improvement of the interpreted execution mode.  Improved the security by using the byte-buffer-based memory instead of the off-heap memory.ToolingGraalVM UpdaterStarting from version 21.0, GraalVM Updater has become more powerful and can be used to update your GraalVM local installation to a newer version or upgrade from a Community to Enterprise Edition. Read more in Upgrade GraalVM.Visual Studio Code Extensions  Added refactoring and other productivity features.  Published GraalVM 21.0 Extension Pack for Visual Studio Code on VS Code Marketplace. Read more on the advancements and modifications here.GraalVM Dashboard  Improved the BGV format to support large amount of integer properties.VisualVM  Enabled a seamless import of settings from the previous installations of VisualVM.",
                    "url": " /release-notes/21_0/"
                  },
                  
                  "release-notes-21-1":  {
                    "title": "",
                    "content": "21.1.0(2021-04-20)Java UpdatesThe OpenJDK release that GraalVM Community Edition is built on was updated to:  8u292 for Java 8 based GraalVM Community  11.0.11 for Java 11 based GraalVM Community  16.0.1 for Java 16 based GraalVM CommunityThe Oracle JDK release that GraalVM Enterprise Edition is built on was updated to:  8u291 for Java 8 based GraalVM Enterprise, please see Java SE 8 release notes  11.0.11 for Java 11 based GraalVM Enterprise, please see Java SE 11 release notes  16.0.1 for Java 16 based GraalVM Enterprise, please see Java SE 16 release notesPlatform Updates  Java 16 (experimental) support: The GraalVM distributions based on Oracle Java 16 and OpenJDK 16 are available for download with several known limitations.  MacOS platform support: Builds of GraalVM Community Edition for macOS based on OpenJDK 8 are no longer being produced. GraalVM Enterprise Edition for macOS  based on Oracle JDK 8 continue to be available.  Linux AArch64 platform compatibility: The GraalVM distributions for Linux AArch64 architecture remain experimental in this release. Supported features include the GraalVM compiler, the gu tool, the Node.js JavaScript runtime, Native Image, some developer tools.  Windows platform compatibility: To run GraalVM Community Edition based on OpenJDK 8u292 on a Windows platform, the MSVCR100.dll redistributable package needs to be installed (for more details, see the issue #3187).Compiler  [GraalVM Enterprise] Added support to detect inverted (tail counted) loops as counted loops. GraalVM Enterprise now detects such loops as counted, enabling them to be analyzed and optimized like all other counted loops. These loops are subject to full unrolling, partial unrolling, guard optimization and vectorization. This new capability can be disabled with -Dgraal.DetectInvertedLoopsAsCounted=false.  [GraalVM Enterprise] Added a novel loop inversion optimization in GraalVM Enterprise. This adds compiler support to generate inverted loops from regular ones. Inverted loops have superior characteristics for instruction level parallelism and optimization capabilities compared to regular, head counted loops. We have seem performance improvements of up to 30% for micro benchmarks exercising the inverted loop shape. Loop inversion is on by default and can be disabled with -Dgraal.LoopInversion=false.  [GraalVM Enterprise] Added a new optimization that analyzes code guarded by a conditional of the form x == y and replace all uses of x with y (or vice versa) if the replacement results in potential for further optimization.  [GraalVM Enterprise] Enhanced SIMD vectorization, to support vector byte reversal (e.g., Integer.reverseBytes). SIMD vectorization is still experimental and not enabled by default. Enable it with -Dgraal.VectorizeSIMD=true.  [GraalVM Enterprise] Added support for vectorizing hashCode-like loops using the hash = c * hash + array[i]. Disable with -Dgraal.VectorizeHashes=false.  Eliminated the cast of the loaded array element to Node, to prevent the situation when volatile fields are loading from arrays, losing type information about the element, and resulting in unneeded casts. This method in ConcurrentHashMap can be an example:     static final &amp;lt;K,V&amp;gt; Node&amp;lt;K,V&amp;gt; tabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i) {      return (Node&amp;lt;K,V&amp;gt;)U.getObjectVolatile(tab, ((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE);  }    Eliminate unneeded memory barriers on sequential volatile writes on x86. There are patterns in classes such as ConcurrentHashMap where numerous volatile writes can occur in a sequence (after inlining). The GraalVM compiler now omits the memory barrier for all but the last write in the sequence, speeding up methods such as ConcurrentHashMap.transfer.Native Image  Improved support for localization. Now you can specify which locales should be included in the native executable, and which should be the default. Forexample, to switch the default locale to German and also include French and English, use -H:DefaultLocale=de -H:IncludeLocales=fr,en. All locales can be included via -H:+IncludeAllLocales.  Deprecated the --enable-all-security-services option as it is no longer necessary. Security services are now registered automatically when found in use by static analysis.  Improved support on Windows: applications now do file globbing on parameters.  Added reporting on the native image build to produce multiple artifacts. Results of the build are written to the imagename.build_artifacts.txt file.  Fixed a bug on Linux and macOS that resulted in local symbols about all methods being included in the native image, when -g is passed for debug information generation. Method symbols are not necessary for debugging because the Dwarf debugging information also contains this information. When local symbols are desired, e.g., for certain profilers, they can be included in the image using -H:-DeleteLocalSymbols (independently of the -g option).  Allowed multiple different native images in the same process, e.g., an application and a shared library. This was required for Linux platforms.  Automatically mark more classes for build-time initializaiton. This reduces the overhead of class initialization at run time.Polyglot Runtime  Enabled multi-tier compilation by default. This feature was first introduced in 20.3 as an experimental option. Truffle now uses two tiers of compilation. The first tier is optimized for compilation speed and reuses the GraalVM compiler economy configuration to perform speedy compilations with method inlining of trivial methods only. The second tier compiles with all GraalVM’s compiler optimizations enabled and is performed after the first tier compilation is completed. Our benchmark results show that this improves warmup for most languages significantly.  Added new capabilities for language implementations that require an optional dependency to the newest JVMCI version 21.1-b02 (issue JDK-8263776). In the next release, 21.2 we plan to use some of these capabilities for core runtime functionality, and therefore JVMCI 21.1-b02 will become a required dependency. This will make runtime compilation for JDK releases that do not support JVMCI 21.1-b02 unsupported. Note that all Truffle languages can still be executed on any JDK but without support for runtime compilation.   Introduced new experimental flags to set the compilation thresholds for multi-tier compilation: --engine.FirstTierCompilationThreshold sets the threshold for the first, and --engine.LastTierCompilationThreshold for the second tier. If multi-tier compilation is disabled, --engine.SingleTierCompilationThreshold=x may be used. The original option, --engine.CompilationThreshold, is now deprecated and will be removed in a future release.  Added a new experimental compilation queue implementation inspired by HotSpot. The implementation is not yet enabled by default, but can be tried out using the --engine.TraversingCompilationQueue option. The flag is expected to reduce warmup time. More changes and enhancements are planned for the next release, where it is expected to become the default implementation.  Deprecated the --engine.CompilationThreshold option. Use --engine.FirstTierCompilationThreshold and --engine.LastTierCompilationThreshold instead.Java on Truffle  Introduced many fixes and improvements to the Java Debug Wire Protocol (JDWP) support. Many edge cases have been fixed which increased the performance of Java on Truffle while debugging is enabled (up to 200x!).  Provided fixes for method redefinition: reflective access and MethodHandles now follow method changes.  Added support for signal handlers (sun.misc.Signal / jdk.internal.misc.Signal). This means shutdown hooks are now run when closing a program with Ctrl-C.  Removed the dependency on deprecated Scope API and implement newly introduced NodeLibrary instead.  Fixed guest stack traces as reported by the GraalVM embedder API (PolyglotException).  Improved support for restricting thread creation.JavaScript  Updated Node.js to version 14.16.1.  Node.js support is not enabled by default and must be installed explicitly with GraalVM Updater if needed: gu install nodejs. The JavaScript runtime continue to be included in the base GraalVM installation.  Added Iterator interoperability support. It allows JavaScript iterators to be used via the Value API (hasIterator(), getIterator(), hasIteratorNextElement(), getIteratorNextElement()), as well as iterable objects from other languages to be iterated in GraalVM’s JavaScript runtime (e.g., via for-of loops), and vice versa.  Enabled buffer interoperability support. It allows host ByteBuffers and buffers from other languages to be used with JavaScript typed arrays (e.g., new Uint8Array(foreignBuffer)) and DataView, without copying. It also enables access to ArrayBuffers via the Value API (readBuffer*, writeBuffer*).  Implemented the experimental version of the WebAssembly JavaScript Interface, which allows invoking WebAssembly programs from within JavaScript programs (available behind the --js.webassembly option).The changelog is available in the project repository.LLVM Runtime (Sulong)  [GraalVM Enterprise] The ability to build GraalVM or a native image with “native mode” completely removed (so only --llvm.managed mode works).  Made pointers to foreign “buffer-like” objects (e.g., JS ArrayBuffer) be transparently accessed like native buffers.  Added support for loading bitcode modules with regular dlopen in addition to the Polyglot API.   Added experimental support for the Linux AArch64 platform.  Implemented a sanity check to verify that loaded bitcode files are compiled correctly for the GraalVM LLVM Runtime. In particular, this will fail when loading bitcode that is built for managed mode and used in native mode, or vice versa. This can be turned into a non-fatal warning with the --llvm.verifyBitcode=false option.The project changelog is available on GitHub.Ruby  Implemented more complete support of Ruby 2.7 (see #2004 for more details).  Multi-tier compilation is now enabled by default, which improves warmup significantly.  C extensions which link to a static library now generally work by prepending the GraalVM LLVM toolchain to PATH when installing gems.  Improved the performance of checks for recursion (#2189).  Improved random number generation performance by avoiding synchronization (#2190).  Implemented the ability to create a single call target per block by default instead of two.  Optimized some uses of class variables (#2259).  Speeded up the interpreter and reduced footprint by making several methods that need the caller frame  always inlined in their caller.  Added support for accessing local variables of the interactive Binding via language bindings: context.getBindings(&quot;ruby&quot;).putMember(&quot;my_var&quot;, 42);. See #2030.  Made signal handlers run without triggering multi-threading.  Implemented the Debug Inspector C API.  Switched to the io-console C extension for better performance and compatibility in irb.  Updated to irb 1.3.3 and reline 0.2.3 which allow pasting code in IRB reasonably fast (#2233).  Standalone builds of TruffleRuby are now based on JDK11 (they used JDK8 previously).More details are available from the TruffleRuby changelog.Python  Improved support for Java subclassing and  new Interoperability APIs for better Jython migration path. The features often requested and available with Jython, like convenient iteration over Python types from Java, implementing Java abstract classes and interfaces from Python, catching and re-throwing Java exceptions in Python code, are now provided with GraalVM’s Python runtime as well, making the migration easier.  Added the SSL support. This allows out-of-the-box installation of Python packages. Now users can run the Python pip installer to download Python packages, and their dependencies, just as they would on CPython.  Added a completely native backend for posix API. This provides better performance and more compatibility for filesystem access.  Added support for multi-threading with GIL. Multi-threading is supported in GraalVM’s Python runtime to the same extent as CPython. That is, there is only concurrency, not parallelism for most workloads.  Added support for the current HPy Python C API to run C extensions at better performance. This is an ongoing research project together with members of the PyPy project and the University of Cape Town to provide a faster API for NumPy and other popular Python C extensions.More details are available in the project changelog.R  Upgraded GraalVM’s R runtime to R 4.0.3:          Made the GraalVM R runtime mostly compatible with R 4.0.3;      Migrated to new versions of the base and recommended packages;      Implemented some of the new features of R 4.0.3 (see the changelog for a complete list).        Upgraded the CRAN snapshot, used by default by install.packages, to 2021-02-01:          Support of the new versions of some of the most popular packages on GraalVM’s R runtime is a work in progress;      Packages with known issues remain: dplyr 1.0.3, ggplot 3.3.3, knitr 1.31.      More details are available in the project changelog.WebAssembly (GraalWasm)  Substantially improved the speedup and the overall peak performance of the GraalWasm interpreter by over 10x.  Provided the basic WASI functions that allow manipulating the files and accessing the file system through the Truffle filesystem layer.   GraalWasm is now passing most of the tests in the official WebAssembly test suite.  Improved the speed of the standalone GraalWasm launcher, and the peak performance overall.  Implemented the WebAssembly-JavaScript Interface specification, which allows invoking WebAssembly programs from within JavaScript programs running on GraalVM’s JavaScript runtime.  Implemented parsing custom name sections in the .wasm files to make stack-traces more user-friendly.  Made the GraalWasm interpreter  respect the binary-validation rules.  Introduced checks for memory/table/function count limits when parsing and linking binaries, as defined in the specification.  Added checks to not get exponential compilation slowdown on some pathological code examples.ToolsVisual Studio Code Extensions  Added results visualization for unit tests:  Improved Micronaut support by adding YAML &amp;lt;&amp;gt; Java code editing features:  Added a number of refactorings.  Included Micronaut projects Docker build commands.  Improved support for Maven and Gradle multi-project builds.VisualVM  Added support for upcoming JDK 16 (#260).  Added support for the new Apple M1 processor (aarch64) (#262).  Added support for the importation of plugins from the previous release (#270).  Added a display list of enabled modules in heap dumps feature, taken from JDK 9+ created by jlink (#275).Polyglot Embedding  [GraalVM Enterprise] Added a new experimental sandbox option --sandbox.MaxHeapMemory=&amp;lt;size&amp;gt; that specifies the maximum heap memory that a guest application can retain during its run. This feature is currently only supported on HotSpot. More information on how to use heap memory limits can be found in the sandbox documentation. Note that this feature is still experimental.  Added support for byte buffer-like data structures. This release adds new methods to access buffer values like Value.hasBufferElements(). Java host interoperability was improved to handle java.nio.ByteBuffer implementations to make them work like native guest language buffers. This feature can be enabled and disabled using HostAccess.Builder.allowBufferAccess(boolean). Support for polyglot buffers in languages may vary. See the individual language changelog for more details.  Added support for iterable and iterator-like data structures. This includes new methods to detect if a polyglot value is an iterator or iterable with Value.isIterator() and Value.hasIterator(). New proxy interfaces ProxyIterator and ProxyIterable were added to mimic iterators and iterables. Java host interoperability was improved to handle java.util.Iterator and java.util.Iterable implementations to make them work like guest language values. This feature can be enabled and disabled with HostAccess.Builder.allowIteratorAccess(boolean) and HostAccess.Builder.allowIterableAccess(boolean). Guest language iterators can now also be mapped to Java iterators using Value.as(Iterator.class). The support for this feature in individual languages may vary. See the language changelog for more details.  Added support for map-like data structures (issue #143). This includes new methods for polyglot values like Value.hasHashEntries() to query if a polyglot value represents a hash map like data structure. A new interface ProxyHashMap was added to mimic such values. Java host interoperability was improved to handle java.util.Map implementations to make them look like guest language hash maps. This feature can be enabled and disabled with HostAccess.Builder.allowMapAccess(boolean). Guest language maps can now also be mapped to Java Maps using Value.as(Map.class). The support for this feature in individual languages may vary. See the language changelog for more details.  Added Context.safepoint() to cooperatively poll thread local actions of a polyglot context while a host method is executed. For example, this allows the context to check for interruption or cancellation.A detailed list of all the changes can be found in the changelog.Truffle Language and Tool Implementations  Added support for submitting thread local actions to run at guest language safepoints for language implementations (issue JDK-8263776). Please see the tutorial on how to adapt and use this feature in a language or tool implementation.  Added a new interoperability trait for buffer elements in InteropLibrary that allows better integration with native buffers.  Added a new interoperability type iterator and a new trait for iterable in InteropLibrary to improve traversal of collections between languages.  Added a new interoperability trait for hash entries in InteropLibrary to improve interoperability between guest language hash maps (issue #143).  Added TruffleInstrument.Env.calculateContextHeapSize(TruffleContext, long, AtomicBoolean) to calculate the heap size retained by a context.  Added @GenerateAOT to support preparation for AOT specializing nodes. Read the AOT tutorial to get started with Truffle and AOT compilation. We also added the --engine.CompileAOTOnCreate option to trigger AOT compilation on call target create. More changes and enhancements are planned for the next release.  Added ExactMath.truncate(float) and ExactMath.truncate(double) methods to remove the decimal part (round toward zero) of a float or of a double respectively. These methods are intrinsified.  Added several new events to ContextsListener when language context initialization was completed or failed.  Added CompilerDirectives.isExact(Object, Class) to check whether a value is of an exact type. This method should be used instead of the value != null &amp;amp;&amp;amp; value.getClass() == exactClass pattern.  Added Frame.clear(FrameSlot). This allows the compiler to reason about the liveness of local variables. Languages are recommended to use this method when applicable.  Added TruffleLanguage.Env.getLogger(String) and TruffleLanguage.Env.getLogger(Class&amp;lt;?&amp;gt;) creating a context-bound logger. The returned TruffleLogger always uses a logging handler and options from Env’s context and does not depend on being entered on any thread.  Added TruffleContext.leaveAndEnter(Node, Supplier) to wait for another thread without triggering multithreading.  The native image build now fails for the Truffle languages if a method that is known to be not suitable for partial evaluation is reachable for runtime compilation. The check can be disabled by the -H:-TruffleCheckBlackListedMethods option for the native-image builder.Removed the deprecated TruffleLanguage.Env.getTruffleFile(String), TruffleLanguage.Env.getTruffleFile(URI) methods.  Added TruffleContext.isCancelling() to check whether a Truffle context is being cancelled.  Added new features to the specializing DSL @NodeChild annotation: Added implicit and implicitCreate attributes to allow implicit creation of child nodes by the parent factory method.  Added allowUncached and uncached attributes to allow using @NodeChild with @GenerateUncached.  Profiles now can be disabled using Profile.disable() and reset using Profile.reset().  Added support for two-phase attach in the Truffle instrumentation with the new EventBinding.attach() method.A detailed list of all the changes can be found in the Truffle framework changelog.",
                    "url": " /release-notes/21_1/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-aot":  {
                    "title": "",
                    "content": "Truffle AOT TutorialMany statically compiled languages, like C are designed to be compilable without prior execution.By default, Truffle first interprets code before it is compiled.In order to improve warmup speed of static languages AOT compilation can be supported.The following tutorial describes how to support Truffle AOT in your language, how to trigger and test it.Language SupportIn order for languages to support AOT compilation the language needs to implement the RootNode.prepareForAOT() method.The language implementation can indicate support for AOT by returning a non null value in this method.The goal for implementing a root node for AOT is to prepare all the AST nodes such that they no longer deoptimize when they are compiled without prior execution.Typical actions performed in an implementation of this method are:  Initialize local variable types in the FrameDescriptor of the root node. If a language uses local variables and their types are known, then this information must be provided to the FrameDescriptor. This step can often be done already during parsing.  Compute the expected execution signature of a root node and return it. This step requires the parser to infer expected typesfor arguments and return values.  Prepare specializing nodes with profiles that do not invalidate on first execution. Truffle DSL supports preparation of specializing nodes for AOT. See the example AOT language for details.Trigger AOT compilationAOT compilation can be triggered and tested by using the --engine.CompileAOTOnCreate=true option.This will trigger AOT compilation for every created call target with a root node that supports AOT compilation.A root node supports AOT compilation if it returns a non null value in RootNode.prepareForAOT().Note that enabling this flag will also disable background compilation which makes it not suitable for production usage.Example UsageUse the following documented and executable Truffle language as inspiration for AOT support:AOT TutorialThe example is executable as mx unittest using mx unittest AOTTutorial.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/AOT/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-aotoverview":  {
                    "title": "",
                    "content": "Truffle AOT OverviewThere are several different flavors of AOT preinitialization, compilation, and caching supported in Truffle.This document is intended to provide an overview of these capabilities.Note that some of the features mentioned here are only supported in GraalVM EE.Preinitialization of the First ContextNative image allows running Java code in static initializers at image build time.After static initialization was run, values referenced from static fields are snapshotted and persisted in the image.Context preinitialization leverages this feature by creating and initializing a language context at image build time to be used by the first context that gets created in an isolate or process at runtime.This typically improves the initialization time of the first context significantly.Context preinitialization can be enabled by setting the system property -Dpolyglot.image-build-time.PreinitializeContexts=ruby,llvm at image build time.A language needs to implement TruffleLanguage.patchContext and return true to support context preinitialization.In addition, languages need to be careful not to bind any host-specific data or create objects that would not be allowed to be stored in a native image, like java.lang.Thread instances.For more information see TruffleLanguage.patchContext javadoc.Code sharing within the same Isolate/ProcessA polyglot engine can be used in order to determine the scope of code sharing between contexts.An example of how that can be done can be found in the reference manual.When a language is initialized for a polyglot context, a new language instance is requested from an engine.If the language supports ContextPolicy.SHARED, then the language instance will be reused for an engine instance.The source parsing cache is associated with a language instance, so parsing happens once per language instance.Languages may choose to disallow reuse of a language instance for a new additional context by implementing TruffleLanguage.areOptionsCompatible.This allows languages to assume specific context options to be compilation final for all root nodes created by the language.An exception from this rule is InteropLibrary, where nodes may be shared unconditionally between languages instances.Supporting Context Independent CodeCodesharing requires that all code data structures are independent of their context.For example, code is context-independent if it can be executed with one context and then executed again with a new context without deoptimizing the code.A good test to verify a language implementation’s context independence is to create a context with an explicit engine, run a test application, and then verify that the second context does not cause deoptimizations when running the same deterministic application.The Truffle framework announces the potential use of a language instance in multiple contexts by calling TruffleLanguage.initializeMultipleContexts, typically even before the first context is created.The framework is able to initialize multiple contexts before the first context is created when an explicit engine is used or --engine.CacheStore is set to true.The following criteria should be satisfied when supporting context independent code:  All speculation on runtime value identity must be disabled with multiple contexts initialized, as they will lead to a guaranteed deoptimization when used with the second context.  Function inline caches should be modified and implemented as a two-level inline cache. The first level speculates on the function instance’s identity and the second level on the underlying CallTarget instance. The first level cache must be disabled if multiple contexts are initialized, as this would unnecessarily cause deoptimization.  The DynamicObject root Shape instance should be stored in the language instance instead of the language context. Otherwise, any inline cache on shapes will not stabilize and ultimately end up in the generic state.  All Node implementations must not store context-dependent data structures or context-dependent runtime values.  Loading and parsing of sources, even with language-internal builtins, should be performed using TruffleLanguage.Env.parse to cache Source parsing per language instance.  All assumption instances should be stored in the language instance instead of the context. With multiple contexts initialized, the context instance read using context references may no longer be a constant. In this case any assumption read from the context would not be folded and they would cause significant runtime performance overhead. Assumptions from the language can be folded by the compiler in both single and multiple context mode.It is expected that an AST created for multiple contexts is compiled to less efficient machine code as it does not allow for speculation on the identity of runtime values.For example, instead of speculating on the function instance in an inline cache, it is necessary to speculate on the contained CallTarget.This is slower because it requires an additional read to access the CallTarget stored in the function.It may be costly to create context independent code, therefore, speculation on runtime values should still be performed if multiple contexts are not initialized.SimpleLanguage and JavaScript are two languages that already support context independent code and might be useful as a guidance on concrete problems.Persistent Context Independent Code with Auxiliary Engine Caching (EE)GraalVM Enterprise Edition supports persisting code data structures to disk.This enables to almost eliminate warmup time for the first run of an application in an isolate/process.The SVM auxiliary image feature is used to persist and load the necessary data structures to the disk.Persisting the image can take a significant amount of time as compilation needs to be performed.However, loading is designed to be as fast as possible, typically almost instantaneous.Engine caching is enabled using options and functional even if the context was created without an explicit engine.More information on engine caching can be found in the engine caching tutorial.Compilation without ProfilingBy default, if language functions are created but never executed, they are not compiled when they are stored in an auxiliary engine cache image.Auxiliary engine caching supports triggering compilation for root nodes that were loaded but never executed.In such a case the framework calls the RootNode.prepareForAOT method.More information on making a language implementation ready for compilation without prior execution can be found in the AOT tutorial.Note that not every language can be compiled without prior execution and produce efficient machine code.Statically typed languages are typically more suitable for this.Application SnapshottingIt is planned to also support persisting runtime values of polyglot context instances to disk.More information will appear here as soon as this feature is implemented.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/AOTOverview/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-auxiliaryenginecachingenterprise":  {
                    "title": "",
                    "content": "Auxiliary Engine CachingThe following document describes how the auxiliary engine cache of GraalVM works.This feature is only available in GraalVM Enterprise Edition. In the community edition, these options are not available.IntroductionWarmup of Truffle guest language programs can take a significant amount of time.Warmup consists of work that is repeated every time a program is executed until peak performance is reached.This includes:  Loading and parsing the guest application into Truffle AST data structures.  Execution and profiling of the guest application in the interpreter.  Compilation of the AST to machine code.Within a single OS process, the work performed during warmup can be shared by specifying an explicit engine.This requires language implementations to disable context-related optimizations to avoid deoptimizations between contexts that share code.Auxiliary engine caching builds upon the mechanism for disabling context-related optimizations and adds the capability to persist an engine with ASTs and optimized machine code to disk.This way, the work performed during warmup can be significantly reduced in the first application context of a new process.We use the SVM auxiliary image feature to persist and load the necessary data structures to the disk.Persisting the image can take significant time as compilation needs to be performed.However, loading is designed to be as fast as possible, typically almost instantaneous.This reduces the warmup time of an application significantly.Getting StartedStarting from a GraalVM EE installation, you first need to (re)build an image with auxiliary engine caching capabilities.For example, one can rebuild the JavaScript image by adding the auxiliary engine cache feature:graalvm/bin/native-image --macro:js-launcher -H:+AuxiliaryEngineCache -H:ReservedAuxiliaryImageBytes=1073741824The --macro argument value depends on the guest languageBy default, auxiliary images of up to 1GB are possible.The maximum size can be increased or decreased as needed.The amount of reserved bytes does not actually impact the memory consumed by the application.In future versions, the auxiliary engine cache will be enabled by default when the --macro:js-launcher macro is used.After rebuilding the JavaScript launcher, the feature is used as follows:Create a new file fib.js:function fib(n) {   if (n == 1 || n == 2) {       return 1;   }   return fib(n - 1) + fib(n - 2);}console.log(fib(32))In order to persist the engine of a profiling run to disk use the following command line:graalvm/bin/js --experimental-options --engine.TraceCache=true --engine.CacheStore=fib.image fib.jsThe ` –engine.TraceCache=true` option is optional and allows you to see what is going on.The output is as follows:[engine] [cache] No load engine cache configured.2178309[engine] [cache] Preparing engine for store (compile policy hot)...[engine] [cache] Force compile targets mode: hot[engine] [cache] Prepared engine in 1 ms.[engine] [cache] Persisting engine for store ...[engine] [cache] Persisted engine in 20 ms.[engine] [cache] Detecting changes (update policy always)...[engine] [cache]     New image contains         1 sources and  82 function roots.[engine] [cache]     Always persist policy.[engine] [cache] Writing image to fib.image...[engine] [cache] Finished writing 1,871,872 bytes in 4 ms.The engine can now be loaded from disk using the following command:graalvm/bin/js --experimental-options --engine.TraceCache --engine.CacheLoad=fib.image fib.jswhich prints:[engine] [cache] Try loading image &#39;./fib.image&#39;...[engine] [cache] Loaded image in 0 ms. 1,871,872 bytes   1 sources  82 roots[engine] [cache] Engine from image successfully patched with new options.2178309[engine] [cache] No store engine cache configured.Since there is no need to warm up the application, the application’s execution time should be significantly improved.UsageThe cache store and load operations can be controlled using the following options:  --engine.Cache=&amp;lt;path&amp;gt; Loads and stores the cached engine from/to  path.  --engine.CacheStore=&amp;lt;path&amp;gt; Stores the cached engine to  path.  --engine.CacheLoad=&amp;lt;path&amp;gt; Loads the cached engine from path.  --engine.CachePreinitializeContext=&amp;lt;boolean&amp;gt; Preinitialize a new context in the image (default true).  --engine.TraceCache=&amp;lt;boolean&amp;gt; Enables debug output.  --engine.TraceCompilation=&amp;lt;boolean&amp;gt; Prints forced compilations.The compilation of roots may be forced when an image is stored using the --engine.CacheCompile=&amp;lt;policy&amp;gt; option. The supported policies are:  none: No compilations will be persisted, and existing compilations will be invalidated.  compiled: No compilations will be forced, but finished compilations will be persisted.  hot: All started compilations will be completed and then persisted. (default)  aot: All started, and AOT compilable roots will be forced to compile and persisted.  executed: All executed and all AOT compilable roots will be forced to compile.By default, all started compilations in the compile queue will be completed and then persisted.Whether a function root is AOT compilable is determined by the language.A language supports AOT by implementing RootNode.prepareForAOT().An update policy can be specified if both load and store operations are set using the --engine.UpdatePolicy=&amp;lt;policy&amp;gt; option.Available policies are:  always Always persist.  newsource Store if new source was loaded that was not contained in the previously loaded image.  newroot Store if a new root was loaded and not contained in the previously loaded image.  never Never persist.Known Restrictions      There are generally no restrictions on the kind of applications that can be persisted.If the language supports a shared context policy, auxiliary engine caching should work.If the language does not support it, then no data will be persisted.        The persisted auxiliary engine image can only be used with the same SVM native image that it was created with.Using the engine image with any other native-image will fail.        There can only be one active auxiliary image per native-image isolate.Trying to load multiple auxiliary images at the same time will fail.Currently, auxiliary images can also not be unloaded, but it is planned to lift this restriction in the future.  Security ConsiderationsAll data that is persisted to disk represents code only and no application context-specific data like global variables.However, profiled ASTs and code may contain artifacts of the optimizations performed in a Truffle AST.For example, it is possible that runtime strings are used for optimizations and therefore persisted to an engine image.Development and Debugging on NativeImageThere are several options useful for debugging auxiliary engines caching when running on NativeImage:  -XX:+TraceAuxiliaryImageClassHistogram Prints a class histogram of all the objects contained in an image when persisting.  -XX:+TraceAuxiliaryImageReferenceTree Prints a class reference tree of all the objects contained in an image when persisting.Development and Debugging on HotSpotIt can be useful to debug language implementation issues related to auxiliary image on HotSpot.On GraalVM EE in JVM mode, we have additional options that can be used to help debug issues with this feature:Since storing partial heaps on HotSpot is not supported, these debug features do not work on HotSpot.  --engine.DebugCacheStore=&amp;lt;boolean&amp;gt; Prepares the engine for caching and stores it to a static field instead of writing it to disk.  --engine.DebugCacheLoad=&amp;lt;boolean&amp;gt; Prepares the engine to use the engine stored in the static field instead of reading it from disk.  --engine.DebugCacheCompile=&amp;lt;boolean&amp;gt; Policy to use to force compilation for executed call targets before persisting the engine. This supports the same values as --engine.CacheCompile.  --engine.DebugCacheTrace=&amp;lt;boolean&amp;gt; Enables tracing for the engine cache debug feature.For example:js --jvm  --experimental-options --engine.TraceCompilation --engine.DebugCacheTrace --engine.DebugCacheStore --engine.DebugCacheCompile=executed fib.jsPrints the following output:[engine] opt done         fib                                                         |ASTSize            32 |Time   231( 147+84  )ms |Tier             Last |DirectCallNodes I    6/D    8 |GraalNodes   980/ 1857 |CodeSize         7611 |CodeAddress 0x10e20e650 |Source       fib.js:22178309[engine] [cache] Preparing debug engine for storage...[engine] [cache] Force compile targets mode: executed[engine] [cache] Force compiling 4 roots for engine caching.[engine] opt done         @72fa3b00                                                   |ASTSize             3 |Time   211( 166+45  )ms |Tier             Last |DirectCallNodes I    2/D    1 |GraalNodes   500/ 1435 |CodeSize         4658 |CodeAddress 0x10e26c8d0 |Source            n/a[engine] opt done         :program                                                    |ASTSize            25 |Time   162( 123+39  )ms |Tier             Last |DirectCallNodes I    1/D    1 |GraalNodes   396/ 1344 |CodeSize         4407 |CodeAddress 0x10e27fd50 |Source       fib.js:1[engine] opt done         Console.log                                                 |ASTSize             3 |Time    26(  11+15  )ms |Tier             Last |DirectCallNodes I    0/D    0 |GraalNodes    98/  766 |CodeSize         2438 |CodeAddress 0x10e285710 |Source    &amp;lt;builtin&amp;gt;:1[engine] [cache] Stored debug engine in memory.This allows rapidly iterating on problems related to the compilation as well as to attach a Java debugger.A Java debugger can be attached using --vm.Xdebug --vm.Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000.Debugging the loading of persisted engines is more difficult as writing an engine to disk is not supported on HotSpot.However, it is possible to use the polyglot embedding API to simulate this use-case in a unit test.See the com.oracle.truffle.enterprise.test.DebugEngineCacheTest class as an example.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/AuxiliaryEngineCachingEnterprise/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-branchinstrumentation":  {
                    "title": "",
                    "content": "Truffle Branches InstrumentationIn languages implemented on top of Truffle, it is common that the AST implementations contain fast and slowexecution paths, usually based on some condition, such as a profile. These executionpaths are organized into different conditional branches. In these cases, it is oftenhelpful to know if running the program actually exercised the code in each of thoseexecutions paths.The branch instrumentation functionality instruments if-statements in target methodsto track which of the branches have been taken during execution. Branch instrumentationdoes this by instrumenting branches with code that writes to a globaltable. Each branch has an entry in this table. When the program ends, thecontents of the table are decoded and dumped to the standard output in readableform.There are several flags that control how branch instrumentation works. These flags arespecified as system properties:  --engine.InstrumentBranches - controls whether instrumentation is on (trueor false, default is false)  --engine.InstrumentFilter - filters methods in which instrumentationshould be done (method filter syntax, essentially &amp;lt;package&amp;gt;.&amp;lt;class&amp;gt;.&amp;lt;method&amp;gt;[.&amp;lt;signature&amp;gt;])  --engine.InstrumentationTableSize - controls the maximum number ofinstrumented locations  --engine.InstrumentBranchesPerInlineSite - controls whether instrumentationprovides separate branch profiles for each guest language function/compilation unit(default is false).Example UsageHere is an example of how to enable branch instrumentation on a program.When using instrumentation to detect hot or infrequently used branches in a Trufflelanguage implementation, it usually starts by finding a language node with aproblematic method. The following command runs a unit test for the SimpleLanguage,and instruments all the if-statements:mx --jdk jvmci sl --engine.BackgroundCompilation=false   --engine.InstrumentBranches   &#39;--engine.InstrumentFilter=*.*.*&#39;   ../truffle/truffle/com.oracle.truffle.sl.test/src/tests/LoopObjectDyn.slYou get the following output:Execution profile (sorted by hotness)=====================================  0: *****************************************************  1: **************************com.oracle.truffle.sl.nodes.access.SLPropertyCacheNode.namesEqual(SLPropertyCacheNode.java:109) [bci: 120][0] state = IF(if=36054#, else=0#)com.oracle.truffle.sl.nodes.controlflow.SLWhileRepeatingNode.executeRepeating(SLWhileRepeatingNode.java:102) [bci: 5][1] state = BOTH(if=18000#, else=18#)This output tells that both branches were visited in the if-statement in the fileSLWhileRepeatingNode.java at line 102, and only the true branch was visited forthe if-statement in the file SLPropertyCacheNode.java at line 109.However, it does not tell, e.g., where this specific SLPropertyCacheNode node wasused from – the same execute method can be called from many different SimpleLanguagenodes, and you may wish to distinguish these occurrences. Therefore, set theper-inline-site flag to true, and change the filter to focus only onSLPropertyCacheNode:mx --jdk jvmci sl -Dgraal.TruffleBackgroundCompilation=false   --engine.InstrumentBranchesPerInlineSite   --engine.InstrumentBranches   &#39;--engine.InstrumentFilter=*.SLPropertyCacheNode.*&#39;   ../truffle/truffle/com.oracle.truffle.sl.test/src/tests/LoopObjectDyn.slThis time you get more output, because the method namesEqual was inlined atmultiple sites (each site is represented by its inlining chain). The following outputfragment first shows the histogram with the if-statement ID and its occurrencecount. It then shows the exact call stacks and execution counts for the branches.For example, for [1], when namesEqual is called from executeRead, the truebranch is taken 18018 times. When the namesEqual is called from executeWrite([0]), the true branch is taken only 18 times:Execution profile (sorted by hotness)=====================================  1: ***************************************  2: ***************************************  0:  3:com.oracle.truffle.sl.nodes.access.SLPropertyCacheNode.namesEqual(SLPropertyCacheNode.java:109) [bci: 120]com.oracle.truffle.sl.nodes.access.SLReadPropertyCacheNodeGen.executeRead(SLReadPropertyCacheNodeGen.java:76) [bci: 88]com.oracle.truffle.sl.nodes.access.SLReadPropertyNode.read(SLReadPropertyNode.java:71) [bci: 7]com.oracle.truffle.sl.nodes.access.SLReadPropertyNodeGen.executeGeneric(SLReadPropertyNodeGen.java:30) [bci: 35]com.oracle.truffle.sl.nodes.SLExpressionNode.executeLong(SLExpressionNode.java:81) [bci: 2]com.oracle.truffle.sl.nodes.expression.SLLessThanNodeGen.executeBoolean_long_long0(SLLessThanNodeGen.java:42) [bci: 5]com.oracle.truffle.sl.nodes.expression.SLLessThanNodeGen.executeBoolean(SLLessThanNodeGen.java:33) [bci: 14]com.oracle.truffle.sl.nodes.controlflow.SLWhileRepeatingNode.evaluateCondition(SLWhileRepeatingNode.java:133) [bci: 5]com.oracle.truffle.sl.nodes.controlflow.SLWhileRepeatingNode.executeRepeating(SLWhileRepeatingNode.java:102) [bci: 2]org.graalvm.compiler.truffle.OptimizedOSRLoopNode.executeLoop(OptimizedOSRLoopNode.java:113) [bci: 61]com.oracle.truffle.sl.nodes.controlflow.SLWhileNode.executeVoid(SLWhileNode.java:69) [bci: 5]com.oracle.truffle.sl.nodes.controlflow.SLBlockNode.executeVoid(SLBlockNode.java:84) [bci: 37]com.oracle.truffle.sl.nodes.controlflow.SLFunctionBodyNode.executeGeneric(SLFunctionBodyNode.java:81) [bci: 5]com.oracle.truffle.sl.nodes.SLRootNode.execute(SLRootNode.java:78) [bci: 28][1] state = IF(if=18018#, else=0#)...com.oracle.truffle.sl.nodes.access.SLPropertyCacheNode.namesEqual(SLPropertyCacheNode.java:109) [bci: 120]com.oracle.truffle.sl.nodes.access.SLWritePropertyCacheNodeGen.executeWrite(SLWritePropertyCacheNodeGen.java:111) [bci: 244]com.oracle.truffle.sl.nodes.access.SLWritePropertyNode.write(SLWritePropertyNode.java:73) [bci: 9]com.oracle.truffle.sl.nodes.access.SLWritePropertyNodeGen.executeGeneric(SLWritePropertyNodeGen.java:33) [bci: 47]com.oracle.truffle.sl.nodes.access.SLWritePropertyNodeGen.executeVoid(SLWritePropertyNodeGen.java:41) [bci: 2]com.oracle.truffle.sl.nodes.controlflow.SLBlockNode.executeVoid(SLBlockNode.java:84) [bci: 37]com.oracle.truffle.sl.nodes.controlflow.SLFunctionBodyNode.executeGeneric(SLFunctionBodyNode.java:81) [bci: 5]com.oracle.truffle.sl.nodes.SLRootNode.execute(SLRootNode.java:78) [bci: 28][0] state = IF(if=18#, else=0#)...Truffle Call Boundary InstrumentationThe Truffle Call Boundary Instrumentation tool instruments callsites to methods thathave a TruffleCallBoundary annotation, and counts the calls to those methods. It iscontrolled by the following set of flags:  --engine.InstrumentBoundaries - controls whether instrumentation is on (trueor false, default is false)  --engine.InstrumentFilter - filters methods in which instrumentationshould be done (method filter syntax, essentially &amp;lt;package&amp;gt;.&amp;lt;class&amp;gt;.&amp;lt;method&amp;gt;[.&amp;lt;signature&amp;gt;])  --engine.InstrumentationTableSize - controls the maximum number ofinstrumented locations  --engine.InstrumentBoundariesPerInlineSite - controls whether instrumentationis done per a declaration of an Truffle boundary call (false), or per every callstack where that callsite was inlined (true)This tool can be used together with the Branch Instrumentation tool.Assume that you need to find frequently occurring methods that were not, for example,inlined. The usual steps in identifying the Truffle call boundaries is to first run theprogram with the InstrumentBoundariesPerInlineSite flag set to false, andthen, after identifying the problematic methods, set that flag to true and set theInstrumentFilter to identify the particular call stacks for those methods.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/BranchInstrumentation/"
                  },
                  
                  "reference-manual-native-image-buildconfiguration":  {
                    "title": "",
                    "content": "Native Image Build Configuration  Embedding a Configuration File  Configuration File Format  Memory Configuration for Native Image Build  Runtime vs Build-Time Initialization  Assisted Configuration of Native Image Builds  Building Native Image with Java Reflection Example  Agent Advanced UsageNative Image supports a wide range of options to configure a native image build process.Embedding a Configuration FileA recommended way to provide configuration is to embed anative-image.properties file into a project JAR file. The Native Image builderwill automatically pick up all configuration options provided anywhere below theresource location META-INF/native-image/ and use it to constructnative-image command line arguments.To avoid a situation when constituent parts of a project are builtwith overlapping configurations, it is recommended to use “subdirectories” withinMETA-INF/native-image. That way a JAR file built from multiple maven projectscannot suffer from overlapping native-image configurations. For example:  foo.jar has its configurations in META-INF/native-image/foo_groupID/foo_artifactID  bar.jar has its configurations in META-INF/native-image/bar_groupID/bar_artifactIDThe JAR file that contains foo and bar will then contain both configurationswithout conflicting with one another. Therefore the recommended layout forstoring native image configuration data in JAR files is the following:META-INF/└── native-image    └── groupID        └── artifactID            └── native-image.propertiesNote that the use of ${.} in a native-image.properties file expands to theresource location that contains that exact configuration file. This can beuseful if the native-image.properties file wants to refer to resources withinits “subfolder”, for example, -H:SubstitutionResources=${.}/substitutions.json.Always make sure to use the option variants that take resources, i.e., use-H:ResourceConfigurationResources instead of -H:ResourceConfigurationFiles.Other options that are known to work in this context are:  -H:DynamicProxyConfigurationResources  -H:JNIConfigurationResources  -H:ReflectionConfigurationResources  -H:ResourceConfigurationResources  -H:SubstitutionResources  -H:SerializationConfigurationResourcesBy having such a composable native-image.properties file, building an imagedoes not require any additional arguments specified on command line. It issufficient to just run the following command:$JAVA_HOME/bin/native-image -jar target/&amp;lt;name&amp;gt;.jarTo debug which configuration data gets applied for the image building, use native-image --verbose. This will show from where native-image picks up theconfigurations to construct the final composite configuration command lineoptions for the native image builder.native-image --verbose -jar build/basic-app-0.1-all.jarApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/common/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/buffer/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/transport/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/handler/native-image.propertiesApply jar:file://~/build/basic-app-0.1-all.jar!/META-INF/native-image/io.netty/codec-http/native-image.properties...Executing [    &amp;lt;composite configuration command line options for the image builder&amp;gt;]Typical examples of META-INF/native-image based native image configuration can be found in Native Image configuration examples.Configuration File FormatA native-image.properties file is a regular Java properties file that can beused to specify native image configurations. The following properties aresupported.ArgsUse this property if your project requires custom native-image command line options to build correctly. For example, the native-image-configure-examples/configure-at-runtime-example has Args = --initialize-at-build-time=com.fasterxml.jackson.annotation.JsonProperty$Access  in its native-image.properties file to ensure the class com.fasterxml.jackson.annotation.JsonProperty$Access gets initialized at image build time.JavaArgsSometimes it can be necessary to provide custom options to the JVM that runs thenative image builder. The JavaArgs property can be used in this case.ImageNameThis property can be used to specify a user-defined name for the image. IfImageName is not used, a name gets automatically chosen:  native-image -jar &amp;lt;name.jar&amp;gt; has a default image name &amp;lt;name&amp;gt;  native-image -cp ... fully.qualified.MainClass has a default image name fully.qualified.mainclassNote that using ImageName does not prevent the user to override the name later via command line. For example, if foo.bar contains ImageName=foo_app:  native-image -jar foo.bar generates the image foo_app but  native-image -jar foo.bar application generates the image applicationOrder of Arguments EvaluationThe arguments passed to native-image are evaluated left-to-right. This alsoextends to arguments that get passed indirectly via META-INF/native-imagebased native image configuration. Suppose you have a JAR file that containsnative-image.properties with Args = -H:Optimize=0. Then by using the-H:Optimize=2 option after -cp &amp;lt;jar-file&amp;gt; you can override the setting thatcomes from the JAR file.Specifying Default Options for Native ImageIf there is a need to pass some options for every image build unconditionally, forexample, to always generate an image in verbose mode (--verbose), you canmake use of the NATIVE_IMAGE_CONFIG_FILE environment variable.If it is set to a Java properties file, the Native Image builder will use thedefault setting defined in there on each invocation. Write aconfiguration file and exportNATIVE_IMAGE_CONFIG_FILE=$HOME/.native-image/default.properties in~/.bash_profile. Every time native-image gets used, it will implicitly usethe arguments specified as NativeImageArgs, plus the arguments specified on thecommand line. Here is an example of a configuration file, saved as~/.native-image/default.properties:NativeImageArgs = --configurations-path /home/user/custom-image-configs                   -O1Changing the Configuration DirectoryNative Image by default stores the configuration information in user’s home directory – $HOME/.native-image/.In order to change the output directory, set the environment variable NATIVE_IMAGE_USER_HOME to a different location. For example:export NATIVE_IMAGE_USER_HOME= $HOME/.local/share/native-imageMemory Configuration for Native Image BuildThe native image build runs on the Java HotSpot VM and uses the memory management of the underlying platform.The usual Java HotSpot command-line options for garbage collection apply to the native image builder.During the native image build, the representation of a whole program is created tofigure out which classes and methods will be used at run time. It is acomputationally intensive process. The default values for memory usage at image build time are:-Xss10M -Xms1G These defaults can be changed by passing -J + &amp;lt;jvm option for memory&amp;gt; to the native image builder.The -Xmx value is computed by using 80% of the physical memory size, but no more than 14G per server.Providing a larger value for -Xmx on command line is possible, e.g., -J-Xmx26G.By default, image building uses of up to 32 threads (but not more than the number of processors available). For custom values -H:NumberOfThreads=... can be used.Check other related options to the native image builder from the native-image --expert-options-all list.Runtime vs Build-Time InitializationBuilding your application into a native image allows you to decide which partsof your application should be run at image build time and which parts have torun at image run time.All class-initialization code (static initializers and staticfield initialization) of the application you build an image for is executedat image run time by default. Sometimes it is beneficial to allow classinitialization code to get executed at image build time for faster startup (e.g.,if some static fields get initialized to run-time independent data). This can becontrolled with the following native-image options:  --initialize-at-build-time=&amp;lt;comma-separated list of packages and classes&amp;gt;  --initialize-at-run-time=&amp;lt;comma-separated list of packages and classes&amp;gt;In addition to that, arbitrary computations are allowed at build time that can be put into ImageSingletons that areaccessible at image run time. For more information please have a look at Native Image configuration examples.For more information, continue reading to the Class Initialization in Native Image guide.Assisted Configuration of Native Image BuildsNative images are built ahead of runtime and their build relies on a static analysis of which code will be reachable. However, this analysis cannot always completely predict all usages of the Java Native Interface (JNI), Java Reflection, Dynamic Proxy objects (java.lang.reflect.Proxy), or class path resources (Class.getResource). Undetected usages of these dynamic features need to be provided to the native-image tool in the form of configuration files.In order to make preparing these configuration files easier and more convenient, GraalVM provides an agent that tracks all usages of dynamic features of an execution on a regular Java VM. It can be enabled on the command line of the GraalVM java command:$JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/ ...Note that -agentlib must be specified before a -jar option or a class name or any application parameters in the java command line.During execution, the agent interfaces with the Java VM to intercept all calls that look up classes, methods, fields, resources, or request proxy accesses. The agent then generates the files jni-config.json, reflect-config.json, proxy-config.json and resource-config.json in the specified output directory, which is /path/to/config-dir/ in the example above. The generated files are standalone configuration files in JSON format which contain all intercepted dynamic accesses.It can be necessary to run the target application more than once with different inputs to trigger separate execution paths for a better coverage of dynamic accesses. The agent supports this with the config-merge-dir option which adds the intercepted accesses to an existing set of configuration files:$JAVA_HOME/bin/java -agentlib:native-image-agent=config-merge-dir=/path/to/config-dir/ ...                                                              ^^^^^If the specified target directory or configuration files in it are missing when using config-merge-dir, the agent creates them and prints a warning.By default the agent will write the configuration files after the JVM process terminates. In addition, the agent provides the following flags to write configuration files on a periodic basis:  config-write-period-secs: executes a periodic write every number of seconds as specified in this configuration. Supports only integer values greater than zero.  config-write-initial-delay-secs: the number of seconds before the first write is schedule for execution. Supports only integer values greater or equal to zero. Enabled only if config-write-period-secs is greater than zero.For example:$JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/,config-write-period-secs=300,config-write-initial-delay-secs=5 ...It is advisable to manually review the generated configuration files. Because the agent observes only code that was executed, the resulting configurations can be missing elements that are used in other code paths. It could also make sense to simplify the generated configurations to make any future manual maintenance easier.The generated configuration files can be supplied to the native-image tool by placing them in a META-INF/native-image/ directory on the class path, for example, in a JAR file used in the image build. This directory (or any of its subdirectories) is searched for files with the names jni-config.json, reflect-config.json, proxy-config.json and resource-config.json, which are then automatically included in the build. Not all of those files must be present. When multiple files with the same name are found, all of them are included.Building Native Image with Java Reflection ExampleFor demonstration purposes, save the following code as ReflectionExample.java file:import java.lang.reflect.Method;class StringReverser {    static String reverse(String input) {        return new StringBuilder(input).reverse().toString();    }}class StringCapitalizer {    static String capitalize(String input) {        return input.toUpperCase();    }}public class ReflectionExample {    public static void main(String[] args) throws ReflectiveOperationException {        String className = args[0];        String methodName = args[1];        String input = args[2];        Class&amp;lt;?&amp;gt; clazz = Class.forName(className);        Method method = clazz.getDeclaredMethod(methodName, String.class);        Object result = method.invoke(null, input);        System.out.println(result);    }}This is a simple Java program where non-constant strings for accessing programelements by name must come as external inputs. The main method invokes a methodof a particular class (Class.forName) whose names are passed as command linearguments. Providing any other class or method name on the command line leads toan exception.Having compiled the example, invoke each method:$JAVA_HOME/bin/javac ReflectionExample.java$JAVA_HOME/bin/java ReflectionExample StringReverser reverse &quot;hello&quot;olleh$JAVA_HOME/bin/java ReflectionExample StringCapitalizer capitalize &quot;hello&quot;HELLOBuild a native image normally, without a reflection configuration file, and run a resulting image:$JAVA_HOME/bin/native-image ReflectionExample[reflectionexample:59625]    classlist:     467.66 ms..../reflectionexampleThe reflectionexample binary is just a launcher for the JVM. Tobuild a native image with reflective lookup operations, apply the tracingagent to write a configuration file to be later fed into the native imagebuild together.  Create a directory META-INF/native-image in the working directory:    mkdir -p META-INF/native-image    Enable the agent and pass necessary command line arguments:    $JAVA_HOME/bin/java -agentlib:native-image-agent=config-output-dir=META-INF/native-image ReflectionExample StringReverser reverse &quot;hello&quot;    This command creates a reflection-config.json file which makes the StringReverser class and the reverse() method accessible via reflection. The jni-config.json, proxy-config.json , and resource-config.json configuration files are written in that directory too.    Build a native image:    $JAVA_HOME/bin/native-image --no-fallback ReflectionExample    The native image builder automatically picks up configuration files in theMETA-INF/native-image directory or subdirectories. However, it is recommendedto have META-INF/native-image location on the class path, either via a JARfile or via the -cp flag. It will help to avoid confusion for IDE users where adirectory structure is defined by the tool.    Test the methods, but remember that you have not run the tracing agent twice to create a configuration that supports both:    ./reflectionexample StringReverser reverse &quot;hello&quot;olleh./reflectionexample  StringCapitalizer capitalize &quot;hello&quot;Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: StringCapitalizer at com.oracle.svm.core.hub.ClassForNameSupport.forName(ClassForNameSupport.java:60) at java.lang.Class.forName(DynamicHub.java:1161) at ReflectionExample.main(ReflectionExample.java:21)  Neither the tracing agent nor native images generator can automatically checkif the provided configuration files are complete. The agent only observes andrecords which values are accessed through reflection so that the same accessesare possible in a native image. You can either manually edit thereflection-config.json file, or re-run the tracing agent to transform theexisting configuration file, or extend it by using config-merge-dir option:$JAVA_HOME/bin/java -agentlib:native-image-agent=config-merge-dir=META-INF/native-image ReflectionExample StringCapitalizer capitalize &quot;hello&quot;Note, the different config-merge-dir option instructs the agent to extend theexisting configuration files instead of overwriting them. After re-building thenative image, the StringCapitalizer class and the capitalize method will beaccessible too.Agent Advanced UsageCaller-based FiltersBy default, the agent filters dynamic accesses which Native Image supports without configuration. The filter mechanism works by identifying the Java method performing the access, also referred to as caller method, and matching its declaring class against a sequence of filter rules. The built-in filter rules exclude dynamic accesses which originate in the JVM, or in parts of a Java class library directly supported by Native Image (such as java.nio) from the generated configuration files. Which item (class, method, field, resource, etc.) is being accessed is not relevant for filtering.In addition to the built-in filter, custom filter files with additional rules can be specified using the caller-filter-file option. For example: -agentlib:caller-filter-file=/path/to/filter-file,config-output-dir=...Filter files have the following structure:{ &quot;rules&quot;: [    {&quot;excludeClasses&quot;: &quot;com.oracle.svm.**&quot;},    {&quot;includeClasses&quot;: &quot;com.oracle.svm.tutorial.*&quot;},    {&quot;excludeClasses&quot;: &quot;com.oracle.svm.tutorial.HostedHelper&quot;}  ]}The rules section contains a sequence of rules. Each rule specifies either includeClasses, which means that lookups originating in matching classes will be included in the resulting configuration, or excludeClasses, which excludes lookups originating in matching classes from the configuration. Each rule defines a pattern for the set of matching classes, which can end in .* or .**: a .* ending matches all classes in a package and that package only, while a .** ending matches all classes in the package as well as in all subpackages at any depth. Without .* or .**, the rule applies only to a single class with the qualified name that matches the pattern. All rules are processed in the sequence in which they are specified, so later rules can partially or entirely override earlier ones. When multiple filter files are provided (by specifying multiple caller-filter-file options), their rules are chained together in the order in which the files are specified. The rules of the built-in caller filter are always processed first, so they can be overridden in custom filter files.In the example above, the first rule excludes lookups originating in all classes from package com.oracle.svm and from all of its subpackages (and their subpackages, etc.) from the generated configuration. In the next rule however, lookups from those classes that are directly in package com.oracle.svm.tutorial are included again. Finally, lookups from the HostedHelper class is excluded again. Each of these rules partially overrides the previous ones. For example, if the rules were in the reverse order, the exclusion of com.oracle.svm.** would be the last rule and would override all other rules.For testing purposes, the built-in filter for Java class library lookups can be disabled by adding the no-builtin-caller-filter option, but the resulting configuration files are generally unsuitable for a native image build. Similarly, the built-in filter for Java VM-internal accesses based on heuristics can be disabled with no-builtin-heuristic-filter and will also generally lead to less usable configuration files. For example: -agentlib:native-image-agent=no-builtin-caller-filter,no-builtin-heuristic-filter,config-output-dir=...Access FiltersUnlike the caller-based filters described above, which filter dynamic accesses based on where they originate from, access filters apply to the target of the access. Therefore, access filters enable directly excluding packages and classes (and their members) from the generated configuration.By default, all accessed classes (which also pass the caller-based filters and the built-in filters) are included in the generated configuration. Using the access-filter-file option, a custom filter file that follows the file structure described above can be added. The option can be specified more than once to add multiple filter files and can be combined with the other filter options. For example: -agentlib:access-filter-file=/path/to/access-filter-file,caller-filter-file=/path/to/caller-filter-file,config-output-dir=...Specifying Configuration Files as Native Image ArgumentsA directory containing configuration files that is not part of the class path can be specified to native-image via -H:ConfigurationFileDirectories=/path/to/config-dir/. This directory must directly contain all four files: jni-config.json, reflect-config.json, proxy-config.json and resource-config.json. A directory with the same four configuration files that is on the class path, but not in META-INF/native-image/, can be provided via -H:ConfigurationResourceRoots=path/to/resources/. Both -H:ConfigurationFileDirectories and -H:ConfigurationResourceRoots can also take a comma-separated list of directories.Injecting the Agent via the Process EnvironmentAltering the java command line to inject the agent can prove to be difficult if the Java process is launched by an application or script file, or if Java is even embedded in an existing process. In that case, it is also possible to inject the agent via the JAVA_TOOL_OPTIONS environment variable. This environment variable can be picked up by multiple Java processes which run at the same time, in which case each agent must write to a separate output directory with config-output-dir. (The next section describes how to merge sets of configuration files.) In order to use separate paths with a single global JAVA_TOOL_OPTIONS variable, the agent’s output path options support placeholders:export JAVA_TOOL_OPTIONS=&quot;-agentlib:native-image-agent=config-output-dir=/path/to/config-output-dir-{pid}-{datetime}/&quot;The {pid} placeholder is replaced with the process identifier, while {datetime} is replaced with the system date and time in UTC, formatted according to ISO 8601. For the above example, the resulting path could be: /path/to/config-output-dir-31415-20181231T235950Z/.Trace FilesIn the examples above, native-image-agent has been used to both keep track of the dynamic accesses in a Java VM and then to generate a set of configuration files from them. However, for a better understanding of the execution, the agent can also write a trace file in JSON format that contains each individual access:$JAVA_HOME/bin/java -agentlib:native-image-agent=trace-output=/path/to/trace-file.json ...The native-image-configure tool can transform trace files to configuration files that can be used in native image builds. The following command reads and processes trace-file.json and generates a set of configuration files in directory /path/to/config-dir/:native-image-configure generate --trace-input=/path/to/trace-file.json --output-dir=/path/to/config-dir/InteroperabilityAlthough the agent is distributed with GraalVM, it uses the JVM Tool Interface (JVMTI) and can potentially be used with other JVMs that support JVMTI. In this case, it is necessary to provide the absolute path of the agent:/path/to/some/java -agentpath:/path/to/graalvm/jre/lib/amd64/libnative-image-agent.so=&amp;lt;options&amp;gt; ...The Native Image Configure ToolWhen using the agent in multiple processes at the same time as described in the previous section, config-output-dir is a safe option, but results in multiple sets of configuration files. The native-image-configure-launcher tool can be used to merge these configuration files. This tool must first be built with:native-image --macro:native-image-configure-launcher  Note: The Native Image Configure Tool is only available if native-image is built via mx. This configuration tool is not part of any GraalVM distribution by default.Then, the tool can be used to merge sets of configuration files as follows:native-image-configure-launcher generate --input-dir=/path/to/config-dir-0/ --input-dir=/path/to/config-dir-1/ --output-dir=/path/to/merged-config-dir/This command reads one set of configuration files from /path/to/config-dir-0/ and another from /path/to/config-dir-1/ and then writes a set of configuration files that contains both of their information to /path/to/merged-config-dir/.An arbitrary number of --input-dir arguments with sets of configuration files can be specified. See native-image-configure-launcher help for all options.",
                    "url": " /reference-manual/native-image/BuildConfiguration/"
                  },
                  
                  "reference-manual-native-image-c-api":  {
                    "title": "",
                    "content": "Native Image C APINative Image provides an API for the C language for initializing isolates and attaching threads for use with the entry point feature that is demonstrated here.The C API is available when Native Image is built as a shared library and its declarations are included in the header file that is generated during the build./* * Structure representing an isolate. A pointer to such a structure can be * passed to an entry point as the execution context. */struct __graal_isolate_t;typedef struct _graal_isolate_t graal_isolate_t;/* * Structure representing a thread that is attached to an isolate. A pointer to * such a structure can be passed to an entry point as the execution context, * requiring that the calling thread has been attached to that isolate. */struct __graal_isolatethread_t;typedef struct __graal_isolatethread_t graal_isolatethread_t;/* Parameters for the creation of a new isolate. */struct __graal_create_isolate_params_t {    /* for future use */};typedef struct __graal_create_isolate_params_t graal_create_isolate_params_t;/* * Create a new isolate, considering the passed parameters (which may be NULL). * Returns 0 on success, or a non-zero value on failure. * On success, the current thread is attached to the created isolate, and the * address of the isolate and the isolate thread structures is written to the * passed pointers if they are not NULL. */int graal_create_isolate(graal_create_isolate_params_t* params, graal_isolate_t** isolate, graal_isolatethread_t** thread);/* * Attaches the current thread to the passed isolate. * On failure, returns a non-zero value. On success, writes the address of the * created isolate thread structure to the passed pointer and returns 0. * If the thread has already been attached, the call succeeds and also provides * the thread&#39;s isolate thread structure. */int graal_attach_thread(graal_isolate_t* isolate, graal_isolatethread_t** thread);/* * Given an isolate to which the current thread is attached, returns the address of * the thread&#39;s associated isolate thread structure.  If the current thread is not * attached to the passed isolate or if another error occurs, returns NULL. */graal_isolatethread_t* graal_get_current_thread(graal_isolate_t* isolate);/* * Given an isolate thread structure, determines to which isolate it belongs and * returns the address of its isolate structure. If an error occurs, returns NULL * instead. */graal_isolate_t* graal_get_isolate(graal_isolatethread_t* thread);/* * Detaches the passed isolate thread from its isolate and discards any state or * context that is associated with it. At the time of the call, no code may still * be executing in the isolate thread&#39;s context. * Returns 0 on success, or a non-zero value on failure. */int graal_detach_thread(graal_isolatethread_t* thread);/* * Tears down the passed isolate, waiting for any attached threads to detach from * it, then discards the isolate&#39;s objects, threads, and any other state or context * that is associated with it. * Returns 0 on success, or a non-zero value on failure. */int graal_tear_down_isolate(graal_isolatethread_t* thread);In addition to the C level API, there is also a way to initialize an isolatefrom Java and thus use Java and Native Image toimplement native methods in Java.",
                    "url": " /reference-manual/native-image/C-API/"
                  },
                  
                  "reference-manual-native-image-classinitialization":  {
                    "title": "",
                    "content": "Class Initialization in Native ImageThe semantics of Java requires that a class is initialized the first time it is accessed at run time.Class initialization has negative consequences for ahead-of-time compilation of Java as:  It significantly degrades the performance of native images: every class access (via field or method) requires a check if the class is already initialized. Without special optimizations, this can reduce performance by more than 2x.  It increases the amount of work to start the application. For example, the simple “Hello, World!” program requires initialization of more than 300 classes.To reduce the negative impact of class initialization, Native Image supports class initialization at build time: certain classes can be initialized during image building, making run-time initialization and checks unnecessary.All the static state information from initialized classes is stored in the image.Access to the static fields that were initialized at build time is transparent to the application and works as if the class was initialized at run time.Specifying class initialization policies can be complicated due to the following constraints that come from class initialization semantics:  When a class is initialized, all super classes and super interfaces with default methods must also be initialized.Interfaces without default methods, however, are not initialized. To describe this, a short-term “relevant supertype” is used furhter, and a relevant subtype for subtypes of classes and interfaces with default methods.  Relevant supertypes of types initialized at build time must also be initialized at build time.  Relevant subtypes of types initialized at run time must also be initialized at run time.  No instances classes that are initialized at run time must be present in the image.To enjoy the complete out-of-the-box experience of Native Image and still get the benefits of build-time initailization, Native Image does three things:  Build-Time Initialization of Native Image Runtime  Automatic Initialization of Safe Classes  Explicitly Specifying Class InitializationTo track which classes were initialized and why, one can use the flag -H:+PrintClassInitialization.This flag greatly helps to configure the image build to work as intended. The goal is to have as many classes as possible initialized at build time, yet keep the correct semantics of the program.Build-Time Initialization of Native Image RuntimeIn the Native Image runtime most of the classes are initialized at image build time.This includes the garbage collector, important JDK classes, the deoptimizer, etc.For all of the build-time initialized classes from the runtime, Native Image gives proper support so the semantics remains the same even if initialization happened at build time.If there is an issue with a JDK class behaving incorrectly because of class initialization at build time, please report an issue.Automatic Initialization of Safe ClassesFor application classes, Native Image tries to find classes that can be safely initialized at build time.A class is considered safe if all of its relevant super types are safe and if the class initializer does not call any unsafe methods or initialize other unsafe classes.A method is considered as unsafe:  If it transitively calls into native code (e.g., System.out.println): native code is not analyzed so Native Image cannot know which illegal actions could have been performed.  If it calls methods that cannot be reduced to a single target (virtual methods).This restriction is there to avoid the explosion of search space for the safety analysis of static initializers.  If it is substituted by Native Image. Running initializers of substituted methods would yield different results in the hosting VM than in the produced image.As a result, the safety analysis would consider some methods safe but their execution would lead to illegal states.A test that shows examples of classes that are proven safe can be found here.The list of all classes that are proven safe is displayed in a file when -H:+PrintClassInitialization is set on the command line.Explicitly Specifying Class InitializationEach class can be initialized either (1) at run time, or (2) at build time.To specify class-initialization policies, two flags are provided: --initialize-at-build-time and --initialize-at-run-time.These flags allow specifying a policy for whole packages or individual classes.For example, if you have classes p.C1, p.C2, … , or p.Cn, you can eagerly initialize this package with:--initialize-at-build-time=pIf you want to delay one of the classes in package p, simply add:--initialize-at-run-time=p.C1The whole class hierarchy can be initialized at build time by passing --initialize-at-build-time on the command line.Class initialization can also be specified programatically by using RuntimeClassInitialization from the Native Image feature.",
                    "url": " /reference-manual/native-image/ClassInitialization/"
                  },
                  
                  "reference-manual-native-image-codestyle":  {
                    "title": "",
                    "content": "Native Image Code StyleSource Code FormattingThe IDE projects generated with mx ideinit are configured with strict formatting rules.In Eclipse, when a file is saved, it is automatically formatted according to these rules.The rule set has grown over time and proved to be useful, but the rules are open for discussion.The configuration includes special comments which can be used to relax checks in particular regions of code.Source code formatting can be disabled with special comments://@formatter:off//@formatter:onComment reformatting can be disabled like this:/*- * */Checks with CheckstyleCheckstyle is used to verify adherence to the style rules.It can be run manually with mx checkstyle.The default Checkstyle rules are defined in src/com.oracle.svm.core/.checkstyle_checks.xml and define various special comments, including//Checkstyle: stop method name check//Checkstyle: resume method name checkand similar commands for other checks that can be disabled (including general stop and resume commands).Of course, ensuring a reasonable use of these comments is a matter for code review.If a project requires a different set of Checkstyle rules, this can be specified in mx.substratevm/suite.py by changing the value of the project’s checkstyle attribute (which, by default, references com.oracle.svm.core).Specific code files can be excluded from Checkstyle on a directory granularity with a file src/&amp;lt;project name&amp;gt;/.checkstyle.exclude.Such an exclusion file must contain one directory per line, with paths relative to the project root.The file must be explicitly added with git add because git will ignore it by default.When pulling a changeset which adds or removes Checkstyle XML files, the IDE might show inappropriate style warnings or errors.This is resolved by running mx ideinit and cleaning the affected projects.IDE IntegrationIDE plugins can be helpful in adhering to style rules.Some examples are:  Eclipse Checkstyle Plugin: reports Checkstyle violations in Eclipse, making it unnecessary to run mx checkstyle manually.https://checkstyle.github.io/eclipse-cs/  IntelliJ Eclipse Code Formatter: formats source files in IntelliJ according to Eclipse IntelliJ rules.This plugin is automatically configured by mx ideinit.https://github.com/krasa/EclipseCodeFormatter  IntelliJ Save Actions to automatically format files before saving them.https://github.com/dubreuia/intellij-plugin-save-actionsSee the documentation on IDE integration for further suggestions.",
                    "url": " /reference-manual/native-image/CodeStyle/"
                  },
                  
                  "reference-manual-llvm-compatibility":  {
                    "title": "",
                    "content": "LLVM CompatibilityGraalVM supports LLVM bitcode versions 3.8 to 10.0.It is recommended to use the LLVM toolchain shipped with GraalVM.Optimizations FlagsIn contrast to the static compilation model of LLVM languages, in GraalVM themachine code is not directly produced from the LLVM bitcode. There is anadditional dynamic compilation step by the GraalVM compiler.First, the LLVM frontend (e.g., clang) performs optimizations onthe bitcode level, and then the GraalVM compiler does its own optimizations on top of thatduring dynamic compilation. Some optimizations are better when doneahead-of-time on bitcode, while other optimizations are better left for thedynamic compilation of the GraalVM compiler, when profiling information is available.The LLVM toolchain that is shipped with GraalVM automatically selects therecommended flags by default.Generally, all optimization levels should work, but for a better result, it isrecommended to compile the bitcode with the optimization level -O1.For cross-language interoperability, the -mem2reg optimization is required.There are two ways to get that: either compile with at least -O1, or use the opt tool to apply the -mem2reg optimization manually.",
                    "url": " /reference-manual/llvm/Compatibility/"
                  },
                  
                  "reference-manual-r-compatibility":  {
                    "title": "",
                    "content": "GraalVM R Runtime CompatibilityThe GraalVM R runtime is based on GNU R and reuses the base packages.It is currently based on GNU R 4.0.3, and moves to new major versions of R as they become available and stable.GraalVM’s R runtime developers maintain an extensive set of unit tests for all aspects of the R language and the builtin functionality, and these tests are available as part of the R source code.GraalVM’s R runtime aims to be fully compatible with GNU R, including its native interface as used by R extensions.It can install and run unmodified, complex R packages like ggplot2, Shiny, or Rcpp.As some packages rely on unspecified behaviour or implementation details of GNU R, support for packages is a work in progress, and some packages might not install successfully or work as expected.Installing PackagesPackages can be installed using the install.packages function or the R CMD INSTALL shell command.By default, GraalVM’s R runtime uses a fixed snapshot of the CRAN repository1.This behavior can be overridden by explicitly setting the repos argument of the install.packages function.This functionality does not interfere with the checkpoint package. If you are behind a proxy server, make sure to configure the proxy either with environment variables or using the JVM options, e.g., --vm.Djava.net.useSystemProxies=true.The versions of some packages specifically patched for GraalVM’s R runtime can be installed using the install.fastr.packages function that downloads them from the GitHub repository.Currently, those are rJava and data.table.LimitationsThere are some limitations of the GraalVM R runtime compared to GNU R:  Only small parts of the low-level graphics package are functional. However, the grid package is supported and R can install and run packages based on it, like ggplot2. Support for the graphics package in R is planned for future releases.  Encoding of character vectors: related builtins (e.g., Encoding) are available,   but do not execute any useful code. Character vectors are represented as Java Strings and therefore encoded in the UTF-16 format. GraalVM’s R runtime will add support for encoding in future releases.  Some parts of the native API (e.g., DATAPTR) expose implementation details that are hard to emulate for alternative implementations of R. These are implemented as needed while testing the GraalVM R runtime with various CRAN packages.1 More technically, GraalVM’s R runtime uses a fixed MRAN URL from $R_HOME/etc/DEFAULT_CRAN_MIRROR, which is a snapshot of the CRAN repository as it was visible at a given date from the URL string.",
                    "url": " /reference-manual/r/Compatibility/"
                  },
                  
                  "reference-manual-llvm-compiling":  {
                    "title": "",
                    "content": "Compiling to LLVM BitcodeGraalVM can execute C/C++, Rust, and other languages that can be compiled to LLVM bitcode.As the first step, you have to compile a program to LLVM bitcode using some LLVM compiler front end, for example, clang for C and C++, rust for the Rust programing language, etc.File FormatWhile the GraalVM LLVM runtime can execute plain bitcode files,the preferred format is a native executable with embedded bitcode.The executable file formats differ on Linux and macOS.Linux by default uses ELF files.The bitcode is stored in a section called .llvmbc.The macOS platform uses Mach-O files.The bitcode is in the __bundle section of the __LLVM segment.Using native executables with embedded bitcode offers two advantages over plain bitcode files.First, build systems for native projects, for example a Makefile, expect the result to be an executable.Embedding the bitcode instead of changing the output format improves compatibility with existing projects.Second, executables allow specifying library dependencies which is not possible with LLVM bitcode.The GraalVM LLVM runtime utilizes this information to find and load dependencies.LLVM Toolchain for Compiling C/C++To simplify compiling C/C++ to executables with embedded bitcode, GraalVM comes with a pre-built LLVM toolchain.The toolchain contains compilers such as clang for C or clang++ for C++, but also other tools that are neededfor building native projects such as a linker (ld), or an archiver (ar) for creating static libraries.The LLVM toolchain can be added to GraalVM on demand with the GraalVM Updater tool:$GRAALVM_HOME/bin/gu install llvm-toolchainThe above command will install the LLVM toolchain from the GitHub catalog for GraalVM Community users.For GraalVM Enterprise users, the manual installation is required.To get the location of the toolchain, use the --print-toolchain-path argument of lli:export LLVM_TOOLCHAIN=$($GRAALVM_HOME/bin/lli --print-toolchain-path)See the content of the toolchain path for a list of available tools:ls $LLVM_TOOLCHAINUse those tools just as you would for native compilation. For example, save this C code in a file named hello.c:#include &amp;lt;stdio.h&amp;gt;int main() {    printf(&quot;Hello from GraalVM!n&quot;);    return 0;}Then you can compile hello.c to an executable with embedded LLVM bitcode as follows:$LLVM_TOOLCHAIN/clang hello.c -o helloThe resulting executable, hello, can be executed on GraalVM using lli:$GRAALVM_HOME/bin/lli helloExternal Library DependenciesIf the bitcode file depends on external libraries, GraalVM will automaticallypick up the dependencies from the binary headers. For example:#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;ncurses.h&amp;gt;int main() {    initscr();    printw(&quot;Hello, Curses!&quot;);    refresh();    sleep(1);    endwin();    return 0;}This hello-curses.c file can be then compiled and run with:$LLVM_TOOLCHAIN/clang hello-curses.c -lncurses -o hello-curseslli hello-cursesRunning C++For running C++ code, the GraalVM LLVM runtime requires thelibc++ standard library from the LLVM project. TheLLVM toolchain shipped with GraalVM automatically links against libc++. For example, save this code as a hello-c++.cpp file:#include &amp;lt;iostream&amp;gt;int main() {    std::cout &amp;lt;&amp;lt; &quot;Hello, C++ World!&quot; &amp;lt;&amp;lt; std::endl;}Compile it with clang++ shipped with GraalVM and execute:$LLVM_TOOLCHAIN/clang++ hello-c++.cpp -o hello-c++lli hello-c++Hello, C++ World!Running RustThe LLVM toolchain, bundled with GraalVM, does not come with the Rustcompiler. To install Rust, run the following in your command prompt, then follow theonscreen instructions:curl https://sh.rustup.rs -sSf | shSave this example Rust code in a hello-rust.rs file:fn main() {    println!(&quot;Hello Rust!&quot;);}This can be then compiled to bitcode with the --emit=llvm-bc flag:rustc --emit=llvm-bc hello-rust.rsTo run the Rust program, we have to tell GraalVM where to find the Ruststandard libraries:lli --lib $(rustc --print sysroot)/lib/libstd-* hello-rust.bcHello Rust!Since the Rust compiler is not using the LLVM toolchain shipped with GraalVM, depending on thelocal Rust installation, an error similar to one of the following might happen:Mismatching target triple (expected x86_64-unknown-linux-gnu, got x86_64-pc-linux-gnu)Mismatching target triple (expected x86_64-apple-macosx10.11.0, got x86_64-apple-darwin)This indicates that the Rust compiler used a different target triple than the LLVM toolchainshipped with GraalVM. In this particular case, the differences are just different namingconventions across Linux distributions or MacOS versions, there is no real difference.In that case, the error can be safely ignored:lli --experimental-options --llvm.verifyBitcode=false --lib $(rustc --print sysroot)/lib/libstd-* hello-rust.bcThis option should only be used after manually verifying that the target triples arereally compatible, i.e., the architecture, operating system, and C library all match.For example, x86_64-unknown-linux-musl and x86_64-unknown-linux-gnu are really different,the bitcode is compiled for a different C library. The --llvm.verifyBitcode=false optiondisables all checks, GraalVM will then try to run the bitcode regardless, which might randomlyfail in unexpected ways.",
                    "url": " /reference-manual/llvm/Compiling/"
                  },
                  
                  "reference-manual-native-image-debuginfo":  {
                    "title": "",
                    "content": "Debug Info FeatureTo add debug info to a generated native image, add the flag-H:GenerateDebugInfo=&amp;lt;N&amp;gt; to the native image command line (where N isa positive integer value – the default value 0 means generate nodebug info). For example,javac Hello.javanative-image -H:GenerateDebugInfo=1 HelloThe resulting image should contain code (method) debug records in aformat the GNU Debugger (GDB) understands (Windows support is still under development).At present it makes no difference which positive value is supplied to the GenerateDebugInfo option.Source File CachingThe GenerateDebugInfo option also enables caching of sources for anyJDK runtime classes, GraalVM classes, and application classes which canbe located during native image generation. By default, the cache is createdalongside the generated native image in a subdirectory named sources. If atarget directory for the image is specified using option -H:Path=... thenthe cache is also relocated under that same target. A command line option canbe used to provide an alternative path to sources. It is used to configuresource file search path roots for the debugger. Files in the cache arelocated in a directory hierarchy that matches the file pathinformation included in the native image debug records. The sourcecache should contain all the files needed to debug the generated imageand nothing more. This local cache provides a convenient way of makingjust the necessary sources available to the debugger or IDE whendebugging a native image.The implementation tries to be smart about locating source files. Ituses the current JAVA_HOME to locate the JDK src.zip when searchingfor JDK runtime sources. It also uses entries in the classpath tosuggest locations for GraalVM source files and application sourcefiles (see below for precise details of the scheme used to identifysource locations). However, source layouts do vary and it may not bepossible to find all sources. Hence, users can specify the location ofsource files explicitly on the command line using optionDebugInfoSourceSearchPath:javac --source-path apps/greeter/src     -d apps/greeter/classes org/my/greeter/*Greeter.javajavac -cp apps/greeter/classes     --source-path apps/hello/src     -d apps/hello/classes org/my/hello/Hello.javanative-image -H:GenerateDebugInfo=1     -H:-SpawnIsolates     -H:DebugInfoSourceSearchPath=apps/hello/src     -H:DebugInfoSourceSearchPath=apps/greeter/src     -cp apps/hello/classes:apps/greeter/classes org.my.hello.HelloThe DebugInfoSourceSearchPath option can be repeated as many times asrequired to notify all the target source locations. The value passedto this option can be either an absolute or relative path. It canidentify either a directory, a source JAR, or a source zip file. It isalso possible to specify several source roots at once using a commaseparator:native-image -H:GenerateDebugInfo=1     -H:DebugInfoSourceSearchPath=apps/hello/target/hello-sources.jar,apps/greeter/target/greeter-sources.jar     -cp apps/target/hello.jar:apps/target/greeter.jar     org.my.HelloBy default, the cache of application, GraalVM, and JDK sources iscreated in a directory named sources. The DebugInfoSourceCacheRootoption can be used to specify an alternative path, which can beabsolute or relative. In the latter case the path is interpretedrelative to the target directory for the generated native imagespecified via option -H:Path (which defaults to the currentworking directory). As an example, the following variant of theprevious command specifies an absolute temporary directory pathconstructed using the current process id:SOURCE_CACHE_ROOT=/tmp/$$/sourcesnative-image -H:GenerateDebugInfo=1     -H:-SpawnIsolates     -H:DebugInfoSourceCacheRoot=$SOURCE_CACHE_ROOT     -H:DebugInfoSourceSearchPath=apps/hello/target/hello-sources.jar,apps/greeter/target/greeter-sources.jar     -cp apps/target/hello.jar:apps/target/greeter.jar     org.my.HelloThe resulting cache directory will be something like /tmp/1272696/sources.If the source cache path includes a directory that does not yet exist,it will be created during population of the cache.Note that in all the examples above the DebugInfoSourceSearchPathoptions are actually redundant. In the first case, the classpathentries for apps/hello/classes and apps/greeter/classes will be usedto derive the default search roots apps/hello/src andapps/greeter/src. In the second case, the classpath entries forapps/target/hello.jar and apps/target/greeter.jar will be used toderive the default search roots apps/target/hello-sources.jar andapps/target/greeter-sources.jar.Currently Implemented FeaturesThe currently implemented features include:  break points configured by file and line, or by method name  single stepping by line including both into and over function calls  stack backtraces (not including frames detailing inlined code)  printing of primitive values  structured (field by field) printing of Java objects  casting/printing objects at different levels of generality  access through object networks via path expressions  reference by name to methods and static field dataNote that single stepping within a compiled method includes file andline number info for inlined code, including inlined GraalVM methods.So, GDB may switch files even though you are still in the samecompiled method.Currently Missing Features  reference by name to values bound to parameter and local varsThis feature is scheduled for inclusion in a later release.Special considerations for debugging Java from GDBGDB does not currently include support for debugging of Java programs.In consequence, debug capability has been implemented by generating debuginfo that models the Java program as an equivalent C++ program. Javaclass, array and interface references are actually pointers to recordsthat contain the relevant field/array data. In the corresponding C++model the Java name is used to label the underlying C++ (class/struct)layout types and Java references appear as pointers.So, for example in the DWARF debug info model java.lang.Stringidentifies a C++ class. This class layout type declares the expectedfields like hash of type int and value of type byte[] andmethods like String(byte[]), charAt(int), etc. However, the copyconstructor which appears in Java as String(String) appears in gdbwith the signature String(java.lang.String *).The C++ layout class inherits fields and methods from class (layout)type java.lang.Object using C++ public inheritance. The latter in turninherits standard oop (ordinary object pointer) header fields from a special struct class named_objhdr which includes a single field called hub whose type isjava.lang.Class * i.e. it is a pointer to the object’s class.The ptype command can be used to print details of a specific type. Notethat the java type name must be specified in quotes because to escape theembedded . characters.(gdb) ptype &#39;java.lang.String&#39;type = class java.lang.String : public java.lang.Object {  private:    byte [] *value;    int hash;    byte coder;  public:    void String(byte [] *);    void String(char [] *);    void String(byte [] *, java.lang.String *);    . . .    char charAt(int);    . . .    java.lang.String * concat(java.lang.String *);    . . .}The print command can be used to print the contents of a referenced objectfield by field. Note how a cast is used to convert a raw memory address toa reference for a specific Java type.(gdb) print *(&#39;java.lang.String&#39; *) 0x7ffff7c01060$1 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0x90cb58    }, &amp;lt;No data fields&amp;gt;},  members of java.lang.String:  value = 0x7ffff7c011a0,  hash = 0,  coder = 0 &#39;000&#39;}The hub field in the object header is actually a reference of Java typejava.lang.Class. Note that the field is typed by gdb using a pointerto the underlying C++ class (layout) type.All classes, from Object downwards inherit from a common, automaticallygenerated header type _objhdr. It is this header type which includesthe hub field:(gdb) ptype _objhdrtype = struct _objhdr {    java.lang.Class *hub;    int idHash;}(gdb) ptype &#39;java.lang.Object&#39;type = class java.lang.Object : public _objhdr {  public:    void Object(void);    . . .Given an address that might be an object reference it is possible toverify that case and identify the object’s type by printing thecontents of the String referenced from the hub’s name field.  Firstthe value is cast to an object reference. Then a path expression isused to dereference through the the hub field and the hub’s name fieldto the byte[] value array located in the name String.(gdb) print/x ((_objhdr *)$rdi)$2 = 0x7ffff7c01028(gdb) print *$2-&amp;gt;hub-&amp;gt;name-&amp;gt;value$3 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0x942d40,      idHash = 1806863149    }, &amp;lt;No data fields&amp;gt;},  members of byte []:  len = 19,  data = 0x923a90 &quot;[Ljava.lang.String;&quot;}The value in register rdx is obviously a reference to a String array.Casting it to this type shows it has length 1.(gdb) print *(&#39;java.lang.String[]&#39; *)$rdi$4 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0x925be8,      idHash = 0    }, &amp;lt;No data fields&amp;gt;},  members of java.lang.String[]:  len = 1,  data = 0x7ffff7c01038}A simpler command which allows just the name of the hub object to beprinted is as follows:(gdb) x/s $2-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;data798:&quot;[Ljava.lang.String;&quot;Indeed it is useful to define a gdb command hubname_raw to execute thisoperation on an arbitrary raw memory address.define hubname_raw  x/s ((&#39;java.lang.Object&#39; *)($arg0))-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;dataend(gdb) hubname_raw $rdi0x904798:&quot;[Ljava.lang.String;&quot;Attempting to print the hub name for an invalid reference will failsafe, printing an error message.(gdb) p/x $rdx$5 = 0x2(gdb) hubname $rdxCannot access memory at address 0x2Array type layouts are modelled as a C++ class type. It inheritsfrom class Object so it includes the hub and idHash header fieldsdefined by _objhdr. It adds a length field and an embedded (C++) dataarray whose elements are typed from the Java array’s element type,either primitive values or object references.(gdb) ptype &#39;java.lang.String[]&#39;type = class java.lang.String[] : public java.lang.Object {    int len;    java.lang.String *data[0];}The embedded array is nominally sized with length 0. However, when aJava array instance is allocated it includes enough space to ensurethe data array can store the number of items defined in the lengthfield.Notice that in this case the type of the values stored in the dataarray is java.lang.String *. The the C++ array stores Javaobject references i.e. addresses as far as the C++ model isconcerned.If gdb already knows the Java type for a reference it can be printedwithout casting using a simpler version of the hubname command. Forexample, the String array retrieved above as $4 has a known type.(gdb) ptype $4type = class java.lang.String[] : public java.lang.Object {    int len;    java.lang.String *data[0];}define hubname  x/s (($arg0))-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;dataend(gdb) hubname $40x923b68:&quot;[Ljava.lang.String;&quot;Interface layouts are modelled as C++ union types. The members of theunion include the C++ layout types for all Java classes which implementthe interface.(gdb) ptype &#39;java.lang.CharSequence&#39;type = union java.lang.CharSequence {    java.nio.CharBuffer _java.nio.CharBuffer;    java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;    java.lang.String _java.lang.String;    java.lang.StringBuilder _java.lang.StringBuilder;    java.lang.StringBuffer _java.lang.StringBuffer;}Given a reference typed to an interface it can be resolved to therelevant class type by viewing it through the relevant union element.If we take the first String in the args array we can ask gdb to castit to interface CharSequence.(gdb) print ((&#39;java.lang.String[]&#39; *)$rdi)-&amp;gt;data[0]$5 = (java.lang.String *) 0x7ffff7c01060(gdb) print (&#39;java.lang.CharSequence&#39; *)$5$6 = (java.lang.CharSequence *) 0x7ffff7c01060The hubname command will not work with this union type because it isonly objects of the elements of the union that include the hub field:(gdb) hubname $6There is no member named hub.However, since all elements include the same header any one of themcan be passed to hubname in order to identify the actual type. Thisallows the correct union element to be selected:(gdb) hubname $6-&amp;gt;&#39;_java.nio.CharBuffer&#39;0x7d96d8:&quot;java.lang.String270&quot;, &amp;lt;incomplete sequence 344220&amp;gt;(gdb) print $6-&amp;gt;&#39;_java.lang.String&#39;$18 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {      hub = 0x90cb58    }, &amp;lt;No data fields&amp;gt;},  members of java.lang.String:  value = 0x7ffff7c011a0,  hash = 0,  coder = 0 &#39;000&#39;}Notice that the printed class name for the hub includes some trailingcharacters. That’s because a data array storing Java String textis not guaranteed to be zero-terminated.The current debug info model does not include the location info neededto allow symbolic names for local vars and parameter vars to beresolved to primitive values or object references. However, thedebugger does understand method names and static field names.The following command places a breakpoint on the main entry point forclass Hello. Note that since GDB thinks this is a C++ method it usesthe :: separator to separate the method name from the class name.(gdb) info func ::mainAll functions matching regular expression &quot;::main&quot;:File Hello.java:void Hello::main(java.lang.String[] *);(gdb) x/4i Hello::main=&amp;gt; 0x4065a0 &amp;lt;Hello::main(java.lang.String[] *)&amp;gt;:sub    $0x8,%rsp   0x4065a4 &amp;lt;Hello::main(java.lang.String[] *)+4&amp;gt;:cmp    0x8(%r15),%rsp   0x4065a8 &amp;lt;Hello::main(java.lang.String[] *)+8&amp;gt;:jbe    0x4065fd &amp;lt;Hello::main(java.lang.String[] *)+93&amp;gt;   0x4065ae &amp;lt;Hello::main(java.lang.String[] *)+14&amp;gt;:callq  0x406050 &amp;lt;Hello$Greeter::greeter(java.lang.String[] *)&amp;gt;(gdb) b Hello::mainBreakpoint 1 at 0x4065a0: file Hello.java, line 43.An example of a static field containing Object data is provided by the static field powerCache in class BigInteger.(gdb) ptype &#39;java.math.BigInteger&#39;type = class _java.math.BigInteger : public _java.lang.Number {  public:    int [] mag;    int signum;  private:    int bitLengthPlusOne;    int lowestSetBitPlusTwo;    int firstNonzeroIntNumPlusTwo;    static java.math.BigInteger[][] powerCache;    . . .  public:    void BigInteger(byte [] *);    void BigInteger(java.lang.String *, int);    . . .}(gdb) info var powerCacheAll variables matching regular expression &quot;powerCache&quot;:File java/math/BigInteger.java:java.math.BigInteger[][] *java.math.BigInteger::powerCache;The static variable name can be used to refer to the value stored inthis field. Note also that the address operator can be used identifythe location (address) of the field in the heap.(gdb) p &#39;java.math.BigInteger&#39;::powerCache$8 = (java.math.BigInteger[][] *) 0xa6fd98(gdb) p &amp;amp;&#39;java.math.BigInteger&#39;::powerCache$9 = (java.math.BigInteger[][] **) 0xa6fbd8The gdb dereferences through symbolic names for static fields to accessthe primitive value or object stored in the field.(gdb) p *&#39;java.math.BigInteger&#39;::powerCache$10 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {    hub = 0x9ab3d0,    idHash = 489620191    }, &amp;lt;No data fields&amp;gt;},  members of _java.math.BigInteger[][]:  len = 37,  data = 0xa6fda8}(gdb) p &#39;java.math.BigInteger&#39;::powerCache-&amp;gt;data[0]@4$11 = {0x0, 0x0, 0xc09378, 0xc09360}(gdb) p *&#39;java.math.BigInteger&#39;::powerCache-&amp;gt;data[2]$12 = {  &amp;lt;java.lang.Object&amp;gt; = {    &amp;lt;_objhdr&amp;gt; = {    hub = 0x919898,    idHash = 1796421813    }, &amp;lt;No data fields&amp;gt;},  members of java.math.BigInteger[]:  len = 1,  data = 0xc09388}(gdb) p *&#39;java.math.BigInteger&#39;::powerCache-&amp;gt;data[2]-&amp;gt;data[0]$14 = {  &amp;lt;java.lang.Number&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x919bc8      }, &amp;lt;No data fields&amp;gt;}, &amp;lt;No data fields&amp;gt;},  members of java.math.BigInteger:  mag = 0xa5b030,  signum = 1,  bitLengthPlusOne = 0,  lowestSetBitPlusTwo = 0,  firstNonzeroIntNumPlusTwo = 0}Identifying the Location of Source CodeOne goal of the implementation is to make it simple to configure yourdebugger so that it can identify the relevant source file when itstops during program execution. The native image builder tries toachieve this by accumulating the relevant sources in a suitablystructured file cache.The native image builder uses different strategies to locate sourcefiles for JDK runtime classes, GraalVM classes, and application sourceclasses for inclusion in the local sources cache. It identifies whichstrategy to use based on the package name of the class. So, forexample, packages starting with java.* or jdk.* are JDK classes;packages starting with org.graal.* or com.oracle.svm.* are GraalVMclasses; any other packages are regarded as application classes.Sources for JDK runtime classes are retrieved from the src.zip foundin the JDK release used to run the native image generation process.Retrieved files are cached under subdirectory sources/jdk, using themodule name (for JDK11) and package name of the associated class todefine the directory hierarchy in which the source is located.For example, on Linux the source for class java.util.HashMap willbe cached in file sources/jdk/java.base/java/util/HashMap.java. Debuginfo records for this class and its methods will identify this sourcefile using the relative directory path java.base/java/util and filename HashMap.java. On Windows things will be the same modulo use of rather than / as the file separator.Sources for GraalVM classes are retrieved from zip files or sourcedirectories derived from entries in the classpath. Retrieved files arecached under subdirectory sources/graal, using the package name of theassociated class to define the directory hierarchy in which the sourceis located (e.g., class com.oracle.svm.core.VM has its source filecached at sources/graal/com/oracle/svm/core/VM.java).The lookup scheme for cached GraalVM sources varies depending uponwhat is found in each classpath entry. Given a JAR file entry like/path/to/foo.jar, the corresponding file /path/to/foo.src.zip isconsidered as a candidate zip file system from which source files maybe extracted. When the entry specifies a dir like /path/to/bar thendirectories /path/to/bar/src and /path/to/bar/src_gen are consideredas candidates. Candidates are skipped when the zip file or sourcedirectory does not exist, or it does not contain at least onesubdirectory hierarchy that matches one of the the expected GraalVMpackage hierarchies.Sources for application classes are retrieved from source JAR files orsource directories derived from entries in the classpath. Retrievedfiles are cached under subdirectory sources/src, using the packagename of the associated class to define the directory hierarchy inwhich the source is located (e.g., class org.my.foo.Foo has itssource file cached as sources/src/org/my/foo/Foo.java).The lookup scheme for cached application sources varies depending uponwhat is found in each classpath entry. Given a JAR file entry like/path/to/foo.jar, the corresponding JAR /path/to/foo-sources.jar isconsidered as a candidate zip file system from which source files maybe extracted. When the entry specifies a dir like /path/to/bar/classesor /path/to/bar/target/classes then one of the directories/path/to/bar/src/main/java, /path/to/bar/src/java or /path/to/bar/srcis selected as a candidate (in that order of preference). Finally, thecurrent directory in which the Native Image program is being run isalso considered as a candidate.These lookup strategies are only provisional and may need extending in thefuture. However, it is possible to make missing sourcesavailable by other means. One option is to unzip extra app source JAR files,or copy extra app source trees into the cache. Another is toconfigure extra source search paths.Configuring Source Paths in GNU DebuggerBy default, GDB will employ the three local directory rootssources/{jdk,graal,src} to locate the source files for your app classes, GraalVMclasses, and JDK runtime classes. If the sources cache is not located in thedirectory in which you run GDB, you can configure the required paths using thefollowing command:(gdb) set directories /path/to/sources/jdk:/path/to/sources/graal:/path/to/sources/srcThe /path/to/sources/jdk directory should contain source files for all JDK runtimeclasses referenced from debug records.The /path/to/sources/graal directory should contain source files for all GraalVMclasses referenced from debug records. Note that the currentimplementation does not yet find some sources for the GraalVM JITcompiler in the org.graalvm.compiler* package subspace.The /path/to/sources/src directory should contain source files for allapplication classes referenced from debug records, assuming they canbe located using the lookup strategy described above.You can supplement the files cached in sources/src by unzippingapplication source JAR files or copying application source trees into thecache. You will need to ensure that any new subdirectory you add tosources/src corresponds to the top level package for the classes whosesources are being included.You can also add extra directories to the search path using the set directories command:(gdb) set directories /path/to/my/sources/:/path/to/my/other/sourcesNote that the GNU Debugger does not understand zip format file systems so any extra entries youadd must identify a directory tree containing the relevantsources. Once again, top level entries in the directory added to thesearch path must correspond to the top level package for the classeswhose sources are being included.Checking Debug Info on LinuxNote that this is only of interest to those who want to understand how thedebug info implementation works or want to troubleshoot problemsencountered during debugging that might relate to the debug infoencoding.The objdump command can be used to display the debug info embeddedinto a native image. The following commands (which all assume thetarget binary is called hello) can be used to display all generated content:objdump --dwarf=info hello &amp;gt; infoobjdump --dwarf=abbrev hello &amp;gt; abbrevobjdump --dwarf=ranges hello &amp;gt; rangesobjdump --dwarf=decodedline hello &amp;gt; decodedlineobjdump --dwarf=rawline hello &amp;gt; rawlineobjdump --dwarf=str hello &amp;gt; strobjdump --dwarf=frames hello &amp;gt; framesThe info section includes details of all compiled Java methods.The abbrev section defines the layout of records in the info sectionthat describe Java files (compilation units) and methods.The ranges section details the start and end addresses of methodcode segments.The decodedline section maps subsegments of method code rangesegments to files and line numbers. This mapping includes entriesfor files and line numbers for inlined methods.The rawline segment provides details of how the line table isgenerated using DWARF state machine instructions that encode file,line, and address transitions.The str section provides a lookup table for strings referencedfrom records in the info section.The frames section lists transition points in compiled methodswhere a (fixed size) stack frame is pushed or popped, allowingthe debugger to identify each frame’s current and previous stackpointers and its return address.Note that some of the content embedded in the debug records isgenerated by the C compiler and belongs to code that is either inlibraries or the C lib bootstrap code that is bundled in with theJava method code.Currently Supported TargetsThe prototype is currently implemented only for the GNU Debugger on Linux:      Linux/x86_64 support has been tested and should workcorrectly        Linux/AArch64 support is present but has not yet been fullyverified (break points should work ok but stack backtracesmay be incorrect)  Windows support is still under development.Debugging with IsolatesNote that it is currently recommended to disable use of Isolates bypassing flag -H:-SpawnIsolates on the command line when debug infogeneration is enabled. Enabling of Isolates affects the way ordinary object pointers (oops) are encoded. In turn, that means the debug infogenerator has to provide gdb with information about how to translatean encoded oop to the address in memory, where the object data isstored. This sometimes requires care when asking gdb to processencoded oops vs decoded raw addresses.When isolates are disabled, oops are essentially raw addresses pointingdirectly at the object contents. This is generally the same whetherthe oop is embedded in a static/instance field or is referenced from alocal or parameter variable located in a register or saved to the stack.It is not quite that simple because the bottom 3 bits of some oops maybe used to hold “tags” that record certain transient properties ofan object. However, the debuginfo provided to gdb means that it willremove these tag bits before dereferencing the oop as an address.By contrast, when isolates are enabled, oops references stored in staticor instance fields are actually relative addresses, offsets from adedicated heap base register (r14 on x86_64, r29 on AArch64), ratherthan direct addresses (in a few special cases the offset may also havesome low tag bits set). When an ‘indirect’ oop of this kind gets loadedduring execution, it is almost always immediately converted to a ‘raw’address by adding the offset to the heap base register value. So, oopswhich occur as the value of local or parameter vars are actually rawaddresses.The DWARF info encoded into the image, when isolates are enabled, tellsgdb to rebase indirect oops whenever it tries to dereference them toaccess underlying object data. This is normally automatic andtransparent, but it is visible in the underlying type model that gdbdisplays when you ask for the type of objects.For example, consider the static field we encountered above. Printingits type in an image that uses Isolates shows that this (static) fieldhas a different type to the expected one:(gdb) ptype &#39;java.math.BigInteger&#39;::powerCachetype = class _z_.java.math.BigInteger[][] : public java.math.BigInteger[][] {} *The field is typed as _z_.java.math.BigInteger[][] which is an emptywrapper class that inherits from the expected typejava.math.BigInteger[][]. This wrapper type is essentially the sameas the original but the DWARF info record that defines it includesinformation that tells gdb how to convert pointers to this type.When gdb is asked to print the oop stored in this field it is clear thatit is an offset rather than a raw address.(gdb) p/x &#39;java.math.BigInteger&#39;::powerCache$1 = 0x286c08(gdb) x/x 0x286c080x286c08:Cannot access memory at address 0x286c08However, when gdb is asked to dereference through the field, it appliesthe necessary address conversion to the oop and fetches the correctdata.(gdb) p/x *&#39;java.math.BigInteger&#39;::powerCache$2 = {  &amp;lt;java.math.BigInteger[][]&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1ec0e2,        idHash = 0x2f462321      }, &amp;lt;No data fields&amp;gt;},    members of java.math.BigInteger[][]:    len = 0x25,    data = 0x7ffff7a86c18  }, &amp;lt;No data fields&amp;gt;}Printing the type of the hub field or the data array shows that theyare also modelled using indirect types:(gdb) ptype $1-&amp;gt;hubtype = class _z_.java.lang.Class : public java.lang.Class {} *(gdb) ptype $2-&amp;gt;datatype = class _z_.java.math.BigInteger[] : public java.math.BigInteger[] {} *[0]The gdb still knows how to dereference these oops:(gdb) p $1-&amp;gt;hub$3 = (_z_.java.lang.Class *) 0x1ec0e2(gdb) x/x $1-&amp;gt;hub0x1ec0e2:Cannot access memory at address 0x1ec0e2(gdb) p *$1-&amp;gt;hub$4 = {  &amp;lt;java.lang.Class&amp;gt; = {    &amp;lt;java.lang.Object&amp;gt; = {      &amp;lt;_objhdr&amp;gt; = {        hub = 0x1dc860,        idHash = 1530752816      }, &amp;lt;No data fields&amp;gt;},    members of java.lang.Class:    name = 0x171af8,    . . .  }, &amp;lt;No data fields&amp;gt;}Since the indirect types inherit from the corresponding raw type it ispossible to use an expression that identifies an indirect type pointerin almost all cases where an expression identifying a raw type pointerwould work. The only case case where care might be needed is whencasting a displayed numeric field value or displayed register value.For example, if the indirect hub oop printed above is passed tohubname_raw, the cast to type Object internal to that command fails toforce the required indirect oops translation. The resulting memoryaccess fails:(gdb) hubname_raw 0x1dc860Cannot access memory at address 0x1dc860In this case it is necessary to use a slightly different command thatcasts its argument to an indirect pointer type:(gdb) define hubname_indirect x/s ((&#39;_z_.java.lang.Object&#39; *)($arg0))-&amp;gt;hub-&amp;gt;name-&amp;gt;value-&amp;gt;dataend(gdb) hubname_indirect 0x1dc8600x7ffff78a52f0:&quot;java.lang.Class&quot;",
                    "url": " /reference-manual/native-image/DebugInfo/"
                  },
                  
                  "reference-manual-llvm-debugging":  {
                    "title": "",
                    "content": "Debugging on the GraalVM LLVM RuntimeThe GraalVM LLVM runtime supports source-level (e.g., the C language) debugging with the Chrome Developer Tools using GraalVM’s Chrome Inspector implementation.This includes support for single-stepping, breakpoints, and inspection of local and global variables.To use this feature, make sure to compile your program with debug information enabled by specifying the -g argument when compiling with clang (the LLVM toolchain shipped with GraalVM will automatically enable debug information).This gives you the ability to step through the program’s source code and set breakpoints in it.With GraalVM 20.0 and older, the option --llvm.enableLVI=true is needed for being able to inspect variables during debugging.This option is not enabled by default as it decreases the program’s run-time performance.Starting with GraalVM 20.1, this option is not needed anymore and thus deprecated.To start debugging, run lli with the --inspect option:$GRAALVM_HOME/bin/lli --inspect &amp;lt;bitcode file&amp;gt;When launched, the inspector will suspend execution at the first instruction of the program and print a link to the console.Pasting this link into Chrome’s address bar will open the developer tools for you.BreakpointsBreakpoints can only be set in functions that have already been parsed.GraalVM defaults to parsing functions in LLVM bitcode files only when they are first being executed.To instead parse functions eagerly, and be able to set breakpoints also in functions not yet executed, you can use the option lli --llvm.lazyParsing=false.Program-defined Breakpoints Using __builtin_debugtrap()Program-defined breakpoints using the __builtin_debugtrap function enables you to mark locations in the program at which you explicitly want GraalVM to halt the program and switch to the debugger.The debugger automatically halts at each call to this function as if a breakpoint were set on the call.You can use this feature to quickly reach the code you are actually trying to debug without having to first find and set a breakpoint on it after launching your application.You can also instruct Chrome Inspector not to suspend your program at the first source-level statement being executed. When doing so, GraalVM will instead execute your program until it reaches a call to __builtin_debugtrap() before invoking the debugger.To enable this behavior you need to pass the arguments lli --inspect.Suspend=false --inspect.WaitAttached=true.Locating Source FilesDebug information in LLVM bitcode files contains absolute search paths to identify thelocation of source code. If the source files did not move, it should be found automatically.If the source files moved, or were compiled on a different machine, a search path can bespecified using the --inspect.SourcePath=&amp;lt;path&amp;gt; option (multiple paths can be separatedby :).",
                    "url": " /reference-manual/llvm/Debugging/"
                  },
                  
                  "reference-manual-java-on-truffle-demos":  {
                    "title": "",
                    "content": "Running Demo ApplicationsJava on Truffle is an implementation of the Java Virtual Machine Specification, which offers some interesting capabilities in addition to being able to run applications in Java or other JVM languages.To illustrate what Java on Truffle can do, please consider the following short examples.Enhanced HotSwap Capabilities with Java on TruffleYou can use the built-in enhanced HotSwap capabilities for applications running with Java on Truffle.You do not have to configure anything specific besides launching your app in debug mode and attaching a standard IDE debugger to gain the advantages of enhanced HotSwap.Debugging with Java on TruffleYou can use your favorite IDE debugger to debug Java applications running in the Java on Truffle runtime.For example, starting a debugger session from IntelliJ IDEA is based on the Run Configurations.To ensure you attach the debugger to your Java application in the same environment, navigate in the main menu to Run -&amp;gt; Debug… -&amp;gt; Edit Configurations, expand Environment, check the JRE value and VM options values.It should show GraalVM as project’s JRE and VM options should include -truffle -XX:+IgnoreUnrecognizedVMOptions. It is necessary to specify -XX:+IgnoreUnrecognizedVMOptions because Intellij automatically adds a -javaagent argument which is not supported yet.Press Debug.This will run the application and start a debugger session in the background.Applying Code Changes in a Debugging SessionOnce you have your debugger session running, you will be able to apply extensive code changes (HotSwap) without needing to restart the session.Feel free to try this out on your own applications or by following these instructions:  Create a new Java application.      Use the following main method as a starting point:           public class HotSwapDemo {           private static final int ITERATIONS = 100;           public static void main(String[] args) {               HotSwapDemo demo = new HotSwapDemo();               System.out.println(&quot;Starting HotSwap demo with Java on Truffle: &#39;java.vm.name&#39; = &quot; + System.getProperty(&quot;java.vm.name&quot;));               // run something in a loop               for (int i = 1; i &amp;lt;= ITERATIONS; i++) {                   demo.runDemo(i);               }               System.out.println(&quot;Completed HotSwap demo with Java on Truffle&quot;);           }           public void runDemo(int iteration) {               int random = new Random().nextInt(iteration);               System.out.printf(&quot;titeration %d ran with result: %dn&quot;, iteration, random);           }       }    Check that the java.vm.name property says you’re running on Espresso.  Place a line breakpoint on the first line in runDemo().      Setup the Run configurations to run with Java on Truffle and press Debug. You will see:            While paused at the breakpoint, extract a method from the body of runDemo():            Reload the changes by navigating to Run -&amp;gt; Debugging Actions -&amp;gt; Reload Changed Classes:            Verify that the change was applied by noticing the &amp;lt;obsolete&amp;gt;:-1 current frame in the Debug -&amp;gt; Frames view:            Place a breakpoint on the first line of the new extracted method and press Resume Program. The breakpoint will hit:            Try to change the access modifiers of printRandom() from private to public static. Reload the changes. Press Resume Program to verify the change was applied:      Watch  video version of the enhanced HotSwap capabilities with Java on Truffle demo.                      watch video                            Supported ChangesThe plan is to support arbitrary code changes when running applications with Java on Truffle.As of GraalVM 21.1.0 the following changes are supported:  Add and remove methods  Add and remove constructors  Add and remove methods from interfaces  Change access modifiers of methods  Change access modifiers of constructors  Changes to Lambdas  Add new anonymous inner classes  Remove anonymous inner classesAs of GraalVM 21.1.0, the following limitations remain:  Changes to fields  Changes to class access modifiers, e.g., from abstract to concrete  Changing the superclass  Changing implemented interfaces  Changes to enumsMixing AOT and JIT for JavaGraalVM Native Image technology allows compiling applications ahead-of-time (AOT) to executable native binaries which:  are standalone  start instantly  have lower memory usageThe main trade off for using Native Image is that the analysis and compilation of your program happens under the closed world assumption, meaning the static analysis needs to process all bytecode which will ever be executed in the application.This makes using some language features like dynamic class loading or reflection tricky.Java on Truffle is a JVM implementation of a JVM bytecode interpreter, built on the Truffle framework.It is essentially a Java application, as are the Truffle framework itself and the GraalVM JIT compiler.All three of them can be compiled ahead-of-time with native-image.Using Java on Truffle for some parts of your application makes it possible to isolate the required dynamic behaviour and still use the native image on the rest of your code.Consider a canonical Java Shell tool (JShell) as an example command line application.It is a REPL capable of evaluating Java code and consists of two parts:  the UI - CLI app handling input-output  the backend processor for running code you enter into Shell.This design naturally fits the point we are trying to illustrate. We can build a native executable of the JShell’s UI part, and make it include Java on Truffle to run the code dynamically specified at run time.Prerequisites:  GraalVM 21.0  Native Image  Java on Truffle  Clone the project with the demo applications and navigate to the espresso-jshell directory:git clone https://github.com/graalvm/graalvm-demos.gitcd graalvm-demos/espresso-jshellThe JShell implementation is actually the normal JShell launcher code, which only accepts Java on Truffle implementation (the project code-name is “Espresso”) of the execution engine.The “glue” code that binds the part which is AOT compiled with the component that dynamically evaluates the code is located in the EspressoExecutionControl class.It loads the JShell classes within the Java on Truffle context and delegate the input to them:    protected final Lazy&amp;lt;Value&amp;gt; ClassBytecodes = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ClassBytecodes&quot;));    protected final Lazy&amp;lt;Value&amp;gt; byte_array = Lazy.of(() -&amp;gt; loadClass(&quot;[B&quot;));    protected final Lazy&amp;lt;Value&amp;gt; ExecutionControlException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ExecutionControlException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; RunException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$RunException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; ClassInstallException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ClassInstallException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; NotImplementedException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$NotImplementedException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; EngineTerminationException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$EngineTerminationException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; InternalException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$InternalException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; ResolutionException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$ResolutionException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; StoppedException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$StoppedException&quot;));    protected final Lazy&amp;lt;Value&amp;gt; UserException = Lazy.of(() -&amp;gt; loadClass(&quot;jdk.jshell.spi.ExecutionControl$UserException&quot;));There is more code to pass the values correctly and transform the exceptions.To try it out, build the espresso-jshell binary using the provided script, which will:  Build the Java sources to the bytecode  Build the JAR file  Build a native imageThe most important configuration line in the native-image command is --language:java which instructs to include the Java on Truffle implementation into the binary.After the build you can observe the resulting binary file (file and ldd are Linux commands)file ./espresso-jshellldd ./espresso-jshellIt is indeed a binary file not depending on the JVM, and you can run it noticing how fast it starts:./espresso-jshell|  Welcome to JShell -- Version 11.0.10|  For an introduction type: /help introjshell&amp;gt; 1 + 11 ==&amp;gt; 2Experiment with loading new code into JShell and see how Java on Truffle executes it.Watch a video version of the mixing AOT and JIT compiled code with Java on Truffle demo.                      watch video                            GraalVM Tools with Java on TruffleJava on Truffle is a proper part of the GraalVM ecosystem, and like other GraalVM-supported languages gets the support of developer tooling by default. The Truffle framework integrates with the tools like the debugger, profiler, memory analyser, the Instrumentation API.The interpreter for a language needs to mark the AST nodes with some annotations to support those tools.For example, to be able to use a profiler, a language interpreter needs to mark the root nodes.For the debugger purposes, the language expressions should be marked as instrumental, the scopes for the variables specified, and so on. The language interpreter does not need to integrate with the tools itself.As a result, you can profile a Java on Truffle program out of the box using either the CPU Sampler or Memory Tracer tools.For example, if we have a class like the following one computing the prime numbers:import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.stream.LongStream;public class Main {    public static void main(String[] args) {        Main m = new Main();        for (int i = 0; i &amp;lt; 100_000; i++) {            System.out.println(m.random(100));        }    }    private Random r = new Random(41);    public List&amp;lt;Long&amp;gt; random(int upperbound) {        int to = 2 + r.nextInt(upperbound - 2);        int from = 1 + r.nextInt(to - 1);        return primeSequence(from, to);    }    public static List&amp;lt;Long&amp;gt; primeSequence(long min, long max) {        return LongStream.range(min, max)                .filter(Main::isPrime)                .boxed()                .collect(Collectors.toList());    }    public static boolean isPrime(long n) {        return LongStream.rangeClosed(2, (long) Math.sqrt(n))                .allMatch(i -&amp;gt; n % i != 0);    }}Build this program, and run it with the --cpusampler option.javac Main.javajava -truffle --cpusampler Main &amp;gt; output.txtAt the end of the output.txt file you will find the profiler output, the histogram of the methods, and how much time the execution took.You can also try an experiment with the --memtracer option, to see where the allocations in this program are happening.java -truffle --experimental-options --memtracer Main &amp;gt; output.txtOther tools that GraalVM offers are Chrome Debugger, Code Coverage, and GraalVM Insight.Having the “out-of-the-box” support for the developer tooling makes Java on Truffle an interesting choice of the JVM.Watch a short demonstration of GraalVM built-in tools for Java on Truffle.                      watch video                            ",
                    "url": " /reference-manual/java-on-truffle/demos/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-dynamicobjectmodel":  {
                    "title": "",
                    "content": "Dynamic Object ModelThis guide demonstrates how to get started with using the DynamicObject and DynamicObjectLibrary APIs introduced with GraalVM 20.2.0.The full documentation can be found in the Javadoc.MotivationWhen implementing a dynamic language, the object layout of user-defined objects/classes often cannot be statically inferred and needs to accommodate dynamically added members and changing types.This is where the Dynamic Object API comes in: it takes care of the object layout and classifies objects by their shape, i.e., their properties, and the types of their values.Access nodes can then cache the encountered shapes, forego costly checks and access object properties more efficiently.Getting StartedA guest language should have a common base class for all language objects that extends DynamicObject and implements TruffleObject. For example:@ExportLibrary(InteropLibrary.class)public class BasicObject extends DynamicObject implements TruffleObject {    public BasicObject(Shape shape) {        super(shape);    }    @ExportMessage    boolean hasLanguage() {        return true;    }    // ...}It makes sense to also export common InteropLibrary messages in this class.Builtin object classes can then extend this base class and export additional messages, and, as usual, extra Java fields and methods:@ExportLibrary(InteropLibrary.class)public class Array extends BasicObject {    private final Object[] elements;    public Array(Shape shape, Object[] elements) {        super(shape);        this.elements = elements;    }    @ExportMessage    boolean hasArrayElements() {        return true;    }    @ExportMessage    long getArraySize() {        return elements.length;    }    // ...}Dynamic object members can be accessed using the DynamicObjectLibrary, which can be obtained using the @CachedLibrary annotation of the Truffle DSL and DynamicObjectLibrary.getFactory() + getUncached(), create(DynamicObject), and createDispatched(int).Here is an example of how it could be used to implement InteropLibrary messages:@ExportLibrary(InteropLibrary.class)public class SimpleObject extends BasicObject {    public UserObject(Shape shape) {        super(shape);    }    @ExportMessage    boolean hasMembers() {        return true;    }    @ExportMessage    Object readMember(String name,                    @CachedLibrary(&quot;this&quot;) DynamicObjectLibrary objectLibrary)                    throws UnknownIdentifierException {        Object result = objectLibrary.getOrDefault(this, name, null);        if (result == null) {            /* Property does not exist. */            throw UnknownIdentifierException.create(name);        }        return result;    }    @ExportMessage    void writeMember(String name, Object value,                    @CachedLibrary(&quot;this&quot;) DynamicObjectLibrary objectLibrary) {        objectLibrary.put(this, name, value);    }    @ExportMessage    boolean isMemberReadable(String member,                    @CachedLibrary(&quot;this&quot;) DynamicObjectLibrary objectLibrary) {        return objectLibrary.containsKey(this, member);    }    // ...}In order to construct instances of these objects, you first need a Shape that you can pass to the DynamicObject constructor.This shape is created using Shape.newBuilder().build().The returned shape describes the initial shape of the object and forms the root of a new shape tree.As you are adding new properties with DynamicObjectLibrary#put, the object will mutate into other shapes in this shape tree.Note: You should reuse the same initial shapes because shapes are internally cached per root shape.It is recommended that you store the initial shapes in the TruffleLanguage instance, so they can be shared across contexts of the same engine.Static shapes should be avoided except for singletons (like a null value).For example:@TruffleLanguage.Registration(...)public final class MyLanguage extends TruffleLanguage&amp;lt;MyContext&amp;gt; {    private final Shape initialObjectShape;    private final Shape initialArrayShape;    public MyLanguage() {        this.initialObjectShape = Shape.newBuilder(ExtendedObject.class).build();        this.initialArrayShape = Shape.newBuilder().build();    }    public createObject() {        return new MyObject(initialObjectShape);    }    //...}Extended Object LayoutYou can extend the default object layout with extra dynamic fields that you hand over to the dynamic object model by adding @DynamicField-annotated field declarations of type Object or long in your subclasses, and specifying the layout class with Shape.newBuilder().layout(ExtendedObject.class).build();.Dynamic fields declared in this class and its superclasses will then automatically be used to store dynamic object properties and allow faster access to properties that fit into this reserved space.Note: You must not access dynamic fields directly. Always use DynamicObjectLibrary for this purpose.@ExportLibrary(InteropLibrary.class)public class ExtendedObject extends SimpleObject {    @DynamicField private Object _obj0;    @DynamicField private Object _obj1;    @DynamicField private Object _obj2;    @DynamicField private long _long0;    @DynamicField private long _long1;    @DynamicField private long _long2;    public ExtendedObject(Shape shape) {        super(shape);    }}Caching ConsiderationsIn order to ensure optimal caching, avoid reusing the same cached DynamicObjectLibrary for multiple, independent operations (get, put, etc.).Try to minimize the number of different shapes and property keys seen by each cached library instance.When the property keys are known statically (compilation-final), always use a separate DynamicObjectLibrary for each property key.Use dispatched libraries (@CachedLibrary(limit=...)) when putting multiple properties in succession.For example:public abstract class MakePairNode extends BinaryExpressionNode {    @Specialization    Object makePair(Object left, Object right,                    @CachedLanguage MyLanguage language,                    @CachedLibrary(limit = &quot;3&quot;) putLeft,                    @CachedLibrary(limit = &quot;3&quot;) putRight) {        MyObject obj = language.createObject();        putLeft.put(obj, &quot;left&quot;, left);        putRight.put(obj, &quot;right&quot;, right);        return obj;    }}Further ReadingA high-level description of the object model has been published in An Object Storage Model for the Truffle Language Implementation Framework.See Truffle documentation and publications for more tutorials, presentations, and publications about Truffle and GraalVM.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/DynamicObjectModel/"
                  },
                  
                  "reference-manual-native-image-dynamicproxy":  {
                    "title": "",
                    "content": "Dynamic Proxy in Native ImageJava dynamic proxies, implemented by java.lang.reflect.Proxy, provide a mechanism which enables object level access control by routing all method invocations through java.lang.reflect.InvocationHandler.Dynamic proxy classes are generated from a list of interfaces.Native Image does not provide machinery for generating and interpreting bytecodes at run time.Therefore all dynamic proxy classes need to be generated at native image build time.See also the guide on assisted configuration of Java resources and other dynamic features.Automatic DetectionNative Image employs a simple static analysis that detects calls to java.lang.reflect.Proxy.newProxyInstance(ClassLoader, Class&amp;lt;?&amp;gt;[], InvocationHandler) and java.lang.reflect.Proxy.getProxyClass(ClassLoader, Class&amp;lt;?&amp;gt;[]), then tries to determine the list of interfaces that define dynamic proxies automatically. Given the list of interfaces, Native Image generates proxy classes at image build time and adds them to the native image heap.In addition to generating the dynamic proxy class, the constructor of the generated class that takes a java.lang.reflect.InvocationHandler argument, i.e., the one reflectively invoked by java.lang.reflect.Proxy.newProxyInstance(ClassLoader, Class&amp;lt;?&amp;gt;[], InvocationHandler), is registered for reflection so that dynamic proxy instances can be allocated at run time.The analysis is limited to situations where the list of interfaces comes from a constant array or an array that is allocated in the same method.For example, in the code snippets bellow the dynamic proxy interfaces can be determined automatically.Static Final Array:class ProxyFactory {    private static final Class&amp;lt;?&amp;gt;[] interfaces = new Class&amp;lt;?&amp;gt;[]{java.util.Comparator.class};    static Comparator createProxyInstanceFromConstantArray() {        ClassLoader classLoader = ProxyFactory.class.getClassLoader();        InvocationHandler handler = new ProxyInvocationHandler();        return (Comparator) Proxy.newProxyInstance(classLoader, interfaces, handler);    }}Note: The analysis operates on compiler graphs and not source code.Therefore the following ways to declare and populate an array are equivalent from the point of view of the analysis:private static final Class&amp;lt;?&amp;gt;[] interfacesArrayPreInitialized = new Class&amp;lt;?&amp;gt;[]{java.util.Comparator.class};private static final Class&amp;lt;?&amp;gt;[] interfacesArrayLiteral = {java.util.Comparator.class};private static final Class&amp;lt;?&amp;gt;[] interfacesArrayPostInitialized = new Class&amp;lt;?&amp;gt;[1];static {    interfacesArrayPostInitialized[0] = java.util.Comparator.class;}However, there are no immutable arrays in Java.Even if the array is declared as static final, its contents can change later on.The simple analysis employed here does not track further changes to the array.New Array:class ProxyFactory {    static Comparator createProxyInstanceFromNewArray() {        ClassLoader classLoader = ProxyFactory.class.getClassLoader();        InvocationHandler handler = new ProxyInvocationHandler();        Class&amp;lt;?&amp;gt;[] interfaces = new Class&amp;lt;?&amp;gt;[]{java.util.Comparator.class};        return (Comparator) Proxy.newProxyInstance(classLoader, interfaces, handler);    }}Note: Just like with constant arrays, the following ways to declare and populate an array are equivalent from the point of view of the analysis:Class&amp;lt;?&amp;gt;[] interfaces = new Class&amp;lt;?&amp;gt;[]{java.util.Comparator.class};Class&amp;lt;?&amp;gt;[] interfaces = new Class&amp;lt;?&amp;gt;[1];interfaces[0] = Question.class;Class&amp;lt;?&amp;gt;[] interfaces = {java.util.Comparator.class};The static analysis covers code patterns most frequently used to define dynamic proxy classes.For the exceptional cases where the analysis cannot discover the interface array there is also a manual dynamic proxy configuration mechanism.Manual ConfigurationDynamic proxy classes can be generated at native image build time by specifying the list of interfaces that they implement. Native Image provides two options for this purpose: -H:DynamicProxyConfigurationFiles=&amp;lt;comma-separated-config-files&amp;gt; and -H:DynamicProxyConfigurationResources=&amp;lt;comma-separated-config-resources&amp;gt;.These options accept JSON files whose structure is an array of arrays of fully qualified interface names. For example:[    [&quot;java.lang.AutoCloseable&quot;, &quot;java.util.Comparator&quot;],    [&quot;java.util.Comparator&quot;],    [&quot;java.util.List&quot;]]The java.lang.reflect.Proxy API also allows creation of a dynamic proxy that does not implement any user provided interfaces. Therefore the following is a valid configuration:[    []]In this case the generated dynamic proxy class only implements java.lang.reflect.Proxy.Dynamic Proxy Classes in Static InitializersDynamic proxy classes and instances of dynamic proxy classes that are defined in static initializers can be accessed at run time without any special handling.This is possible since the static initializers are executed at native image build time.For example, this will work:private final static Comparator proxyInstance;private final static Class&amp;lt;?&amp;gt; proxyClass;static {    ClassLoader classLoader = ProxyFactory.class.getClassLoader();    InvocationHandler handler = new ProxyInvocationHandler();    Class&amp;lt;?&amp;gt;[] interfaces = {java.util.Comparator.class};    proxyInstance = (Comparator) Proxy.newProxyInstance(classLoader, interfaces, handler);    proxyClass = Proxy.getProxyClass(classLoader, interfaces);}",
                    "url": " /reference-manual/native-image/DynamicProxy/"
                  },
                  
                  "reference-manual-r-extensionssupport":  {
                    "title": "",
                    "content": "R Extensions SupportThe GraalVM R runtime can run R extensions in two modes:  native: the native machine code is run directly on your CPU, the same way GNU R runs R extensions.  llvm: if the LLVM bitcode is available, it can be interpreted by the LLVM interpreter shipped with GraalVM.The native mode is better suited for code that does not extensively interact with the R API, for example, plain C or Fortran numerical computations working on primitive arrays.The llvm mode provides significantly better performance for extensions that frequently call between R and the C/C++ code, because GraalVM’s LLVM runtime is also partially evaluated like the R code.Both can be inlined and optimized as one compilation unit.Moreover, GraalVM’s LLVM runtime is supported by GraalVM tools which allows users to, for instance, debug R and C code together.In one GraalVM R process, any R package can be loaded in either mode.That is, GraalVM’s R runtime supports mixing packages loaded in the native mode with packages loaded in the llvm mode in one process.Generating LLVM BitcodeAs of version 19.3.0, the GraalVM R runtime is configured to use the LLVM toolchain to compile R packages’ native code.This toolchain produces standard executable binaries for a given system, but it also embeds the corresponding LLVM bitcode into them.The binaries produced by the LLVM toolchain can be loaded in both modes: native or llvm.The GraalVM R runtime can be reconfigured to use your system default compilers when installing R packages by running:# use local installation of GGC:R -e &#39;fastr.setToolchain(&quot;native&quot;)&#39;# to revert back to using the GraalVM&#39;s LLVM toolchain:R -e &#39;fastr.setToolchain(&quot;llvm&quot;)&#39;Using the system default compilers may be more reliable, but you lose the ability to load the R packages built with the LLVM toolchain in the llvm mode, because they will not contain the embedded bitcode.Moreover, mixing packages built by the local system default compilers and packages built by the LLVM toolchain in one R process may cause linking issues.Fortran CompilerAs of version 20.1.0, the GraalVM R runtime uses gfortran as the default Fortran compiler when installing R packages.Since gfortran cannot produce bitcode, packages that contain Fortran code will not work in the llvm mode.The GraalVM R runtime contains the F2C tool, which can convert Fortran code to C and then compile it with the LLVM toolchain.Users can configure GraalVM’s R runtime to use this tool by editing the configuration file R_HOME/etc/Makeconf, variable FC.Choosing the Running ModeStarting with version 19.3.0, GraalVM’s R runtime uses the following defaults:  native mode to load the packages  llvm toolchain to build their sourcesTo enable the llvm mode for loading the packages, use --R.BackEnd=llvm.You can also enable each mode selectively for the given R packages by using:  --R.BackEndLLVM=package1,package2  --R.BackEndNative=package1,package2Moreover, you can configure which packages will be always run in the native mode in file R_HOME/etc/native-packages. GraalVM’s R runtime comes with a default configuration that covers some popular R packages that are known to not work yet in the llvm mode.",
                    "url": " /reference-manual/r/ExtensionsSupport/"
                  },
                  
                  "reference-manual-java-on-truffle-faq":  {
                    "title": "",
                    "content": "Frequently Asked QuestionsDoes Java running on Truffle implement the Java language running as a Truffle interpreter?Not quite: it implements the Java Virtual Machine running as a Truffle interpreter.That means it can only run a Java program once it has been compiled to Java bytecode (classes, JARs, etc.) with your favorite Java compiler (e.g., javac) or a build tool (Maven, Gradle, etc.).In the GraalVM family, this is similar to WebAssembly or the LLVM interpreter: while both can run C programs, they have to be complied by a C compiler first.Does Java running on Truffle run on HotSpot too?Like other languages implemented with the Truffle framework, it can run both as a native image or on top of HotSpot.Running on top of HotSpot is currently only possible on Linux.We plan to extend this capability to macOS and Windows platforms also.Does running Java on Truffle require HotSpot?No, it doesn’t, it works fine as a native image.Java on Truffle does require a standard core Java library (the rt.jar library for Java 8 or the lib/modules file for Java 11 as well as the associated native libraries: libjava, libnio, etc.)Running Java on GraalVM already brings the highest level of optimization, what benefits will Java on Truffle give me?  Java on Truffle will inherit the extensive tooling provided by the Truffle framework. This means that for the things like code coverage and profiling you would no longer need to rely on external tools.  Another important aspect is that Java on Truffle comes with improved isolation of the host Java VM and the Java program running on Truffle.  Moreover, Java on Truffle can run in the context of a native image while still allowing dynamically-loaded bytecodes!  Finally, you can enjoy the benefits of enhanced HotSwap capabilities which will help boost your productivity.What is the license for Java on Truffle?Java on Truffle is an implementation of the Java Virtual Machine. It is open source and is offered as free software under the GNU General Public License version two (GPLv2).Can I run Java on Truffle in production?Running in production is not recommended.While Java on Truffle already passes the Java Compatibility Kit (JCK or TCK for Java SE) 8 and 11 runtimes, it is still an early prototype and experimental feature in GraalVM.It may undergo significant improvements before being considered production-ready.What performance can I expect from executing Java on Truffle?Performance is currently 2-3x slower than HotSpot.It does not match the speed offered by GraalVM yet for sure, but having created a fully working Java on Truffle runtime, the development team is now focusing on making it as performant as the GraalVM JIT.Can I embed Java running on Truffle in my application?Yes, you can use GraalVM’s Polyglot API to run Java bytecodes in a separate context from the host Java VM.You can even embed a Java 8 context in a Java 11 application!Why do I see “Unrecognized option: -javaagent:…/idea_rt.jar…” when I try to run my app from the IDE?Java on Truffle does not yet support attaching Java agents. For the time being add: -XX:+IgnoreUnrecognizedVMOptions to the VM options too.",
                    "url": " /reference-manual/java-on-truffle/faq/"
                  },
                  
                  "reference-manual-js-faq":  {
                    "title": "",
                    "content": "Frequently Asked QuestionsBelow are the most frequently asked questions and answers about JavaScript running on GraalVM.CompatibilityIs GraalVM compatible with the JavaScript language?GraalVM is compatible with the ECMAScript 2020 specification and is further developed alongside the 2021 draft specification.The compatibility of GraalVM’s JavaScript runtime is verified by external sources, like the Kangax ECMAScript compatibility table.GraalVM JavaScript is tested against a set of test engines, like the official test suite of ECMAScript, test262, as well as tests published by V8 and Nashorn, Node.js unit tests, and GraalVM’s own unit tests.For a reference of the JavaScript APIs that GraalVM supports, see GRAAL.JS-API.Is GraalVM compatible with the original node implementation?Node.js based on GraalVM is largely compatible with the original Node.js (based on the V8 engine).This leads to a high number of npm-based modules being compatible with GraalVM. In fact, out of the 95k modules we test, more than 90% of them pass all tests.Still, several sources of differences have to be considered:  Setup:GraalVM mostly mimicks the original setup of Node, including the node executable, npm, and similar. However, not all command-line options are supported (or behave exactly identically). You need to (re-)compile native modules against the v8.h file, etc.Since GraalVM 21.1, Node.js and all related executables (e.g., node, npm, etc.) are not included by default in the GraalVM binary.Node.js support is now packaged in a separate component that can be installed with the GraalVM Updater using $GRAALVM/bin/gu install nodejs.      Internals:GraalVM is implemented on top of a JVM, and thus has a different internal architecture than Node.js based on V8. This implies that some internal mechanisms behave differently and cannot exactly replicate V8 behaviour. This will hardly ever affect user code, but might affect modules implemented natively, depending on V8 internals.        Performance:Due to GraalVM being implemented on top of a JVM, performance characteristics vary from the original native implementation. While GraalVM’s peak performance can match V8 on many benchmarks, it will typically take longer to reach the peak (known as warmup). Be sure to give the GraalVM compiler some extra time when measuring (peak) performance.  In addition, GraalVM uses the following approaches to check and retain compatibility with Node.js code:  node-compat-table: GraalVM is compared against other engines using the node-compat-table module, highlighting incompatibilities that might break Node.js code.  automated mass-testing of modules using mocha: in order to test a large set of modules, GraalVM is tested against 95k modules that use the mocha test framework. Using mocha allows automating the process of executing the test and comprehending the test result.  manual testing of popular modules: a select list of npm modules is tested in a manual test setup. These highly-relevant modules are tested in a more sophisticated manner.My application used to run on Nashorn, it does not work on GraalVM JavaScript?Reason:  GraalVM JavaScript tries to be compatible with the ECMAScript specification, as well as competing engines (including Nashorn). In some cases, this is a contradicting requirement; then, ECMAScript is given precedence. Also, there are cases where GraalVM Javascript is not exactly replicating Nashorn features intentionally, e.g., for security reasons.Solution:  In many cases, enabling GraalVM’s Nashorn compatibility mode enables features not enabled by default. Note that this can have negative effects on application security! See the Nashorn Migration Guide for details.Specific applications:  For JSR 223 ScriptEngine, you might want to set the system property polyglot.js.nashorn-compat to true in order to use the Nashorn compatibility mode.  For ant, use ANT_OPTS=&quot;-Dpolyglot.js.nashorn-compat=true&quot; ant when using GraalVM JavaScript via ScriptEngine.Builtin functions like array.map() or fn.apply() are not available on non-JavaScript objects like ProxyArrays from JavaReason:  Java objects provided to JavaScript are treated as close as possible to their JavaScript counterpart. For instance, Java arrays provided to JavaScript are treated like JavaScript Array exotic objects (JavaScript arrays) whenever possible; the same is true for functions. One obvious difference is that such object’s prototype is null. This means that while you can, e.g., read the length or read and write the values of a Java array in JavaScript code, you cannot call sort() on it, as the Array.prototype is not provided by default.Solution:  While the objects do not have the methods of the prototype assigned, you can explicitly call them, e.g., Array.prototype.call.sort(myArray).  We offer the option js.foreign-object-prototype. When enabled, objects on the JavaScript side get the most prototype (e.g. Array.prototype, Function.prototype, Object.prototype) set and can thus behave more similarly to native JavaScript objects of the respective type. Normal JavaScript precedence rules apply here, e.g., own properties (of the Java object in that case) take precedence over and hide properties from the prototype.Note that while the JavaScript builtin functions. e.g., from Array.prototype can be called on the respective Java types, those functions expect JavaScript semantics.This for instance means that operations might fail (typically with a TypeError: Message not supported) when an operation is not supported in Java.Consider Array.prototype.push as an example: while arrays can grow in size in JavaScript, they are fixed-size in Java, thus pushing a value is semantically not possible and will fail.In such cases, you can wrap the Java object and handle that case explicitly.Use the interfaces ProxyObject and ProxyArray for that purpose.How can one verify GraalVM works on their application?If your module ships with tests, execute them with GraalVM. Of course, this willonly test your application, but not its dependencies. You can use theCompatibilitytool to find whether the module you are interested in is tested on GraalVM, andwhether the tests pass successfully. Additionally, you can upload yourpackage-lock.json or package.json file into that tool and it will analyzeall your dependencies at once.PerformanceMy application is slower on GraalVM JavaScript than on another engineReason:  Ensure your benchmark considers warmup. During the first few iterations, GraalVM JavaScript will be slower than natively implemented engines, while on peak performance, this difference should level out.  GraalVM JavaScript is shipped in two different modes: native (default) and JVM. While the default of native offers fast startup, it might show slower peak performance once the application is warmed up. In the JVM mode, the application might need a few hundred milliseconds more to start, but typically shows better peak performance.Solution:  Use proper warmup in your benchmark, and disregard the first few iterations where the application still warms up.  Use the --jvm option for slower startup, but higher peak performance.  Double-check you have no flags set that might lower your performance, e.g., -ea/-esa.  Try to minify the problem to the root cause and file an issue so the GraalVM team can have a look.How to achieve the best peak performance?Here are a few tips you can follow to analyse and improve peak performance:  When measuring, ensure you have given the GraalVM compiler enough time to compile all hot methods before starting to measure peak performance. A useful command line option for that is --engine.TraceCompilation=true – this outputs a message whenever a (JavaScript) method is compiled. As long as this still prints frequently, measurement should not yet start.  Compare the performance between the Native Image and the JVM mode if possible. Depending on the characteristics of your application, one or the other might show better peak performance.  The Polyglot API comes with several tools and options to inspect the performance of your application:          --cpusampler and --cputracer will print a list of the hottest methods when the application is terminated. Use that list to figure out where most time is spent in your application.      --experimental-options --memtracer can help you understand the memory allocations of your application. Refer to the Profiling Command Line Tool reference for more detail.      What is the difference between running GraalVM’s JavaScript in a Native Image compared to the JVM?In essence, the JavaScript engine of GraalVM is a plain Java application.Running it on any JVM (JDK 8 or higher) is possible, but, for a better result, it should be GraalVM or a compatible JVMCI-enabled JDK using the GraalVM compiler.This mode gives the JavaScript engine full access to Java at runtime, but also requires the JVM to first (just-in-time) compile the JavaScript engine when executed, just like any other Java application.Running in a Native Image means that the JavaScript engine, including all its dependencies from, e.g., the JDK, is pre-compiled into a native binary. This will tremendously speed up the startup of any JavaScript application, as GraalVM can immediately start to compile JavaScript code, without itself requiring to be compiled first.This mode, however, will only give GraalVM access to Java classes known at the time of image creation.Most significantly, this means that the JavaScript-to-Java interoperability features are not available in this mode, as they would require dynamic class loading and execution of arbitrary Java code at runtime.Can npm packages be installed globally?Node packages can be installed globally using npm and the -g option, both with the original Node.js implementation and GraalVM.While the original Node.js implementation has one main folder (NODE/bin) to put binaries and globally installed packages and their commandline tools, GraalVM has several: the main GRAALVM/bin folder, and separate folders for each language, e.g. GRAALVM/jre/languages/js/bin.When installing npm packages globally in GraalVM, links to the executables e.g. for command line interface tools are put to the JavaScript-specific folder.In order for globally installed packages to function properly, you might need to add GRAALVM/jre/languages/js/bin to your $PATH.Another option is to specify the global installation folder of npm by setting the $PREFIX environment variable, or by specifying the --prefix option when running npm install.For more details, see Installing npm Packages Globally.ErrorsTypeError: Access to host class com.myexample.MyClass is not allowed or does not existReason:  You are trying to access a Java class that is not known to the js or node process, or is not among the allowed classes your code can access.Solution:  Ensure there is no typo in the class name.  Ensure the class is on the classpath. Use the --vm.cp=&amp;lt;classpath&amp;gt; option of the launchers.  Ensure access to the class is permitted, by having @HostAccess.Export on your class and/or the Context.Builder.allowHostAccess() set to a permissive setting. See JavaDoc of org.graalvm.polyglot.Context.TypeError: UnsupportedTypeExceptionTypeError: execute on JavaObject[Main$$Lambda$63/1898325501@1be2019a (Main$$Lambda$63/1898325501)] failed due to: UnsupportedTypeExceptionReason:  GraalVM JavaScript in some cases does not allow concrete callback types when calling from JavaScript to Java. A Java function expecting, e.g., a Value object, might fail with the quoted error message due to that.Solution:  Change the signature in the Java callback method.Status:  This is a known limitation and should be resolved in future versions.Example:import java.util.function.Function;import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.HostAccess;public class Minified {  public static void main(String ... args) {    //change signature to Function&amp;lt;Object, String&amp;gt; to make it work    Function&amp;lt;Value, String&amp;gt; javaCallback = (test) -&amp;gt; {      return &quot;passed&quot;;    };    try(Context ctx = Context.newBuilder()    .allowHostAccess(HostAccess.ALL)    .build()) {      Value jsFn = ctx.eval(&quot;js&quot;, &quot;f =&amp;gt; function() { return f(arguments); }&quot;);      Value javaFn = jsFn.execute(javaCallback);      System.out.println(&quot;finished: &quot;+javaFn.execute());    }  }}TypeError: Message not supportedTypeError: execute on JavaObject[Main$$Lambda$62/953082513@4c60d6e9 (Main$$Lambda$62/953082513)] failed due to: Message not supported.Reason:  You are trying to execute an operation (a message) on a polyglot object that this object does not handle. E.g., you are calling Value.execute() on a non-executable object.  A security setting (e.g., org.graalvm.polyglot.HostAccess) might prevent the operation.Solution:  Ensure the object (type) in question does handle the respective message.  Specifically, ensure the JavaScript operation you try to execute on a Java type is possible semantically in Java. For instance, while you can push a value to an array in JavaScript and thus automatically grow the array, arrays in Java are of fixed length and trying to push to them will result in a Message not supported failure. You might want to wrap Java objects for such cases, e.g., as a ProxyArray.  Ensure access to the class is permitted, by having @HostAccess.Export on your class and/or the Context.Builder.allowHostAccess() set to a permissive setting. See JavaDoc of org.graalvm.polyglot.Context.  Are you trying to call a Java Lambda expression or Functional Interface? Annotating the proper method with @HostAccess.Export can be a pitfall. While you can annotate the method the functional interface refers to, the interface itself (or the Lambda class created in the background) fails to be properly annotated and recognized as exported. See below for examples highlighting the problem and a working solution.An example that triggers a Message not supported error with certain HostAccess settings, e.g., HostAccess.EXPLICIT:{  ...  //a JS function expecting a function as argument  Value jsFn = ...;  //called with a functional interface as argument  jsFn.execute((Function&amp;lt;Integer, Integer&amp;gt;)this::javaFn);  ...}@Exportpublic Object javaFn(Object x) { ... }@Exportpublic Callable&amp;lt;Integer&amp;gt; lambda42 = () -&amp;gt; 42;In the example above, the method javaFn is seemingly annotated with @Export, but the functional interface passed to jsFn is not, as the functional interface behaves like a wrapper around javaFn, thus hiding the annotation.Neither is lambda42 properly annotated - that pattern annotates the field lambda42, not its executable function in the generated lambda class.In order to add the @Export annotation to a functional interface, use this pattern instead:import java.util.function.Function;import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.HostAccess;public class FAQ {  public static void main(String[] args) {    try(Context ctx = Context.newBuilder()    .allowHostAccess(HostAccess.EXPLICIT)    .build()) {      Value jsFn = ctx.eval(&quot;js&quot;, &quot;f =&amp;gt; function() { return f(arguments); }&quot;);      Value javaFn = jsFn.execute(new MyExportedFunction());      System.out.println(&quot;finished: &quot; + javaFn.execute());    }  }  @FunctionalInterface  public static class MyExportedFunction implements Function&amp;lt;Object, String&amp;gt; {    @Override    @HostAccess.Export    public String apply(Object s) {      return &quot;passed&quot;;    }  };}Another option is to allow access to java.function.Function’s apply method.However, note that this allows access to ALL instances of this interface - in most production setups, this will be too permissive and open potential security holes.HostAccess ha = HostAccess.newBuilder(HostAccess.EXPLICIT)  //warning: too permissive for use in production  .allowAccess(Function.class.getMethod(&quot;apply&quot;, Object.class))  .build();Warning: Implementation does not support runtime compilation.If you get the following warning, you are not running on GraalVM or a JVMCI-enabled JVM using the GraalVM compiler:[engine] WARNING: The polyglot context is using an implementation that does not support runtime compilation.The guest application code will therefore be executed in interpreted mode only.Execution only in interpreted mode will strongly impact the guest application performance.For more information on using GraalVM see https://www.graalvm.org/java/quickstart/.To disable this warning the &#39;--engine.WarnInterpreterOnly=false&#39; option or use the &#39;-Dpolyglot.engine.WarnInterpreterOnly=false&#39; system property.To resolve this, use GraalVM or see RunOnJDK.md for instructions how to set up the Graal compiler on a compatible JVMCI-enabled stock JDK.Nevertheless, if this is intentional, you can disable the warning and continue to run with degraded performance by setting the above mentioned option, either via the command line or using the Context.Builder, e.g.:try (Context ctx = Context.newBuilder(&quot;js&quot;)    .option(&quot;engine.WarnInterpreterOnly&quot;, &quot;false&quot;)    .build()) {  ctx.eval(&quot;js&quot;, &quot;console.log(&#39;Greetings!&#39;);&quot;);}Note that when using an explicit polyglot engine, the option has to be set on the Engine, e.g.:try (Engine engine = Engine.newBuilder()    .option(&quot;engine.WarnInterpreterOnly&quot;, &quot;false&quot;)    .build()) {  try (Context ctx = Context.newBuilder(&quot;js&quot;).engine(engine).build()) {    ctx.eval(&quot;js&quot;, &quot;console.log(&#39;Greetings!&#39;);&quot;);  }}",
                    "url": " /reference-manual/js/FAQ/"
                  },
                  
                  "reference-manual-python-faq":  {
                    "title": "",
                    "content": "Frequently Asked QuestionsDoes module/package XYZ work on GraalVM’s Python runtime?It depends, but is currently unlikely.The first goal with GraalVM’s Python runtime was to show that NumPy and related packages can run using the managed GraalVM LLVM runtime.The GraalVM team continues to improve the number of passing CPython unittests, and to track the compatibility with popular PyPI packages.Can the GraalVM Python runtime replace my Jython use case?It can, but there are some caveats, like Python code subclassing Java classes or use through the javax.script.ScriptEngine not being supported.See the Jython Migration guide for details.Do I need to compile and run native modules as LLVM bitcode to use on GraalVM’s Python runtime?On GraalVM, Python C extension modules run using the GraalVM LLVM runtime.To use such modules, you cannot use binary distributions, but instead you must install them from source using the GraalVM Python runtime, which will transparently produce LLVM bitcode during the build process.However, many of the core features of Python (including, e.g., large parts of the os API) are implemented in pure Java and many standard library modules and packages work without running any LLVM bitcode.So even though the Python runtime depends on the GraalVM LLVM runtime, for many use cases you can disallow native modules entirely.Can I use the GraalVM sandboxing features with Python?Yes, you can.As an embedder, you can selectively disable features.For example, you can disable native code execution or filesystem access.Also, GraalVM’s managed execution mode for LLVM fully works for running extensions such as NumPy in a safer manner.Do all the GraalVM polyglot features work with Python?The team is continuously working to ensure all polyglot features of GraalVM work as a Python user would expect.There are still many cases where expectations are unclear or where multiple behaviors are imaginable.The team is actively looking at use cases and continuously evolving the GraalVM Python runtime to provide the mostconvenient and least surprising behaviour.What performance can I expect from GraalVM’s Python runtime?For the pure Python code, performance after warm-up can be expected to be around 5-6 times faster than CPython 3.8 (or 6-7x faster than Jython).For native extensions running as LLVM bitcode, CPython is currently slower – you can expect to see between 0.1x and 0.5x performance.I heard languages with JIT compilers have slow startup. Is that true for GraalVM’s Python runtime?It depends.When you use Native Image with Python, or the graalpython launcher of GraalVM, startup is competitive with CPython.In any case, both with Native Image or when running on the JVM, you first need to warm up to reach peak performance. This is a complicated story in itself, but, in general, it can take a while (a minute or two) after you have reached and are running your core workload.Can I share warmed-up code between multiple Python contexts?Yes, this works, and you will find that starting up multiple contexts in the same engine, and running the same or similar code in them will get increasingly faster, because the compiled code is shared across contexts.However, the peak performance in this setup is currently lower than in the single context case.",
                    "url": " /reference-manual/python/FAQ/"
                  },
                  
                  "reference-manual-native-image-hostedvsruntimeoptions":  {
                    "title": "",
                    "content": "Native Image Hosted and Runtime OptionsAlong with all the options listed in the Optionsguide,  Native Image also distinguishes hosted and runtime options.      Hosted options: configure a native image build, i.e., influence what is put into the image and how the image is built.These are set using the prefix -H: on the command line.        Runtime options: get their initial value during an image generation, using the prefix -R: on the command line for the native image builder. At runtime, the default prefix is -XX: (but this is application-specific and not mandated by Native Image).  For developer documentation on how to define and use options, read the documentation of the com.oracle.svm.core.option package.List of Useful OptionsGraph DumpingNative Image re-used the GraalVM options for graph dumping, logging, counters,and everything else in the GraalVM debug environment. These GraalVM options canbe used both as hosted options (if you want to dump graphs of the native imagebuilder), and as runtime options (if you want to dump graphs during dynamiccompilation at runtime).The GraalVM compiler options that work as expected include Dump, DumpOnError, Log,MethodFilter, and the options to specify file names and ports for the dumphandlers.For example:      To dump the compiler graphs of the native image builder: -H:Dump= -H:MethodFilter=ClassName.MethodName.        To dump the compile graphs at runtime, specify the dump flags at runtime: -XX:Dump= -XX:MethodFilter=ClassName.MethodName.  Debug OptionsThese options enable additional checks in the generated executable to help with debugging:  -H:[+|-]HostedAssertionsenables or disables Java assert statements in the native image builder.This flag is translated to either -ea -esa or -da -dsa for the HotSpot VM.  -H:[+|-]RuntimeAssertionsenables or disables Java assert statements at run time.  -H:TempDirectory=FileSystemPathgenerates a directory for temporary files during a native image generation.If this option is specified, the temporary files are not deleted so that you can inspect them after the native image generation.Control the Main Entry Points  -H:Kind=[EXECUTABLE | SHARED_LIBRARY]:generates an executable with a main entry point, or a shared library with all entry points that are marked via @CEntryPoint.  -H:Class=ClassName:the class containing the default entry point method.Ignored if Kind == SHARED_LIBRARY.  -H:Projects=Project1,Project2:the project that contains the application (and transitively all projects that it depends on).  -H:Name=FileName:the name of the executable file that is generated.  -H:Path=FileSystemPath:the directory where the generated executable is placed.",
                    "url": " /reference-manual/native-image/HostedvsRuntimeOptions/"
                  },
                  
                  "reference-manual-java-on-truffle-implementation":  {
                    "title": "",
                    "content": "Implementation DetailsJava on Truffle operates, like other languages implemented with Truffle, both as a native image or on top of HotSpot (currently possible on Linux only).In the first case, when the Java on Truffle runtime is compiled to a native image, it does not require HotSpot to run Java.However it requires a standard core Java library (the rt.jar library for Java 8 or the lib/modules file for Java 11 as well as the associated native libraries: libjava, libnio, etc.).Java on Truffle is a minified Java VM that implements all core components of a VM including:  Bytecode interpreter  Bytecode verifier  Single Java Class File parser  Simple object model  Java Native Interface (JNI) implementation in Java  Virtual Machine Implementation in Java  Java Debug Wire Protocol (JDWP)Java on Truffle reuses all JARs and native libraries from GraalVM.All native libraries and methods are loaded/accessed/called via Truffle Native Function Interface (JNI).JNI handles are implemented in Java on Truffle, e.g., all Truffle NFI methods only receive and return primitives.Some methods are substituted for performance, e.g., Math.sqrt, System.arraycopy, avoiding the expensive transition to native.Some native libraries might contain static data that would conflict if were used from multiple Java on Truffle contexts or even from both Java on Truffle and Java running on HotSpot.On Linux, Java on Truffle uses the capability of Truffle NFI to try to load libraries in isolated namespaces (dlmopen). This is only available on Linux with glibc and has many limitations.This mode is not used when running in a native image since there will be no conflict with HotSpot.Current Limitations  Java on Truffle does not implement the JVM Tool Interface (JVMTI). As a result, it does not support the -agentlib, or -agentpath VM options.  Java on Truffle does not implement the java.lang.instrument interface. As a result it does not support the -javaagent VM option.  Java on Truffle currently uses the standard native libraries from the Java core library. This requires allowing a polyglot Context native access. Because of the way these libraries are loaded (via Truffle NFI), running on top of HotSpot only works on Linux (with glibc). Running as part of a native image works on Linux, Windows, and macOS but it currently limited to one context.  Support for Java Management Extensions (JMX) is partial and some methods might return partial data.  The Debugger Protocol Implementation (JDWP) lacks some capabilities compared to HotSpot. It will correctly report the supported capabilities. In particular actions that require to enumerate all Java objects are not supported. However it does support a few hot reloading cases that HotSpot does not. See Enhanced HotSwap Capabilities with Java on Truffle.  When the java.MultiThreaded option is set to “false”, reference processing will not happen. Depending on the application, this could create resource leaks. Note that this option is set to “false” automatically if Java on Truffle runs in a context where a single-threaded language is enabled (e.g., JavaScript).  Java on Truffle does not support the Polyglot API yet. However, it provides a guest Java Polyglot API, described in polyglot.jar. For more information, see Interoperability with Truffle Languages.",
                    "url": " /reference-manual/java-on-truffle/implementation/"
                  },
                  
                  "reference-manual-native-image-implementingnativemethodsinjavawithsvm":  {
                    "title": "",
                    "content": "Implementing Native Methods in Java with Native ImageNative Image can be used to implement low-level system operations in Java andmake them available via JNI to Java code executing on a standard JVM. Asa result one can use the same language to write the application logicas well as the system calls.Note that this document describes the opposite of what is commonly done via JNI:usually low-level system operations are implemented in C and invoked from Javausing JNI. If you are interested in how Native Image supports the common use case,continue reading to the Native Image JNI support guide instead.Create a Shared LibraryFirst of all one has to use the native-image builder to generate a shared librarywith some JNI-compatible entry points.Start with the Java code:package org.pkg.implnative;import org.graalvm.nativeimage.c.function.CEntryPoint;import org.graalvm.word.Pointer;public final class NativeImpl {    @CEntryPoint(name = &quot;Java_org_pkg_apinative_Native_add&quot;)    public static int add(Pointer jniEnv, Pointer clazz, @CEntryPoint.IsolateThreadContext long isolateId, int a, int b) {        return a + b;    }}After being processed by the native-image builder, the codeexposes a C function Java_org_pkg_apinative_Native_add(the name follows conventions of JNI that will be handy later) anda Native Image signature typical for JNI methods. The first parameteris a reference to the JNIEnv* value. The second parameter is a referenceto the jclass value for the class declaring the method. The third parameter is aportable (e.g., long) identifier of the Native Image isolatethread.The rest of the parameters are the actual parameters of the Java Native.addmethod described in the next section. Compile the code with the --shared option:$GRAALVM/bin/native-image --shared -H:Name=libnativeimpl -cp nativeimplThe libnativeimpl.so is generated. We are ready to use it from standardJava code.Bind a Java Native MethodNow we need another Java class to use the native library generated in the previous step:package org.pkg.apinative;public final class Native {    private static native int add(long isolateThreadId, int a, int b);}The package name of the class, as well as the name of the method, has to correspond(after the JNI mangling)to the name of the @CEntryPoint introduced previously. The first argument isa portable (e.g., long) identifier of the Native Image isolate thread. The rest of the argumentsmatch the parameters of the entry point.Loading the Native LibraryThe next step is to bind the JDK with the generated .so library. For example,make sure the implementation of the native Native.add method is loaded.Simple load or loadLibrary calls will do:public static void main(String[] args) {    System.loadLibrary(&quot;nativeimpl&quot;);    // ...}This is assuming your LD_LIBRARY_PATH environment variable is specified,or the java.library.path Java property is properly set.Initializing a Native Image IsolateBefore making calls to the Native.add method, we need to create a Native Imageisolate. Native Image provides a special built-in to allow that:CEntryPoint.Builtin.CREATE_ISOLATE. Define another method along your otherexisting @CEntryPoint methods. Let it return IsolateThread and take no parameters:public final class NativeImpl {    @CEntryPoint(name = &quot;Java_org_pkg_apinative_Native_createIsolate&quot;, builtin=CEntryPoint.Builtin.CREATE_ISOLATE)    public static native IsolateThread createIsolate();}Native Image then generates default native implementation of themethod into the final .so library.The method initializes the Native Image runtime andreturns a portable identification, e.g., long, to holdan instance of a Native Image isolatethread. The isolate thread can then be used formultiple invocations of the native part of your code:package org.pkg.apinative;public final class Native {    public static void main(String[] args) {        System.loadLibrary(&quot;nativeimpl&quot;);        long isolateThread = createIsolate();        System.out.println(&quot;2 + 40 = &quot; + add(isolateThread, 2, 40));        System.out.println(&quot;12 + 30 = &quot; + add(isolateThread, 12, 30));        System.out.println(&quot;20 + 22 = &quot; + add(isolateThread, 20, 22));    }    private static native int add(long isolateThread, int a, int b);    private static native long createIsolate();}The standard JVM is started. It initializes a Native Image isolate,attaches the current thread to the isolate, and the universal answer 42 isthen computed three times inside of the isolate.Calling JVM from Native JavaThere is a detailed tutorial on the C interface of Native Image. The following example shows how to make a callback to JVM.In the classical setup, when C needs to call into JVM, it uses a jni.hheader file. The file defines essential JVM structures (like JNIEnv) as well asfunctions one can invoke to inspect classes, access fields, and call methodsin the JVM. In order to call these functions from the NativeImpl class in the aboveexample, you need to define appropriate Java API wrappers of the jni.h concepts:@CContext(JNIHeaderDirectives.class)@CStruct(value = &quot;JNIEnv_&quot;, addStructKeyword = true)interface JNIEnvironment extends PointerBase {    @CField(&quot;functions&quot;)    JNINativeInterface getFunctions();}@CPointerTo(JNIEnvironment.class)interface JNIEnvironmentPointer extends PointerBase {    JNIEnvironment read();    void write(JNIEnvironment value);}@CContext(JNIHeaderDirectives.class)@CStruct(value = &quot;JNINativeInterface_&quot;, addStructKeyword = true)interface JNINativeInterface extends PointerBase {    @CField    GetMethodId getGetStaticMethodID();    @CField    CallStaticVoidMethod getCallStaticVoidMethodA();}interface GetMethodId extends CFunctionPointer {    @InvokeCFunctionPointer    JMethodID find(JNIEnvironment env, JClass clazz, CCharPointer name, CCharPointer sig);}interface JObject extends PointerBase {}interface CallStaticVoidMethod extends CFunctionPointer {    @InvokeCFunctionPointer    void call(JNIEnvironment env, JClass cls, JMethodID methodid, JValue args);}interface JClass extends PointerBase {}interface JMethodID extends PointerBase {}Leaving aside the meaning of JNIHeaderDirectives for now, the restof the interfaces are type-safe representations of the C pointers found in thejni.h file. JClass, JMethodID, and JObject are all pointers. Thanks tothe above definitions, you now have Java interfaces to representinstances of these objects in your native Java code in a type-safe way.The core part of any JNI API is the set of functions one can callwhen talking to the JVM. There are dozens of them, but in the JNINativeInterfacedefinition, you just define wrappers for those few that are needed in the example.Again, give them proper types, so in your native Java code you can useGetMethodId.find(...), CallStaticVoidMethod.call(...), etc. In addition,there is another important part missing in the puzzle - the jvalue union typewrapping all the possible Java primitive and object types. Here are definitionsof its getters and setters:@CContext(JNIHeaderDirectives.class)@CStruct(&quot;jvalue&quot;)interface JValue extends PointerBase {    @CField boolean z();    @CField byte b();    @CField char c();    @CField short s();    @CField int i();    @CField long j();    @CField float f();    @CField double d();    @CField JObject l();    @CField void z(boolean b);    @CField void b(byte b);    @CField void c(char ch);    @CField void s(short s);    @CField void i(int i);    @CField void j(long l);    @CField void f(float f);    @CField void d(double d);    @CField void l(JObject obj);    JValue addressOf(int index);}The addressOf method is a special Native Image construct used to performC pointer arithmetics. Given a pointer, one can treat it as the initial element ofan array, then, for example, use addressOf(1) to access the subsequent element.With this you have all the API needed to make a callback - redefinethe previously introduced NativeImpl.add method to accept properly typedpointers, and then use these pointers to invoke a JVM method before computingthe sum of a + b:@CEntryPoint(name = &quot;Java_org_pkg_apinative_Native_add&quot;)static int add(JNIEnvironment env, JClass clazz, @CEntryPoint.IsolateThreadContext long isolateThreadId, int a, int b) {    JNINativeInterface fn = env.getFunctions();    try (        CTypeConversion.CCharPointerHolder name = CTypeConversion.toCString(&quot;hello&quot;);        CTypeConversion.CCharPointerHolder sig = CTypeConversion.toCString(&quot;(ZCBSIJFD)V&quot;);    ) {        JMethodID helloId = fn.getGetStaticMethodID().find(env, clazz, name.get(), sig.get());        JValue args = StackValue.get(8, JValue.class);        args.addressOf(0).z(false);        args.addressOf(1).c(&#39;A&#39;);        args.addressOf(2).b((byte)22);        args.addressOf(3).s((short)33);        args.addressOf(4).i(39);        args.addressOf(5).j(Long.MAX_VALUE / 2l);        args.addressOf(6).f((float) Math.PI);        args.addressOf(7).d(Math.PI);        fn.getCallStaticVoidMethodA().call(env, clazz, helloId, args);    }    return a + b;}The above example seeks a static method hello and invokes it with eightJValue parameters in an array reserved by StackValue.geton the stack. Individual parameters are accessed by use ofthe addressOf operator and filled with appropriate primitive valuesbefore the call happens. The method hello is defined in the class Nativeand prints values of all parameters to verify they are properlypropagated from the NativeImpl.add caller:public class Native {    public static void hello(boolean z, char c, byte b, short s, int i, long j, float f, double d) {        System.err.println(&quot;Hi, I have just been called back!&quot;);        System.err.print(&quot;With: &quot; + z + &quot; &quot; + c + &quot; &quot; + b + &quot; &quot; + s);        System.err.println(&quot; and: &quot; + i + &quot; &quot; + j + &quot; &quot; + f + &quot; &quot; + d);    }There is just one final piece to explain: the JNIHeaderDirectives.The Native Image C interface needs to understand the layout of the C structures. Itneeds to know at which offset of JNINativeInterface structure it can findthe pointer to the GetMethodId function. To do so, it needs jni.h and additionalfiles during compilation. One can specify them by @CContext annotation andimplementation of its Directives:final class JNIHeaderDirectives implements CContext.Directives {    @Override    public List&amp;lt;String&amp;gt; getOptions() {        File[] jnis = findJNIHeaders();        return Arrays.asList(&quot;-I&quot; + jnis[0].getParent(), &quot;-I&quot; + jnis[1].getParent());    }    @Override    public List&amp;lt;String&amp;gt; getHeaderFiles() {        File[] jnis = findJNIHeaders();        return Arrays.asList(&quot;&amp;lt;&quot; + jnis[0] + &quot;&amp;gt;&quot;, &quot;&amp;lt;&quot; + jnis[1] + &quot;&amp;gt;&quot;);    }    private static File[] findJNIHeaders() throws IllegalStateException {        final File jreHome = new File(System.getProperty(&quot;java.home&quot;));        final File include = new File(jreHome.getParentFile(), &quot;include&quot;);        final File[] jnis = {            new File(include, &quot;jni.h&quot;),            new File(new File(include, &quot;linux&quot;), &quot;jni_md.h&quot;),        };        return jnis;    }}The good thing is that jni.h is inside of every JDK, so one can use thejava.home property to locate the necessary header files. The actual logiccan, of course, be made more robust and OS-independent.Implementing any JVM native method in Java and/or making callbacks to the JVMwith Native Image should now be as easy as expanding upon the given exampleand invoking native-image.",
                    "url": " /reference-manual/native-image/ImplementingNativeMethodsInJavaWithSVM/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-inlining":  {
                    "title": "",
                    "content": "Truffle Approach to Function InliningTruffle provides automated inlining for all languages built with the framework.Since the 20.2.0 release a new approach to inlining was introduced.This document describes how the new approach works, compares it to the legacyinlining approach, and motivates the design choices made for the new approach.InliningInlining is the process of replacing a call to a function with the body of that function.This removes the overhead of the call but more importantly it opens up more optimization opportunities for later phases of the compiler.The down side of the process is that the size of the compilation grows with each inlined function.Overly large compilation units are hard to optimize and there is finite memory for installing code.Because of all this, choosing which functions to inline is a delicate trade-offbetween the expected gains of inlining a function versus the cost of theincrease of the size of the compilation unit.Truffle Legacy InliningTruffle has had an approach to inlining for quite a while.Unfortunately, this early approach suffered from multiple issues, the main one being that it relied on the number of Truffle AST nodes in a call target to approximate the size of the call target.AST nodes are a very poor proxy for actual code size of the call target since there is no guarantee how much code a single AST node will produce.For example, an addition node specialized for adding two integers will produce significantly less code than that same node if specialized for adding integers, doubles, and strings (not to mention a different node and nodes from different languages).This made it impossible to have a single inlining approach that would work reliably across all the Truffle languages.One notable thing about the legacy inlining is that, since it only uses information from the AST, inlining decisions are made before partial evaluation begins.This means that we only ever partially evaluate call targets that we decide to inline.The advantage of this approach is that no time is spent on the partial evaluation of call targets that do not end up being inlined.On the other hand this results in frequent compilation problems stemming from the poor decisions made by the inliner.For example, the resulting compilation unit would be too big to compile.Language-agnostic InliningThe main design goal of the new inlining approach is to use the number of Graal nodes (compiler nodes) after partial evaluation as a proxy for call target size.This is a much better size proxy since partial evaluation removes all the abstractions of the AST and results in a graph that is much closer to the low-level instructions that the call target actually performs.This results in a more precise cost model when deciding whether or not to inline a call target, and it removes much ofthe language-specific information that the AST carries (hence the name: Language-agnostic inlining).This is achieved by performing partial evaluation on every candidate call target and then making the inlining decision after that (as opposed to the legacy inlining which made decisions before doing any partial evaluation).Both the amount of partial evaluation that will be done as well as the amount that will be inlined are controlled by the notion of budgets.These are the “exploration budget” and “inlining budget” respectively, both expressed in terms of Graal node counts.The downside of this approach is that we need to do partial evaluation even on call targets which we ultimately decide not to inline.This results in a measurable increase in average compilation time compared to legacy inlining (approximate 10%).Observing and Impacting the InliningThe inliner keeps an internal call tree to keep track of the states of individual calls to targets, as well as the inlining decisions that were made.The following sections explain the states in which calls in the call tree can be, as well as how to find out which decisions were made during compilations.Call Tree StatesNodes in the inline call treerepresent calls to particular targets.This means that if one target calls another twice, we will see this as two nodes despite it being the same call target.Each node can be in one of six states explained here:  Inlined - This state means that the call was inlined. Initially, only theroot of the compilation is in this state since it is implicitly “inlined”(i.e., part of the compilation unit).  Cutoff - This state means that the call target was not partially evaluated,thus was not even considered for inlining. This is normally due to theinliner hitting its exploration budget limitations.  Expanded - This state means that the call target was partially evaluated(thus, considered for inlining) but a decision was made not to inline. Thiscould be due to inlining budget limitations or the target being deemed tooexpensive to inline (e.g., inlining a small target with multiple outgoing“Cutoff” calls would just introduce more calls to the compilation unit).  Removed - This state means that this call is present in the AST but partialevaluation removed the call. This is an advantage over the legacy inliningwhich made the decisions ahead of time and had no way of noticing suchsituations.  Indirect - This state denotes an indirect call. We cannot inline an indirectcall.  BailedOut - This state should be very rare and is considered a performanceproblem. It means that partial evaluation of the target resulted in aBailoutException, i.e., it could not be completed successfully. This means there issome problem with that particular target, but rather than quit the entirecompilation, we treat that call as not possible to inline.Tracing Inlining DecisionsTruffle provides an engine option to trace the final state of the call tree, including a lot of accompanying data, during compilation.This option is TraceInlining and can be set in all the usual ways: by adding --engine.TraceInlining=true to the language launchers, adding -Dpolyglot.engine.TraceInlining=true to the command line ifrunning a regular Java program that executes guest languages (languages implemented with Truffle), or setting the option explicitly for an engine.Here is an example output of TraceInlining for a JavaScript function:[engine] inline start     M.CollidePolygons                                           |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.07 |IR Nodes        27149 |Frequency        1.00 |Truffle Callees     14 |Forced          false |Depth               0[engine] Inlined            M.FindMaxSeparation &amp;lt;opt&amp;gt;                                 |call diff       -8.99 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4617 |Frequency        1.00 |Truffle Callees      7 |Forced          false |Depth               1[engine] Inlined              parseInt &amp;lt;opt&amp;gt;                                          |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               2[engine] Inlined              M.EdgeSeparation                                        |call diff       -3.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4097 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               2[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Inlined              parseInt &amp;lt;opt&amp;gt;                                          |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               2[engine] Expanded             M.EdgeSeparation                                        |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4097 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               2[engine] Inlined              parseInt &amp;lt;opt&amp;gt;                                          |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               2[engine] Inlined              M.EdgeSeparation                                        |call diff       -3.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes         4097 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               2[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Inlined                parseInt &amp;lt;opt&amp;gt;                                        |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          111 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               3[engine] Cutoff               M.EdgeSeparation                                        |call diff        0.01 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        0.01 |Truffle Callees      2 |Forced          false |Depth               2[engine] Cutoff             M.FindMaxSeparation &amp;lt;opt&amp;gt;                                 |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      7 |Forced          false |Depth               1[engine] Cutoff             M.FindIncidentEdge &amp;lt;opt&amp;gt;                                  |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees     19 |Forced          false |Depth               1[engine] Cutoff             parseInt &amp;lt;opt&amp;gt;                                            |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced           true |Depth               1[engine] Cutoff             parseInt &amp;lt;opt&amp;gt;                                            |call diff        0.98 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        0.98 |Truffle Callees      0 |Forced           true |Depth               1[engine] Cutoff             A.Set &amp;lt;split-16abdeb5&amp;gt;                                    |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Cutoff             A.Normalize &amp;lt;split-866f516&amp;gt;                               |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      1 |Forced          false |Depth               1[engine] Cutoff             A.Set &amp;lt;split-1f7fe4ae&amp;gt;                                    |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Cutoff             M.ClipSegmentToLine                                       |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               1[engine] Cutoff             M.ClipSegmentToLine                                       |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      2 |Forced          false |Depth               1[engine] Cutoff             A.SetV &amp;lt;split-7c14e725&amp;gt;                                   |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Cutoff             A.SetV &amp;lt;split-6029dec7&amp;gt;                                   |call diff        1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes            0 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Inlined            L.Set &amp;lt;split-2ef5921d&amp;gt;                                    |call diff       -3.97 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          205 |Frequency        1.98 |Truffle Callees      1 |Forced          false |Depth               1[engine] Inlined              set &amp;lt;split-969378b&amp;gt;                                     |call diff       -1.98 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          716 |Frequency        1.98 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            set                                                       |call diff       -1.98 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          381 |Frequency        1.98 |Truffle Callees      0 |Forced          false |Depth               1[engine] inline done      M.CollidePolygons                                           |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.07 |IR Nodes        27149 |Frequency        1.00 |Truffle Callees     14 |Forced          false |Depth               0Dumping Inlining DecisionsThe same information that is provided in textual form through tracing is also available in the IGV dumps.The graphs are part of the Graal Graphs group in a Call Tree subgroup.The graphs show the state of the call tree before inlining and after.Controlling Inlining BudgetsNote: The default values for inlining-related budgets were carefully chosen with consideration for compilation time, performance, and compiler stability in mind.Changing these parameters can impact all of these.Language-agnostic inlining provides two options to control the amount of exploration and the amount of inlining the compiler can do.These are InliningExpansionBudget and InliningInliningBudget, respectively.Both are expressed in terms of Graal node count.They can be controlled as any other engine options (i.e., the same way as described in the “Tracing inlining decisions” section).InliningExpansionBudget controls at which point the inliner will stop partially evaluating candidates.Increasing this budget can thus have a very negative impact on average compilation time (notably on the time spent doingpartial evaluation), but may provide more candidates for inlining.InliningInliningBudget controls how many Graal nodes the compilation unit is allowed to have as a result of inlining. Increasing this budget will likely result in more candidates being inlined, which will result in a larger compilation unit. This, in turn might slow down compilation, notably in the post partial evaluation phases since larger graphs take more time to optimize.It may also improve performance (removed calls, optimization phases have a bigger picture) or hurt performance, e.g., when a graph is too big to optimize correctly or to compile at all.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/Inlining/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-interopmigration":  {
                    "title": "",
                    "content": "Truffle Interop 2.0This document is targeted at guest language and tool implementers.It is recommended to read the Truffle Library Tutorial first, before proceeding.MotivationIn Truffle Version 1.0 RC15 a new API called “Truffle Libraries” was introduced.Truffle Libraries allow users to use polymorphism with support for profiling/caching.With Interop 2.0 it is planned to use Truffle Libraries for the interoperability protocol.The current interoperability APIs are mature and well-tested and alreadyadopted by languages and tools.Here is a list of arguments why current interoperability APIs were changed and Interop 2.0 was introduced:  Footprint: In the current interop API every message send goes through a CallTarget and the arguments are boxed into an Object[]. This makes current interop inefficient for interpreter calls and it requires additional memory. Truffle Libraries use simple nodes and type-specialized call signatures that do not require argument array boxing or call targets.  Uncached dispatch: There is no way to execute current interop messages from the slow-path without allocating a temporary node. Truffle Libraries automatically generate an uncached version of every exported message. This allows the use of interop messages from slow-path/runtime without allocating any temporary data structures.  Reuse dispatch for multiple messages: In current interop, the dispatch to exported messages is repeated for each message that is sent. If multiple messages need to be sent and the receiver type becomes polymorphic, this produces bad code. Interop libraries instances can be specialized for input values. This allows users to do the dispatch once and invoke multiple messages without repeating the dispatch. This leads to more efficient code in polymorphic cases.  Support for default implementations: Current interop can only be used for implementations of TruffleObject. Truffle Libraries can be used with any receiver type. For example, it is possible to invoke the isExecutable message on primitive numbers and it just returns false.  Error proneness: There were some common issues with message resolutions that Truffle Libraries try to avoid by not making them possible, such as mixing up receiver types or implementing a wrong type check. The new assertion feature for Truffle Libraries allows specifying message specific assertions that allow verifying invariants, pre, and post-conditions.  Redundancy in documentation: Current interop documents the messages in the Message constant and in the ForeignAccess static accessor method. This leads to mostly redundant documentation. With Truffle interop, there is only one place for the documentation, which is the instance method in the library class.  Generality: Truffle Libraries can be used for language representation abstractions, since it is now efficient enough in terms of memory consumption and interpreter performance. The current interop API could not realistically be used that way because of this issue.  Address protocol issues: There are some design issues with the current interop API that interop 2.0 tries to address (see later).CompatibilityThe change from interop 1.0 to 2.0 was done in a compatible way.Therefore, the old interop should continue to work and adoption can be incremental.This means that if one language still calls using the old interop API and the other language has already adopted the new interop API, a compatibility bridge will map the APIs.If you are curious about how this works, look for the class DefaultTruffleObjectExports for new interop calls to old interop. And LegacyToLibraryNode for old interop calls to new interop. Note that using the compatibility bridge may cause performance regressions.That is why languages should migrate as early as possible.Interop Protocol ChangesInterop 2.0 comes with many protocol changes. This section is intended to provide rationales for these changes. For fully detailed reference documentation see the InteropLibrary Javadoc.Note: Every deprecated API describes its migration path in the Javadoc tagged by @deprecated.Replace IS_BOXED and UNBOX with Explicit TypesThere are some problems with the IS_BOXED/UNBOX design:  In order to find out if a value is of a particular type, e.g., a String, the value needs to be unboxed first. Unboxing may be an expensive operation leading to inefficient code just to check the type of a value.  The old API cannot be used for values that did not implement TruffleObject. Therefore, the handling of primitive numbers needed to be separated from the TruffleObject case, making the UNBOX design necessary to reuse existing code. Truffle Libraries support primitive receiver types.  The design of UNBOX relies on the specified set of primitive types that it returns. It is hard to introduce additional, new interop types this way, as language refers to the primitive types directly.The following new messages were introduced in InteropLibrary as a replacement:boolean isBoolean(Object)boolean asBoolean(Object)boolean isString(Object)String  asString(Object)boolean isNumber(Object)boolean fitsInByte(Object)boolean fitsInShort(Object)boolean fitsInInt(Object)boolean fitsInLong(Object)boolean fitsInFloat(Object)boolean fitsInDouble(Object)byte asByte(Object)short asShort(Object)int asInt(Object)long asLong(Object)float asFloat(Object)double asDouble(Object)The InteropLibrary specifies default implementations for the receiver types Boolean, Byte, Short, Integer, Long, Float, Double, Character, and String.This design is extendable to support new values like big numbers or a custom String abstraction as Java primitive types are no longer directly used.It is no longer recommended to use primitive types in specializations directly, as the set of interop primitive types may change in the future.Instead, always use the interop library to check for a particular type, e.g., use fitsInInt instead of instanceof Integer.By using the new messages it is possible to emulate the original UNBOX message like this:@Specialization(limit=&quot;5&quot;)Object doUnbox(Object value, @CachedLibrary(&quot;value&quot;) InteropLibrary interop) {    if (interop.isBoolean(value)) {      return interop.asBoolean(value);    } else if (interop.isString(value)) {      return interop.asString(value);    } else if (interop.isNumber(value)) {      if (interop.fitsInByte(value)) {        return interop.asByte(value);      } else if (interop.fitsInShort(value)) {        return interop.asShort(value);      } else if (interop.fitsInInt(value)) {        return interop.asInt(value);      } else if (interop.fitsInLong(value)) {        return interop.asLong(value);      } else if (interop.fitsInFloat(value)) {        return interop.asFloat(value);      } else if (interop.fitsInDouble(value)) {        return interop.asDouble(value);      }    }    throw UnsupportedMessageException.create();}Note: It is not recommended to unbox all primitive types like this.Instead a language should only unbox to the primitive types it actually uses.Ideally an unbox operation is not needed and the interop library is directly used to implement the operation, like this:@Specialization(guards = {                &quot;leftValues.fitsInLong(l)&quot;,                &quot;rightValues.fitsInLong(r)&quot;}, limit=&quot;5&quot;)long doAdd(Object l, Object r,             @CachedLibrary(&quot;l&quot;) InteropLibrary leftValues,             @CachedLibrary(&quot;r&quot;) InteropLibrary rightValues) {       return leftValues.asLong(l) + rightValues.asLong(r);}Explicit Namespaces for Array and Member ElementsThe generic READ and WRITE messages were originally designed with primarily JavaScript use-cases in mind.With the adoption of interop by more languages, it became apparent that there is a need for explicit namespaces for arrays and object members.Over time, the interpretation of READ and WRITE was changed to represent array accesses when used with numbers and object member accesses when used with strings.The HAS_SIZE message was reinterpreted as whether the value contains array elements with additional guarantees, e.g., that array elements were iterable between index 0 and size.For better interop between languages, there is a need for an explicit Hash/Map/Dictionary entry namespace.Originally it was intended to reuse the generic READ/WRITE namespace for this.For JavaScript, this was possible, as the dictionary and member namespaces were equivalent.Most languages, however, separate Map entries from Object members, which leads to ambiguous keys.It is not possible for the source language (the protocol implementer) to know how this conflict needs to be resolved.Instead, by having explicit namespaces we can let the target language (the protocol caller) decide how to resolve the ambiguity.For example, whether dictionary or member elements should take precedence can now be decided in the target language operation.The following interop messages were changed:READ, WRITE, REMOVE, HAS_SIZE, GET_SIZE, HAS_KEYS, KEYSThe updated protocol with separate member and array namespace in InteropLibrary looks like this:Object Namespace:hasMembers(Object)getMembers(Object, boolean)readMember(Object, String)writeMember(Object, String, Object)removeMember(Object, String)invokeMember(Object, String, Object...)Array Namespace:hasArrayElements(Object)readArrayElement(Object, long)getArraySize(Object)writeArrayElement(Object, long, Object)removeArrayElement(Object, long)Array access messages no longer throw UnknownIdentifierException; they instead throw InvalidArrayIndexException.This was a bug in the original design, where the accessed number needed to be converted to the identifier string in the UnknownIdentifierException.Replaced KeyInfo with Individual MessagesIn the previous section, we did not mention the KEY_INFO message.The KEY_INFO message was useful to query all properties of a member or array element.While this was a conveniently small API, it was often inefficient as it required the implementer to return all the key info properties.At the same time, it is rare that the caller really needed all key info properties. With Interop 2.0 we removed the KEY_INFO message.Instead, we introduced explicit messages for each namespace, to address this issue.Object Namespace:isMemberReadable(Object, String)isMemberModifiable(Object, String)isMemberInsertable(Object, String)isMemberRemovable(Object, String)isMemberInvocable(Object, String)isMemberInternal(Object, String)isMemberWritable(Object, String)isMemberExisting(Object, String)hasMemberReadSideEffects(Object, String)hasMemberWriteSideEffects(Object, String)Array Namespace:isArrayElementReadable(Object, long)isArrayElementModifiable(Object, long)isArrayElementInsertable(Object, long)isArrayElementRemovable(Object, long)isArrayElementWritable(Object, long)isArrayElementExisting(Object, long)Note: The array namespace no longer supports querying for read or write side-effects.These messages might be reintroduced but, at the moment, there was no use-case.Also, the array namespace does not allow invocations.Remove Return Type for TO_NATIVEThe TO_NATIVE message was renamed to toNative in the InteropLibrary with the difference that it no longer returns a value, but performs the native transition as a side-effect if supported by the receiver.This allows the caller of the message to simplify their code. No cases the toNative transition required to return a different value were found.The default behaviour of toNative was changed to not return any value.Minor ChangesThe following messages were mostly unchanged. The NEW message was renamed to instantiate to be consistent with isInstantiable.Message.IS_NULL         -&amp;gt; InteropLibrary.isNullMessage.EXECUTE         -&amp;gt; InteropLibrary.executeMessage.IS_INSTANTIABLE -&amp;gt; InteropLibrary.isInstantiableMessage.NEW             -&amp;gt; InteropLibrary.instantiateMessage.IS_EXECUTABLE   -&amp;gt; InteropLibrary.isExecutableMessage.EXECUTE         -&amp;gt; InteropLibrary.executeMessage.IS_POINTER      -&amp;gt; InteropLibrary.isPointerMessage.AS_POINTER      -&amp;gt; InteropLibrary.asPointerStronger AssertionsMany new assertions were introduced as part of the migration. The concrete pre-post and invariant conditions are described in the Javadoc. Unlike the old interop nodes, cached libraries can only be used when adopted as part of the AST.No More Unchecked/Checked ExceptionsWith Interop 2.0 InteropException.raise was deprecated.While possible, it is considered an anti-pattern to rethrow checked exceptions as unchecked exceptions.With Truffle Libraries the target language nodes are directly inserted into the AST of the caller so there is no longer a limiting CallTarget that does not support checked exceptions.Together with additional support for checked Exceptions from Truffle DSL, it should no longer be necessary to use the raise methods.Instead, a new create factory method was introduced for all interop exception types.It is planned to remove stack traces from interop exceptions in order to improve their efficiency, as interop exceptions are intended to be always immediately caught and never be rethrown.This was deferred until the compatibility layer can be removed.MigrationWith the use of Truffle Libraries for interop, most existing interop APIs had to be deprecated.The following comparison of Interop 1.0 with Interop 2.0 is designed to help migrate existing uses of interop.Fast-Path Sending Interop MessagesThis is the fast-path way of sending interop messages embedded in an operation node.This is the most common way of sending interop messages.Interop 1.0:@ImportStatic({Message.class, ForeignAccess.class})abstract static class ForeignExecuteNode extends Node {    abstract Object execute(Object function, Object[] arguments);    @Specialization(guards = &quot;sendIsExecutable(isExecutableNode, function)&quot;)    Object doDefault(TruffleObject function, Object[] arguments,                    @Cached(&quot;IS_EXECUTABLE.createNode()&quot;) Node isExecutableNode,                    @Cached(&quot;EXECUTE.createNode()&quot;) Node executeNode) {        try {            return ForeignAccess.sendExecute(executeNode, function, arguments);        } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {            // ... convert errors to guest language errors ...        }    }}Interop 2.0:abstract static class ForeignExecuteNode extends Node {    abstract Object execute(Object function, Object[] arguments);    @Specialization(guards = &quot;functions.isExecutable(function)&quot;, limit = &quot;2&quot;)    Object doDefault(Object function, Object[] arguments,                    @CachedLibrary(&quot;function&quot;) InteropLibrary functions) {        try {            return functions.execute(function, arguments);        } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {            // ... convert errors to guest language errors ...        }    }}Note the following differences:  To invoke messages we call instance methods on TruffleLibrary instead of calling a static method on ForeignAccess.  The old interop required the creation of one node for each operation. With the new version, only one specialized interop library is created.  In the old API we needed to specialize the receiver type for TruffleObject. The new interop library can be invoked with any interop value. By default isExecutable will return false for values that don’t export the interop library. E.g., it is now valid to call the library with boxed primitive receiver values.  Instead of using @Cached in the old interop, in the new interop we use @CachedLibrary.  The new @CachedLibrary annotation specifies the value the library specializes on. This allows the DSL to specialize the library instance to that value. This again allows the dispatch on the receiver value to be performed once for all message invocations. In the old interop version, the nodes could not be specialized to values. Therefore the dispatch needed to be repeated for every interop message send.  The specialized library instance requires specifying a limit for the specialization method. If this limit overflows, the uncached version of the library will be used that does not perform any profiling/caching. The old interop API assumed a constant specialization limit of 8 per interop node.  The new interop API allows for using a dispatched version of the library by specifying @CachedLibrary(limit=&quot;2&quot;) instead. This allows the interop library to be used with any value, but it has the disadvantage of duplicating the inline cache for every message invocation, like with the old interop API. It is therefore recommended to use specialized libraries whenever possible.Slow-Path Sending Interop MessagesIt is sometimes necessary to call interop messages from the runtime without the context of a node:Interop 1.0:ForeignAccess.sendRead(Message.READ.createNode(), object, &quot;property&quot;)Interop 2.0:InteropLibrary.getFactory().getUncached().read(object, &quot;property&quot;);Note the following differences:  The old interface allocated a node for each invocation.  The new library uses the uncached version of the library that does not require any allocation or boxing for each invocation.  With InteropLibrary.getFactory().getUncached(object) an uncached and specialized version of a library can be looked up. This can be used to avoid repeated export lookups if multiple uncached interop messages need to be sent to the same receiver.Custom Fast-Path Sending Interop MessagesSometimes Truffle DSL cannot be used and the nodes need to be written manually. Both APIs allow you to do so:Interop 1.0:final class ForeignExecuteNode extends Node {    @Child private Node isExecutableNode = Message.IS_EXECUTABLE.createNode();    @Child private Node executeNode = Message.EXECUTE.createNode();    Object execute(Object function, Object[] arguments) {        if (function instanceof TruffleObject) {            TruffleObject tFunction = (TruffleObject) function;            if (ForeignAccess.sendIsExecutable(isExecutableNode, tFunction)) {                try {                    return ForeignAccess.sendExecute(executeNode, tFunction, arguments);                } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {                    // TODO handle errors                }            }        }        // throw user error    }}Interop 2.0:static final class ForeignExecuteNode extends Node {    @Child private InteropLibrary functions = InteropLibrary.getFactory().createDispatched(5);    Object execute(Object function, Object[] arguments) {        if (functions.isExecutable(function)) {            try {                return functions.execute(function, arguments);            } catch (UnsupportedTypeException | ArityException | UnsupportedMessageException e) {                // handle errors                return null;            }        }        // throw user error    }}Note the following differences:  The new interop creates nodes through the LibraryFactory&amp;lt;InteropLibrary&amp;gt; accessible through InteropLibrary.getFactory(). The old interop creates dispatching nodes through the Message instance.  The dispatch limit can be specified for the new interop libraries. The old interop API always assumed a constant limit of 8.  For the new interop we do not need to check for the type TruffleObject as Truffle Libraries can be used with any receiver type. For non-function values, isExecutable will just return false.Implementing/Exporting Interop MessagesTo implement/export interop library messages, see the following example:Interop 1.0:@MessageResolution(receiverType = KeysArray.class)final class KeysArray implements TruffleObject {    private final String[] keys;    KeysArray(String[] keys) {        this.keys = keys;    }    @Resolve(message = &quot;HAS_SIZE&quot;)    abstract static class HasSize extends Node {        public Object access(KeysArray receiver) {            return true;        }    }    @Resolve(message = &quot;GET_SIZE&quot;)    abstract static class GetSize extends Node {        public Object access(KeysArray receiver) {            return receiver.keys.length;        }    }    @Resolve(message = &quot;READ&quot;)    abstract static class Read extends Node {        public Object access(KeysArray receiver, int index) {            try {                return receiver.keys[index];            } catch (IndexOutOfBoundsException e) {                CompilerDirectives.transferToInterpreter();                throw UnknownIdentifierException.raise(String.valueOf(index));            }        }    }    @Override    public ForeignAccess getForeignAccess() {        return KeysArrayForeign.ACCESS;    }    static boolean isInstance(TruffleObject array) {        return array instanceof KeysArray;    }}Interop 2.0:@ExportLibrary(InteropLibrary.class)final class KeysArray implements TruffleObject {    private final String[] keys;    KeysArray(String[] keys) {        this.keys = keys;    }    @ExportMessage    boolean hasArrayElements() {        return true;    }    @ExportMessage    boolean isArrayElementReadable(long index) {        return index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; keys.length;    }    @ExportMessage    long getArraySize() {        return keys.length;    }    @ExportMessage    Object readArrayElement(long index) throws InvalidArrayIndexException {        if (!isArrayElementReadable(index) {            throw InvalidArrayIndexException.create(index);        }        return keys[(int) index];    }}Note the following differences:  Instead of @MessageResolution we use @ExportLibrary.  Both versions need to implement TruffleObject. The new interop API only requires a TruffleObject type for compatibility reasons.  Instead of @Resolve, the @ExportMessage annotation is used. The latter annotation can infer the name of the message from the method name. If the method name is ambiguous, e.g., when multiple libraries are exported, then the name and library can be specified explicitly.  There is no need to specify classes for exports/resolves. However, it is still possible to do so if an export needs multiple specializations. See the Truffle Library tutorial for details.  Exceptions are now thrown as checked exceptions.  It is no longer needed to implement getForeignAccess(). The implementation discovers implementations for receiver types automatically.  It is no longer needed to implement isInstance. The implementation is now derived from the class signature. Note that the check can be more efficient if the receiver type is declared final. For non-final receiver types, it is recommended to specify exported methods as final.Integration with DynamicObjectThe old interop allowed for specifying a foreign access factory through ObjectType.getForeignAccessFactory(). This method is now deprecated and a new method, ObjectType.dispatch(), was introduced. Instead of a foreign access factory, the dispatch method needs to return a class that exports the InteropLibrary with an explicit receiver:Interop 1.0:public final class SLObjectType extends ObjectType {    public static final ObjectType SINGLETON = new SLObjectType();    private SLObjectType() {    }    public static boolean isInstance(TruffleObject obj) {        return SLContext.isSLObject(obj);    }    @Override    public ForeignAccess getForeignAccessFactory(DynamicObject obj) {        return SLObjectMessageResolutionForeign.ACCESS;    }}@MessageResolution(receiverType = SLObjectType.class)public class SLObjectMessageResolution {    @Resolve(message = &quot;WRITE&quot;)    public abstract static class SLForeignWriteNode extends Node {...}    @Resolve(message = &quot;READ&quot;)    public abstract static class SLForeignReadNode extends Node {...}    ...Interop 2.0:@ExportLibrary(value = InteropLibrary.class, receiverType = DynamicObject.class)public final class SLObjectType extends ObjectType {    public static final ObjectType SINGLETON = new SLObjectType();    private SLObjectType() {    }    @Override    public Class&amp;lt;?&amp;gt; dispatch() {        return SLObjectType.class;    }    @ExportMessage    static boolean hasMembers(DynamicObject receiver) {        return true;    }    @ExportMessage    static boolean removeMember(DynamicObject receiver, String member) throws UnknownIdentifierException {...}    // other exports omitted }Note the following differences:  The object type can be reused as the export class.  The isInstance method no longer needs to be specified.  The new interop requires specifying the receiver type to DynamicObject.Extending InteropThe languages implemented with Truffle rarely need to extend interop, but they might need to extend their own language specific protocol:Interop 1.0:  Add new KnownMessage subclass called FooBar.  Add a new method sendFooBar to ForeignAccess.  Add a new method to ForeignAccess.Factory: createFooBar.  Modify the interop annotation processor to generate the code for createFooBar.Interop 2.0:  Add a new method fooBar in InteropLibrary. Everything else is done automatically.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/InteropMigration/"
                  },
                  
                  "reference-manual-java-on-truffle-interoperability":  {
                    "title": "",
                    "content": "Interoperability with Truffle LanguagesJava on Truffle allows you to interface other “Truffle” languages (languages which interpreters are implemented with the Truffle framework) to create polyglot programs – programs written in more than one language.This guide describes how to load code written in foreign languages, how to export and import objects between languages, how to use Java on Truffle objects from a foreign language, how to use foreign objects from Java on Truffle, and how to embed in host Java.To avoid confusion, the terms host and guest are used to differentiate the different layers where Java is executed. Java on Truffle refers to the guest layer.You pass polyglot options to the java -truffle launcher.If you are using the native configuration, you will need to use the --polyglot flag to get access to other languages.Foreign objects must “inhabit” a guest Java type when flowing into Java on Truffle.How this type is attached to foreign objects is an implementation detail.PolyglotJava on Truffle provides a guest Java Polyglot API, described in polyglot.jar.This JAR is automatically injected on guest Java contexts but can be excluded with --java.Polyglot=false.You can import the Polyglot class to interact with other guest languages:// guest javaimport com.oracle.truffle.espresso.polyglot.Polyglot;int two = Polyglot.eval(int.class, &quot;js&quot;, &quot;1+1&quot;);You can determine if an object is foreign:// guest javaObject foreign = Polyglot.eval(&quot;js&quot;, &quot;[2, 0, 2, 1]&quot;);Object local = new int[]{2, 0, 2, 1};System.out.println(Polyglot.isForeignObject(foreign)); // prints trueSystem.out.println(Polyglot.isForeignObject(local));   // prints falseYou can cast foreign objects to guest Java types:// guest javaObject foreignArray = Polyglot.eval(&quot;js&quot;, &quot;[&#39;a string&#39;, 42, 3.14159, null]&quot;);Object[] objects = Polyglot.cast(Object[].class, foreignArray);assert objects.length == 4;String elem0 = Polyglot.cast(String.class, objects[0]);   // eager conversionInteger elem1 = Polyglot.cast(Integer.class, objects[1]); // preserves identityint elem1_ = Polyglot.cast(int.class, objects[1]);        // eager conversiondouble elem2 = Polyglot.cast(double.class, objects[2]);   // eager conversionObject elem3 = objects[3];assert elem3 == null;The Polyglot.cast(targetClass, obj) method is an augmented Java cast, e.g., targetClass.cast(obj):  Java cast succeeds ⇒ Polyglot.cast succeeds.  Java cast does not succeeds, Polyglot.cast can “re-type” foreign objects, e.g., to cast to Integer, the foreign object must fitsInInt.  If Polyglot.cast fails, it will throw ClassCastException similar to Class#cast.Polyglot.cast supports a natural mapping from common interop “kinds” to Java types, summarized below:            Interop “kind”      Allowed types      Preserves identity                  isBoolean      Boolean/boolean      Yes* (boxed type)              fitsInByte      Byte/byte      Yes* (boxed type)              fitsInShort      Short/short      Yes* (boxed type)              fitsInInt      Integer/int      Yes* (boxed type)              fitsInLong      Long/long      Yes* (boxed type)              fitsInFloat      Float/float      Yes* (boxed type)              fitsInDouble      Double/double      Yes* (boxed type)              isString &amp;amp; 1-character      Character/char      Yes* (boxed type)              isString      String      No (eager conversion)              isException &amp;amp; Polyglot.isForeignObject      ForeignException      Yes              hasArrayElements      Object[]      Yes              isNull      *      Yes              *      Object      Yes      You can access the polyglot bindings:// guest javaObject foreignObject = Polyglot.importObject(&quot;foreign_object&quot;);// Also typed importsString userName = Polyglot.importObject(&quot;user_name&quot;, String.class);int year = Polyglot.importObject(&quot;year&quot;, int.class);// And exportsPolyglot.exportObject(&quot;data&quot;, new double[]{56.77, 59.23, 55.67, 57.50, 64.44, 61.37);Polyglot.exportObject(&quot;message&quot;, &quot;Hello, Espresso!&quot;);Interop ProtocolJava on Truffle provides an explicit guest API to access the Interop protocol.It contains methods mimicking the interop protocol messages.This API can be used on guest Java objects as well.// guest javaimport com.oracle.truffle.espresso.polyglot.Interop;Object foreignArray = Polyglot.eval(&quot;js&quot;, &quot;[2, 0, 2, 1]&quot;);System.out.println(Interop.hasArrayElements(foreignArray)); // prints trueSystem.out.println(Interop.getArraySize(foreignArray));     // prints 4Object elem0 = Interop.readArrayElement(foreignArray, 0);System.out.println(Interop.fitsInInt(elem0)); // prints trueSystem.out.println(Interop.asInt(elem0));     // prints 2Embedding in Host JavaJava on Truffle is embedded via the Polyglot API, which is part of GraalVM.// host javaimport org.graalvm.polyglot.*;class Embedding {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().allowAllAccess(true).build();        // Class loading is exposed through language bindings, with class        // names using the same format as Class#forName(String).        Value intArray = polyglot.getBindings(&quot;java&quot;).getMember(&quot;[I&quot;);        Value objectArray = polyglot.getBindings(&quot;java&quot;).getMember(&quot;[Ljava.lang.Object;&quot;)        Value java_lang_Math = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.Math&quot;);        double sqrt2 = java_lang_Math.invokeMember(&quot;sqrt&quot;, 2).asDouble();        double pi = java_lang_Math.getMember(&quot;PI&quot;).asDouble();        System.out.println(sqrt2);        System.out.println(pi);    }}A number of useful context option can be set with contextBuilder.option(key, value):  Java properties can be added by settings java.Properties.property.name to the desired value (in this case this would set the property.name).  java.Properties.java.class.path can be used to set the classpath of the Java on Truffle context.  java.Properties.java.library.path can be used to set the native library path of the Java on Truffle context.  java.EnableAssertions can be set to true to enable assertions.  java.EnableSystemAssertions can be set to true to enable assertions in the Java standard library.  java.Verify can be set to none, remove, or all to control whether bytecode verification does not happen, only happens on user code, or happens for all classes.  java.JDWPOptions can be set to setup and enable debugging over JDWP. For example, it could be set to transport=dt_socket,server=y,address=localhost:8000,suspend=y.  java.Polyglot can be set to true or false to allow or deny access to the polyglot features from the com.oracle.truffle.espresso.polyglot package.*Java on Truffle does not support evaluation (.eval) of Java sources.In Java, methods can be overloaded, e.g., several methods can share the same name, with different signatures.To remove ambiguity, Java on Truffle allows to specify the method descriptor in the methodName/methodDescriptor form:// host javaValue java_lang_String = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.String&quot;);// String#valueOf(int)String valueOf = String.format(&quot;%s/%s&quot;, &quot;valueOf&quot;, &quot;(I)Ljava/lang/String;&quot;);Value fortyTwo = java_lang_String.invokeMember(valueOf, 42);assert &quot;42&quot;.equals(fortyTwo.asString());Class&amp;lt;?&amp;gt; instance vs. static class accessor (Klass):The static class accessor allows to access (public) static fields and call (public) static methods.// Class loading through language bindings return the static class accessor.Value java_lang_Number = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.Number&quot;);Value java_lang_Class = polyglot.getBindings(&quot;java&quot;).getMember(&quot;java.lang.Class&quot;);// Class#forName(String) returns the Class&amp;lt;Integer&amp;gt; instance.Value integer_class = java_lang_Class.invokeMember(&quot;forName&quot;, &quot;java.lang.Integer&quot;);// Static class accessor to Class&amp;lt;?&amp;gt; instance and viceversa.assert integer_class.equals(java_lang_Integer.getMember(&quot;class&quot;));assert java_lang_Integer.equals(integer_class.getMember(&quot;static&quot;));// Get Integer super class.assert java_lang_Number.equals(java_lang_Integer.getMember(&quot;super&quot;));MultithreadingJava on Truffle is designed to be a multi-threaded language and much of the ecosystem expects threads to be available.This may be incompatible with other Truffle languages which do not support threading, so you can disable the creation of multiple threads with the option --java.MultiThreaded=false.When this option is enabled, finalizers will not run, neither the ReferenceQueue notification mechanism.Both these features would require starting new threads. Note that the garbage-collection of weakly reachable objects remains unaffected.",
                    "url": " /reference-manual/java-on-truffle/interoperability/"
                  },
                  
                  "reference-manual-python-interoperability":  {
                    "title": "",
                    "content": "InteroperabilityThe Polyglot APISince GraalVM supports several other programming languages including JavaScript, R,Ruby, and those that compile to LLVM bitcode, it also provides a Python API to interact with them.In fact, GraalVM uses this API internally to execute Python C extensions using the GraalVM LLVM runtime.You can import the polyglot module to interact with other languages:import polyglotYou can import a global value from the entire polyglot scope:imported_polyglot_global = polyglot.import_value(&quot;global_name&quot;)This global value should then work as expected:  Accessing attributes assumes it reads from the members namespace.  Accessing items is supported both with strings and numbers.  Calling methods on the result tries to do a straight invoke and fallsback to reading the member and trying to execute it.You can evaluate some inlined code from another language:polyglot.eval(string=&quot;1 + 1&quot;, language=&quot;ruby&quot;)You can evaluate some code from a file, by passing the path to it:polyglot.eval(path=&quot;./my_ruby_file.rb&quot;, language=&quot;ruby&quot;)If you pass a file, you can also rely on the file-based language detection:polyglot.eval(path=&quot;./my_ruby_file.rb&quot;)You can export some oblect from Python to other supported languages so they can importit:foo = object()polyglot.export_value(foo, name=&quot;python_foo&quot;)The export function can be used as a decorator.In this case the function name is used as the globally exported name:@polyglot.export_valuedef python_method():    return &quot;Hello from Python!&quot;Here is an example of how to use the JavaScript regular expression engine tomatch Python strings. Save this code to the polyglot_example.py file:import polyglotre = polyglot.eval(string=&quot;RegExp()&quot;, language=&quot;js&quot;)pattern = re.compile(&quot;.*(?:we have (?:a )?matching strings?(?:[!?] )?)(.*)&quot;)if pattern.exec(&quot;This string does not match&quot;):    raise SystemError(&quot;that shouldn&#39;t happen&quot;)md = pattern.exec(&quot;Look, we have matching strings! This string was matched by Graal.js&quot;)if not md:    raise SystemError(&quot;this should have matched&quot;)print(&quot;Here is what we found: &#39;%s&#39;&quot; % md[1])To run it, pass the --jvm --polyglot option to the graalpython launcher:graalpython --jvm --polyglot polyglot_example.pyThis program matches Python strings using the JavaScript regular expression object.Python reads the captured group from the JavaScript result and prints:Here is what we found: ‘This string was matched by Graal.js’.As a more complex example, see how you can read a file using R, process the data in Python, and use R again to display the resulting data image, using both the R and Python libraries in conjunction.To run this example, first install the required R library:R -e &#39;install.packages(&quot;https://www.rforge.net/src/contrib/jpeg_0.1-8.tar.gz&quot;, repos=NULL)&#39;This example also uses image_magix.py and workson a JPEG image input (you can try with this image). These files have to be in the same folder that the script below is located in and executed from.import polyglotimport sysimport timesys.path.insert(0, &quot;.&quot;)from image_magix import Imageload_jpeg = polyglot.eval(string=&quot;&quot;&quot;function(file.name) {    library(jpeg)    jimg &amp;lt;- readJPEG(file.name)    jimg &amp;lt;- jimg*255    jimg}&quot;&quot;&quot;, language=&quot;R&quot;)raw_data = load_jpeg(&quot;python_demo_picture.jpg&quot;)# the dimensions are R attributes; define function to access themgetDim = polyglot.eval(string=&quot;function(v, pos) dim(v)[[pos]]&quot;, language=&quot;R&quot;)# Create object of Python class &#39;Image&#39; with loaded JPEG dataimage = Image(getDim(raw_data, 2), getDim(raw_data, 1), raw_data)# Run Sobel filterresult = image.sobel()draw = polyglot.eval(string=&quot;&quot;&quot;function(processedImgObj) {    require(grDevices)    require(grid)    mx &amp;lt;- matrix(processedImgObj$`@data`/255, nrow=processedImgObj$`@height`, ncol=processedImgObj$`@width`)    grDevices:::awt()    grid.raster(mx, height=unit(nrow(mx),&quot;points&quot;))}&quot;&quot;&quot;, language=&quot;R&quot;)draw(result)time.sleep(10)The Java Host Interop APIFinally, to interoperate with Java (only when running on the JVM), you can use the java module:import javaBigInteger = java.type(&quot;java.math.BigInteger&quot;)myBigInt = BigInteger(42)myBigInt.shiftLeft(128)# public Java methods can just be calledmyBigInt[&quot;not&quot;]()# Java method names that are keywords in Python can be accessed using &quot;[]&quot;byteArray = myBigInt.toByteArray()# Java arrays can act like Python listsprint(list(byteArray))For packages under the java package, you can also use the normal Python importsyntax:import java.util.ArrayListfrom java.util import ArrayListjava.util.ArrayList == ArrayListal = ArrayList()al.add(1)al.add(12)print(al)# prints [1, 12]In addition to the type builtin method, the java module exposes the followingmethods as well:            Builtin      Specification                  instanceof(obj, class)      returns True if obj is an instance of class (class must be a foreign object class)              is_function(obj)      returns True if obj is a Java host language function wrapped using Truffle interop              is_object(obj)      returns True if obj if the argument is Java host language object wrapped using Truffle interop              is_symbol(obj)      returns True if obj if the argument is a Java host symbol, representing the constructor and static members of a Java class, as obtained by java.type      import javaArrayList = java.type(&#39;java.util.ArrayList&#39;)my_list = ArrayList()print(java.is_symbol(ArrayList))# prints Trueprint(java.is_symbol(my_list))# prints False, my_list is not a Java host symbolprint(java.is_object(ArrayList))# prints True, symbols are also host objectsprint(java.is_function(my_list.add))# prints True, the add method of ArrayListprint(java.instanceof(my_list, ArrayList))# prints TrueSee Polyglot Programming and Embed Languages for more information about interoperability with other programming languages.The Behaviour of TypesThe interop protocol defines different “types” which can overlap in all kinds ofways and have restrictions on how they can interact with Python.Interop Types to PythonMost importantly and upfront - all foreign objects passing into Python have thePython type foreign. There is no emulation of i.e., objects that are interopbooleans to have the Python type bool. This is because interop types canoverlap in ways that the Python builtin types cannot, and it would not be clearwhat should take precendence. Instead, the foreign type defines all of thePython special methods for type conversion that are used throughout theinterpreter (methods like __add__, __int__, __str__, __getitem__ etc)and these try to do the right thing based on the interop type (or raise anexception.)Types not listed in the below table have no special interpretation in Pythonright now.            Interop type      Python interpretation                  Null      It is like None. Important to know: interop null values are equal, but not identical! This was done because JavaScript defines two “null-like” values; undefined and null, which are not identical              Boolean      Behaves like Python booleans, including the fact that in Python, all booleans are also integers (1 and 0 for true and false, respectively)              Number      Behaves like Python numbers. Python only has one integral and one floating point type, but it cares about the ranges in some places such as typed arrays.              String      Behaves like Python strings.              Buffer      Buffers are also a concept in Python’s native API (albeit a bit different). Interop buffers are treated like Python buffers in some places (like memoryview) to avoid copies of data.              Array      Arrays can be used with subscript access like Python lists, with integers and slices as indices.              Hash      Hashes can be used with subscript access like Python dicts, with any hashable kind of object as key. “Hashable” follows Python semantics, generally all interop types with identity are deemed “hashable”. Note that if an interop object is both Array and Hash, the behavior of the subscript access is undefined.              Members      Members can be read using normal Python ~.~ notation or the getattr etc functions.              Iterable      Iterables are treated like Python objects with an __iter__ method, that is, they can be used in loops and other places that accept Python iterables.              Iterator      Iterators are treated like Python objects with a __next__ method.              Exception      Interop exceptions can be caught in generic except clauses.              MetaObject      Interop meta objects can be used in subtype and isinstance checks              Executable      Executable objects can be executed as functions, but never with keyword arguments.              Instantiable      Instantiable objects behave like executable objects (similar to how Python treats this)      Python to Interop Types            Interop type      Python interpretation                  Null      Only None.              Boolean      Only subtypes of Python bool. Note that in contrast to Python semantics, Python bool is never also an interop number.              Number      Only subtypes of int and float.              String      Only subtypes of str.              Array      Any object with a __getitem__ and a __len__, but not if it also has keys, values, and items (like dict does.)              Hash      Only subtypes of dict.              Members      Any Python object. Note that the rules for readable/writable are a bit ad-hoc, since checking that is not part of the Python MOP.              Iterable      Anything that has an __iter__ method or a __getitem__ method.              Iterator      Anything with a __next__ method.              Exception      Any Python BaseException subtype.              MetaObject      Any Python type.              Executable      Anything with a __call__ method.              Instantiable      Any Python type.      ",
                    "url": " /reference-manual/python/Interoperability/"
                  },
                  
                  "reference-manual-llvm-interoperability":  {
                    "title": "",
                    "content": "InteroperabilityGraalVM supports several other programming languages including JavaScript, Python, Ruby, and R.While GraalVM’s implementation of lli is designed to run LLVM bitcode, it also provides the API for programming language interoperability that lets you execute code from any other GraalVM-supported language.Dynamic languages like JavaScript usually access object members by name. Sincenormally names are not preserved in LLVM bitcode, it must be compiled with debuginformation enabled (the LLVM toolchain shipped with GraalVM will automatically enabledebugging information).The following example demonstrates how you can use the API for interoperabilitywith other programming languages.Define a C struct for points and implement allocation functions in a file named cpart.c:// cpart.c#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;struct Point {    double x;    double y;};POLYGLOT_DECLARE_STRUCT(Point)void *allocNativePoint() {    struct Point *ret = malloc(sizeof(*ret));    return polyglot_from_Point(ret);}void *allocNativePointArray(int length) {    struct Point *ret = calloc(length, sizeof(*ret));    return polyglot_from_Point_array(ret, length);}void freeNativePoint(struct Point *p) {    free(p);}void printPoint(struct Point *p) {    printf(&quot;Point&amp;lt;%f,%f&amp;gt;n&quot;, p-&amp;gt;x, p-&amp;gt;y);}Make sure LLVM_TOOLCHAIN resolves to the GraalVM LLVM toolchain (lli --print-toolchain-path),and then compile cpart.c  (the graalvm-llvm library defines the polyglotAPI functions used in the example):$LLVM_TOOLCHAIN/clang -shared cpart.c -lgraalvm-llvm -o cpart.soYou can then access this C/C++ code from other languages. For example, save this JavaScript code in the jspart.js file:// Load and parse the LLVM bitcode into GraalVMvar cpart = Polyglot.evalFile(&quot;llvm&quot; ,&quot;cpart.so&quot;);// Allocate a light-weight C structvar point = cpart.allocNativePoint();// Access it as if it was a JS objectpoint.x = 5;point.y = 7;// Pass it back to a native functioncpart.printPoint(point);// Allocate an array of structsvar pointArray = cpart.allocNativePointArray(15);// Access this array like it was a JS arrayfor (var i = 0; i &amp;lt; pointArray.length; i++) {    var p = pointArray[i];    p.x = i;    p.y = 2*i;}cpart.printPoint(pointArray[3]);// Additionally, pass a JS object to a native functioncpart.printPoint({x: 17, y: 42});// Free the unmanaged data objectscpart.freeNativePoint(point);cpart.freeNativePoint(pointArray);Finally, run this JavaScript file:js --polyglot jspart.jsPoint&amp;lt;5.000000,7.000000&amp;gt;Point&amp;lt;3.000000,6.000000&amp;gt;Point&amp;lt;17.000000,42.000000&amp;gt;Polyglot C APIThere are also lower level API functions for directly accessing polyglot valuesfrom C. See the Polyglot Programming referenceand the comments in polyglot.h for more details.For example, this program allocates and accesses a Java array from C:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 24);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}Compile it to LLVM bitcode:$LLVM_TOOLCHAIN/clang polyglot.c -lgraalvm-llvm -o polyglotThen run it, using the --jvm argument to run in the JVM mode, since there is a Java type used:lli --jvm polyglot24Embedding in JavaGraalVM can also be used to embed LLVM bitcode in Java host programs.For example, write a Java class Polyglot.java that embeds GraalVM torun the previous example:import java.io.*;import org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) throws IOException {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        File file = new File(&quot;polyglot&quot;);        Source source = Source.newBuilder(&quot;llvm&quot;, file).build();        Value cpart = polyglot.eval(source);        cpart.execute();    }}Compile it and run:javac Polyglot.javajava Polyglot24See the Embedding Languages reference formore information.",
                    "url": " /reference-manual/llvm/Interoperability/"
                  },
                  
                  "reference-manual-r-interoperability":  {
                    "title": "",
                    "content": "InteroperabilityGraalVM supports several other programming languages including JavaScript, Ruby, Python, and those that compile to LLVM bitcode.GraalVM’s R runtime provides an API for programming language interoperability that lets you execute code from any other GraalVM-supported language.Note that you must start the R script with --polyglot to have access to other languages.GraalVM’s R runtime allows the following interoperability primitives:  eval.polyglot(&#39;languageId&#39;, &#39;code&#39;) evaluates code in some other language. The languageId can be, e.g., js.  eval.polyglot(path = &#39;/path/to/file.extension&#39;) evaluates code loaded from a file. The language is recognized from the extension.  export(&#39;polyglot-value-name&#39;, rObject) exports an R object so that it can be imported by other languages.  import(&#39;exported-polyglot-value-name&#39;) imports a polyglot value exported by some other language.Use the ?functionName syntax to learn more. The following example demonstrates the interoperability features:# get an array from Rubyx &amp;lt;- eval.polyglot(&#39;ruby&#39;, &#39;[1,2,3]&#39;)print(x[[1]])# [1] 1# get a JavaScript objectx &amp;lt;- eval.polyglot(path=&#39;r_example.js&#39;)print(x$a)# [1] &quot;value&quot;# use R vector in JavaScriptexport(&#39;robj&#39;, c(1,2,3))eval.polyglot(&#39;js&#39;, paste0(    &#39;rvalue = Polyglot.import(&quot;robj&quot;); &#39;,    &#39;console.log(&quot;JavaScript: &quot; + rvalue.length);&#39;))# JavaScript: 3# NULL -- the return value of eval.polyglot(Uses r_example.js.)R vectors are presented as arrays to other languages.This includes single element vectors, e.g., 42L or NA.However, single element vectors that do not contain NA can be typically used in places where the other languages expect a scalar value.An array subscript or similar operation can be used in other languages to access individual elements of an R vector.If the element of the vector is not NA, the actual value is returned as a scalar value, e.g., int.If the element is NA, then a special object that looks like null is returned.The following Ruby code demonstrates this:vec = Polyglot.eval(&quot;R&quot;, &quot;c(NA, 42)&quot;)p vec[0].nil?# truep vec[1]# 42vec = Polyglot.eval(&quot;R&quot;, &quot;42&quot;)p vec.to_s# &quot;[42]&quot;p vec[0]# 42The foreign objects passed to R are implicitly treated as specific R types.The following table gives some examples:            Example of foreign object (Java)      Viewed ‘as if’ on the R side                  int[] {1,2,3}      c(1L,2L,3L)              int[][] { {1, 2, 3}, {1, 2, 3} }      matrix(c(1:3,1:3),nrow=3)              int[][] { {1, 2, 3}, {1, 3} }      not supported: raises error              Object[] {1, ‘a’, ‘1’}      list(1L, ‘a’, ‘1’)              42      42L      In the following example, we can simply pass the Ruby array to the R built-in function sum, which will work with the Ruby array as if it was an integer vector.sum(eval.polyglot(&#39;ruby&#39;, &#39;[1,2,3]&#39;))Foreign objects can be also explicitly wrapped into adapters that make them look like the desired R type.In such a case, no data copying occurs, if possible.The code snippet below shows the most common use cases:# gives list instead of an integer vectoras.list(eval.polyglot(&#39;ruby&#39;, &#39;[1,2,3]&#39;))# assume the following Java code:# public class ClassWithArrays {#   public boolean[] b = {true, false, true};#   public int[] i = {1, 2, 3};# }x &amp;lt;- new(&#39;ClassWithArrays&#39;); # see Java interop belowas.list(x)# gives: list(c(T,F,T), c(1L,2L,3L))For more details, refer to theexecutable specification of the implicit and explicit foreign objects conversions.Note: R contexts started from other languages, or Java (as opposed to via the R script), will default to non interactive mode, similar to Rscript.This has implications on console output (the results are not echoed) and graphics (the output defaults to a file instead of a window), and some packages may behave differently in non-interactive mode.Bellow is a list of available R interoperability builtin functions.For more information see the R --help message and try these examples:&amp;gt; help(java.type)&amp;gt; ?java.type&amp;gt; example(java.type)  java.type  java.addToClasspath  is.polyglot.value  eval.polyglot  export  importSee the Polyglot Programmingreference for more information about interoperability with other programminglanguages.",
                    "url": " /reference-manual/r/Interoperability/"
                  },
                  
                  "reference-manual-native-image-jcasecurityservices":  {
                    "title": "",
                    "content": "JCA Security Services in Native ImageThis section refers to the use of the services provided by the Java Cryptography Architecture (JCA) framework.For more details see the following guides: JDK8, JDK11.The JCA framework uses a provider architecture to access security services such as digital signatures, message digests, certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, etc.To achieve algorithm independence and extensibility it relies on reflection, therefore it requires a custom configuration in Native Image.By default the Native Image builder uses static analysis to discover which of these services are used (see next section for details).The automatic registration of security services can be disabled with -H:-EnableSecurityServicesFeature.Then a custom reflection configuraion file or feature can be used to register the security services required by a specific application.Note that when automatic registration of security providers is disabled, all providers are, by default, filtered from special JDK caches that are necessary for security functionality.In this case, you must manually mark used providers with -H:AdditionalSecurityProviders.Security services automatic registrationThe mechanism, implemented in the com.oracle.svm.hosted.SecurityServicesFeature class, uses reachability of specific API methods in the JCA framework to determine which security services are used.Each JCA provider registers concrete implementation classes for the algorithms it supports.Each of the service classes (Signature, Cipher, Mac, KeyPair, KeyGenerator, KeyFactory, KeyStore, etc.,) declares a series of getInstance(&amp;lt;algorithm&amp;gt;, &amp;lt;provider&amp;gt;) factory methods which provide a concrete service implementation.When a specific algorithm is requested the framework searches the registered providers for the corresponding implementation classes and it dynamically allocates objects for concrete service implementations.The Native Image builder uses static analysis to discover which of these services are used.It does so by registering reachability handlers for each of the getInstance() factory methods.When it determines that a getInstance() method is reachable at run time it automatically performs the reflection registration for all the concrete implementations of the corresponding service type.Tracing of the security services automatic registation can be enabled with -H:+TraceSecurityServices.The report will detail all registered service classes, the API methods that triggered registration, and the parsing context for each reachable API method.Note: The --enable-all-security-services option is now deprecated and it will be removed in a future release.Provider RegistrationThe native image builder captures the list of providers and their preference order from the underlying JVM.The provider order is specified in the java.security file under &amp;lt;java-home&amp;gt;/lib/security/java.security.New security providers cannot be registered at run time; all providers must be statically configured during a native image building.Provider Reordering At RuntimeIt is possible to reorder security providers at runtime, however only existing provider instances can be used.For example, if the BouncyCastle provider was registered at build time and we wish to insert it at position 1 at runtime:Provider bcProvider = Security.getProvider(&quot;BC&quot;);Security.removeProvider(&quot;BC&quot;);Security.insertProviderAt(bcProvider, 1);SecureRandomThe SecureRandom implementations open the /dev/random and /dev/urandom files which are used as sources for entropy.These files are usually opened in class initializers.To avoid capturing state from the machine that runs the Native Image builder these classes need to be initialized at run time.Custom Service TypesBy default, only services specified in the JCA are automatically registered. To automatically register custom service types, you can use -H:AdditionalSecurityServiceTypes.Note that for automatic registration to work, the service interface must have a getInstance method and have the same simple name as the service type.If relying on third party code that doesn’t comply to the above requirements, manual configuration will be required. In that case, providers for such services must explicitly be registered using -H:AdditionalSecurityProviders.Note that these options are only required in very specific cases and should not normally be needed.",
                    "url": " /reference-manual/native-image/JCASecurityServices/"
                  },
                  
                  "reference-manual-native-image-jni":  {
                    "title": "",
                    "content": "Java Native Interface (JNI) in Native ImageJNI is a native API that enables Java code to interact with native code and vice versa.This page gives an overview of the JNI implementation in Native Image.See also the guide on assisted configuration of Java resources and other dynamic features.IntegrationJNI support is enabled by default and built into Native Image builds. Individual classes, methods, and fields that should be accessible via JNI must be specified during native image generation in a configuration file (read below).LinkingJava code can load native code from a shared object with System.loadLibrary().Alternatively, native code can load the JVM’s native library and attach to its Java environment using JNI’s Invocation API.The Native Image JNI implementation supports both approaches.ReflectionJNI supports looking up classes by their names, and looking up methods and fields by their names and signatures.This requires keeping the necessary metadata for these lookups around.The native image builder must know beforehand which items will be looked up in case they might not be reachable otherwise and therefore would not be included in the native image.Moreover, the native image builder must generate call wrapper code ahead-of-time for any method that can be called via JNI.Therefore, specifying a concise list of items that need to be accessible via JNI guarantees their availability and allows for a smaller footprint.Such a list can be specified with the following image build argument:-H:JNIConfigurationFiles=/path/to/jniconfigHere, jniconfig is a JSON configuration file.The syntax is the same as for reflection configuration files, which are described on the Reflection Use page.The native image builder generates JNI reflection metadata for all classes, methods, and fields referenced in the configuration file.More than one JNI configuration can be used by specifying multiple paths for JNIConfigurationFiles and separating them with ,.Also, -H:JNIConfigurationResources can be specified to load one or several configuration files from the image build’s class path, such as from a JAR file.Alternatively, a custom Feature implementation can register program elements before and during the analysis phase of the native image build using the JNIRuntimeAccess class. For example:class JNIRegistrationFeature implements Feature {  public void beforeAnalysis(BeforeAnalysisAccess access) {    try {      JNIRuntimeAccess.register(String.class);      JNIRuntimeAccess.register(String.class.getDeclaredField(&quot;value&quot;));      JNIRuntimeAccess.register(String.class.getDeclaredField(&quot;hash&quot;));      JNIRuntimeAccess.register(String.class.getDeclaredConstructor(char[].class));      JNIRuntimeAccess.register(String.class.getDeclaredMethod(&quot;charAt&quot;, int.class));      JNIRuntimeAccess.register(String.class.getDeclaredMethod(&quot;format&quot;, String.class, Object[].class));      JNIRuntimeAccess.register(String.CaseInsensitiveComparator.class);      JNIRuntimeAccess.register(String.CaseInsensitiveComparator.class.getDeclaredMethod(&quot;compare&quot;, String.class, String.class));    } catch (NoSuchMethodException | NoSuchFieldException e) { ... }  }}To activate the custom feature --features=&amp;lt;fully qualified name of JNIRegistrationFeature class&amp;gt; needs to be passed to native-image. Native Image Build Configuration explains how this can be automated with a native-image.properties file in META-INF/native-image.Object HandlesJNI does not permit direct access to Java objects.Instead, JNI provides word-sized object handles that can be passed to JNI functions to access objects indirectly.Local handles are only valid for the duration of a native call and only in the caller’s thread, while global handles are valid across threads and remain valid until they are destroyed explicitly.The handle 0 represents NULL.Native Image implements local handles with a thread-local, growing array of referenced objects, where the index in the array is the handle value.A “finger” points to where the next handle will be allocated.Native calls can be nested, so before a native method is invoked, the call stub pushes the current finger on a stack, and after it returns, it restores the old finger from the stack and nullifies all object references from the call in the array.Global handles are implemented using a variable number of object arrays in which referenced objects are inserted and nullified using atomic operations.A global handle’s value is a negative integer that is determined from the index of the containing array and the index within the array.Therefore, the JNI code can distinguish local and global handles by only looking at their sign.The analysis is not obstructed by object handles because it can observe the entire flow of object references and the handles that are passed to native code are only numeric values.Java-to-Native Method CallsMethods declared with the native keyword have a JNI-compliant implementation in native code, but can be called like any other Java method. For example:// Java declarationnative int[] sort0(int[] array);// native declaration with JNI name manglingjintArray JNICALL Java_org_example_sorter_IntSorter_sort0(JNIEnv *env, jobject this, jintArray array)When the image build encounters a method that is declared native, it generates a graph with a wrapper that performs the transition to native code and back, adds the JNIEnv* and this arguments, boxes any object arguments in handles, and in case of an object return type, unboxes the returned handle.The actual native call target address can only be determined at run time.Therefore, the native image builder also creates an extra linkage object in the reflection metadata of native-declared methods.When a native method is called, the call wrapper looks up the matching symbol in all loaded libraries and stores the resolved address in the linkage object for future calls.Alternatively, instead of requiring symbols that conform to JNI name mangling scheme, Native Image also supports the RegisterNatives JNI function to explicitly provide code addresses for native methods.JNI FunctionsJNI provides a set of functions that native code can use to interact with Java code.Substrate VM implements these functions using @CEntryPoint, for example:@CEntryPoint(...) private static void DeleteGlobalRef(JNIEnvironment env, JNIObjectHandle globalRef) { /* setup; */ JNIGlobalHandles.singleton().delete(globalRef); }JNI specifies that these functions are provided via function pointers in a C struct that is accessible via the JNIEnv* argument.The automatic initialization of this struct is prepared during the native image build.Native-to-Java Method CallsNative code can invoke Java methods by first obtaining a jmethodID for the target method, and then using one of the Call&amp;lt;Type&amp;gt;Method, CallStatic&amp;lt;Type&amp;gt;Method or CallNonvirtual&amp;lt;Type&amp;gt;Method functions for the invocation.Each of these Call... functions is also available in a Call...MethodA and a Call...MethodV variant, which take arguments as an array or as a va_list instead of variadic arguments. For example:jmethodID intcomparator_compare_method = (*env)-&amp;gt;GetMethodID(env, intcomparator_class, &quot;compare&quot;, &quot;(II)I&quot;);jint result = (*env)-&amp;gt;CallIntMethod(env, this, intcomparator_compare_method, a, b);The native image builder generates call wrappers for each method that can be called via JNI according to the provided JNI configuration.The call wrappers conform to the signature of the JNI Call... functions that are appropriate for the method.The wrappers perform the transition to Java code and back, adapt the argument list to the target Java method’s signature, unbox any passed object handles, and if necessary, box the return type in an object handle.Each method that can be called via JNI has a reflection metadata object.The address of this object is used as the method’s jmethodID.The metadata object contains the addresses of all of the method’s generated call wrappers.Because each call wrapper conforms precisely to the corresponding Call... function signature, the Call... functions themselves are nothing more than an unconditional jump to the appropriate call wrapper based on the passed jmethodID.As another optimization, the call wrappers are able to efficiently restore the current thread’s Java context from the JNIEnv* argument.Object CreationJNI provides two ways of creating Java objects, either by calling AllocObject to allocate memory and then using CallVoidMethod to invoke the constructor, or by using NewObject to create and initialize the object in a single step (or variants NewObjectA or NewObjectV). For example:jclass calendarClass = (*env)-&amp;gt;FindClass(env, &quot;java/util/GregorianCalendar&quot;);jmethodID ctor = (*env)-&amp;gt;GetMethodID(env, calendarClass, &quot;&amp;lt;init&amp;gt;&quot;, &quot;(IIIIII)V&quot;);jobject firstObject = (*env)-&amp;gt;AllocObject(env, calendarClass);(*env)-&amp;gt;CallVoidMethod(env, obj, ctor, year, month, dayOfMonth, hourOfDay, minute, second);jobject secondObject = (*env)-&amp;gt;NewObject(env, calendarClass, ctor, year, month, dayOfMonth, hourOfDay, minute, second);Native Image supports both approaches.The constructor must be included in the JNI configuration with a method name of &amp;lt;init&amp;gt;.Instead of generating additional call wrappers for NewObject, the regular CallVoidMethod wrapper is reused and detects when it is called via NewObject because it is passed the Class object of the target class.In that case, the call wrapper allocates a new instance before invoking the actual constructor.Field AccessesNative code can access a Java field by obtaining its jfieldID and then using one of the Get&amp;lt;Type&amp;gt;Field, Set&amp;lt;Type&amp;gt;Field, GetStatic&amp;lt;Type&amp;gt;Field or SetStatic&amp;lt;Type&amp;gt;Field functions. For example:jfieldID intsorter_comparator_field = (*env)-&amp;gt;GetFieldID(env, intsorter_class, &quot;comparator&quot;, &quot;Lorg/example/sorter/IntComparator;&quot;);jobject value = (*env)-&amp;gt;GetObjectField(env, self, intsorter_comparator_field);For a field that is accessible via JNI, its offset within an object (or within the static field area) is stored in the reflection metadata and is used as its jfieldID.The native image builder generates accessor methods for fields of all primitive types and for object fields.These accessor methods perform the transition to Java code and back, and use unsafe loads or stores to directly manipulate the field value.Because the analysis cannot observe assignments of object fields via JNI, it assumes that any subtype of the field’s declared type can occur in a field that is accessible via JNI.JNI also permits writing fields that are declared final, which must be enabled for individual fields with an allowWrite property in the configuration file.However, code accessing final fields might not observe changes of final field values in the same way as for non-final fields because of optimizations.ExceptionsJNI specifies that exceptions in Java code that are the result of a call from native code must be caught and retained.In Native Image, this is done in the native-to-Java call wrappers and in the implementation of JNI functions.Native code can then query and clear a pending exception with the ExceptionCheck, ExceptionOccurred, ExceptionDescribe, and ExceptionClear functions.Native code can also throw exceptions with Throw, ThrowNew, or FatalError.When an exception remains unhandled in native code or the native code itself throws an exception, the Java-to-native call wrapper rethrows that exception upon reentering Java code.MonitorsJNI declares the functions MonitorEnter and MonitorExit to acquire and release the intrinsic lock of an object.Native Image provides implementations of these functions.However, the native image build directly assigns intrinsic locks only to objects of classes which the analysis can observe as being used in Java synchronized statements and with wait(), notify() and notifyAll().For other objects, synchronization falls back on a slower mechanism which uses a map to store lock associations, which itself needs synchronization.For that reason, it can be beneficial to wrap synchronization in Java code.java.lang.reflect SupportThe JNI functions FromReflectedMethod and ToReflectedMethod can be used to obtain the corresponding jmethodID to a java.lang.reflect.Method, or to a java.lang.reflect.Constructor object, and vice versa.The functions FromReflectedField and ToReflectedField convert between jfieldID and java.lang.reflect.Field.In order to use these functions, reflection support must be enabled and the methods and fields in question must be included in the reflection configuration, which is specified with -H:ReflectionConfigurationFiles=.",
                    "url": " /reference-manual/native-image/JNI/"
                  },
                  
                  "reference-manual-js-javainteroperability":  {
                    "title": "",
                    "content": "Java InteroperabilityGraalVM includes a JavaScript language execution runtime and allows interoperability with Java code.This document describes the features and usage of this JavaScript-to-Java interoperability feature.For a reference of GraalVM public API, see JavaScript Compatibility.Migration guides for Rhino and Nashorn are also available.By default, GraalVM ships with js and node native launchers.Although other builds are possible, the following examples assume this setup is used.Enabling Java InteroperabilityIn GraalVM, the js and node launchers are started in an ahead-of-time compiled native mode by default. In that mode, Java interoperability is not available.To enable Java interoperability, the --jvm option has to be provided to the native launcher.This way, GraalVM JavaScript is executed on a traditional JVM and allows full Java interoperability.ClasspathIn order to load Java classes you need to have them on the Java classpath.You can specify the classpath with the --vm.classpath=&amp;lt;classpath&amp;gt; option (or short: --vm.cp=&amp;lt;classpath&amp;gt;):node --jvm --vm.cp=/my/class/pathjs --jvm --vm.cp=/my/class/pathThe method Java.addToClasspath() can be used to programmatically add to the classpath at runtime.Polyglot ContextThe preferred method of launching GraalVM JavaScript with Java interop support is via polyglot Context.For that, a new org.graalvm.polyglot.Context is built with the hostAccess option allowing access and a hostClassLookup predicate defining the Java classes you allow access to:Context context = Context.newBuilder(&quot;js&quot;)    .allowHostAccess(HostAccess.ALL)    //allows access to all Java classes    .allowHostClassLookup(className -&amp;gt; true)    .build();context.eval(&quot;js&quot;, jsSourceCode);See the Polyglot Programming reference for more details.ScriptEngine (JSR 223)The org.graalvm.polyglot.Context is the preferred execution method for interoperability with GraalVM’s languages and tools.In addition, JavaScript running on GraalVM is fully compatible with JSR 223 and supports the ScriptEngine API.Internally, the GraalVM’s JavaScript ScriptEngine wraps a polyglot context instance:ScriptEngine eng = new ScriptEngineManager()    .getEngineByName(&quot;graal.js&quot;);Object fn = eng.eval(&quot;(function() { return this; })&quot;);Invocable inv = (Invocable) eng;Object result = inv.invokeMethod(fn, &quot;call&quot;, fn);Access Java from JavaScriptGraalVM provides a set of features to allow interoperability from JavaScript to Java.While Rhino, Nashorn, and GraalVM JavaScript have a mostly comparable overall feature set, they differ in exact syntax, and, partly, semantics.Class AccessTo access a Java class, GraalVM JavaScript supports the Java.type(typeName) function:var FileClass = Java.type(&#39;java.io.File&#39;);By default, Java classes are not automatically mapped to global variables, e.g., there is no java global property in GraalVM JavaScript.Existing code accessing, e.g., java.io.File, should be rewritten to use the Java.type(name) function://GraalVM JavaScript compliant syntaxvar FileClass = Java.type(&quot;java.io.File&quot;);//backwards-compatible syntaxvar FileClass = java.io.File;GraalVM JavaScript provides Packages, java, and similar global properties for compatibility.However, explicitly accessing the required class with Java.type is preferred whenever possible for two reasons:  It allows resolving the class in one step rather than trying to resolve each property as a class.  Java.type immediately throws a TypeError if the class cannot be found or is not accessible, rather than silently treating an unresolved name as a package.The js.java-package-globals flag can be used to deactivate the global fields of Java packages (set false to avoid creation of the fields; default is true).Constructing Java ObjectsJava objects can be constructed with JavaScript’s new keyword:var FileClass = Java.type(&#39;java.io.File&#39;);var file = new FileClass(&quot;myFile.md&quot;);Field and Method AccessStatic fields of a Java class, or fields of a Java object, can be accessed like JavaScript properties:var JavaPI = Java.type(&#39;java.lang.Math&#39;).PI;Java methods can be called like JavaScript functions:var file = new (Java.type(&#39;java.io.File&#39;))(&quot;test.md&quot;);var fileName = file.getName();Conversion of Method ArgumentsJavaScript is defined to operate on the double number type.GraalVM JavaScript might internally use additional Java data types for performance reasons (e.g., the int type).When calling Java methods, a value conversion might be required.This happens when the Java method expects a long parameter, and an int is provided from GraalVM JavaScript (type widening).If this conversion causes a lossy conversion, a TypeError is thrown://Javavoid longArg   (long arg1);void doubleArg (double arg2);void intArg    (int arg3);//JavaScriptjavaObject.longArg(1);     //widening, OKjavaObject.doubleArg(1);   //widening, OKjavaObject.intArg(1);      //match, OKjavaObject.longArg(1.1);   //lossy conversion, TypeError!javaObject.doubleArg(1.1); //match, OKjavaObject.intArg(1.1);    //lossy conversion, TypeError!Selection of MethodJava allows overloading of methods by argument types.When calling from JavaScript to Java, the method with the narrowest available type that the actual argument can be converted to without loss is selected://Javavoid foo(int arg);void foo(short arg);void foo(double arg);void foo(long arg);//JavaScriptjavaObject.foo(1);              //will call foo(short arg);javaObject.foo(Math.pow(2,16)); //will call foo(int arg);javaObject.foo(1.1);            //will call foo(double arg);javaObject.foo(Math.pow(2,32)); //will call foo(long arg);Note that currently there is no way of overriding this behavior from GraalVM JavaScript.In the example above, one might want to always call foo(int arg), even when foo(short arg) can be reached with lossless conversion (foo(1)).Future versions of GraalVM JavaScript might lift that restriction by providing an explicit way to select the method to be called.Package AccessGraalVM JavaScript provides a Packages global property:&amp;gt; Packages.java.io.FileJavaClass[java.io.File]Array AccessGraalVM JavaScript supports the creation of Java arrays from JavaScript code.Both the patterns suggested by Rhino and Nashorn are supported://Rhino patternvar JArray = Java.type(&#39;java.lang.reflect.Array&#39;);var JString = Java.type(&#39;java.lang.String&#39;);var sarr = JArray.newInstance(JString, 5);//Nashorn patternvar IntArray = Java.type(&quot;int[]&quot;);var iarr = new IntArray(5);The arrays created are Java types, but can be used in JavaScript code:iarr[0] = iarr[iarr.length] * 2;Map AccessIn GraalVM JavaScript you can create and access Java Maps, e.g., java.util.HashMap:var HashMap = Java.type(&#39;java.util.HashMap&#39;);var map = new HashMap();map.put(1, &quot;a&quot;);map.get(1);GraalVM JavaScript supports iterating over such maps similar to Nashorn:for (var key in map) {    print(key);    print(map.get(key));}List AccessIn GraalVM JavaScript you can create and access Java Lists, e.g., java.util.ArrayList:var ArrayList = Java.type(&#39;java.util.ArrayList&#39;);var list = new ArrayList();list.add(42);list.add(&quot;23&quot;);list.add({});for (var idx in list) {    print(idx);    print(list.get(idx));}String AccessGraalVM JavaScript can create Java strings with Java interoperability.The length of the string can be queried with the length property (note that length is a value property and cannot be called as a function):var javaString = new (Java.type(&#39;java.lang.String&#39;))(&quot;Java&quot;);javaString.length === 4;Note that GraalVM JavaScript uses Java strings internally to represent JavaScript strings, so the above code and the JavaScript string literal &quot;Java&quot; are actually not distinguishable.Iterating PropertiesProperties (fields and methods) of Java classes and Java objects can be iterated with a JavaScript for..in loop:var m = Java.type(&#39;java.lang.Math&#39;)for (var i in m) { print(i); }&amp;gt; E&amp;gt; PI&amp;gt; abs&amp;gt; sin&amp;gt; ...Access to JavaScript Objects from JavaJavaScript objects are exposed to Java code as instances of com.oracle.truffle.api.interop.java.TruffleMap.This class implements Java’s Map interface.JavaImporterThe JavaImporter feature is available only in Nashorn compatibility mode (js.nashorn-compat option).Console Output of Java Classes and Java ObjectsGraalVM JavaScript provides both print and console.log.GraalVM JavaScript provides a print built-in function compatible with Nashorn.The console.log is provided by Node.js directly.It does not provide special treatment of interop objects.Note that the default implementation of console.log on GraalVM JavaScript is just an alias for print, and Node’s implementation is only available when running on Node.js.ExceptionsExceptions thrown in Java code can be caught in JavaScript code.They are represented as Java objects:try {    Java.type(&#39;java.lang.Class&#39;)    .forName(&quot;nonexistent&quot;);} catch (e) {    print(e.getMessage());}PromisesGraalVM JavaScript provides support for interoperability between JavaScript Promise objects and Java.Java objects can be exposed to JavaScript code as thenable objects, allowing JavaScript code to await Java objects.Moreover, JavaScript Promise objects are regular JavaScript objects, and can be accessed from Java using the mechanisms described in this document.This allows Java code to be called back from JavaScript when a JavaScript promise is resolved or rejected.Creating JavaScript Promise Objects That Can Be Resolved from JavaJavaScript applications can create Promise objects delegating to Java the resolution of the Promise instance.This can be achieved from JavaScript by using a Java object as the “executor” function of the JavaScript Promise.For example, Java objects implementing the following functional interface can be used to create new Promise objects:@FunctionalInterfacepublic interface PromiseExecutor {    void onPromiseCreation(Value onResolve, Value onReject);}Any Java object implementing PromiseExecutor can be used to create a JavaScript Promise:// `javaExecutable` is a Java object implementing the `PromiseExecutor` interfacevar myPromise = new Promise(javaExecutable).then(...);JavaScript Promise objects can be created not only using functional interfaces, but also using any other Java object that can be executed by the GraalVM JavaScript engine (for example, any Java object implementing the Polyglot ProxyExecutable interface).More detailed example usages are available in the GraalVM JavaScript unit tests.Using await with Java ObjectsJavaScript applications can use the await expression with Java objects.This can be useful when Java and JavaScript have to interact with asynchronous events.To expose a Java object to GraalVM JavaScript as a thenable object, the Java object should implement a method called then() having the following signature:void then(Value onResolve, Value onReject);When await is used with a Java object implementing then(), the GraalVM JavaScript runtime will treat the object as a JavaScript Promise.The onResolve and onReject arguments are executable Value objects that should be used by the Java code to resume or abort the JavaScript await expression associated with the corresponding Java object.More detailed example usages are available in the GraalVM JavaScript unit tests.Using JavaScript Promises from JavaPromise objects created in JavaScript can be exposed to Java code like any other JavaScript object.Java code can access such objects like normal Value objects, with the possibility to register new promise resolution functions using the Promise’s default then() and catch() functions.As an example, the following Java code registers a Java callback to be executed when a JavaScript promise resolves:Value jsPromise = context.eval(ID, &quot;Promise.resolve(42);&quot;);Consumer&amp;lt;Object&amp;gt; javaThen = (value)    -&amp;gt; System.out.println(&quot;Resolved from JavaScript: &quot; + value);jsPromise.invokeMember(&quot;then&quot;, javaThen);More detailed example usages are available in the GraalVM JavaScript unit tests.MultithreadingGraalVM JavaScript supports multithreading when used in combination with Java. More details about the GraalVM JavaScript multithreading model can be found in the Multithreading documentation.",
                    "url": " /reference-manual/js/JavaInteroperability/"
                  },
                  
                  "reference-manual-r-javainteroperability":  {
                    "title": "",
                    "content": "Interoperability with JavaThe GraalVM R runtime provides the built-in interoperability with Java.Java class objects can be obtained via java.type(...).In order to run R with the Java interoperability features, the R or Rscript commands have to be started with the --jvm option.R --jvmNote: All of the following examples are meant to be executed in the R REPL; no additional Java dependencies are necessary.  The standard new function interprets String arguments as a Java class if such class exists.  new also accepts Java types returned from java.type.  The fields and methods of Java objects can be accessed using the $ operator.  Additionally, you can use awt(...) to open an R drawing devicedirectly on a Java Graphics surface. For more details see Java Graphics Interoperability.The following example creates a new Java BufferedImage object, plots random data to it using R’s grid package,and shows an image in a window using Java’s AWT framework.Note that you must start the R script with --jvm to have access to Java interoperability.library(grid)openJavaWindow &amp;lt;- function () {   # create image and register graphics   imageClass &amp;lt;- java.type(&#39;java.awt.image.BufferedImage&#39;)   image &amp;lt;- new(imageClass, 450, 450, imageClass$TYPE_INT_RGB);   graphics &amp;lt;- image$getGraphics()   graphics$setBackground(java.type(&#39;java.awt.Color&#39;)$white);   grDevices:::awt(image$getWidth(), image$getHeight(), graphics)   # draw image   grid.newpage()   pushViewport(plotViewport(margins = c(5.1, 4.1, 4.1, 2.1)))   grid.xaxis(); grid.yaxis()   grid.points(x = runif(10, 0, 1), y = runif(10, 0, 1),        size = unit(0.01, &quot;npc&quot;))   # open frame with image   imageIcon &amp;lt;- new(&quot;javax.swing.ImageIcon&quot;, image)   label &amp;lt;- new(&quot;javax.swing.JLabel&quot;, imageIcon)   panel &amp;lt;- new(&quot;javax.swing.JPanel&quot;)   panel$add(label)   frame &amp;lt;- new(&quot;javax.swing.JFrame&quot;)   frame$setMinimumSize(new(&quot;java.awt.Dimension&quot;,                image$getWidth(), image$getHeight()))   frame$add(panel)   frame$setVisible(T)   while (frame$isVisible()) Sys.sleep(1)}openJavaWindow()GraalVM’s R runtime provides its own rJava-compatible replacement package available at GitHub, which can be installed using:R -e &quot;install.fastr.packages(&#39;rJava&#39;)&quot;In order for third party Java libraries to be accessed, they have to be placed on R’s class path:&amp;gt; java.addToClasspath(&quot;/foo/bar.jar&quot;)&amp;gt; java.addToClasspath(c(&quot;/foo/bar.jar&quot;, &quot;/foo/bar2.jar&quot;))Getting a Java ClassThe access to a Java type is achieved by providing a fully qualified class name to the java.type function:&amp;gt; calendarClass &amp;lt;- java.type(&#39;java.util.GregorianCalendar&#39;)The returned value is a polyglot object representing a Java type.The respective Java class is then available through the class property:&amp;gt; calendarClass$classThe same works also for static class members:&amp;gt; calendarClass$getInstance()Every requested class has to be on the R classpath.The JDK classes, like GregorianCalendar used above, work out of the box.Creating a New Java ObjectA new Java object can be created by providing a Java type to the new function:&amp;gt; calendar &amp;lt;- new(calendarClass)It is also possible to pass over additional constructor arguments:&amp;gt; calendar &amp;lt;- new(calendarClass, year=2042L, moth=3L, day=1L)Alternately, you can use just a class name:calendar &amp;lt;- new(&quot;java.util.GregorianCalendar&quot;)calendar &amp;lt;- new(&quot;java.util.GregorianCalendar&quot;, year=2042L, moth=3L, day=1L)Accessing Fields and MethodsThe access to static and instance fields and methods is provided by the $ and [ operators.To access Java fields:&amp;gt; calendarClass$SUNDAY&amp;gt; calendarClass[&quot;SUNDAY&quot;]To invoke Java methods:&amp;gt; currentTime &amp;lt;- calendar$getTime()&amp;gt; currentTime[&quot;toString&quot;]()&amp;gt; calendar$setTime(currentTime)Polyglot objects returned from a field or method, or created via new, are either automatically converted into corresponding R values or they live on as polyglot objects in the GraalVM R runtime.If necessary, they can be passed over to Java:&amp;gt; cet &amp;lt;- java.type(&quot;java.util.TimeZone&quot;)$getTimeZone(&quot;CET&quot;)&amp;gt; cetCalendar &amp;lt;- new(calendarClass, cet)Handling of Java PrimitivesThe returned Java primitives, primitive wrappers, and String instances are automatically converted into corresponding R values and map as follows:  R integer values map directly to Java int/Integer  R numeric to Java double/Double  R logical to Java boolean/Boolean  R character to Java String  If necessary R integer and double are converted to the expected Java typeInspecting Polyglot ObjectsThe names function can be used to obtain a list of instance and static members from a polyglot Java object or Java class:&amp;gt; names(calendar)&amp;gt; names(calendarClass)Code completion works as well:&amp;gt; calendar$a&amp;lt;TAB&amp;gt;Working with Java ArraysThe need for Java arrays appears when they have to be passed over to java as arguments.You can create an array by creating an array class and instantiating an array from it:&amp;gt; arrayClass &amp;lt;- java.type(&#39;int[]&#39;)&amp;gt; intArray &amp;lt;- new(arrayClass, 3)The component type names of primitive arrays are boolean, byte, char, double, float, int, long,and short – the same as in each particular primitive wrapper TYPE constant (see, e.g., Integer.TYPE.getName()).Note that it is possible to pass an R vector into a Java method in case the expected Java array is of a primitive component type or String.Then, the conversion happens automatically in the background.&amp;gt; integerArray &amp;lt;- new(java.type(&#39;java.lang.Integer[]&#39;), 3L)&amp;gt; integer2DimArray &amp;lt;- new(&#39;java.lang.Integer[][]&#39;, c(2L, 3L))&amp;gt; stringArray &amp;lt;- new(java.type(&#39;java.lang.String[]&#39;), 3L)The access to array elements is provided by the [ operator:&amp;gt; stringArray[1] &amp;lt;- &#39;a&#39;&amp;gt; string2DimArray[1,1] &amp;lt;- &#39;a&#39;&amp;gt; element &amp;lt;- stringArray[1]&amp;gt; element &amp;lt;- string2DimArray[1,1]Converting Java Arrays into R ObjectsUnlike Java primitives or their wrappers, Java arrays are not automatically converted into an R vector.Nevertheless, when appropriate, they can be handled by R builtin functions the same way as native R objects:&amp;gt; sapply(intArray, function(e) { e })&amp;gt; length(stringArray)&amp;gt; length(string2DimArray[1])Explicit Java Array ConversionA Java array conversion can be done explicitly by providing a Java array to the as.vector function:&amp;gt; intVec &amp;lt;- as.vector(intArray)Arrays having a Java primitive component type are converted into an R vector.Otherwise a list containing the array elements is created:&amp;gt; characterVector &amp;lt;- as.character(intArray)&amp;gt; logicalVector &amp;lt;- as.logical(intArray)&amp;gt; ...Java Iterable InterfaceWhen appropriate, Java objects implementing java.lang.Iterable are handled in the same way as Java arrays when passed as arguments to functions:&amp;gt; javaList &amp;lt;- new(java.type(&#39;java.util.ArrayList&#39;))&amp;gt; javaList$add(0);&amp;gt; javaList$add(1)&amp;gt; length(javaList)&amp;gt; as.integer(javaList)&amp;gt; as.logical(javaList)Compatibility with rJavaThe GraalVM R runtime comes with an rJava compatibility layer based on the Java interoperability features.Most of the officially documented rJava functions are supported.For more information, see the rJava CRAN documentation.  You can install the GraalVM R runtime’s rJava replacement using install.packages(&quot;rJava&quot;).The install.packages function in R has special handling for some packages, including rJava, and it downloads rJava from the source repository on GitHub instead of from MRAN.  As with any other R package, before executing any rJava functions, the package has to be loaded first:    &amp;gt; library(rJava)  Supported rJava features:  The $ and [ operators work the same as described above.Java Graphics InteroperabilityThe GraalVM R runtime includes its own Java-based implementation of the grid package and the following graphics devices: png, jpeg, bmp, svg, and awt (X11 is aliased to awt).The graphics package and most of its functions are not supported at the moment.The awt device is based on the Java Graphics2D object and users can pass it to their own Graphics2D object instance when opening the device using the awt function, as shown in the Java interop example.When the Graphics2D object is not provided to awt, it opens a new window similar to X11.The svg device in GraalVM R runtime generates more lightweight SVG code than the svg implementation in GNU R.Moreover, functions tailored to manipulate the SVG device are provided: svg.off and svg.string.The SVG device is demonstrated in the following code sample:library(lattice)svg()mtcars$cars &amp;lt;- rownames(mtcars)print(barchart(cars~mpg, data=mtcars))svgCode &amp;lt;- svg.off()cat(svgCode)To learn more, see the ?functionName syntax.",
                    "url": " /reference-manual/r/JavaInteroperability/"
                  },
                  
                  "reference-manual-js-javascriptcompatibility":  {
                    "title": "",
                    "content": "JavaScript CompatibilityGraalVM provides an ECMAScript-compliant JavaScript language runtime.This document explains the public API it presents for user applications written in JavaScript.  ECMAScript Language Compliance  Compatibility Extensions  GraalVM JavaScript ExtensionsECMAScript Language ComplianceGraalVM JavaScript implements JavaScript as prescribed in the ECMAScript (ECMA-262) specification.It is fully compatible with the ECMAScript 2020 specification (sometimes referred to as “version 11” or “ES11”).Starting with GraalVM 21.0.0, all available features of the ECMAScript 2021 draft specification are enabled by default.New features are frequently added to GraalVM when they are confirmed to be part of ECMAScript 2021, see the CHANGELOG.md for details.Older versions starting from ECMAScript 5 can be enabled with a config flag (by number: --js.ecmascript-version=5 or by year: --js.ecmascript-version=2019).In a production setup you might consider specifying a fixed ECMAScript version to be used, as future versions of GraalVM JavaScript will use newer versions of the specification once available.GraalVM JavaScript provides the following function objects in the global scope as specified by ECMAScript, representing the JavaScript core library:Array, ArrayBuffer, Boolean, DataView, Date, Error, Function, JSON, Map, Math, Number, Object, Promise, Proxy, Reflect, RegExp, Set, SharedArrayBuffer, String, Symbol, TypedArray, WeakMap, and WeakSet.Additional objects are available under flags, for instance Intl (flag: --js.intl-402).Run js --help or js --help:languages for the list of available flags.Several of these function objects and some of their members are only available when a certain version of the specification is selected for execution.For a list of methods provided, inspect the ECMAScript specification.Extensions to the specification are specified below.Internationalization API (ECMA-402)Internationalization API implementation (see https://tc39.github.io/ecma402) can be activated using the following flag: --js.intl-402=true.If you run in native mode (default option), you also need to specify the path to your ICU data directory using the following option: --vm.Dcom.ibm.icu.impl.ICUBinary.dataPath=$GRAAL_VM_DIR/jre/languages/js/icu4j/icudt,where $GRAAL_VM_DIR refers to your GraalVM installation directory.If you run in the JVM mode (the --jvm flag is used), you do not need to specify where your ICU data are located, although you can do it with the above option.Once you activate the Internationalization API, you can use the following built-ins:  Intl.NumberFormat  Intl.DateTimeFormat  Intl.Collator  Intl.PluralRulesThe functionality of a few other built-ins is then also updated according to the specification linked above.JavaScript ModulesGraalVM JavaScript supports modules as defined by ECMAScript 6 and later.Be aware that the support for this feature grew and still grows over time. Be sure to use the latest ECMAScript version for the all the latest features.When loading modules via a polyglot Source, you can use the inofficial application/javascript+module mime type to specify you are loading a module.When loading with JavaScript code from a file, make sure the module is loaded from a file with the .mjs extension.Loading with the import keyword is not limited by that, and can import from a file of any extension.Compatibility ExtensionsThe following objects and methods are available in GraalVM JavaScript for compatibility with other JavaScript execution engines.Note that the behavior of such methods might not strictly match the semantics of those methods in all existing engines.Language FeaturesConditional Catch ClausesGraalVM JavaScript supports conditional catch clauses if the js.syntax-extensions option is enabled:try {    myMethod(); // can throw} catch (e if e instanceof TypeError) {    print(&quot;TypeError caught&quot;);} catch (e) {    print(&quot;another Error caught&quot;);}Global Propertiesload(source)  loads (parses and executes) the specified JavaScript source codeSource can be of type:  a String: the path of the source file or a URL to execute.  java.lang.URL: the URL is queried for the source code to execute if the js.load-from-url option is set to true.  java.io.File: the file is read for the source code to execute.  a JavaScript object: the object is queried for a name and a script property, which represent the source name and code, respectively.  all other types: the source is converted to a String.load is available by default and can be deactivated by setting the js.load option to false.print(...arg) and printErr(...arg)  prints the arguments on the console (stdout and stderr, respectively)  provides a best-effort human readable outputprint and printErr are available by default and can be deactivated by setting the js.print option to false.Methods of the console Global ObjectA global console object is provided that offers several methods for debugging purposes.These methods strive to provide similar functionality as provided in other engines, but do not guarantee identical results.Note that those methods behave differently when GraalVM JavaScript is executed in Node.js mode (i.e., the node executable is started instead of js).Node.js provides its own implementation that is used instead.  console.log, console.info, and console.debug: an alias for print(...arg)  console.error, and console.warn: similar to print, but using the error IO stream  console.assert(check, message): prints message when check is falsy  console.clear: clears the console window if possible  console.count(), and console.countReset(): counts and print how many times it has been called, or resets this counter  console.group, and console.groupEnd: increases or decreases the indentation for succeeding outputs to the console  console.time(), console.timeLog(), and console.timeEnd(): starts a timer, prints the duration the timer has been active, or prints the duration and stops the timer, respectivelyThe console object is available by default and can be deactivated by setting the option js.console to false.Additional Global Functions in the js Shellquit(status)  exits the engine and returns the specified status coderead(file)  reads the content of fileThe result is returned as a String.The argument file can be of type:  java.io.File: the file is used directly.  all other types: file is converted to a String and interpreted as a file name.readbuffer(file)  reads the content of file similar to the read functionThe result is returned as a JavaScript ArrayBuffer object.readline()  reads one line of input from the input streamThe result is returned as a String.ObjectObject.prototype.__defineGetter__(prop, func)  defines the prop property of this to be the getter function funcThis functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Object.prototype.__defineSetter__(prop, func)  defines the prop property of this to be the setter function funcThis functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Object.prototype.__lookupGetter__(prop)  returns the getter function for property prop of the object as set by __defineGetter__This functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Object.prototype.__lookupSetter__(prop)  returns the setter function for property prop of the object as set by __defineSetter__This functionality is deprecated in most JavaScript engines.In recent ECMAScript versions, getters and setters are natively supported by the language.Nashorn Scripting ModeGraalVM JavaScript provides a scripting mode compatible with the one provided by the Nashorn engine.It is enabled with the js.scripting option. Make sure to have --experimental-options set:js --experimental-options --js.scripting=trueIn scripting mode, several properties and functions are added to the global object, including readFully, readLine, $ARG, $ENV, and $EXEC.There are migration guides available for code previously targeted to the Nashorn or Rhino engines.GraalVM JavaScript ExtensionsGraal ObjectThe Graal object is provided as a property of the global object.It provides Graal-specific information.The existence of the property can be used to identify whether the GraalVM JavaScript engine is the current language engine:if (typeof Graal != &#39;undefined&#39;) {    print(Graal.versionJS);    print(Graal.versionGraalVM);    print(Graal.isGraalRuntime);}The Graal object is available in GraalVM JavaScript by default, unless deactivated by an option (js.graal-builtin=false).Graal.versionJS  provides the version number of GraalVM JavaScriptGraal.versionGraalVM  provides the version of GraalVM, if the current engine is executed on GraalVMGraal.isGraalRuntime  provides whether GraalVM JavaScript is executed on a GraalVM-enabled runtimeIf true, hot code is compiled by the GraalVM compiler, resulting in high peak performance.If false, GraalVM JavaScript will not be optimized by the GraalVM Compiler, typically resulting in lower performance.JavaThe Java object is only available when the engine is started in JVM mode (--jvm flag).Note that some functions require a Nashorn compatibility mode flag to be set.On GraalVM, this flag can be set with:js --jvm --experimental-options --js.nashorn-compat=trueJava.type(className)  loads the specified Java class and provides it as an object  fields of this object can be read directly from it, and new instances can be created with the JavaScript new keyword:    var BigDec = Java.type(&#39;java.math.BigDecimal&#39;);var bd = new BigDec(&quot;0.1&quot;);console.log(bd.add(bd).toString());  Java.from(javaData)  creates a shallow copy of the Java datastructure (Array, List) as a JavaScript arrayIn many cases, this is not necessary; you can typically use the Java datastructure directly from JavaScript.Java.to(jsData, toType)  converts the argument to a Java dataypeThe source object jsData is expected to be a JavaScript array, or an object with a length property.The target toType can either be a String (e.g. &quot;int[]&quot;) or a type object (e.g., Java.type(&quot;int[]&quot;)).Valid target types are Java arrays.When no target type is provided, Object[] is assumed:var jsArr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var strArrType = Java.type(&quot;java.lang.String[]&quot;);var javaArr = Java.to(jsArr, strArrType);assertEquals(&#39;class [Ljava.lang.String;&#39;, String(javaArr.getClass()));The conversion methods as defined by ECMAScript (e.g., ToString and ToDouble) are executed when a JavaScript value has to be converted to a Java type.Lossy conversion is disallowed and results in a TypeError.Java.isJavaObject(obj)  returns whether obj is an object of the Java language  returns false for native JavaScript objects, as well as for objects of other polyglot languagesJava.isType(obj)  returns whether obj is an object of the Java language, representing a Java Class instance  returns false for all other argumentsJava.typeName(obj)  returns the Java Class name of objobj is expected to represent a Java Class instance, i.e., isType(obj) should return true; otherwise, undefined is returned.Java.isJavaFunction(fn)  returns whether fn is an object of the Java language that represents a Java function  returns false for all other types, including native JavaScript function, and functions of other polyglot languagesThis function requires the Nashorn compatibility mode flag.Java.isScriptObject(obj)  returns whether obj is an object of the JavaScript language  returns false for all other types, including objects of Java and other polyglot languagesThis function requires the Nashorn compatibility mode flag.Java.isScriptFunction(fn)  returns whether fn is a JavaScript function  returns false for all other types, including Java function, and functions of other polyglot languagesThis function requires the Nashorn compatibility mode flag.Java.addToClasspath(location)  adds the specified location (file name or path name, as String) to Java’s classpathPolyglotThe functions of the Polyglot object allow to interact with values from other polyglot languages.The Polyglot object is available by default, unless deactivated by setting the js.polyglot-builtin option to false.Polyglot.export(key, value)  exports the JavaScript value under the name key (a string) to the polyglot bindings:    function helloWorld() { print(&quot;Hello, JavaScript world&quot;); }Polyglot.export(&quot;helloJSWorld&quot;, helloWorld);  If the polyglot bindings already had a value identified by key, it is overwritten with the new value. The value may be any valid Polyglot value.  throws a TypeError if key is not a String or is missingPolyglot.import(key)  imports the value identified by key (a string) from the polyglot bindings and returns it:    var rubyHelloWorld = Polyglot.import(&quot;helloRubyWorld&quot;);rubyHelloWorld();  If no language has exported a value identified by key, undefined is returned.  throws a TypeError if key is not a string or missingPolyglot.eval(languageId, sourceCode)  parses and evaluates the sourceCode with the interpreter identified by languageIdThe value of sourceCode is expected to be a String (or convertable to one).  returns the evaluation result, depending on the sourceCode and/or the semantics of the language evaluated:    var rArray = Polyglot.eval(&#39;R&#39;, &#39;runif(1000)&#39;);  Exceptions can occur when an invalid languageId is passed, when the sourceCode cannot be evaluated by the language, or when the executed program throws one.Polyglot.evalFile(languageId, sourceFileName)  parses the file sourceFileName with the interpreter identified by languageIdThe value of sourceFileName is expected to be a String (or convertable to one), representing a file reachable by the current path.  returns an executable object, typically a function:    var rFunc = Polyglot.evalFile(&#39;R&#39;, &#39;myExample.r&#39;);var result = rFunc();  Exceptions can occur when an invalid languageId is passed, when the file identified by sourceFileName cannot be found, or when the language throws an exception during parsing (parse time errors, e.g. syntax errors).Exceptions thrown by the evaluated program are only thrown once the resulting function is evaluated.The Polyglot.evalFile function is available by default when the Polyglot builtin is available, unless deactivated by setting the js.polyglot-evalfile option to false.It is also available when js.debug-builtin is activated.Debug  requires starting the engine with the js.debug-builtin flagDebug is a GraalVM JavaScript specific function object that provides functionality for debugging JavaScript code and the GraalVM JavaScript compiler.This API might change without notice. Do not use for production purposes.Global FunctionsprintErr(...arg)  behaves identical to printThe only difference is that the error stream is used to print to, instead of the default output stream.loadWithNewGlobal(source, arguments)  behaves similarly to load functionThe relevant difference is that the code is evaluated in a new global scope (Realm, as defined by ECMAScript).Source can be of type:  java.lang.URL: the URL is queried for the source code to execute.  a JavaScript object: the object is queried for a name and a script property.  all other types: the source is converted to a String.The value of arguments is provided to the loaded code upon execution.",
                    "url": " /reference-manual/js/JavaScriptCompatibility/"
                  },
                  
                  "reference-manual-python-jython":  {
                    "title": "",
                    "content": "Jython Migration GuideMost Jython code that uses Java integration will be based on astable Jython release, and these only come in Python 2.x versions.GraalVM’s Python runtime, in contrast, is only targeting Python 3.x.GraalVM does not provide a full compatibility with these earlier 2.x versions of Jython.Thus, a significant migration step will have to be taken to migrate all your code to Python 3.For Jython specific features, follow this document to learn about migration to GraalVM’s Python runtime.Note that some features of Jython have a negative impact on runtime performance, and are disabled by default.To make migration easier, you can enable some features with a command line flag on GraalVM: --python.EmulateJython.Importing Java PackagesThere are certain features of Jython’s Java integration that are enabled by default on GraalVM’s Python runtime.Here is an example:&amp;gt;&amp;gt;&amp;gt; import java.awt as awt&amp;gt;&amp;gt;&amp;gt; win = awt.Frame()&amp;gt;&amp;gt;&amp;gt; win.setSize(200, 200)&amp;gt;&amp;gt;&amp;gt; win.setTitle(&quot;Hello from Python!&quot;)&amp;gt;&amp;gt;&amp;gt; win.getSize().toString()&#39;java.awt.Dimension[width=200,height=200]&#39;&amp;gt;&amp;gt;&amp;gt; win.show()This example works exactly the same on both Jython and Python on GraalVM.However, on GraalVM only packages in the java namespace can be directly imported.Importing classes from packages outside the java namespace also requires the --python.EmulateJython option to be active.Additionally, importing Java packages as Python modules is only supported under very specific circumstances.For example, this will work:import java.lang as langThis will not work:import javax.swing as swingfrom javax.swing import *Instead, you will have to import one of the classes you are interested in directly:import javax.swing.Window as WindowBasic Object UsageConstructing and working with Java objects and classes is done with naturalPython syntax. The methods of Java objects can also be retrieved and passedaround as first class objects (bound to their instance), the same as Pythonmethods:&amp;gt;&amp;gt;&amp;gt; from java.util import Random&amp;gt;&amp;gt;&amp;gt; rg = Random(99)&amp;gt;&amp;gt;&amp;gt; boundNextInt = rg.nextInt&amp;gt;&amp;gt;&amp;gt; rg.nextInt()1491444859&amp;gt;&amp;gt;&amp;gt; boundNextInt = rg.nextInt1672896916Java-to-Python Types: Automatic ConversionMethod overloads are resolved by matching the Python arguments in a best-effort manner to the available parameter types.This also happens during when data conversion.The goal here is to make using Java from Python as smooth as possible.The matching allowed here is similar to Jython, but GraalVM’s Python runtime uses a more dynamic approach to matching — Python types emulating int or float are also converted to the appropriate Java types.This allows, for example, to use Pandas frames as double[][] or NumPy array elements as int[] when the elements fit into those Java primitive types.            Java type      Python type                  null      None              boolean      bool              byte, short, int, long      int, any object that has an __int__ method              float      float, any object that has a __float__ method              char      str of length 1              java.lang.String      str              byte[]      bytes, bytearray, wrapped Java array, Python list with only the appropriate types              Java arrays      Wrapped Java array or Python list with only the appropriate types              Java objects      Wrapped Java object of the appropriate type              java.lang.Object      Any object      Special Jython ModulesNone of the special Jython modules are available, but many of those modules functions can still be achieved.For example, the jarray module on Jython allows construction of primitive Java arrays.This can beachieved as follows on GraalVM’s Python runtime:&amp;gt;&amp;gt;&amp;gt; import java&amp;gt;&amp;gt;&amp;gt; java.type(&quot;int[]&quot;)(10)The code that only needs to pass a Java array can also use Python types.However, implicitly, this may entail a copy of the array data, which can be deceiving when using Java arrays as output parameters:&amp;gt;&amp;gt;&amp;gt; i = java.io.ByteArrayInputStream(b&quot;foobar&quot;)&amp;gt;&amp;gt;&amp;gt; buf = [0, 0, 0]&amp;gt;&amp;gt;&amp;gt; i.read(buf) # buf is automatically converted to a byte[] array3&amp;gt;&amp;gt;&amp;gt; buf[0, 0, 0] # the converted byte[] array got lost&amp;gt;&amp;gt;&amp;gt; jbuf = java.type(&quot;byte[]&quot;)(3)&amp;gt;&amp;gt;&amp;gt; i.read(jbuf)3&amp;gt;&amp;gt;&amp;gt; jbuf[98, 97, 122]Exceptions from JavaCatching all kinds of Java exceptions comes with a performance penalty and is only enabled with the --python.EmulateJython option.&amp;gt;&amp;gt;&amp;gt; import java&amp;gt;&amp;gt;&amp;gt; v = java.util.Vector()&amp;gt;&amp;gt;&amp;gt; try:...    x = v.elementAt(7)... except java.lang.ArrayIndexOutOfBoundsException as e:...    print(e.getMessage())...7 &amp;gt;= 0Java CollectionsThere is no automatic mapping of the Python syntax for accessing dictionaryelements to the java.util mapping and list classes’ ` get, set, or put`methods. To use these mapping and list clases, you must call the Java methods:&amp;gt;&amp;gt;&amp;gt; ht = java.util.Hashtable()&amp;gt;&amp;gt;&amp;gt; ht.put(&quot;foo&quot;, &quot;bar&quot;)&amp;gt;&amp;gt;&amp;gt; ht.get(&quot;foo&quot;)&#39;bar&#39;The Python-style iteration of Java java.util.Enumerable,java.util.Iterator, or java.lang.Iterable  is not supported. For these, you will have to use awhile loop and use the hasNext() and next() (or equivalent) methods. Inheritance from JavaPython classes cannot inherit from Java classes.A workaround can be to create a flexible subclass in Java, compile it, and use delegation instead.Take this example:import java.util.logging.Handler;public class PythonHandler extends Handler {    private final Value pythonDelegate;    public PythonHandler(Value pythonDelegate) {        this.pythonDelegate = pythonDelegate;    }    public void publish(LogRecord record) {        pythonDelegate.invokeMember(&quot;publish&quot;, record);    }    public void flush() {        pythonDelegate.invokeMember(&quot;flush&quot;);    }    public void close() {        pythonDelegate.invokeMember(&quot;close&quot;);    }}Then you can use it like this in Python:from java.util.logging import LogManager, Loggerclass MyHandler():    def publish(self, logRecord): print(&quot;[python]&quot;, logRecord.toString())​    def flush(): pass​    def close(): pass​LogManager.getLogManager().addLogger(Logger(&#39;my.python.logger&#39;, None, MyHandler()))Embedding Python into JavaThe other way to use Jython is to embed it into Java applications.Where above GraalVM’s Python runtime offered some measure of compatibility with existing Jython code, nothing is offered in this case.Existing code using Jython depends directly on the Jython package (for example, in the Maven configuration), because the Java code has references to Jython internal classes such as PythonInterpreter.For GraalVM’s Python runtime, no dependency other than on the GraalVM SDK is required.There are no APIs particular to Python that are exposed, and everything is done through the GraalVM API.It is important to note that as long as your application is executed on GraalVM with the Python language installed,you can embed Python in your programs.For more details, refer to the Embed Languages guide.",
                    "url": " /reference-manual/python/Jython/"
                  },
                  
                  "reference-manual-native-image-llvmbackend":  {
                    "title": "",
                    "content": "LLVM Backend for Native ImageNative Image includes an alternative backend which uses the LLVM intermediate representation and the LLVM compiler to produce native executables. To use it, add the -H:CompilerBackend=llvm option to the Native Image invocation.The LLVM backend requires GraalVM’s LLVM toolchain to be installed (with gu install llvm-toolchain).Code Generation Options  -H:+SpawnIsolates: enables isolates, which are disabled by default when using the LLVM backend as they incur a performance penalty.  -H:+BitcodeOptimizations: enables aggressive optimizations at the LLVM bitcode level. This is experimental and may cause bugs.Debugging Options  -H:TempDirectory=: specifies where the files generated by Native Image will be saved. The LLVM files are saved under SVM-&amp;lt;timestamp&amp;gt;/llvm in this folder.  -H:LLVMMaxFunctionsPerBatch=: specifies the maximum size of a compilation batch*. Setting it to 1 compiles every function separately, 0 compiles everything as a single batch.  -H:DumpLLVMStackMap=: specifies a file in which to dump debugging information, including a mapping between compiled functions and the name of the corresponding bitcode file.About batches: LLVM compilation happens in four phases:  LLVM bitcode files (named f0.bc, f1.bc, etc.,) are created for each function.  The bitcode files are linked into batches (named b0.bc, b1.bc, etc.). This phase is skipped when -H:LLVMMaxFunctionsPerBatch=1 is specified.  The batches are optimized (into b0o.bc, b1o.bc, etc.,) and then compiled (into b0.o, b1.o, etc.).  The compiled batches are linked into a single object file (llvm.o), which is then linked into the final executable.How to Add a Target Architecture to GraalVM Using LLVM BackendAn interesting use case for the LLVM backend is to target a new architecture without having to implement a complete new backend for Native Image. The following are the necessary steps to achieve this at the moment.Target-Specific LLVM SettingsThere are a few instances where the GraalVM code has to go deeper than the target-independent nature of LLVM.These are most notably inline assembly snippets to implement direct register accesses and direct register jumps (for trampolines), as well as precisions about the structure of the stack frames of the code emitted by LLVM.All in all, this represents less than a dozen simple values to be set for each new target. It is our goal that in the future this will be the only addition needed to support a new target.(Complete set of values for AArch64)LLVM Statepoint SupportWhile the LLVM backend uses mostly common, well-supported features of LLVM, garbage collection support implies the use of statepoint intrinsics, an experimental feature of LLVM.Currently this feature is only supported for x86_64, and we are currently pushing for the inclusion GraalVM implementation for AArch64 in the code base.This means that, unless a significant effort is put together by the LLVM community, supporting a new architecture will require the implementation of statepoints in LLVM for the requested target.As most of the statepoint logic is handled at the bitcode level, i.e., at a target-independent stage, this is mostly a matter of emitting the right type of calls to lower the statepoint intrinsics.Our AArch64 implementation of statepoints consists of less than 100 lines of code.(Implementation of statepoints for AArch64)Object File SupportThe data section for programs created with the LLVM backend of the GraalVM compiler is currently emitted independently from the code, which is handled by LLVM.This means that the GraalVM compiler needs an understanding of object file relocations for the target architecture to be able to link the LLVM-compiled code with the GraalVM-generated data section.Emitting the data section with the code as LLVM bitcode is our next priority for the LLVM backend, so this should not be an issue for future targets.(see ELFMachine$ELFAArch64Relocations for an example)",
                    "url": " /reference-manual/native-image/LLVMBackend/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-languagetutorial":  {
                    "title": "",
                    "content": "Implementing a New Language with TruffleFor an in-depth presentation on how to implement your language with Truffle,watch this three-hour walkthrough presented at theConference on Programming Language Design and Implementation PLDI 2016.Download SlidesNext Steps:  Start to subclass TruffleLanguage for your own language implementation.  Fork SimpleLanguage, a toy language that demonstrates how to use many Truffle features.  Embed Truffle languages in Java host applications using the Polyglot API.  Read GraalVM/Truffle publications.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/LanguageTutorial/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-languages":  {
                    "title": "",
                    "content": "Language ImplementationsThis page is intended to keep track of the growing number of language implementations and experiments on top of Truffle.The following language implementations exist already:  FastR, an implementation of GNU R. *  Graal.js, an ECMAScript 2020 compliant JavaScript implementation. *  Graal.Python, an early-stage implementation of Python. *  grCUDA, a polyglot CUDA integration.  SimpleLanguage, a toy language implementation to demonstrate Truffle features.  SOMns, a Newspeak implementation for Concurrency Research.  Sulong, an LLVM bitcode interpreter. *  TRegex, a generic regular expression engine (internal, for use by other languages only). *  TruffleRuby, an implementation of Ruby. *  TruffleSOM, a SOM Smalltalk implementation.  TruffleSqueak, a Squeak/Smalltalk VM implementation and polyglot programming environment.  Yona, the reference implementation of a minimalistic, strongly and dynamically-typed, parallel and non-blocking, polyglot, strict, functional programming language.  Enso, an open source, visual language for data science that lets you design, prototype and develop any application by connecting visual elements together.* Shipped as part of GraalVM.Experiments  bf, an experimental Brainfuck programming language implementation.  brainfuck-jvm, another Brainfuck language implementation.  Cover, a Safe Subset of C++.  DynSem, a DSL for declarative specification of dynamic semantics of languages.  Heap Language, a tutorial showing the embedding of Truffle languages via interoperability.  hextruffe, an implementation of Hex.  LuaTruffle, an implementation of the Lua language.  Mozart-Graal, an implementation of the Oz programming language.  Mumbler, an experimental Lisp programming language.  PorcE, an Orc language implementation.  ProloGraal a Prolog language implementation supporting interoperability.  PureScript, a small, strongly-typed programming language.  Reactive Ruby, TruffleRuby meets Reactive Programming.  shen-truffle, a port of the Shen programming language.  TruffleMATE, a Smalltalk with a completely reified runtime system.  TrufflePascal, a Pascal interpreter.  ZipPy, a Python implementation.Submit a pull request to add/remove from this list.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/Languages/"
                  },
                  
                  "reference-manual-native-image-limitations":  {
                    "title": "",
                    "content": "Native Image Compatibility and Optimization GuideNative Image uses a different way of executing Java programs than users of the Java HotSpot VM are used to.It distinguishes between image build time and image run time.At image build time, a static analysis finds all methods that are reachable from the entry point of the application.These (and only these) methods are then ahead-of-time compiled into a native image.Because of the different optimization model, Java programs can behave somewhat differently when compiled into a native image.Native Image is an optimization that reduces the memory footprint and startup time of an application.This requires a closed-world assumption, where all code is known at image build time, i.e., no new code is loaded at run time.As with most optimizations, not all applications are amenable for that optimization.If an application is not optimizable, then a so-called fallback image is generated that launches the Java HotSpot VM, i.e., requires a JDK for execution.Class Metadata Features (Require Configuration)The following features generally require the configuration at image build time in order to use the closed-world optimization. This configuration ensures that the minimum amount of space necessary is used in the native image binary.If one of the following features is used without providing a configuration at image build time, a fallback image is generated.Dynamic Class LoadingAny class to be accessed by name at image run time must be enumerated at image build time.For example, a call to Class.forName(&quot;myClass”) must have myClass in a configuration file.If the configuration file is used, but does not include a class that is requested for dynamic class loading, a ClassNotFoundException will be thrown, as if the class was not found on the class path or was inaccessible.ReflectionThis category includes listing methods and fields of a class; invoking methods and accessing fields reflectively; and using other classes in the package java.lang.reflect.Individual classes, methods, and fields that should be accessible via reflection need to be known ahead-of-time.Native Image tries to resolve these elements through a static analysis that detects calls to the Reflection API.Where the analysis fails the program elements reflectively accessed at run time must be specified during native image generation in a configuration file or by using RuntimeReflection from a Feature.For more details, read the Reflection support guide.Reflection can be used without restrictions during a native image generation, for example, in class initializers.Dynamic ProxyThis category includes generating dynamic proxy classes and allocating instances of dynamic proxy classes using the java.lang.reflect.Proxy API.Dynamic class proxies are supported with the closed-world optimization as long as the bytecode is generated ahead-of-time.This means that the list of interfaces that define dynamic proxies needs to be known at image build time.Native Image employs a simple static analysis that intercepts calls to java.lang.reflect.Proxy.newProxyInstance(ClassLoader, Class&amp;lt;?&amp;gt;[], InvocationHandler) and java.lang.reflect.Proxy.getProxyClass(ClassLoader, Class&amp;lt;?&amp;gt;[]) and tries to determine the list of interfaces automatically.Where the analysis fails the lists of interfaces can be specified in a configuration file.For more details, read the Dynamic Proxies support guide.JNI (Java Native Interface)Native code may access Java objects, classes, methods and fields by name, in a similar way to using the reflection API in Java code.For the same reasons, any Java artifacts accessed by name via JNI must be specified during a native image generation in a configuration file. For more details, read the JNI Implementation guide.As an alternative, and in addition to JNI, Native Image provides its own native interface that is much simpler than JNI and with lower overhead.It allows calls between Java and C, and access of C data structures from Java code.However, it does not allow access of Java data structures from C code.For more details, read the JavaDoc of the package org.graalvm.nativeimage.c and its subpackages.SerializationJava serialization requires class metadata information in order to function and must be specified during a native image generation in a configuration file.However, Java serialization has been a persistent source of security vulnerabilities. The Java architects have announced that the existing serialization mechanism will be replacedwith a new mechanism avoiding these problems in the near future.Features Incompatible with Closed-World OptimizationSome Java features are not yet supported with the closed-world optimization, and if used, lead to a fallback image.invokedynamic Bytecode and Method HandlesUnder the closed-world assumption, all methods that are called and their call sites must be known.invokedynamic and method handles can introduce calls at run time or change the method that is invoked.Note that invokedynamic use cases generated by javac for, e.g., Java lambda expressions and string concatenation are supported because they do not change called methods at image run time.Security ManagerThe Java security manager is no longer recommended as a way to isolate less trusted code from more trusted code in the same process.This is because almost all typical hardware architectures are susceptible to side-channel attacks to access data that is restricted via the security manager.Using separate processes is now recommended for these cases.Features That May Operate Differently in Native ImageNative Image implements some Java features in a different way than the Java HotSpot VM.Signal HandlersRegistering a signal handler requires to start a new thread that handles thesignal and invokes the shutdown hooks. By default, no signal handlers areregistered when building a native image, unless they are registered explicitly by the user.For example, it is not recommended to register the default signalhandlers when building a shared library, but it is desirable to includesignal handlers when building native images for containerized environments, likeDocker containers.To register the default signal handlers, pass the --install-exit-handlers option to thenative-image builder. This option gives you the same signal handlers as a JVM does.Class InitializersBy default, classes are initialized at image run time.This ensures compatibility, but limits some optimizations.For faster startup and better peak performance, it is desirable to initialize classes at image build time.Class initialization behaviour can be adjusted using the options --initialize-at-build-time or --initialize-at-run-time for specific classes and packages or for all classes.See native-image --help for details.Classes of the JDK class libraries are handled for you and do not need special consideration from the user.Native Image users should be aware that class initialization at image build timemay break specific assumptions in existing code.For example, files loaded in a class initializer may not be in the same place at image build time as at image run time.Also, certain objects such as a file descriptors or running threads must not be stored into a native image binary.If such objects are reachable at image build time, image generation fails with an error.FinalizersThe Java base class java.lang.Object defines the method finalize().It is called by the garbage collector on an object when garbage collection determines that there are no more references to the object.A subclass overrides the finalize() method to dispose of system resources or to perform other cleanup.Finalizers are deprecated since Java 9.They are complicated to implement, and have badly designed semantics.For example, the finalizer can make the object reachable again by storing it in a static field.Therefore, finalizers are not invoked.It is recommended to replace finalizers with weak references and reference queues for use in any Java VM.ThreadsNative Image does not implement long-deprecated methods in java.lang.Thread such as Thread.stop().Unsafe Memory AccessFields that are accessed using sun.misc.Unsafe need to be marked as such for the static analysis if classes are initialized at image build time.In most cases, that happens automatically: field offsets stored in static final fields are automatically rewritten from the hosted value (the field offset for the VM that the image generator is running on) to the native image value, and as part of that rewrite the field is marked as Unsafe-accessed.For non-standard patterns, field offsets can be recomputed manually using the annotation RecomputeFieldValue.Debugging and MonitoringJava has some optional specifications that a Java implementation can use for debugging and monitoring Java programs, including JVMTI.They help you monitor the VM at run time for events like compilation, for example, which do not occur in most native images.These interfaces are built on the assumption that Java bytecode is available at run time, which is not the case for native images built with the closed-world optimization.Because the native image builder generates a native binary, users must use native debuggers and monitoring tools (like GDB or VTune) rather than tools targeted for Java.JVMTI and other bytecode-based tools are not supported with Native Image.",
                    "url": " /reference-manual/native-image/Limitations/"
                  },
                  
                  "reference-manual-native-image-logging":  {
                    "title": "",
                    "content": "Logging in Native ImageOut of the box, Native Image supports logging using the java.util.logging.* API.Default Logging ConfigurationThe logging configuration built in a native image by default is based on the logging.properties file found in the JDK.This configures a java.util.logging.ConsoleHandler which will only show messages at the INFO and above levels.Custom logging configuration can be loaded either at image build time or at run time as described below.Note that if additional logging handlers are used, the corresponding classes need to be registered for reflection.For example, if java.util.logging.FileHandler is used then the following reflection configuration is necessary:{    &quot;name&quot; : &quot;java.util.logging.FileHandler&quot;,    &quot;methods&quot; : [      { &quot;name&quot; : &quot;&amp;lt;init&amp;gt;&quot;, &quot;parameterTypes&quot; : [] },    ]  }See the Reflection Support page for more details.Build-Time Logger InitializationThe logger can be initialized at image build time with a custom logging.properties config, as in the code below:public class BuildTimeLoggerInit {  private static final Logger LOGGER;  static {    LogManager.getLogManager().readConfiguration(BuildTimeLoggerInit.class.getResourceAsStream(&quot;logging.properties&quot;));    LOGGER = Logger.getLogger(BuildTimeLoggerInit.class.getName());  }  public static void main(String[] args) throws IOException {    // Use the LOGGER here  }}The logging.properties file is processed at image build time.It does not need to be included in the native image, therefore reducing the image size.LoggerHolder.LOGGER is also initialized at image build time and is readily available at run time, therefore improving the startup.Unless the application needs to process a custom logging.properties configuration at run time, this approach is recommended.Runtime Logger InitializationThe logger can also be initialized at run time, as in the code below:public class RuntimeLoggerInit {    public static void main(String[] args) throws IOException {        LogManager.getLogManager().readConfiguration(RuntimeLoggerInit.class.getResourceAsStream(&quot;logging.properties&quot;));        Logger logger = Logger.getLogger(RuntimeLoggerInit.class.getName());        // Use the logger here    }}In this case, the logging.properties file needs to be available for runtime processing and it must be included in the image via the -H:IncludeResources=logging.properties option.See the information about accessing resources at runtime for more details on this option.",
                    "url": " /reference-manual/native-image/Logging/"
                  },
                  
                  "reference-manual-native-image-memorymanagement":  {
                    "title": "",
                    "content": "Memory Management at Image Run TimeA native image, when being executed, does not run on the Java HotSpot VM but on the runtime system provided with GraalVM.That runtime includes all necessary components, and one of them is the memory management.Java objects that a native image allocates at run time reside in the area called “the Java heap”.The Java heap is created when the native image starts up, and may increase or decrease in size while the native image runs.When the heap becomes full, a garbage collection is triggered to reclaim memory of objects that are no longer used.For managing the Java heap, Native Image provides different garbage collector (GC) implementations:  The Serial GC is the default GC in both GraalVM Community and Enterprise Edition.It is optimized for low memory footprint and small Java heap sizes.  The G1 GC (only available with GraalVM Enterprise Edition) is a multi-threaded GC that is optimized to reduce stop-the-world pauses and therefore improve latency, while achieving high throughput.To enable G1, specify the option --gc=G1 at image build time.Currently, G1 can only be used in native images that are built on Linux for AMD64.  The Epsilon GC (available with GraalVM 21.2 or later) is a no-op garbage collector that does not do any garbage collection and therefore never frees any allocated memory.The primary use case for this GC are very short running applications that only allocate a small amount of memory.To enable the Epsilon GC, specify the option --gc=epsilon at image build time.Performance ConsiderationsThe primary metrics for garbage collection are throughput, latency, and footprint:  Throughput is the percentage of total time not spent in garbage collection considered over long periods of time.  Latency is the responsiveness of an application.Garbage collection pauses negatively affect the responsiveness.  Footprint is the working set of a process, measured in pages and cache lines.Choosing settings for the Java heap is always a trade-off between these metrics.For example, a very large young generation may maximize throughput, but does so at the expense of footprint and latency.Young generation pauses can be minimized by using a small young generation at the expense of throughput.By default, Native Image automatically determines values for the Java heap settings that are listed below.The exact values may depend on the system configuration and the used GC.  The maximum Java heap size defines the upper limit for the size of the whole Java heap.If the Java heap is full and the GC is unable reclaim sufficient memory for a Java object allocation, the allocation will fail with the OutOfMemoryError.Note: The maximum heap size is only the upper limit for the Java heap and not necessarily the upper limit for the total amount of consumed memory, as Native Image places some data such as thread stacks, just-in-time compiled code, and internal data structures in memory that is separate from the Java heap.  The minimum Java heap size defines how much memory the GC may always assume as reserved for the Java heap, no matter how little of that memory is actually used.  The young generation size determines the amount of Java memory that can be allocated without triggering a garbage collection.Serial Garbage CollectorThe Serial GC is optimized for low footprint and small Java heap sizes.If no other GC is specified, the Serial GC will be used implicitly as the default on both GraalVM Community and Enterprise Edition.Since GraalVM 20.3, it is also possible to explicitly enable the Serial GC by passing the option --gc=serial to the native image builder.# Build a native image that uses the serial GC with default settingsnative-image --gc=serial HelloWorldOverviewIn its core, the Serial GC is a simple (non-parallel, non-concurrent) stop and copy GC.It divides the Java heap into a young and an old generation.Each generation consists of a set of equally sized chunks, each a contiguous range of virtual memory.Those chunks are the GC-internal unit for memory allocation and memory reclamation.The young generation is reserved for the allocation of new objects and when this part becomes full, a young collection is triggered.Objects that are alive in the young generation, will be moved to the old generation, thus freeing up the young generation for subsequent object allocations.When the old generation becomes full, a full collection is triggered.Typically, a young collection is much faster than an full collection, however doing full collections is important for keeping the memory footprint low.By default, the GC tries to balance the time that is spent in young and full collections.If no maximum Java heap size is specified, a native image that uses the Serial GC will set its maximum Java heap size to 80% of the physical memory size.For example, on a machine with 4GB of RAM, the maximum Java heap size will be set to 3.2GB.If the same image is executed on a machine that has 32GB of RAM, the maximum Java heap size will be set to 25.6GB.Note that this is just the maximum value.Depending on the application, the amount of actually used Java heap memory can be much lower.To override this default behavior, either specify a value for -XX:MaximumHeapSizePercent or explicitly set the maximum Java heap size.Performance TuningFor tuning the GC performance and the memory footprint, the following options can be used:  -XX:MaximumHeapSizePercent - the percentage of the physical memory size that is used as the maximum Java heap size if the maximum Java heap size is not specified otherwise.  -XX:MaximumYoungGenerationSizePercent - the maximum size of the young generation as a percentage of the maximum Java heap size.  -XX:PercentTimeInIncrementalCollection - determines how much time the GC should spend doing young collections.With the default value of 50, the GC tries to balance the time spent on young and full collections.Increasing this value will reduce the number of full GCs, which can improve performance but may worsen the memory footprint.Decreasing this value will increase the number of full GCs, which can improve the memory footprint but may decrease performance.  -XX:±CollectYoungGenerationSeparately (since GraalVM 21.0) - determines if a full GC collects the young generation separately or together with the old generation.If enabled, this may reduce the memory footprint during full GCs.However, full GCs may take more time.  -H:AlignedHeapChunkSize (can only be specified at image build time) - the size of a heap chunk in bytes.  -H:MaxSurvivorSpaces (since GraalVM 21.1, can only be specified at image build time) - the number of survivor spaces that are used for the young generation.With a value of 0, objects that survive a young collection are directly promoted to the old generation.  -H:LargeArrayThreshold (can only be specified at image build time) - the size at or above which an array will be allocated in its own heap chunk.Arrays that are considered as large are more expensive to allocate but they are never copied by the GC, which can reduce the GC overhead.# Build and execute a native image that uses the serial GC but does less full GCsnative-image --gc=serial -R:PercentTimeInIncrementalCollection=70 HelloWorld./helloworld# Execute the native image from above but force more full GCs./helloworld -XX:PercentTimeInIncrementalCollection=40G1 Garbage CollectorGraalVM Enterprise Edition also provides the Garbage-First (G1) garbage collector, which is based on the G1 GC from the Java HotSpot VM.Currently, G1 can only be used in native images that are built on Linux for AMD64.To enable it, pass the option --gc=G1 to the native image builder.# Build a native image that uses the G1 GC with default settingsnative-image --gc=G1 HelloWorldNote: In GraalVM 20.0, 20.1, and 20.2, the G1 GC was called low-latency GC and could be enabled via the experimental option -H:+UseLowLatencyGC.OverviewG1 is a generational, incremental, parallel, mostly concurrent, stop-the-world, and evacuating GC.It aims to provide the best balance between latency and throughput.Some operations are always performed in stop-the-world pauses to improve throughput.Other operations that would take more time with the application stopped, such as whole-heap operations like global marking, are performed in parallel and concurrently with the application.The G1 GC tries to meet set pause-time targets with high probability over a longer time.However, there is no absolute certainty for a given pause.G1 partitions the heap into a set of equally sized heap regions, each a contiguous range of virtual memory.A region is the GC-internal unit for memory allocation and memory reclamation.At any given time, each of these regions can be empty, or assigned to a particular generation.If no maximum Java heap size is specified, a native image that uses the G1 GC will set its maximum Java heap size to 25% of the physical memory size.For example, on a machine with 4GB of RAM, the maximum Java heap size will be set to 1GB.If the same image is executed on a machine that has 32GB of RAM, the maximum Java heap size will be set to 8GB.To override this default behavior, either specify a value for -XX:MaxRAMPercentage or explicitly set the maximum Java heap size.Performance TuningThe G1 GC is an adaptive garbage collector with defaults that enable it to work efficiently without modification.However, it can be tuned to the performance needs of a particular application.Here is a small subset of the options that can be specified when doing performance tuning:  -H:G1HeapRegionSize (can only be specified at image build time) - the size of a G1 region.  -XX:MaxRAMPercentage - the percentage of the physical memory size that is used as the maximum heap size if the maximum heap size is not specified otherwise.  -XX:MaxGCPauseMillis - the goal for the maximum pause time.  -XX:ParallelGCThreads - the maximum number of threads used for parallel work during garbage collection pauses.  -XX:ConcGCThreads - the maximum number of threads used for concurrent work.  -XX:InitiatingHeapOccupancyPercent - the Java heap occupancy threshold that triggers a marking cycle.  -XX:G1HeapWastePercent - the allowed unreclaimed space in the collection set candidates. G1 stops the space-reclamation phase if the free space in the collection set candidates is lower than that.# Build and execute a native image that uses the G1 GC with a region size of 2MB and a maximum pause time goal of 100msnative-image --gc=G1 -H:G1RegionSize=2m -R:MaxGCPauseMillis=100 HelloWorld./helloworld# Execute the native image from above and override the maximum pause time goal./helloworld -XX:MaxGCPauseMillis=50Memory Management OptionsThis section describes the most important memory management command-line options that are independent of the used GC.For all numeric values the suffix k, m, or g can be used for scaling.Further options to the native image builder can be listed using native-image --expert-options-all.Java Heap SizeWhen executing a native image, suitable Java heap settings will be determined automatically based on the system configuration and the used GC.To override this automatic mechanism and to explicitly set the heap size at run time, the following command-line options can be used:  -Xmx - maximum heap size in bytes  -Xms - minimum heap size in bytes  -Xmn - the size of the young generation in bytesIt is also possible to preconfigure default heap settings at image build time.The specified values will then be used as the default values at run time:  -R:MaxHeapSize (since GraalVM 20.0) - maximum heap size in bytes  -R:MinHeapSize (since GraalVM 20.0) - minimum heap size in bytes  -R:MaxNewSize (since GraalVM 20.0) - size of the young generation in bytes# Build a native image with the default heap settings and override the heap settings at run timenative-image HelloWorld./helloworld -Xms2m -Xmx10m -Xmn1m# Build a native image and &quot;bake&quot; heap settings into the image. The specified values will be used at run timenative-image -R:MinHeapSize=2m -R:MaxHeapSize=10m -R:MaxNewSize=1m HelloWorld./helloworldCompressed ReferencesGraalVM Enterprise Edition supports compressed references to Java objects that use 32-bit instead of 64-bit.Compressed references are enabled by default and can have a large impact on the memory footprint.However, they limit the maximum Java heap size to 32 GB of memory.If more than 32 GB are needed, compressed references need to be disabled.  -H:±UseCompressedReferences (can only be specified at image build time) - determines if 32-bit instead of 64-bit references to Java objects are used.Native MemoryNative Image may also allocate memory that is separate from the Java heap.One common use-case is a java.nio.DirectByteBuffer that directly references native memory.  -XX:MaxDirectMemorySize (since GraalVM 20.1) - the maximum size of direct buffer allocations.Printing Garbage CollectionsWhen executing a native image, the following options can be be used to print some information on garbage collection.Which data is printed in detail depends on the used GC.  -XX:+PrintGC - print basic information for every garbage collection  -XX:+VerboseGC - can be added to print further garbage collection details# Execute a native image and print basic garbage collection information./helloworld -XX:+PrintGC# Execute a native image and print detailed garbage collection information./helloworld -XX:+PrintGC -XX:+VerboseGC",
                    "url": " /reference-manual/native-image/MemoryManagement/"
                  },
                  
                  "reference-manual-js-modules":  {
                    "title": "",
                    "content": "Using JavaScript Modules and Packages in GraalVM JavaScriptGraalVM JavaScript is compatible with the latest ECMAScript standard, and can be executed in a variety of embedding scenarios such as Java-based applications or Node.js.Depending on the GraalVM’s JavaScript embedding scenario, JavaScript packages and modules may be used in different ways.Node.jsGraalVM ships with a specific Node.js version that it is compatible with.Applications can therefore freely import and use NPM packages compatible with the supported Node.js version, including CommonJS, ES modules, and modules that use native bindings.To check and verify the Node.js version supported by GraalVM, simply run bin/node --version.Java-based applications (Context API)When embedded in a Java application (using the Context API), GraalVM JavaScript can execute JavaScript applications and modules that do not depend on Node.js’ built-in modules such as &#39;fs&#39;, &#39;events&#39;, or &#39;http&#39; or Node.js-specific functions such as setTimeout() or setInterval().On the other hand, modules that depend on such Node.js builtins cannot be loaded in a GraalVM polyglot Context.Supported NPM packages can be used in a GraalVM JavaScript Context using one of the following approaches:  Using a package bundler.For example, to combine multiple NPM packages in a single JavaScript Source file.  Using ES modules on the local FileSystem.Optionally, a custom Truffle FileSystem can be used to configure how files are resolved.By default, a Java Context does not support loading modules using the CommonJS require() function.This is because require() is a Node.js built-in function, and is not part of the ECMAScript specification.Experimental support for CommonJS modules can be enabled through the js.commonjs-require option as described below.ECMAScript Modules (ESM)GraalVM JavaScript supports the full ES modules specification, including import statements, dynamic import of modules using import(), and advanced features such as top-level await.ECMAScript modules can be loaded in a Context simply by evaluating the module sources.GraalVM JavaScript loads ECMAScript modules based on their file extension.Therefore, any ECMAScript module should have file name extension .mjs.Alternatively, the module Source should have Mime type &quot;application/javascript+module&quot;.As an example, let’s assume that you have a file named foo.mjs containing the following simple ES module:export class Foo {    square(x) {        return x * x;    }}The ES module can be loaded in a polyglot Context in the following way:public static void main(String[] args) throws IOException {    String src = &quot;import {Foo} from &#39;/path/to/foo.mjs&#39;;&quot; +                 &quot;const foo = new Foo();&quot; +                 &quot;console.log(foo.square(42));&quot;;    Context cx = Context.newBuilder(&quot;js&quot;)                .allowIO(true)                .build();cx.eval(Source.newBuilder(&quot;js&quot;, src, &quot;test.mjs&quot;).build());}Note that the ES module file has .mjs extension.Also note that the allowIO() option is provided to enable IO access.More examples of ES modules usage are available here.Truffle FileSystemBy default, GraalVM JavaScript uses the built-in FileSystem of the polyglot Context to load and resolve ES modules.A FileSystem can be used to customize the ES modules loading process.For example, a custom FileSystem can be used to resolve ES modules using URLs:Context cx = Context.newBuilder(&quot;js&quot;).fileSystem(new FileSystem() {private final Path TMP = Paths.get(&quot;/some/tmp/path&quot;);    @Override    public Path parsePath(URI uri) {    // If the URL matches, return a custom (internal) Path    if (&quot;http://localhost/foo&quot;.equals(uri.toString())) {        return TMP;} else {        return Paths.get(uri);        }    }@Override    public SeekableByteChannel newByteChannel(Path path, Set&amp;lt;? extends OpenOption&amp;gt; options, FileAttribute&amp;lt;?&amp;gt;... attrs) throws IOException {    if (TMP.equals(path)) {        String moduleBody = &quot;export class Foo {&quot; +                            &quot;        square(x) {&quot; +                            &quot;            return x * x;&quot; +                            &quot;        }&quot; +                            &quot;    }&quot;;            // Return a dynamically-generated file for the ES module.            return createByteChannelFrom(moduleBody);        }    }    /* Other FileSystem methods not shown */}).allowIO(true).build();String src = &quot;import {Foo} from &#39;http://localhost/foo&#39;;&quot; +             &quot;const foo = new Foo();&quot; +             &quot;console.log(foo.square(42));&quot;;cx.eval(Source.newBuilder(&quot;js&quot;, src, &quot;test.mjs&quot;).build());In this simple example, a custom FileSystem is used to load a dynamically-generated ES module when an application attempts to import the http://localhost/foo URL.A complete example of a custom Truffle FileSystem to load ES modules can be found here.CommonJS Modules (CJS)By default, the Context API does not support CommonJS modules, and has no built-in require() function.In order to be loaded and used from a Context in Java, a CommonJS module needs to be bundled into a self-contained JavaScript source file.This can be done using one of the many popular open-source bundling tools such as Parcel, Browserify, and Webpack.Experimental support for CommonJS modules can be enabled through the js.commonjs-require option as described below.Experimental support for CommonJS NPM modules in the Context APIThe js.commonjs-require option provides a built-in require() function that can be used to load NPM-compatible CommonJS modules in a JavaScript Context.Currently, this is an experimental feature not for production usage.To enable CommonJS support, a JavaScript context can be created in the following way:Map&amp;lt;String, String&amp;gt; options = new HashMap&amp;lt;&amp;gt;();// Enable CommonJS experimental support.options.put(&quot;js.commonjs-require&quot;, &quot;true&quot;);// (optional) folder where the NPM modules to be loaded are located.options.put(&quot;js.commonjs-require-cwd&quot;, &quot;/path/to/root/folder&quot;);// (optional) initialization script to pre-define globals.options.put(&quot;js.commonjs-global-properties&quot;, &quot;./globals.js&quot;);// (optional) Node.js built-in replacements as a comma separated list.options.put(&quot;js.commonjs-core-modules-replacements&quot;,            &quot;buffer:buffer/,&quot; +            &quot;path:path-browserify&quot;);// Create context with IO support and experimental options.Context cx = Context.newBuilder(&quot;js&quot;)                            .allowExperimentalOptions(true)                            .allowIO(true)                            .options(options)                            .build();// Require a moduleValue module = cx.eval(&quot;js&quot;, &quot;require(&#39;some-module&#39;);&quot;);The &quot;js.commonjs-require-cwd&quot; option can be used to specify the main folder where NPM packages have been installed.As an example, this can be the folder where the npm install command was executed, or the folder containing your main node_modules folder.Any NPM module will be resolved relative to that folder, including the &quot;js.commonjs-global-properties&quot; file and any built-in replacement specified using &quot;js.commonjs-core-modules-replacements&quot;.Differences with Node.js built-in require() functionThe Context built-in require() function can load regular NPM modules implemented in JavaScript, but cannot load native NPM modules.The built-in require() relies on the FileSystem, therefore I/O access needs to be enabled at context creation time using the allowIO option.The built-in require() aims to be largely compatible with Node.js, and we expect it to work with any NPM module that would work in a browser (e.g., created using a package bundler).Installing an NPM module to be used via the Context APIIn order to be used from a JavaScript Context, an NPM module needs to be installed to a local folder.This can be done using GraalVM JavaScript’s npm install command like one would normally do for Node.js applications.At runtime, the option js.commonjs-require-cwd can be used to specify the main installation folder for NPM packages.The require() built-in function will resolve packages according to the default Node.js’ package resolution protocol starting from the directory specified via js.commonjs-require-cwd.When no directory is provided with the option, the current working directory of the application will be used.Node.js core modules mockupsSome JavaScript applications or NPM modules might need functionalities that are available in Node.js’ built-in modules (e.g., &#39;fs&#39; and &#39;buffer&#39;, etc.).Such modules are not available in the Context API.Thankfully, the Node.js community has developed high-quality JavaScript implementations for many Node.js core modules (e.g., the ‘buffer’ module for the browser).Such alternative module implementations can be exposed to a JavaScript Context using the js.commonjs-core-modules-replacements option, in the following way:options.put(&quot;js.commonjs-core-modules-replacements&quot;, &quot;buffer:my-buffer-implementation&quot;);As the code suggests, the option instructs the GraalVM JavaScript runtime to load a module called my-buffer-implementation when an application attempts to load the Node.js &#39;buffer&#39; built-in module using require(&#39;buffer&#39;).Global symbols pre-initializationAn NPM module or a JavaScript application might expect certain global properties to be defined in the global scope.For example, applications or modules might expect the Buffer global symbol to be defined in the JavaScript global object.The option js.commonjs-global-properties can be used to pre-initialize such global symbols using the Context API.The option can be used in the following way:options.put(&quot;js.commonjs-global-properties&quot;, &quot;./globals.js&quot;);Once specified, the file globals.js will be loaded at context creation time. That is, before any JavaScript source execution.An example globals.js file might perform the following initialization steps:// define an empty object called &#39;process&#39;globalThis.process = {}// define the &#39;Buffer&#39; global symbolglobalThis.Buffer = require(&#39;some-buffer-implementation&#39;).Buffer;The file will be executed at context creation time, and Buffer will be available as a global symbol in all new Context instances.",
                    "url": " /reference-manual/js/Modules/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-monomorphization":  {
                    "title": "",
                    "content": "MonomorphizationTruffle has an automatic approach to monomorphization (also known as “splitting”). For more information about the benefits of monomorphization, continue reading to Monomorphization Use Cases.It is controlled by the Splitting engine option and is on by default.Adding --engine.Splitting=false to your command line will disable it.The heuristic relies on information from the language implementation to guide the decisions. To find out more about how to use the new approach in your language implementation, refer to the Reporting Polymorphism guide.For more details on how the new approach works, see the Splitting guide.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/Monomorphization/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-monomorphization":  {
                    "title": "",
                    "content": "MonomorphizationTruffle has an automatic approach to monomorphization (also known as “splitting”). For more information about the benefits of monomorphization, continue reading to Monomorphization Use Cases.It is controlled by the Splitting engine option and is on by default.Adding --engine.Splitting=false to your command line will disable it.The heuristic relies on information from the language implementation to guide the decisions. To find out more about how to use the new approach in your language implementation, refer to the Reporting Polymorphism guide.For more details on how the new approach works, see the Splitting guide.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/Monomorphization/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-monomorphizationusecases":  {
                    "title": "",
                    "content": "Monomorphization Use CasesThis guide demonstrates through examples how monomorphization can improve performance of dynamic languages without going into any detail on how monomorphization is implemented (described in the Splitting guide) or how to leverage monomorphization in your language implementation (described in the Reporting Polymorphism guide).MonomorphizationTo better illustrate the benefits of monomorphization, consider a small example written in JavaScript:function add(arg1, arg2) {    return arg1 + arg2;}function callsAdd() {    add(1, 2);    add(&quot;foo&quot;, &quot;bar&quot;);}var i = 0;while (i &amp;lt; 1000) {    callsAdd();    i++;}As you can see in this example, the add function is called from callsAdd once with integer arguments and once with string arguments.Once add is executed enough times to be compiled its execution profile will show that the + operator has been executed with both integers and strings and thus handlers (i.e., type checks and execution) for both types will be compiled which has aperformance impact.This can be avoided by rewriting the example as follows:function addInt(arg1, arg2) {    return arg1 + arg2;}function addString(arg1, arg2) {    return arg1 + arg2;}function callsAdd() {    addInt(1, 2);    addString(&quot;foo&quot;, &quot;bar&quot;);}i = 0;while (i &amp;lt; 1000) {    callsAdd();    i++;}In this example the add has been duplicated (split) in such a way that each type profile is contained in a separate copy of the function (addInt and addString).The result is that, come compilation time, only a single type profile is available for each function avoiding potentially costly type checks in the compiled code.Automating the detection suitable candidates, as well as their duplication, performed at run time is what we call monomorphization.It is, in other words, automated run-time monomorphization of polymorphic nodes through AST duplication.Example 1 - Monomorphization of ArgumentsThis example is an extended version of the illustration example from the previous section.The add function is still the target for monomorphization and is called from the action function 3 times with 3 sets of different arguments (numbers, strings and arrays).Execute the action function for 15 seconds in order to have enough time for warmup, and afterwards execute it for 60 seconds keeping track of how long each execution took, reporting finally the average.Execute this code twice: once with and once without monomorphization enabled and report the output of these two runs as well as the speedup.function add(arg1, arg2) {    return arg1 + arg2;}var global = 0;function action() {    for (var i = 0; i &amp;lt; 10000; i++) {        global = add(1, 2);        global = add(&quot;foo&quot;, &quot;bar&quot;);        global = add([1,2,3], [4,5,6]);    }}// Warm up.var start = Date.now();while ((Date.now() - start) &amp;lt; 15000 /* 15 seconds */) {    action();}// Benchmarkvar iterations = 0;var sum = 0;var start = Date.now();while ((Date.now() - start) &amp;lt; 60000 /* 60 seconds */) {    var thisIterationStart = Date.now();    action();    var thisIterationTime = Date.now() - thisIterationStart;    iterations++;    sum += thisIterationTime;}console.log(sum / iterations);The output without monomorphization is 4.494225288735564.The output with monomorphization is 4.2421633923.The speedup is ~5%.Example 2 - Monomorphization of Indirect CallsThis example is slightly more complicated and illustrates how monomorphization benefits higher order functions. In the example, the insertionSort function is defined, which - given an array of items and a function for comparing these items - sorts the array using insertion sort.Define an array of 1000 random double values between 0 and 1 and sort it four times using 4 different sorting methods (in the action function).Finally, as with the previous example, warm up the action function for 15 second, and report the average execution time ofthis function over the next 60 seconds with and without monomorphization.function insertionSort (items, comparator) {    for (var i = 0; i &amp;lt; items.length; i++) {        let value = items[i];        for (var j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; comparator(items[j], value); j--) {            items[j + 1] = items[j]        }        items[j + 1] = value    }}// Random values in an arrayvar array = new Array(1000);for (i = 0; i &amp;lt; array.length; i++) {    array[i] = Math.random();}function action() {    insertionSort(array, function (a, b) { return a &amp;lt; b                                      });    insertionSort(array, function (a, b) { return a &amp;gt; b                                      });    insertionSort(array, function (a, b) { return a.toString().length &amp;lt; b.toString().length; });    insertionSort(array, function (a, b) { return a.toString().length &amp;gt; b.toString().length; });}// Warm up.var start = Date.now();while ((Date.now() - start) &amp;lt; 15000 /* 15 seconds */) {    action();}// Benchmarkvar iterations = 0;var sum = 0;var start = Date.now();while ((Date.now() - start) &amp;lt; 60000 /* 60 seconds */) {    var thisIterationStart = Date.now();    action();    var thisIterationTime = Date.now() - thisIterationStart;    iterations++;    sum += thisIterationTime;}console.log(sum / iterations);The output without monomorphization is 194.05161290322582.The output with monomorphization is 175.41071428571428.The speedup is ~10%.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/MonomorphizationUseCases/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-monomorphizationusecases":  {
                    "title": "",
                    "content": "Monomorphization Use CasesThis guide demonstrates through examples how monomorphization can improve performance of dynamic languages without going into any detail on how monomorphization is implemented (described in the Splitting guide) or how to leverage monomorphization in your language implementation (described in the Reporting Polymorphism guide).MonomorphizationTo better illustrate the benefits of monomorphization, consider a small example written in JavaScript:function add(arg1, arg2) {    return arg1 + arg2;}function callsAdd() {    add(1, 2);    add(&quot;foo&quot;, &quot;bar&quot;);}var i = 0;while (i &amp;lt; 1000) {    callsAdd();    i++;}As you can see in this example, the add function is called from callsAdd once with integer arguments and once with string arguments.Once add is executed enough times to be compiled its execution profile will show that the + operator has been executed with both integers and strings and thus handlers (i.e., type checks and execution) for both types will be compiled which has aperformance impact.This can be avoided by rewriting the example as follows:function addInt(arg1, arg2) {    return arg1 + arg2;}function addString(arg1, arg2) {    return arg1 + arg2;}function callsAdd() {    addInt(1, 2);    addString(&quot;foo&quot;, &quot;bar&quot;);}i = 0;while (i &amp;lt; 1000) {    callsAdd();    i++;}In this example the add has been duplicated (split) in such a way that each type profile is contained in a separate copy of the function (addInt and addString).The result is that, come compilation time, only a single type profile is available for each function avoiding potentially costly type checks in the compiled code.Automating the detection suitable candidates, as well as their duplication, performed at run time is what we call monomorphization.It is, in other words, automated run-time monomorphization of polymorphic nodes through AST duplication.Example 1 - Monomorphization of ArgumentsThis example is an extended version of the illustration example from the previous section.The add function is still the target for monomorphization and is called from the action function 3 times with 3 sets of different arguments (numbers, strings and arrays).Execute the action function for 15 seconds in order to have enough time for warmup, and afterwards execute it for 60 seconds keeping track of how long each execution took, reporting finally the average.Execute this code twice: once with and once without monomorphization enabled and report the output of these two runs as well as the speedup.function add(arg1, arg2) {    return arg1 + arg2;}var global = 0;function action() {    for (var i = 0; i &amp;lt; 10000; i++) {        global = add(1, 2);        global = add(&quot;foo&quot;, &quot;bar&quot;);        global = add([1,2,3], [4,5,6]);    }}// Warm up.var start = Date.now();while ((Date.now() - start) &amp;lt; 15000 /* 15 seconds */) {    action();}// Benchmarkvar iterations = 0;var sum = 0;var start = Date.now();while ((Date.now() - start) &amp;lt; 60000 /* 60 seconds */) {    var thisIterationStart = Date.now();    action();    var thisIterationTime = Date.now() - thisIterationStart;    iterations++;    sum += thisIterationTime;}console.log(sum / iterations);The output without monomorphization is 4.494225288735564.The output with monomorphization is 4.2421633923.The speedup is ~5%.Example 2 - Monomorphization of Indirect CallsThis example is slightly more complicated and illustrates how monomorphization benefits higher order functions. In the example, the insertionSort function is defined, which - given an array of items and a function for comparing these items - sorts the array using insertion sort.Define an array of 1000 random double values between 0 and 1 and sort it four times using 4 different sorting methods (in the action function).Finally, as with the previous example, warm up the action function for 15 second, and report the average execution time ofthis function over the next 60 seconds with and without monomorphization.function insertionSort (items, comparator) {    for (var i = 0; i &amp;lt; items.length; i++) {        let value = items[i];        for (var j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; comparator(items[j], value); j--) {            items[j + 1] = items[j]        }        items[j + 1] = value    }}// Random values in an arrayvar array = new Array(1000);for (i = 0; i &amp;lt; array.length; i++) {    array[i] = Math.random();}function action() {    insertionSort(array, function (a, b) { return a &amp;lt; b                                      });    insertionSort(array, function (a, b) { return a &amp;gt; b                                      });    insertionSort(array, function (a, b) { return a.toString().length &amp;lt; b.toString().length; });    insertionSort(array, function (a, b) { return a.toString().length &amp;gt; b.toString().length; });}// Warm up.var start = Date.now();while ((Date.now() - start) &amp;lt; 15000 /* 15 seconds */) {    action();}// Benchmarkvar iterations = 0;var sum = 0;var start = Date.now();while ((Date.now() - start) &amp;lt; 60000 /* 60 seconds */) {    var thisIterationStart = Date.now();    action();    var thisIterationTime = Date.now() - thisIterationStart;    iterations++;    sum += thisIterationTime;}console.log(sum / iterations);The output without monomorphization is 194.05161290322582.The output with monomorphization is 175.41071428571428.The speedup is ~10%.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/MonomorphizationUseCases/"
                  },
                  
                  "reference-manual-js-multithreading":  {
                    "title": "",
                    "content": "MultithreadingRunning JavaScript on GraalVM supports multithreading.Depending on the usage scenario, threads can be used to execute parallel JavaScript code using multiple Context objects, or multiple Worker threads.Multithreading with Java and JavaScriptMultithreading is supported when running JavaScript in the context of Java interoperability.The basic model of multi-threaded execution supported by GraalVM is a “share-nothing” model that should be familiar to any JavaScript developer:  An arbitrary number of JavaScript Contexts can be created, but they should be used by one thread at a time.  Concurrent access to JavaScript objects is not allowed: any JavaScript object cannot be accessed by more than one thread at a time.  Concurrent access to Java objects is allowed: any Java object can be accessed by any Java or JavaScript thread, concurrently.A JavaScript Context cannot be accessed by two or more threads, concurrently, but it is possible to access the same Context from multiple threads using proper syncronization, to ensure that concurrent access never happens.ExamplesThe GraalVM JavaScript unit tests contain several examples of multi-threaded Java/JavaScript interactions.The most notable ones describe how:  Multiple Context objects can be executed in multiple threads.  JavaScript values created by one thread can be used from another thread when proper synchronization is used.  A Context can be accessed from multiple threads when proper synchronization is used.  Java concurrency can be used from JavaScript.  Java objects can be accessed by multiple JavaScript threads, concurrently.Multithreading with Node.jsThe basic multithreading model of GraalVM JavaScript applies to Node.js applications as well.In Node.js, a Worker thread can be created to execute JavaScript code in parallel, but JavaScript objects cannot be shared between Workers.On the contrary, a Java object created with GraalVM Java interoperability (e.g., using Java.type()) can be shared between Node.js Workers.This allows multi-threaded Node.js applications to share Java objects.ExamplesThe GraalVM Node.js unit tests contain several examples of multi-threaded Node.js applications.The most notable examples show how:  Node.js worker threads can execute Java code.  Java objects can be shared between Node.js worker threads.  JavaScript Promise objects can be used to await on messages from workers, using Java objects to bind promises to worker messages.",
                    "url": " /reference-manual/js/Multithreading/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-nfi":  {
                    "title": "",
                    "content": "Truffle Native Function InterfaceTruffle includes a way to call native functions, called the Native Function Interface (NFI).It is implemented as an internal language on top of Truffle that language implementors can access via the standard polyglot eval interface and Truffle interoperability.NFI is intended to be used, for example, to implement a language’s FFI, or to call native runtime routines that are not available in Java.NFI uses libffi.On a standard JVM it calls it using JNI, and on GraalVM Native Image it uses system Java.In the future it may be optimised by the GraalVM compiler in native executables so that native calls are made directly from the compiled code.StabilityThe NFI is an internal language designed for language implementors.It is not considered stable and the interface and behavior may change without warning.It is not intended to be used directly by end-users.Basic ConceptsThe NFI is accessed via the polyglot interface of whatever language you are using.This could be Java, or it could be a Truffle language.This lets you use the NFI from both your Java language implementation code, or from your guest language to reduce the amount of Java that you need to write.The entry point is the polyglot eval interface.This runs a special DSL, and returns Truffle interoperability objects which can then expose more methods.Below are some examples using Ruby’s polyglot interface, but any other JVM or a language implementation could be used instead.Basic ExampleHere is a basic working example, before going into the details:library = Polyglot.eval(&#39;nfi&#39;, &#39;load &quot;libSDL2.dylib&quot;&#39;)  # load a librarysymbol = library[&#39;SDL_GetRevisionNumber&#39;]               # load a symbol from the lirbaryfunction = symbol.bind(&#39;():UINT32&#39;)                     # bind the symbol to types to create a functionputs function.call # =&amp;gt; 12373                           # call the functionLoading libariesTo load a library, a script written in the ‘nfi’ language DSL is evaluated.It returns an object that represents the loaded library.library = Polyglot.eval(&#39;nfi&#39;, &#39;...load command...&#39;)The load command can be any of these forms:  default  load &quot;filename&quot;  load (flag | flag | ...) &quot;filename&quot;The default command returns a pseudo-library that contains all symbols already loaded inthe process, equivalent to RTLD_DEFAULT in the Posix interface.The load &quot;filename&quot; command loads a library from a file.You are responsible for any cross-platform concerns about library naming conventions and load paths.The load (flag | flag | ...) &quot;filename&quot;command allows you to specify flags to load the library.For the default backend (backends will be described later), and when running on a Posix platform, the flags available are RTLD_GLOBAL, RTLD_LOCAL, RTLD_LAZY, and RTLD_NOW, which have the conventional Posix semantics.The default is RTLD_NOW if neither RTLD_LAZY nor RTLD_NOW were specified.Loading Symbols from LibrariesTo load a symbol from a library, read the symbol as a property from the library object that was previously loaded.symbol = library[&#39;symbol_name&#39;]Producing Native Function Objects from SymbolsTo get an executable object that you can call in order to invoke the nativefunction, bind the symbol object that was previously loaded, by callingthe bind method on it. Supply a type signature that needs to match thenative function’s actual type signature.function = symbol.bind(&#39;...signature...&#39;)The format of the signature is (arg, arg, ...) : return, where arg and return are types.Types can be one of the simple types:  VOID  UINT8  SINT8  UINT16  SINT16  UINT32  SINT32  UINT64  SINT64  FLOAT  DOUBLE  POINTER  STRING  OBJECT  ENVArray types are formed by placing another type in square brackets.For example [UINT8]. These are C-style arrays.Function pointer types are formed by writing a nested signature.For example the signature of qsort would be (POINTER, UINT64, UINT64, (POINTER, POINTER) : SINT32) : VOID.For a function with a signature with variadic arguments, you specify ... where the variadic arguments start, but then you must specify the actual types that you will be calling the function with.You may therefore need to bind the same symbol multiple times in order to call it with different types or a different number of arguments.For example, to call printf with %d %f you would use the type signature (STRING, ...SINT32, DOUBLE) : SINT32.Type expressions can be nested arbitrarily deep.Two additional special types, ENV and OBJECT, are described in the section on the native API, later in this document.Types can be written in any case.You are responsible for any mapping of types from a foreign language such as C into NFI types.Calling Native Function ObjectsTo call a native function, execute it.return_value = function.call(...arguments...)Calling back from Native Code to Managed FunctionsUsing nested signatures, a function call can get function pointers as arguments.The managed caller needs to pass a Polyglot executable object, that will be converted to a native function pointer.When calling this function pointer from the native side, the execute message is sent to the Polyglot object.void native_function(int32_t (*fn)(int32_t)) {  printf(&quot;%dn&quot;, fn(15));}native_function = library[&#39;native_function&#39;].bind(&quot;((SINT32):SINT32):VOID&quot;)native_function.call(-&amp;gt;(x) { x + 1 })The arguments and return values of callback functions are converted the same as for regular function calls, with the conversion in the other direction, i.e., arguments are converted from native to managed, and return values are converted from managed to native.Callback function pointers can themselves have function pointer arguments.That works as you would expect: the function accepts a native function pointer as argument, and it is converted to a Truffle executable object.Sending the execute message to that object calls the native function pointer, same as calling a regular NFI function.Function pointer types are also supported as return types.Combined Loading and BindingYou can optionally combine loading a library with loading symbols and binding them.This is achieved with an extended load command, which then returns an object with the already bound functions as methods.These two examples are equivalent:library = Polyglot.eval(&#39;nfi&#39;, &#39;load libSDL2.dylib&#39;)symbol = library[&#39;SDL_GetRevisionNumber&#39;]function = symbol.bind(&#39;():UINT32&#39;)puts function.call # =&amp;gt; 12373library = Polyglot.eval(&#39;nfi&#39;, &#39;load libSDL2.dylib { SDL_GetRevisionNumber():UINT32; }&#39;)puts library.SDL_GetRevisionNumber # =&amp;gt; 12373The definitions in the curly braces {} can contain multiple function bindings, so that many functions can be loaded from a library at once.BackendsThe load command can be prefixed by with in order to select a specific NFI backend.Multiple NFI backends are available.The default is called native, and will be used if there is no with prefix, or the selected backend is not available.Depending on the configuration of components you are running, available backends may include:  native  llvm, which uses the GraalVM LLVM runtime to run the native codeTruffle NFI on Native ImageTo build a native image that contains the Truffle NFI, it is sufficient to use the --langeage:nfi argument, or specify Requires = language:nfi in native-image.properties.It is possible to select what implementation to use for the native backend using --language:nfi=&amp;lt;backend&amp;gt;.Note that the --language:nfi=&amp;lt;backend&amp;gt; argument must come before any other arguments that might pull in the NFI as dependency via Requires = language:nfi.The first instance of language:nfi wins and determines what backend will be built into the native image.Available arguments for --language:nfi=&amp;lt;backend&amp;gt; are:  libffi (the default)  noneSelecting the none native backend will effectively disable access to native functions using the Truffle NFI.This will break users of the NFI that rely on native access (e.g. the GraalVM LLVM Runtime, unless used with --llvm.managed on EE).Native APIThe NFI can be used with unmodified, already compiled native code, but it can also be used with a Truffle-specific API being used by the native code.The special type ENV adds an additional parameter TruffleEnv *env to the signature. An additional simple type OBJECT translates to an opaqueTruffleObject type.The trufflenfi.h library provides declarations for working with these types, that can then be used by the native code called through the NFI. See trufflenfi.h itself for more documentation on this API.Type MarshallingThis section describes in detail how argument values and return values are converted for all types in the function signature.The following table shows the possible types in NFI signatures with their corresponding C language types on the native side, and what polyglot values these arguments map to on the managed side:            NFI type      C language type      Polyglot value                  VOID      void      Polyglot object with isNull == true (only valid as return type).              SINT8/16/32/64      int8/16/32/64_t      Polyglot isNumber that fitsIn... the corresponding integer type.              UINT8/16/32/64      uint8/16/32/64_t      Polyglot isNumber that fitsIn... the corresponding integer type.              FLOAT      float      Polyglot isNumber that fitsInFloat.              DOUBLE      double      Polyglot isNumber that fitsInDouble.              POINTER      void *      Polyglot object with isPointer == true or isNull == true.              STRING      char * (zero-terminated UTF-8 string)      Polyglot isString.              OBJECT      TruffleObject      Arbitrary object.              [type]      type * (array of primitive)      Java host primitive array.              (args):ret      ret (*)(args) (function pointer type)      Polyglot function with isExecutable == true.              ENV      TruffleEnv *      nothing (injected argument)      The following sections describe the type conversions in detail.The type conversion behavior with function pointers can be slightly confusing, because the direction of the arguments is reversed. When in doubt, always try to figure out in which direction arguments or return values flow, from managed to native or from native to managed.VOIDThis type is only allowed as return type, and is used to denote functions that do not return a value.Since in the Polyglot API, all executable objects have to return a value, a Polyglot object with isNull == true will be returned from native functions that have a VOID return type.The return value of managed callback functions with return type VOID will be ignored.Primitive NumbersThe primitive number types are converted as you might expect.The argument needs to be a Polyglot number, and its value needs to fit in the value range of the specified numeric type.One thing to note is the handling of the unsigned integer types.Even though the Polyglot API does not specify separate messages for values fitting in unsigned types, the conversion is still using the unsigned value ranges.For example, the value 0xFF passed from native to managed through a return value of type SINT8 will result in a Polyglot number -1, which fitsInByte, but the same value returned as UINT8 results in a Polyglot number 255, which does notfitsInByte.Also, passing -1 to an argument of type UINT8 is a type error, but passing 255 is allowed, even though it does not fitsInByte.Since in the current Polyglot API it is not possible to represent numbers outside of the signed 64-bit range, the UINT64 type is currently handled with signed semantics.This is a known bug in the API, and will change in a future release.POINTERThis type is a generic pointer argument.On the native side, it does not matter what exact pointer type the argument is.A polyglot object passed to POINTER arguments will be converted to a native pointer if possible (using the isPointer, asPointer and toNative messages as necessary).An object with isNull == true will be passed as a native NULL.POINTER return values will produce a polyglot object with isPointer == true.The native NULL pointer will additionally have isNull == true.In addition, the returned pointer object will also have a method bind, and behave the same as symbols loaded from an NFI library. When calling bind on such a pointer, it is the user’s responsibility to ensure that the pointer really points to a function with a matching signature.STRINGThis is a pointer type with special conversion semantics for strings.Polyglot strings passed from managed to native using the STRING type will be converted to a zero-terminated UTF-8 encoded string.For STRING arguments, the pointer is owned by the caller, and is guaranteed to stay alive for the duration of the call only.The STRING values returned from managed function pointers to a native caller are also owned by the caller.They have to be freed with free after use.Polyglot pointer values or null values can also be passed to STRING arguments.The semantics is the same as for POINTER arguments.The user is responsible for ensuring that the pointer is a valid UTF-8 string.The STRING values passed from native functions to managed code behave like POINTER return values, but in addition they have isString == true.The user is responsible for the ownership of the pointer and it might be necessary to free the return value, depending on the semantics of the called native function.After freeing the returned pointer, the returned polyglot string is invalid and reading it results in undefined behavior.In that sense, the returned polyglot string is not a safe object, similar to a raw pointer.It is recommented that the user of the NFI copies the returned string before passing it along to untrusted managed code.OBJECTThis argument corresponds to the C type TruffleObject.This type is defined in trufflenfi.h, and is an opaque pointer type.A value of type TruffleObject represents a reference to an arbitrary managed object.Native code can do nothing with values of type TruffleObject except pass them back to managed code, either through return values or passing them to callback function pointers.The lifetime of TruffleObject references needs to be managed manually.See the documentation in trufflenfi.h for API functions to manage the lifetime of TruffleObject references.A TruffleObject passed as an argument is owned by the caller, and guaranteed to stay alive for the duration of the call.A TruffleObject reference returned from a callback function pointer is owned by the caller, and needs to be freed after use. Returning a TruffleObject from a native function does not transfer ownership (but there is an API function in trufflenfi.h to do that).[...] (Native Primitive Arrays)This type is only allowed as an argument from managed code to a native function, and only arrays of primitive numeric types are supported.On the managed side, only Java host objects containing a Java primitive array are supported.On the native side, the type is a pointer to the contents of the array.It is the user’s responsibility to pass along the array length as a separate argument.The pointer is valid for the duration of the native call only.Modifications to the contents are propagated back to the Java array after returning from the call.The effects of concurrent access to the Java array during the native call are unspecified.(...):... (Function Pointer)On the native side, a nested signature type corresponds to a function pointer with the given signature, calling back to managed code.Polyglot executable objects passed from managed to native using a function pointer type must be converted to a function pointer that can be called by the native code.For function pointer arguments, the function pointer is owned by the caller, and is guaranteed to stay alive for the duration of the call only.Function pointer return values are owned by the caller, and have to be freed manually.See polyglot.h for API functions to manage the lifetime of function pointer values.Polyglot pointer values or null values can also be passed to function pointer arguments.The semantics is the same as for POINTER arguments.The user is responsible for ensuring that the pointer is a valid function pointer.Function pointer return types are the same as regular POINTER return types, but in addition they are already bound to the given signature type.They support the execute message, and behave the same as regular NFI functions.ENVThis type is a special argument of type TruffleEnv *.It is only valid as argument type, not as a return type.It is an injected argument on the native side, there is no corresponding argument on the managed side.When used as argument type of a native function, the native function will get an environment pointer on this position.That environment pointer can be used to call API functions (see trufflenfi.h).The argument is injected, for example, if the signature is (SINT32, ENV, SINT32):VOID.This function object is expected to be called with two integer arguments, and the corresponding native function will be called with three arguments: first the first real argument, then the injected ENV argument, and then the second real argument.When the ENV type is used as an argument type for a function pointer parameter, that function pointer must be called with a valid NFI environment as an argument.If the caller already has an environment, threading it through to callback function pointers is more efficient than calling them without an ENV argument.Other PointNative functions must use the system’s standard ABI.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/NFI/"
                  },
                  
                  "reference-manual-js-nashornmigrationguide":  {
                    "title": "",
                    "content": "Migration Guide from Nashorn to GraalVM JavaScriptThis guide serves as a migration guide for code previously targeted to the Nashorn engine.See the Java Interoperability guide for an overview of supported Java interoperability features.The Nashorn engine has been deprecated in JDK 11 as part of JEP 335 andand has been removed from JDK15 as part of JEP 372.GraalVM can step in as a replacement for JavaScript code previously executed on the Nashorn engine.GraalVM provides all the features for JavaScript previously provided by Nashorn.Many are available by default, some are behind flags, and others require minor modifications to your source code.Both Nashorn and GraalVM JavaScript support a similar set of syntax and semantics for Java interoperability.One notable difference is that GraalVM JavaScript takes a secure by default approach, meaning some features need to be explicitly enabled that were available by default on Nashorn.The most important differences relevant for migration are listed here.Nashorn features available by default (dependent on security settings):  Java.type, Java.typeName  Java.from, Java.to  Java.extend, Java.super  Java package globals: Packages, java, javafx, javax, com, org, eduNashorn Compatibility ModeGraalVM JavaScript provides a Nashorn compatibility mode.Some of the functionality necessary for Nashorn compatibility is only available when the js.nashorn-compat option is enabled.This is the case for Nashorn-specific extensions that GraalVM JavaScript does not want to expose by default.Note that you have to enable experimental options to use this flag.Further note that setting this flag defeats the secure by default approach of GraalVM JavaScript in some cases, e.g., when operating on a legacy ScriptEngine.When you use the Nashorn compatibility mode, by default, ECMAScript 5 is set as compatibility level.You can specify a different ECMAScript version using the js.ecmascript-version flag; note that this might conflict with full Nashorn compatibilty.A code example how to set the flag is given near the end of this section.The js.nashorn-compat option can be set:1. by using a command line option:js --experimental-options --js.nashorn-compat=true2. by using the Polyglot API:import org.graalvm.polyglot.Context;try (Context context = Context.newBuilder().allowExperimentalOptions(true).option(&quot;js.nashorn-compat&quot;, &quot;true&quot;).build()) {    context.eval(&quot;js&quot;, &quot;print(__LINE__)&quot;);}3. by using a system property when starting a Java application (remember to enable allowExperimentalOptions on the Context.Builder in your application as well):java -Dpolyglot.js.nashorn-compat=true MyApplicationFunctionality only available under the nashorn-compat flag includes:  Java.isJavaFunction, Java.isJavaMethod, Java.isScriptObject, Java.isScriptFunction  new Interface|AbstractClass(fn|obj)  JavaImporter  JSAdapter  java.lang.String methods on string values  load(&quot;nashorn:parser.js&quot;), load(&quot;nashorn:mozilla_compat.js&quot;)  exit, quitThe js.ecmascript-version option can be set in similar fashion.As this is a supported option, there is no need to provide the experimental-options flag just for setting the ecmascript-version:1. by using a command line option:js --js.ecmascript-version=2020Nashorn Syntax ExtensionsNashorn syntax extensions can be enabled using the js.syntax-extensions experimental option.They are also enabled by default in the Nashorn compatibility mode (js.nashorn-compat).GraalVM JavaScript vs NashornGraalVM JavaScript differs from Nashorn in some aspects that were intentional design decisions.Secure by DefaultGraalVM JavaScript takes a secure by default approach.Unless explicitly permitted by the embedder, JavaScript code cannot access Java classes or access the file system, among other restrictions.Several features of GraalVM JavaScript, including Nashorn compatibility features, are only available when the relevant security settings are permissive enough.Make sure you understand the security implications of any change that lifts the secure default limits to your application and the host system.For a full list of available settings, see Context.Builder.Those flags can be defined when building the context with GraalVM Polyglot API.Flags frequently required to enable features of GraalVM JavaScript are:  allowHostAccess(): configure which public constructors, methods or fields of public classes are accessible by guest applications. Use HostAccess.EXPLICIT or a custom HostAccess policy to selectively enable access. Set to HostAccess.ALL to allow unrestricted access.  allowHostClassLookup(): set a filter that specifies the Java host classes that can be looked up by the guest application. Set to the Predicate className -&amp;gt; true to allow lookup of all classes.  allowIO(): allow the guest language to perform unrestricted IO operations on the host system, required, e.g., to load() from the file system. Set to true to enable IO.If you run code on the legacy ScriptEngine, see Setting options via Bindings regarding how to set them there.Finally, note that the nashorn-compat mode enables the relevant flags when executing code on the ScriptEngine (but not on Context), to provide better compatibilty with Nashorn in that setup.Launcher Name jsGraalVM JavaScript comes with a binary launcher named js.Note that, depending on the build setup, GraalVM might still ship Nashorn and its jjs launcher.ScriptEngine Name graal.jsGraalVM JavaScript is shipped with support for ScriptEngine.It registers under several names, including “graal.js”, “JavaScript”, and “js”.Be sure to activate the Nashorn compatibility mode as described above if you need full Nashorn compatibility.Depending on the build setup, GraalVM might still ship Nashorn and provide it via ScriptEngine.For more details, see ScriptEngine Implementation.ClassFilterGraalVM JavaScript supports a class filter when starting with a polyglot Context.See Context.Builder.hostClassFilter.Fully Qualified NamesGraalVM Javascript requires the use of Java.type(typename).It does not support accessing classes just by their fully qualified class name by default.Java.type brings more clarity and avoids the accidental use of Java classes in JavaScript code.For instance, look at this pattern:var bd = new java.math.BigDecimal(&#39;10&#39;);It should be expressed as:var BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;);var bd = new BigDecimal(&#39;10&#39;);Lossy ConversionGraalVM JavaScript does not allow lossy conversions of arguments when calling Java methods.This could lead to bugs with numeric values that are hard to detect.GraalVM JavaScript will always select the overloaded method with the narrowest possible argument types that can be converted to without loss.If no such overloaded method is available, GraalVM JavaScript throws a TypeError instead of lossy conversion.In general, this affects which overloaded method is executed.Custom targetTypeMappings can be used to customize behaviour. See HostAccess.Builder#targetTypeMapping.ScriptObjectMirror ObjectsGraalVM JavaScript does not provide objects of the class ScriptObjectMirror.Instead, JavaScript objects are exposed to Java code as objects implementing Java’s Map interface.Code referencing ScriptObjectMirror instances can be rewritten by changing the type to either an interface (Map or List) or the polyglot Value class which provides similar capabilities.MultithreadingRunning JavaScript on GraalVM supports multithreading by creating several Context objects from Java code.Contexts can be shared between threads, but each context must be accessed by a single thread at a time.Multiple JavaScript engines can be created from a Java application, and can be safely executed in parallel on multiple threads:Context polyglot = Context.create();Value array = polyglot.eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);GraalVM JavaScript does not allow the creation of threads from JavaScript applications with access to the current Context.Moreover, GraalVM JavaScript does not allow concurrent threads to access the same Context at the same time.This could lead to unmanagable synchronization problems like data races in a language that is not prepared for multithreading. For example:new Thread(function() {    print(&#39;printed from another thread&#39;); // throws Exception due to potential synchronization problems}).start();JavaScript code can create and start threads with Runnables implemented in Java.The child thread may not access the Context of the parent thread or of any other polyglot thread.In case of violations, an IllegalStateException will be thrown.A child thread may create a new Context instance, though.new Thread(aJavaRunnable).start(); // allowed on GraalVM JavaScriptWith proper synchronization in place, multiple contexts can be shared between different threads. The example Java applications using GraalVM JavaScript Contexts from multiple threads can be found here.Extensions Only Available in Nashorn Compatibility ModeThe following extensions to JavaScript available in Nashorn are deactivated in GraalVM JavaScript by default.They are provided in GraalVM’s Nashorn compatibility mode.It is highly recommended not to implement new applications based on those features, but only to use it as a means to migrate existing applications to GraalVM.String length PropertyGraalVM JavaScript does not treat the length property of a String specially.The canonical way of accessing the String length is reading the length property:myJavaString.length;Nashorn allows users to access length as both a property and a function.Existing function calls length() should be expressed as property access.Nashorn behavior is mimicked in the Nashorn compatibility mode.Java Packages in the JavaScript Global ObjectGraalVM JavaScript requires the use of Java.type instead of fully qualified names.In the Nashorn compatibility mode, the following Java packages are added to the JavaScript global object: java, javafx, javax, com, org, and edu.JavaImporterThe JavaImporter feature is available only in the Nashorn compatibility mode.JSAdapterThe use of the non-standard JSAdapter feature is discouraged and should be replaced with the equivalent standard Proxy feature.For compatibility, JSAdapter is still available in the Nashorn compatibility mode.Java.* MethodsSeveral methods provided by Nashorn on the Java global object are available only in the Nashorn compatibility mode, or currently not supported by GraalVM JavaScript.Available in the Nashorn compatibility mode are: Java.isJavaFunction, Java.isJavaMethod, Java.isScriptObject, and Java.isScriptFunction. Java.asJSONCompatible is currently not supported.AccessorsIn the Nashorn compatibility mode, GraalVM JavaScript allows users to access getters and setters just by using the names as properties, while omitting get, set, or is:var Date = Java.type(&#39;java.util.Date&#39;);var date = new Date();var myYear = date.year; // calls date.getYear()date.year = myYear + 1; // calls date.setYear(myYear + 1);GraalVM JavaScript mimics the behavior of Nashorn regarding the ordering of the access:  In case of a read operation, GraalVM JavaScript will first try to call a getter with the name get and the property name in camel case. If that is not available, a getter with the name is and the property name in camel case is called. In the second case, unlike Nashorn, the resulting value is returned even if it is not of type boolean. Only if both methods are not available, the property itself will be read.  In case of a write operation, GraalVM JavaScript will try to call a setter with the name set and the property name in camel case, providing the value as argument to that function. If the setter is not available, the property itself will be written.Note that Nashorn (and thus, GraalVM JavaScript) makes a clear distinction between property read/writes and function calls.When the Java class has both a field and a method of the same name publicly available, obj.property will always read the field (or the getter as discussed above), while obj.property() will always call the respective method.Additional Aspects to ConsiderFeatures of GraalVM JavaScriptGraalVM JavaScript supports features of the newest ECMAScript specification and some extensions to it. See JavaScript Compatibility. Note that this example adds objects to the global scope that might interfere with existing source code unaware of those extensions.Console OutputGraalVM JavaScript provides a print builtin function compatible with Nashorn.Note that GraalVM JavaScript also provides a console.log function.This is an alias for print in pure JavaScript mode, but uses an implementation provided by Node.js when running in Node mode.The behaviour around Java objects differs for console.log in Node mode as Node.js does not implement special treatment for such objects.",
                    "url": " /reference-manual/js/NashornMigrationGuide/"
                  },
                  
                  "reference-manual-llvm-nativeexecution":  {
                    "title": "",
                    "content": "Limitations and Differences to Native ExecutionLLVM code interpreted or compiled with the default configuration of GraalVM Community or Enterprise editions will not have the same characteristics as the same code interpreted or compiled in a managed environment, enabled with the --llvm.managed option on top of GraalVM Enterprise.The behaviour of the lli interpreter used to directly execute programs in LLVM bitcode format differs between native and managed modes.The difference lies in safety guarantees and cross-language interoperability.Note: Managed execution mode for LLVM bitcode is possible with GraalVM Enterprise only.In the default configuration, cross-language interoperability requires bitcodeto be compiled with the debug information enabled (-g), and the -mem2regoptimization performed on LLVM bitcode (compiled with at least -O1, orexplicitly using the opt tool). These requirements can be overcome in amanaged environment of GraalVM Enterprise that allows native code to participate in thepolyglot programs, passing and receiving the data from any other supportedlanguage. In terms of security, the execution of native code in a managedenvironment passes with additional safety features: catching illegal pointeraccesses, accessing arrays outside of the bounds, etc.There are certain limitations and differences to the native execution depending on the GraalVM edition.Consider them respectively.Limitations and Differences to Native Execution on Top of GraalVM CommunityThe LLVM interpreter in GraalVM Community Edition environment allows executing LLVM bitcode within amultilingual context. Even though it aspires to be a generic LLVM runtime, thereare certain fundamental and/or implementational limitations that users need tobe aware of.The following restrictions and differences to native execution (i.e., bitcode compiled down to native code) exist when LLVM bitcode is executed with the LLVM interpreter on top of GraalVM Community:  The GraalVM LLVM interpreter assumes that bitcode was generated to target the x86_64 architecture.  Bitcode should be the result of compiling C/C++ code using clang version 7, other compilers/languages, e.g., Rust, might have specific requirements that are not supported.  Unsupported functionality – it is not possible to call any of the following functions:          clone()      fork()      vfork()      setjmp(), sigsetjmp(), longjmp(), siglongjmp()      Functions of the exec() function family      Pthread functions      Code running in the LLVM interpreter needs to be aware that a JVM is running in the same process, so many syscalls such as fork, brk, sbrk, futex, mmap, rt_sigaction, rt_sigprocmask, etc. might not work as expected or cause the JVM to crash.      Calling unsupported syscalls or unsupported functionality (listed above) via native code libraries can cause unexpected side effects and crashes.        Thread local variables          Thread local variables from bitcode are not compatible with thread local variables from native code.        Cannot rely on memory layout          Pointers to thread local variables are not stored in specific locations, e.g., the FS segment.      The order of globals in memory might be different, consequently no assumptions about their relative locations can be made.      Stack frames cannot be inspected or modified using pointer arithmetic (overwrite return address, etc.).      Walking the stack is only possible using the Truffle APIs.      There is a strict separation between code and data, so that reads, writes and pointer arithmetic on function pointers or pointers to code will lead to undefined behavior.        Signal handlers          Installing signal handlers is not supported.        The stack          The default stack size is not set by the operating system but by the option --llvm.stackSize.        Dynamic linking          Interacting with the LLVM bitcode dynamic linker is not supported, e.g., dlsym/dlopen can only be used for native libraries.      The dynamic linking order is undefined if native libraries and LLVM bitcode libraries are mixed.      Native libraries cannot import symbols from bitcode libraries.        x86_64 inline assembly is not supported.  Undefined behavior according to C spec          While most C compilers map undefined behavior to CPU semantics, the GraalVM LLVM interpreter might map some of this undefined behavior to Java or other semantics. Examples include: signed integer overflow (mapped to the Java semantics of an arithmetic overflow), integer division by zero (will throw an ArithmeticException), oversized shift amounts (mapped to the Java behavior).        Floating point arithmetics          Some floating point operations and math functions will use more precise operations and cast the result to a lower precision (instead of performing the operation at a lower precision).      Only the rounding mode FE_TONEAREST is supported.      Floating point exceptions are not supported.        NFI limitations (calling real native functions)          Structs, complex numbers, or fp80 values are not supported as by-value arguments or by-value return values.      The same limitation applies to calls back from native code into interpreted LLVM bitcode.        Limitations of polyglot interoperability (working with values from other GraalVM languages)          Foreign objects cannot be stored in native memory locations. Native memory locations include:                  globals (except the specific case of a global holding exactly one pointer value);          malloc’ed memory (including c++ new, etc.);          stack (e.g., escaping automatic variables).                      LLVM instruction set support (based on LLVM 7.0.1)          A set of rarely-used bitcode instructions are not available (va_arg, catchpad, cleanuppad, catchswitch, catchret, cleanupret, fneg, callbr).      The instructions with limited support:                  atomicrmw (only supports sub, add, and, nand, or, xor, xchg);          extract value and insert value (only supports a single indexing operand);          cast (missing support for certain rarely-used kinds);          atomic ordering and address space attributes of load and store instructions are ignored.                    Values – assembly constants are not supported (module-level assembly and any assembly strings).      Types:                  There is no support for 128-bit floating point types (fp128 and ppc_fp128), x86_mmx, half-precision floats (fp16) and any vectors of unsupported primitive types.          The support for fp80 is limited (not all intrinsics are supported for fp80, some intrinsics or instructions might silently fall back to fp64).                      A number of rarely-used or experimental intrinsics based on LLVM 7.0.1 are not supported because of implementational limitations or because they are out of scope:          experimental intrinsics: llvm.experimental.*, llvm.launder.invariant.group, llvm.strip.invariant.group;      trampoline intrinsics: llvm.init.trampoline, llvm.adjust.trampoline;      general intrinsics: llvm.var.annotation, llvm.ptr.annotation, llvm.annotation, llvm.codeview.annotation, llvm.trap, llvm.debugtrap, llvm.stackprotector, llvm.stackguard, llvm.ssa_copy, llvm.type.test, llvm.type.checked.load, llvm.load.relative, llvm.sideeffect;      specialised arithmetic intrinsics: llvm.canonicalize, llvm.fmuladd;      standard c library intrinsics: llvm.fma, llvm.trunc, llvm.nearbyint, llvm.round;      code generator intrinsics: llvm.returnaddress, llvm.addressofreturnaddress, llvm.frameaddress, llvm.localescape, llvm.localrecover, llvm.read_register, llvm.write_register, llvm.stacksave, llvm.stackrestore, llvm.get.dynamic.area.offset, llvm.prefetch, llvm.pcmarker, llvm.readcyclecounter, llvm.clear_cache, llvm.instrprof*, llvm.thread.pointer;      exact gc intrinsics: llvm.gcroot, llvm.gcread, llvm.gcwrite;      element wise atomic memory intrinsics: llvm.*.element.unordered.atomic;      masked vector intrinsics: llvm.masked.*;      bit manipulation intrinsics: llvm.bitreverse, llvm.fshl, llvm.fshr.      Limitations and Differences to Managed Execution on Top of GraalVM EnterpriseThe managed execution for LLVM bitcode is a GraalVM Enterprise Edition feature and can be enabled with the --llvm.managed command line option.In managed mode, the GraalVM LLVM runtime prevents access to unmanaged memory and uncontrolled calls to native code and operating system functionality.The allocations are performed in the managed Java heap, and accesses to the surrounding system are routed through proper Language API and Java API calls.All the restrictions from the default native LLVM execution on GraalVM apply to the managed execution, but with the following differences/changes:  Platform independent          Bitcode must be compiled for the generic linux_x86_64 target using the provided musl libc library on all platforms, regardless of the actual underlying operating system.        C++          C++ on managed mode requires GraalVM 20.1 or newer.        Native memory and code          Calls to native functions are not possible. Thus only the functionality provided in the supplied musl libc and by the GraalVM LLVM interface is available.      Loading native libraries is not possible.      Native memory access is not possible.        System calls          System calls with only limited support are read, readv, write, writev, open, close, dup, dup2, lseek, stat, fstat, lstat, chmod, fchmod, ioctl, fcntl, unlink, rmdir, utimensat, uname, set_tid_address, gettid, getppid, getpid, getcwd, exit, exit_group, clock_gettime, and arch_prctl.      The functionality is limited to common terminal IO, process control, and file system operations.      Some syscalls are implemented as a noop and/or return error warning that they are not available, e.g., chown, lchown, fchown, brk, rt_sigaction, sigprocmask, and futex.        Musl libc          The musl libc library behaves differently than the more common glibc in some cases.        The stack          Accessing the stack pointer directly is not possible.      The stack is not contiguous, and accessing memory that is out of the bounds of a stack allocation (e.g., accessing neighboring stack value using pointer arithmetics) is not possible.        Pointers into the managed heap          Reading parts of a managed pointer is not possible.      Overwriting parts of a managed pointer (e.g., using bits for pointer tagging) and subsequently dereferencing the destroyed managed pointer is not possible.      Undefined behavior in C pointer arithmetics applies.      Complex pointer arithmetics (e.g., multiplying pointers) can convert a managed pointer to an i64 value. The i64 value can be used in pointer comparisons but cannot be dereferenced.        Floating point arithmetics          80-bit floating points only use 64-bit floating point precision.        Dynamic linking          The interaction with the LLVM bitcode dynamic linker is not supported, e.g., dlsym/dlopen cannot be used. This does not allow to load native code.      ",
                    "url": " /reference-manual/llvm/NativeExecution/"
                  },
                  
                  "reference-manual-native-image-nativeimageheapdump":  {
                    "title": "",
                    "content": "Generating Heap Dumps from Native ImagesWith GraalVM Enterprise Edition you can generate heap dumps of the Native Image processes to monitor the execution.Native Image does not implement JVMTI agent and it is not possible to triggerheap dump creation using tools like VisualVM or jmap. You can build a native image for your application in a way so that it can handle certain signals and then get a heapdump when the application receives the USR1 signal (other supported signals are QUIT/BREAK for stackdumps and USR2 to dump runtime compilation info). You only need to build your image with GraalVM Enterprise Native Image and use the -H:+AllowVMInspection option.Another possibility is towrite a special method which will generate a heap dump at certain points in thelifetime of your application. For example, when certain conditions are met whileexecuting a native image, your application code can trigger heap dump creation.A dedicated org.graalvm.nativeimage.VMRuntime#dumpHeap API exists for thispurpose. Both possibilities are covered in this guide.Note: This feature is available with GraalVM Enterprise only.Handle SIGUSR1 SignalThe following Java example is a simple multi-threaded application which runs for60 seconds. There is enough time to get its PID and send the SIGUSR1 signalwhich will generate a heap dump into the application’s working directory. Savethe following code as SVMHeapDump.java file on your disk:import java.text.DateFormat;import java.util.Date;public class SVMHeapDump extends Thread {    static int i = 0;    static int runs = 60;    static int sleepTime = 1000;    @Override    public void run() {        System.out.println(DateFormat.getDateTimeInstance().format(new Date()) + &quot;: Thread started, it will run for &quot; + runs + &quot; seconds&quot;);        while (i &amp;lt; runs){            System.out.println(&quot;Sleeping for &quot; + (runs-i) + &quot; seconds.&quot; );            try {                Thread.sleep(sleepTime);            } catch (InterruptedException ie){                System.out.println(&quot;Sleep interrupted.&quot;);            }            i++;        }    }    /**     * @param args the command line arguments     */    public static void main(String[] args) throws InterruptedException {        StringBuffer sb1 = new StringBuffer(100);        sb1.append(DateFormat.getDateTimeInstance().format(new Date()));        sb1.append(&quot;: Hello GraalVM native image developer! nGet PID of this process: &quot;);        sb1.append(&quot;&#39;ps -C svmheapdump -o pid= &#39;n&quot;);        sb1.append(&quot;then send it signal: &quot;);        sb1.append(&quot;&#39;kill -SIGUSR1 &amp;lt;pid_printed_above&amp;gt;&#39; n&quot;);        sb1.append(&quot;to get heap dump generated into working directory.n&quot;);        sb1.append(&quot;Starting thread!&quot;);        System.out.println(sb1);        SVMHeapDump t = new SVMHeapDump();        t.start();        while (t.isAlive()) {            t.join(0);        }        sb1 = new StringBuffer(100);        sb1.append(DateFormat.getDateTimeInstance().format(new Date()));        sb1.append(&quot;: Thread finished after: &quot;);        sb1.append(i);        sb1.append(&quot; iterations.&quot;);        System.out.println(sb1);    }}Build a Native ImageCompile SVMHeapDump.java as following:$JAVA_HOME/bin/javac SVMHeapDump.javaIf you run it on java, you will see that it runs for 60 seconds then finishes.Build a native executable and provide the -H:+AllowVMInspection option for thebuilder. This way the native executable will accept SIGUSR1 signal to produce aheap dump.$JAVA_HOME/bin/native-image SVMHeapDump -H:+AllowVMInspection[svmheapdump:41691]    classlist:     412.03 ms,  2.52 GB[svmheapdump:41691]        (cap):   1,655.34 ms,  2.52 GB[svmheapdump:41691]        setup:   2,741.18 ms,  2.52 GB[svmheapdump:41691]     (clinit):     190.08 ms,  2.59 GB[svmheapdump:41691]   (typeflow):   5,231.29 ms,  2.59 GB[svmheapdump:41691]    (objects):   6,489.13 ms,  2.59 GB[svmheapdump:41691]   (features):     203.11 ms,  2.59 GB[svmheapdump:41691]     analysis:  12,394.98 ms,  2.59 GB[svmheapdump:41691]     universe:     425.55 ms,  2.59 GB[svmheapdump:41691]      (parse):   1,418.69 ms,  2.59 GB[svmheapdump:41691]     (inline):   1,289.94 ms,  2.59 GB[svmheapdump:41691]    (compile):  21,338.61 ms,  2.62 GB[svmheapdump:41691]      compile:  24,795.01 ms,  2.62 GB[svmheapdump:41691]        image:   1,446.14 ms,  2.62 GB[svmheapdump:41691]        write:   5,482.12 ms,  2.62 GB[svmheapdump:41691]      [total]:  47,805.47 ms,  2.62 GBThe native-image builder analyzes existing SVMHeapDump.class and creates fromit an executable file. When the command completes, svmheapdump is created inthe current directory.Run the application and check the heap dumpRun the application:./svmheapdumpMay 15, 2020, 4:28:14 PM: Hello GraalVM native image developer!Get PID of this process: &#39;ps -C svmheapdump -o pid= &#39;then send it signal: &#39;kill -SIGUSR1 &amp;lt;pid_printed_above&amp;gt;&#39;to get heap dump generated into working directory.Starting thread!May 15, 2020, 4:28:14 PM: Thread started, it will run for 60 secondsOpen the 2nd terminal to get the process ID of the running svmheapdumpapplication using a command like ps -C svmheapdump -o pid= for Linux OS andpgrep svmheapdump for macOS. Copy the printed process ID, e.g. 100, and use itto send the signal to the running application:kill -SIGUSR1 100The heap dump will be available at the working directory while the application continues to run.Generate a Heap Dump from within a Java ApplicationThe following Java example shows how a heap dump can be generated from withina running Java application using VMRuntime.dumpHeap() after some condition is met.The condition to generate a heap dump is provided as an option on the command line.Save the code snippet below as SVMHeapDumpAPI.java.import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.text.DateFormat;import java.util.Date;import org.graalvm.nativeimage.VMRuntime;public class SVMHeapDumpAPI {    /**     * @param args the command line arguments     */    public static void main(String[] args) {        StringBuffer sb1 = new StringBuffer(100);        sb1.append(DateFormat.getDateTimeInstance().format(new Date()));        sb1.append(&quot;: Hello GraalVM native image developer. nYour command line options are: &quot;);        String liveArg = &quot;true&quot;;        if (args.length &amp;gt; 0) {            sb1.append(args[0]);            System.out.println(sb1);            if (args[0].equalsIgnoreCase(&quot;--heapdump&quot;)){                if(args.length &amp;gt; 1 ) {                  liveArg = args[1];                }                createHeapDump(Boolean.valueOf(liveArg));            }        } else {            sb1.append(&quot;None&quot;);            System.out.println(sb1);        }     }    /**     * Generate heap dump and save it into temp file     */     private static void createHeapDump(boolean live) {     try {         File file = File.createTempFile(&quot;SVMHeapDump-&quot;, &quot;.hprof&quot;);         VMRuntime.dumpHeap(file.getAbsolutePath(), live);         System.out.println(&quot;  Heap dump created &quot; + file.getAbsolutePath() + &quot;, size: &quot; + file.length());     } catch (UnsupportedOperationException unsupported) {         System.out.println(&quot;  Heap dump creation failed.&quot; + unsupported.getMessage());     } catch (IOException ioe) {         System.out.println(&quot;IO went wrong: &quot; + ioe.getMessage());     } }}The application creates some data to have something to dump, checks the command lineto see if heap dump has to be created, and then in method createHeapDump() createsthe actual heap dump, performing checks for file’s existence.Building a Native ImageIn the next step, compile SVMHeapDumpAPI.java:$JAVA_HOME/bin/javac SVMHeapDumpAPI.javaThen build a native executable:$JAVA_HOME/bin/native-image SVMHeapDumpAPI[svmheapdumpapi:41691]    classlist:     447.96 ms,  2.53 GB[svmheapdumpapi:41691]        (cap):   2,105.64 ms,  2.53 GB[svmheapdumpapi:41691]        setup:   3,010.19 ms,  2.53 GB[svmheapdumpapi:41691]     (clinit):     178.51 ms,  2.61 GB[svmheapdumpapi:41691]   (typeflow):   9,153.49 ms,  2.61 GB[svmheapdumpapi:41691]    (objects):   9,170.40 ms,  2.61 GB[svmheapdumpapi:41691]   (features):     347.67 ms,  2.61 GB[svmheapdumpapi:41691]     analysis:  19,208.00 ms,  2.61 GB[svmheapdumpapi:41691]     universe:     390.40 ms,  2.61 GB[svmheapdumpapi:41691]      (parse):   1,519.70 ms,  2.63 GB[svmheapdumpapi:41691]     (inline):   1,072.87 ms,  2.63 GB[svmheapdumpapi:41691]    (compile):  36,028.90 ms,  2.61 GB[svmheapdumpapi:41691]      compile:  40,595.67 ms,  2.61 GB[svmheapdumpapi:41691]        image:   2,384.57 ms,  2.61 GB[svmheapdumpapi:41691]        write:   3,161.35 ms,  2.63 GB[svmheapdumpapi:41691]      [total]:  69,300.73 ms,  2.63 GBWhen the command completes, the svmheapdumpapi executable is created in the current directory.Run the application and check the heap dumpNow you can run your native image application and generate a heap dump from itwith the output similar to one below:./svmheapdumpapi --heapdumpSep 15, 2020, 4:06:36 PM: Hello GraalVM native image developer.Your command line options are: --heapdump  Heap dump created /var/folders/hw/s9d78jts67gdc8cfyq5fjcdm0000gp/T/SVMHeapDump-6437252222863577987.hprof, size: 8051959The resulting heap dump can be then opened with the VisualVM tool like any other Java heap dump.",
                    "url": " /reference-manual/native-image/NativeImageHeapdump/"
                  },
                  
                  "reference-manual-native-image-nativeimagemavenplugin":  {
                    "title": "",
                    "content": "Native Image Maven PluginTo simplify the generation of native images, Native Image now works outof Maven with the Native Image Maven Plugin.You can build a native executable directly with Maven using the mvn package command without running the native-image command as a separate step.However, the Maven project that uses the plugin should be built on a JDK containing the native-image tool in &amp;lt;java.home&amp;gt;/lib/svm/bin/native-image (or &amp;lt;java.home&amp;gt;/jre/lib/svm/bin/native-image for a Java 8 JDK).GraalVM is such a JDK (if native-image has been previously installed with gu).Next, add native-image-maven-plugin into the &amp;lt;plugins&amp;gt; section of the pom.xml file:&amp;lt;plugin&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.nativeimage&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;native-image-maven-plugin&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.version}&amp;lt;/version&amp;gt;    &amp;lt;executions&amp;gt;        &amp;lt;execution&amp;gt;            &amp;lt;goals&amp;gt;                &amp;lt;goal&amp;gt;native-image&amp;lt;/goal&amp;gt;            &amp;lt;/goals&amp;gt;            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;        &amp;lt;/execution&amp;gt;    &amp;lt;/executions&amp;gt;    &amp;lt;configuration&amp;gt;        &amp;lt;skip&amp;gt;false&amp;lt;/skip&amp;gt;        &amp;lt;imageName&amp;gt;example&amp;lt;/imageName&amp;gt;        &amp;lt;buildArgs&amp;gt;            --no-fallback        &amp;lt;/buildArgs&amp;gt;    &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;Last, add the org.graalvm.sdk library dependency in the &amp;lt;dependencies&amp;gt; list:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.sdk&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;graal-sdk&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.version}&amp;lt;/version&amp;gt;    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;The plugin figures out which JAR files it needs to pass to the native image andwhat the executable main class should be. If the heuristics fails with the no main manifest attribute, in target/&amp;lt;name&amp;gt;.jar error, the main class should bespecified in the &amp;lt;configuration&amp;gt; node of the plugin. When mvn package completes, an executable is ready for use, generated in the target directory of the project.Maven Plugin CustomizationIf you use Native Image Maven plugin, it will pick up all the configuration for your application stored below the  META-INF/native-image/ resource location, as described in Native Image Build Configuration.It is also possible to customize the plugin within a&amp;lt;configuration&amp;gt; node. The following configurations are available.  Configuration parameter &amp;lt;mainClass&amp;gt;: if the execution fails with the no main manifest attribute, in target/&amp;lt;name&amp;gt;.jar error, the main class should be specified. By default the plugin consults several locations in the  pom.xml file in the following order to determine what the main class of the image should be:          &amp;lt;maven-shade-plugin&amp;gt; &amp;lt;transformers&amp;gt; &amp;lt;transformer&amp;gt; &amp;lt;mainClass&amp;gt;      &amp;lt;maven-assembly-plugin&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;mainClass&amp;gt;      &amp;lt;maven-jar-plugin&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;mainClass&amp;gt;        Configuration parameter &amp;lt;imageName&amp;gt;: if an image filename is not set explicitly, use parameter &amp;lt;imageName&amp;gt; to provide a custom filename for the image.  Configuration parameter &amp;lt;buildArgs&amp;gt;: if you want to pass additional options for to the native image builder, use the &amp;lt;buildArgs&amp;gt; parameter in the definition of the plugin. For example, to build a native image with assertions enabled that uses com.test.classname as a main class, add:&amp;lt;configuration&amp;gt;    &amp;lt;imageName&amp;gt;executable-name&amp;lt;/imageName&amp;gt;    &amp;lt;mainClass&amp;gt;com.test.classname&amp;lt;/mainClass&amp;gt;    &amp;lt;buildArgs&amp;gt;        --no-fallback    &amp;lt;/buildArgs&amp;gt;    &amp;lt;skip&amp;gt;false&amp;lt;/skip&amp;gt;&amp;lt;/configuration&amp;gt;If you use GraalVM Enterprise as the JAVA_HOME environment, the plugin builds a native image with Enterprise features enabled, e.g., an executable will automatically be built with compressed references and other optimizations enabled.Reusing configuration from a parent POMThe &amp;lt;buildArgs&amp;gt; element can be combined between parent and children POM. Suppose the following parent POM definition:&amp;lt;plugin&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.nativeimage&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;native-image-maven-plugin&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;${graalvm.version}&amp;lt;/version&amp;gt;    &amp;lt;configuration&amp;gt;        &amp;lt;imageName&amp;gt;${project.artifactId}&amp;lt;/imageName&amp;gt;        &amp;lt;mainClass&amp;gt;${exec.mainClass}&amp;lt;/mainClass&amp;gt;        &amp;lt;buildArgs&amp;gt;            &amp;lt;buildArg&amp;gt;--no-fallback&amp;lt;buildArg&amp;gt;        &amp;lt;/buildArgs&amp;gt;    &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;Children projects have the ability to append &amp;lt;buildArg&amp;gt;s in the following way:&amp;lt;plugin&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.nativeimage&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;native-image-maven-plugin&amp;lt;/artifactId&amp;gt;    &amp;lt;configuration&amp;gt;        &amp;lt;buildArgs combine.children=&quot;append&quot;&amp;gt;            &amp;lt;buildArg&amp;gt;--verbose&amp;lt;/buildArg&amp;gt;        &amp;lt;/buildArgs&amp;gt;    &amp;lt;/configuration&amp;gt;&amp;lt;/plugin&amp;gt;In this case, the arguments that will be passed to the native-image executable will be:--no-fallback --verbose",
                    "url": " /reference-manual/native-image/NativeImageMavenPlugin/"
                  },
                  
                  "reference-manual-js-nodejs":  {
                    "title": "",
                    "content": "Node.js RuntimeGraalVM can run unmodified Node.js applications.Applications can freely import and use NPM packages, including native ones.For the differences between running the node native launcher and accessing Node.js/npm modules/ECMAScript modules from a Java Context, see NodeJSVSJavaScriptContext.Installing the Node.js componentSince GraalVM 21.1, the Node.js support is packaged in a separate GraalVM component.It can be installed with the GraalVM Updater.$GRAALVM/bin/gu install nodejsThis installs the node and npm binaries in the $GRAALVM/bin directory.Polyglot support in Node.jsThe Node.js component is able to use the polyglot language interoperability (flag: --polyglot) with other installed polyglot languages.This feature is available by default in JVM mode (flag: --jvm).For polyglot access to the Ruby language, you can e.g. use this command:$GRAALVM/bin/node --jvm --polyglot -e &#39;var array = Polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;); console.log(array[2]);&#39;To use the polyglot capabilities of node in the native mode (flag: --native), the libpolyglot needs to be rebuilt first.For this, the native-image component and the other languages need to be installed first, before the image can be rebuilt:$GRAALVM/bin/gu install native-image$GRAALVM/bin/gu rebuild-images libpolyglotAfter a successfull rebuild, the polyglot access is also available in the --native mode:$GRAALVM/bin/node --native --polyglot -e &#39;var array = Polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;); console.log(array[2]);&#39;Running Node.js ApplicationsTo run Node.js-based applications, use the node launcher in the GraalVM distribution:$GRAALVM_HOME/bin/node [options] [filename] [args]GraalVM’s Node.js runtime is based on a recent version of Node.js, and runs theGraalVM JavaScript engine instead of Google V8. Thus, some internal features (e.g., VM-internal statistics, configuration, profiling, debugging, etc.) are unsupported, or supported with potentially different behavior.The node command is largely compatible with Node.js, and features additional GraalVM-specific functionalities (e.g., interoperability with Java and all other GraalVM languages).A list of available options can be obtained with node --help.Installing Packages Using npmTo install a Node.js package, you can use the npm launcher from the GraalVM’s /bin folder.The npm command is equivalent to the default NPM command, and supports most of its options.An NPM package can be installed with:$GRAALVM_HOME/bin/npm install &amp;lt;package&amp;gt;As the npm command of GraalVM is largely compatible with NPM, packages will be installed in the node_modules folder, as expected.Installing npm Packages GloballyNode packages can be installed globally using npm and the -g option.By default, npm installs global packages (links to their executables) in the path where the node executable is installed, typically NODE/bin.In GraalVM, while there is a node executable in GRAALVM/bin, this is just a link to the actual executable in the GRAALVM/jre/languages/js/bin folder.That folder is where global packages are installed.You might want to add that directory to your $PATH if you regularly use globally installed packages, especially their command line interfaces.Another option is to specify the global installation folder of npm by setting the $PREFIX environment variable, or by specifying the --prefix option when running npm install.For example, the following command will install global packages in the /foo/bar folder:$GRAALVM_HOME/bin/npm install --prefix /foo/bar -g &amp;lt;package&amp;gt;More details about prefix can be found in the official NPM documentation.",
                    "url": " /reference-manual/js/NodeJS/"
                  },
                  
                  "reference-manual-js-nodejsvsjavascriptcontext":  {
                    "title": "",
                    "content": "Differences Between Node.js and Java EmbeddingsGraalVM provides a fully-compliant ECMAScript 2020 JavaScript language runtime.As such, it can run JavaScript code in a variety of embedding scenarios, including Oracle Database, any Java-based application, and Node.js.Depending on the GraalVM’s JavaScript embedding scenario, applications have access to different built-in capabilities.For example, Node.js applications executed using GraalVM’s bin/node executable have access to all of Node.js’ APIs, including built-in Node.js modules such as fs, http, etc.Conversely, JavaScript code embedded in a Java application has access to limited capabilities, as specified through the Context API, and do not have access to Node.js built-in modules.This guide describes the main differences between a Node.js application and a GraalVM JavaScript application embedded in Java.Context CreationJavaScript code in GraalVM can be executed using a GraalVM execution Context.In a Java application, a new context can be created using the Context API.New contexts can be configured in multiple ways, and configuration options include exposing access to Java classes, allowing access to IO, etc.A list of context creation options can be found in the API documentation.In this scenario, Java classes can be exposed to JavaScript by using GraalVM’s polyglot Bindings.In a Node.js application, the GraalVM Context executing the application is pre-initialized by the Node.js runtime, and cannot be configured by the user application.In this scenario, Java classes can be exposed to the Node.js application by using the --vm.cp= command line option of the bin/node command, as described below.Java InteroperabilityJavaScript applications can interact with Java classes using the Java built-in object.The object is not available by default, and can be enabled in the following way:  In Node.js mode, start GraalVM using the bin/node --jvm command.  In Java, create a GraalVM context using the withHostInterop() option, e.g.:    Context.create(&quot;js&quot;).withHostInterop()    More details on the Java interoperability capabilities of GraalVM JavaScript are available in Java Interoperability.  MultithreadingA GraalVM context running JavaScript enforces a “share-nothing” model of parallelism: no JavaScript values can be accessed by two concurrent Java threads at the same time.In order to leverage parallel execution, multiple contexts have to be created and executed from multiple threads:  In Node.js mode, multiple contexts can be created using Node.js’ Worker threads API.The Worker threads API ensures that no sharing can happen between two parallel contexts.  In Java, multiple contexts can be executed from multiple threads.As long as a context is not accessed by two threads at the same time, parallel execution happens safely.More details on parallel execution in GraalVM JavaScript are available in this blog post.Java LibrariesJava libraries can be accessed from JavaScript in GraalVM through the Java built-in object.In order for a Java library to be accessible from a Context, its jar files need to be added to the GraalVM classpath. This can be done in the following way:  In Node.js mode, the classpath can be modified using the --jvm.cp option.  In Java, the default Java’s -cp option can be used.More details on GraalVM command line options are available in Options.JavaScript Packages and ModulesMany popular JavaScript modules such as those available on the npm package registry can be used from Node.js as well as from Java:  In Node.js mode, JavaScript modules are handled by the Node.js runtime.Therefore, GraalVM JavaScript supports all modules supported by Node.js (including ES modules, CommonJS modules, and native modules).  In Java mode, GraalVM JavaScript can execute any JavaScript module or package that does not depend on native Node.js built-in modules (such as &#39;fs&#39;, &#39;http&#39;, etc.)Modules can be loaded using a package bundler, or using the available built-in mechanisms for ES modules.CommonJS modules are supported in Java mode under an experimental flag.More details on JavaScript modules are available in Modules.",
                    "url": " /reference-manual/js/NodeJSvsJavaScriptContext/"
                  },
                  
                  "reference-manual-java-operations":  {
                    "title": "",
                    "content": "JVM Operations ManualRunning the GraalVM Compiler in Native Image vs on the JVMWhen running the GraalVM compiler on the JVM, it goes through the same warm-up phase that therest of the Java application does. That is, it is first interpreted beforeits hot methods are compiled. This can translate into slightly longer timesuntil the application reaches peak performance when compared to the native compilersin the JVM such as C1 and C2.To address the issue of taking longer to reach to peak performance, libgraalwas introduced – a shared library, produced using Native Image to ahead-of-time compile the compiler itself. That means the GraalVM Enterprisecompiler is deployed as a native shared library.In this mode, thecompiler uses memory separate from the HotSpot heap, and it runs compiled fromthe start. Therefore it has execution properties similar to other native HotSpotcompilers such as C1 and C2. Currently, this is the default mode ofoperation. It can be disabled with -XX:-UseJVMCINativeLibrary.Measuring PerformanceThe first thing to be sure of when measuring performance is to ensure the JVM is using the GraalVM Enterprise compiler.In the GraalVM binary, the JVM is configured to use the GraalVM compileras the top tier compiler by default. You can confirm this by adding -Dgraal.ShowConfiguration=infoto the command line. It will produce a line of output similar to the one belowwhen the compiler is initialized:Using Graal compiler configuration &#39;community&#39; provided by org.graalvm.compiler.hotspot.CommunityCompilerConfigurationFactory loaded from jar:file:/Users/dsimon/graal/graal/compiler/mxbuild/dists/graal.jar!/org/graalvm/compiler/hotspot/CommunityCompilerConfigurationFactory.classNote: The GraalVM compiler is only initialized on the first top-tier JIT compilation requestso if your application is short-lived, you may not see this output.Optimizing JVM-based applications is a science in itself. The compilation may noteven be a factor in the case of poor performance as the problem maylie in any other part of the VM (I/O, garbage collection, threading, etc), or ina poorly written application or 3rd party library code. For this reason, it’sworth utilizing the JDK Mission Control tool chain todiagnose the application behavior.You can also compare performance against the native top-tier compiler in the JVM byadding -XX:-UseJVMCICompiler to the command line.If you observe a significant performance regression when using the GraalVM compiler, pleaseopen an issue on GitHub. Attaching a Java Flight Recorder log and instructionsto reproduce the issue makes investigation easier and thus thechances of a fix higher. Even better is if you can submit a JMHbenchmark that represents the hottest parts of your application (as identifiedby a profiler). This allows us to very quickly pinpoint missing optimizationopportunities or to offer suggestions on how to restructure the code toavoid or reduce performance bottlenecks.Troubleshooting the GraalVM CompilerLike all software, the GraalVM compiler is not guaranteed to be bug free so it is useful toknow how to diagnose and submit useful bug reports if you encounter issues.If you spot a security vulnerability, please do not report it via GitHub Issues or the public mailing lists,but via the process outlined at Reporting Vulnerabilities guide.Compilation ExceptionsOne advantage of the compiler being written in Java is that runtime exceptions duringcompilation are not fatal VM errors. Instead, each compilation has an exceptionhandler that takes action based on the graal.CompilationFailureActionproperty.The default value is Silent. Specifying Diagnose causes failing compilations to be retriedwith extra diagnostics enabled. In this case, just before the VM exits, all diagnostic outputcaptured during retried compilations is written to a .zip file and its locationis printed on the console:Graal diagnostic output saved in /Users/demo/graal-dumps/1499768882600/graal_diagnostics_64565.zipYou can then attach the .zip file to an issue on GitHub.Apart from Silent and Diagnose, the following values for graal.CompilationFailureActionare also supported:  Print: prints a message and stack trace to the console but does not perform the re-compilation.  ExitVM: same as Diagnose but the VM process exits after the re-compilation.Code Generation ErrorsThe other type of error you might encounter with compilers is the production of incorrect machine code.This error can cause a VM crash, which should produce a file that starts withhs_err_pid in the current working directory of the VM process. In most cases,there is a section in the file that shows the stack at the time of the crash,including the type of code for each frame in the stack, as in the followingexample:Stack: [0x00007000020b1000,0x00007000021b1000],  sp=0x00007000021af7a0,  free space=1017kNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)J 761 JVMCI org.graalvm.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)V (299 bytes) @ 0x0000000108a2fc01 [0x0000000108a2fac0+0x141] (null)j  org.graalvm.compiler.core.gen.NodeLIRBuilder.doBlock(Lorg/graalvm/compiler/nodes/cfg/Block;Lorg/graalvm/compiler/nodes/StructuredGraph;Lorg/graalvm/compiler/core/common/cfg/BlockMap;)V+211j  org.graalvm.compiler.core.LIRGenerationPhase.emitBlock(Lorg/graalvm/compiler/nodes/spi/NodeLIRBuilderTool;Lorg/graalvm/compiler/lir/gen/LIRGenerationResult;Lorg/graalvm/compiler/nodes/cfg/Block;Lorg/graalvm/compiler/nodes/StructuredGraph;Lorg/graalvm/compiler/core/common/cfg/BlockMap;)V+65This example shows that the top frame was compiled (J) by the JVMCI compiler,which is the GraalVM compiler. The crash occurred at offset 0x141 in the machinecode produced for:org.graalvm.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)VThe next two frames in the stack were executed in the interpreter (j). Thelocation of the crash is also often indicated near the top of the file withsomething like this:# Problematic frame:# J 761 JVMCI org.graalvm.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)V (299 bytes) @ 0x0000000108a2fc01 [0x0000000108a2fac0+0x141] (null)In this example, there is likely an error in the code produced by the GraalVM compiler for NodeLIRBuilder.matchComplexExpressions.When filing an issue on GitHubfor such a crash, you should first attempt to reproduce the crash with extradiagnostics enabled for the compilation of the problematic method.In this example, you would add the following to your command line:-Dgraal.MethodFilter=NodeLIRBuilder.matchComplexExpressions, -Dgraal.Dump=:2These options are described in more detail here.In brief, these options tell the compiler to capture snapshots of the compiler state atverbosity level 2 while compiling any method named matchComplexExpressions ina class with a simple name of NodeLIRBuilder. The complete format of theMethodFilter option is described in the output of java -XX:+JVMCIPrintProperties.Quite often, the crash location does not exist directly in the problematic methodmentioned in the crash log but comes from an inlined method.In such a case, simply filtering for the problematic method might not capture anerroneous compilation causing a crash.To improve the likelihood of capturing an erroneous compilation, you need tobroaden the MethodFilter value. To guide this, add -Dgraal.PrintCompilation=truewhen trying to reproduce the crash so you can see what was compiled just beforethe crash.The following shows sample output from the console:HotSpotCompilation-1218        Lorg/graalvm/compiler/core/amd64/AMD64NodeLIRBuilder;                  peephole                                      (Lorg/graalvm/compiler/nodes/ValueNode;)Z           |   87ms   428B   447B  1834kBHotSpotCompilation-1212        Lorg/graalvm/compiler/lir/LIRInstructionClass;                         forEachState                                  (Lorg/graalvm/compiler/lir/LIRInstruction;Lorg/graalvm/compiler/lir/InstructionValueProcedure;)V  |  359ms    92B   309B  6609kBHotSpotCompilation-1221        Lorg/graalvm/compiler/hotspot/amd64/AMD64HotSpotLIRGenerator;          getResult                                     ()Lorg/graalvm/compiler/hotspot/HotSpotLIRGenerationResult;  |   54ms    18B   142B  1025kB## A fatal error has been detected by the Java Runtime Environment:##  SIGSEGV (0xb) at pc=0x000000010a6cafb1, pid=89745, tid=0x0000000000004b03## JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-graalvm-olabs-b13)# Java VM: OpenJDK 64-Bit GraalVM (25.71-b01-internal-jvmci-0.30 mixed mode bsd-amd64 compressed oops)# Problematic frame:# J 1221 JVMCI org.graalvm.compiler.hotspot.amd64.AMD64HotSpotLIRGenerator.getResult()Lorg/graalvm/compiler/hotspot/HotSpotLIRGenerationResult; (18 bytes) @ 0x000000010a6cafb1 [0x000000010a6caf60+0x51] (null)## Failed to write core dump. Core dumps have been disabled. To enable core dumping, try &quot;ulimit -c unlimited&quot; before starting Java againHere we see that the crash happened in a different method than the first crash.As such, we expand the filter argument to be -Dgraal.MethodFilter=NodeLIRBuilder.matchComplexExpressions,AMD64HotSpotLIRGenerator.getResultand run again.When the VM crashes in this way, it does not execute the shutdown code thatarchives the GraalVM compiler diagnostic output or delete the directory it was written to.This must be done manually after the crash.By default, the directory is $PWD/graal-dumps/&amp;lt;timestamp&amp;gt;; for example, ./graal-dumps/1499938817387.However, you can set the directory with -Dgraal.DumpPath=&amp;lt;path&amp;gt;.A message, such as the following, is printed to the console when thisdirectory is first used by the compiler:Dumping debug output in /Users/demo/graal-dumps/1499768882600This directory should contain content related to the crashing method, such as:ls -l /Users/demo/graal-dumps/1499768882600-rw-r--r--  1 demo  staff    144384 Jul 13 11:46 HotSpotCompilation-1162[AMD64HotSpotLIRGenerator.getResult()].bgv-rw-r--r--  1 demo  staff     96925 Jul 13 11:46 HotSpotCompilation-1162[AMD64HotSpotLIRGenerator.getResult()].cfg-rw-r--r--  1 demo  staff  12600725 Jul 13 11:46 HotSpotCompilation-791[NodeLIRBuilder.matchComplexExpressions(List)].bgv-rw-r--r--  1 demo  staff   1727409 Jul 13 11:46 HotSpotCompilation-791[NodeLIRBuilder.matchComplexExpressions(List)].cfgYou should attach a .zip of this directory to an issue on GitHub.",
                    "url": " /reference-manual/java/operations/"
                  },
                  
                  "reference-manual-js-operatoroverloading":  {
                    "title": "",
                    "content": "Operator OverloadingGraalVM JavaScript provides an early implementation of the ECMAScript operator overloading proposal. This lets you overload the behavior of JavaScript’s operators on your JavaScript classes.If you want to experiment with this feature, you will first need to enable it. Since both the proposal and our implementation of it are in early stages, you will need to set the following experimental option.js --experimental-options --js.operator-overloadingAfter setting the option, you will see a new builtin in the global namespace, the Operators function. You can call this function, passing it a JavaScript object as an argument. The object should have a property for every operator you wish to overload, with the key being the name of the operator and the value being a function which implements it. The return value of the Operators function is a constructor that you can then subclass when defining your type. By subclassing this constructor, you get a class whose objects will all inherit the overloaded operator behavior that you defined in your argument to the Operators function.Basic ExampleLet’s look at an example from the original proposal featuring vectors:const VectorOps = Operators({  &quot;+&quot;(a, b) {    return new Vector(a.contents.map((elt, i) =&amp;gt; elt + b.contents[i]));  },  &quot;==&quot;(a, b) {    return a.contents.length === b.contents.length &amp;amp;&amp;amp;           a.contents.every((elt, i) =&amp;gt; elt == b.contents[i]);  },});class Vector extends VectorOps {  contents;  constructor(contents) {    super();    this.contents = contents;  }}Here we define overloads for two operators, + and ==. Calling the Operators function with the table of overloaded operators yields the VectorOps class. We then define our Vector class as a subclass of VectorOps.If we create instances of Vector, we can observe that they follow our overloaded operator definitions:&amp;gt; new Vector([1, 2, 3]) + new Vector([4, 5, 6]) == new Vector([5, 7, 9])trueExample with Mixed TypesIt is also possible to overload operators between values of different types, allowing, for example, multiplication of vectors by numbers.const VectorOps = Operators({    &quot;+&quot;(a, b) {        return new Vector(a.contents.map((elt, i) =&amp;gt; elt + b.contents[i]));    },    &quot;==&quot;(a, b) {        return a.contents.length === b.contents.length &amp;amp;&amp;amp;            a.contents.every((elt, i) =&amp;gt; elt == b.contents[i]);    },}, {    left: Number,    &quot;*&quot;(a, b) {        return new Vector(b.contents.map(elt =&amp;gt; elt * a));    }});class Vector extends VectorOps {    contents;    constructor(contents) {        super();        this.contents = contents;    }}To define mixed-type operators, we need to pass additional objects to the Operators function. These extra tables should each have either a left property or a right property, depending on whether we are overloading the behavior of operators with some other type on the left or on the right side of the operator. In our case, we are overloading the * operator for cases when there is a Number on the left and our type, Vector, on the right. Each extra table can have either a left property or a right property and then any number of operator overloads which will apply to that particular case.Let’s see this in action:&amp;gt; 2 * new Vector([1, 2, 3]) == new Vector([2, 4, 6])trueReferenceThe function Operators(table, extraTables...) returns a class with overloaded operators. Users should define their own class which extends that class.The table argument must be an object with one property for every overloaded operator. The property key must be the name of the operator. These are the names of operators which can be overloaded:  binary operators: &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;%&quot;, &quot;**&quot;, &quot;&amp;amp;&quot;, &quot;^&quot;, &quot;|&quot;, &quot;&amp;lt;&amp;lt;&quot;, &quot;&amp;gt;&amp;gt;&quot;, &quot;&amp;gt;&amp;gt;&amp;gt;&quot;, &quot;==&quot;, &quot;&amp;lt;&quot;  unary operators: &quot;pos&quot;, &quot;neg&quot;, &quot;++&quot;, &quot;--&quot;, &quot;~&quot;The &quot;pos&quot; and &quot;neg&quot; operator names correspond to unary + and unary -, respectively. Overloading &quot;++&quot; works both for pre-increments ++x and post-increments x++, the same goes for &quot;--&quot;. The overload for &quot;==&quot; is used both for equality x == y and inequality x != y tests. Similarly, the overload for &quot;&amp;lt;&quot; is used for all comparison operators (x &amp;lt; y, x &amp;lt;= y, x &amp;gt; y, x &amp;gt;= y) by swapping the arguments and/or negating the result.The value assigned to an operator name must be a function of two arguments in the case of binary operators or a function of one argument in the case of unary operators.The table argument can also have an open property. If so, the value of that property must be an array of operator names. These are the operators which future classes will be able to overload on this type (e.g. a Vector type might declare &quot;*&quot; to be open so that later a Matrix type might overload the operations Vector * Matrix and Matrix * Vector). If the open property is missing, all operators are considered to be open for future overloading with other types.Following the first argument table are optional arguments extraTables. Each of these must also be an object. Each extra table must have either a left property or a right property, not both. The value of that property must be one of the following JavaScript constructors:  Number  BigInt  String  any class with overloaded operators (i.e. extended from a constructor returned by Operators)The other properties of the extra table should be operator overloads as in the first table argument (operator name as key, function implementing the operator as value).These extra tables define the behavior of operators when one of the operand types is of a type other than the one being defined. If the extra table has a left property, its operator definitions will apply to cases when the left operand is of the type named by the left property and the right operand is of the type whose operators are being defined. Similarly for the right property, if the extra table has a right property, the table’s operator definitions will apply when the right operand has the named type and the left operand has the type whose operators are being defined.Note that you are free to overload any of the binary operators between your custom type and the JavaScript numeric types Number and BigInt. However, the only operators you are allowed to overload between your custom type and the String type are &quot;==&quot; and &quot;&amp;lt;&quot;.The Operators function will return a constructor that you will usually want to extend in your own class. Instances of that class will respect your overloaded operator definitions. Whenever you use an operator on an object with overloaded operators, the following happens:1) Every operand that does not have overloaded operators is coerced to a primitive.  2) If there is an applicable overload for this pairing of operands, it is called. Otherwise, a TypeError is thrown.Notably, your objects with overloaded operators will not be coerced to primitives when applying operators and you can get TypeErrors when applying undefined operators to them. There are two exceptions to this:1) If you are using the + operator and one of the arguments is a string (or an object without overloaded operators that coerces to a string via ToPrimitive), then the result will be a concatenation of the ToString values of the two operands.  2) If you are using the == operator and there is no applicable overload found, the two operands are assumed to be different (x == y will return false and x != y will return true).Differences from the ProposalThere a few differences between the proposal (as defined by its specification and prototype implementation) and our implementation in GraalVM JavaScript:  You do not have to use the with operators from construction to enable the use of overloaded operators. When you overload operators for a class, those operators can then be used anywhere without using with operators from. Furthermore, our parser will not accept the with operators from clause as valid JavaScript.  You cannot use decorators to define overloaded operators. At the time of implementing this proposal, GraalVM JavaScript does not support decorators (these are still an in-progress proposal).  You cannot overload the &quot;[]&quot; and &quot;[]=&quot; operators for reading and writing integer-indexed elements. These two operators require more complex treatment and are not currently supported.",
                    "url": " /reference-manual/js/OperatorOverloading/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-optimizing":  {
                    "title": "",
                    "content": "Optimizing Truffle InterpretersThis document discusses tools for optimizing or debugging Truffle interpreters for peak temporal performance.Strategy      Run with a profiler to sample the application and identify responsible compilation units. Use a sampling delay (--cpusampler.Delay=MILLISECONDS) to only profile after warmup. See the Profiling guide.        Understand what is being compiled and look for deoptimizations. Methods that are listed to run mostly in the interpreter likely have a problem with deoptimization.        Simplify the code as much as possible where it still shows the performance problem.        Enable performance warnings and list boundary calls.    Dump the Graal graph of the responsible compilation unit and look at the phase After TruffleTier.          Look at the Graal graphs at the phases After TruffleTier and After PartialEscape and check if it is what you would expect.If there are nodes there that you don’t want to be there, think about how to guard against including them.If there are more complex nodes there than you want, think about how to add specialisations that generate simpler code.If there are nodes you think should be there in a benchmark that are not, think about how to make values dynamic so they are not optimized away.            Search for Invoke nodes in the Graal IR. Invoke nodes that are not representing guest language calls should be specialized away. This may not be always possible, e.g., if the method does I/O.        Search for control flow splits (red lines) and investigate whether they result from control flow caused by the guest application or are just artifacts from the language implementation. The latter should be avoided if possible.    Search for indirections in linear code (Load and LoadIndexed) and try to minimize the code. The less code that is on the hot-path the better.Truffle Compiler OptionsA full list of the latest expert and internal options can be found in the Options guide.Observing CompilationsThis section provides an overview of most of the available command line options to observe compilations.Note: Most options also require the additional --experimental-options flag set.The --engine.TraceCompilation command prints a line each time a method is compiled:[engine] opt done     EqualityConstraint.execute                                  |AST   17|Tier      2|Time  152( 143+9   )ms|Inlined   2Y   0N|IR   266/  300|CodeSize   1010|Addr 0x7f60068c82d0|Src octane-deltablue.js:528The --engine.TraceCompilationDetail command prints a line when compilation is queued, started, or completed:[engine] opt queued   BinaryConstraint.output                                     |AST   19|Tier      2|Calls/Thres    1000/    3|CallsAndLoop/Thres    1000/ 1000|Src octane-deltablue.js:416|QueueSize      0|Time 1725905750[engine] opt start    BinaryConstraint.output                                     |AST   19|Tier      2|Calls/Thres    1000/    3|CallsAndLoop/Thres    1000/ 1000|Src octane-deltablue.js:416|QueueSize      0|Time 1734518023[engine] opt queued   OrderedCollection.size                                      |AST   10|Tier      2|Calls/Thres    1000/    3|CallsAndLoop/Thres    1000/ 1000|Src octane-deltablue.js:71|QueueSize      0|Time 1743713143[engine] opt start    OrderedCollection.size                                      |AST   10|Tier      2|Calls/Thres    1000/    3|CallsAndLoop/Thres    1000/ 1000|Src octane-deltablue.js:71|QueueSize      0|Time 1744034479[engine] opt queued   Planner.addConstraintsConsumingTo                           |AST   51|Tier      2|Calls/Thres     368/    3|CallsAndLoop/Thres    1001/ 1000|Src octane-deltablue.js:743|QueueSize      1|Time 1791073465... more queues ...[engine] opt queued   BinaryConstraint.markInputs                                 |AST   13|Tier      2|Calls/Thres    1000/    3|CallsAndLoop/Thres    1000/ 1000|Src octane-deltablue.js:402|QueueSize     27|Time 2813136318[engine] opt done     BinaryConstraint.output                                     |AST   19|Tier      2|Time 1146( 851+295 )ms|Inlined   0Y   0N|IR   106/  167|CodeSize    634|Addr 0x7f600586f990|Src octane-deltablue.js:416[engine] opt start    Planner.removePropagateFrom                                 |AST  149|Tier      2|Calls/Thres       8/    3|CallsAndLoop/Thres    2052/ 1000|Src octane-deltablue.js:717|QueueSize     26|Time 2903518862[engine] opt queued   UnaryConstraint.output                                      |AST    7|Tier      2|Calls/Thres    1000/    3|CallsAndLoop/Thres    1000/ 1000|Src octane-deltablue.js:255|QueueSize     27|Time 3175165217The --engine.TraceCompilationAST command prints the Truffle AST for each compilation:[engine] opt AST          OrderedCollection.size &amp;lt;split-57429b3a&amp;gt;                     |ASTSize      10/   10 |Calls/Thres   10559/    3 |CallsAndLoop/Thres   10559/ 1000  FunctionRootNode    body = FunctionBodyNode      body = DualNode        left = JSWriteCurrentFrameSlotNodeGen          rhsNode = JSPrepareThisNodeGen            operandNode = AccessThisNode        right = TerminalPositionReturnNode          expression = PropertyNode            target = PropertyNode              target = JSReadCurrentFrameSlotNodeGen              cache = PropertyGetNode                cacheNode = ObjectPropertyGetNode                  receiverCheck = ShapeCheckNode            cache = PropertyGetNode              cacheNode = ArrayLengthPropertyGetNode                receiverCheck = ShapeCheckNode                arrayLengthRead = ArrayLengthReadNodeGenThe --engine.TraceInlining command prints guest-language inlining decisions for each compilation:[engine] inline start     Plan.execute                                                |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.00 |IR Nodes         2704 |Frequency        1.00 |Truffle Callees      5 |Forced          false |Depth               0[engine] Inlined            Plan.size                                                 |call diff     -203.75 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          175 |Frequency      101.88 |Truffle Callees      1 |Forced          false |Depth               1[engine] Inlined              OrderedCollection.size &amp;lt;split-e13c02e&amp;gt;                  |call diff     -101.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          157 |Frequency      101.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            Plan.constraintAt                                         |call diff     -201.75 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          206 |Frequency      100.88 |Truffle Callees      1 |Forced          false |Depth               1[engine] Inlined              OrderedCollection.at                                    |call diff     -100.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          232 |Frequency      100.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            ScaleConstraint.execute                                   |call diff       -0.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          855 |Frequency        0.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] Inlined            EqualityConstraint.execute                                |call diff     -299.63 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          295 |Frequency       99.88 |Truffle Callees      2 |Forced          false |Depth               1[engine] Inlined              BinaryConstraint.output &amp;lt;split-1e163df7&amp;gt;                |call diff      -99.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          259 |Frequency       99.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined              BinaryConstraint.input &amp;lt;split-2dfade22&amp;gt;                 |call diff      -99.88 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes          259 |Frequency       99.88 |Truffle Callees      0 |Forced          false |Depth               2[engine] Inlined            EditConstraint.execute                                    |call diff       -1.00 |Recursion Depth      0 |Explore/inline ratio      NaN |IR Nodes           22 |Frequency        1.00 |Truffle Callees      0 |Forced          false |Depth               1[engine] inline done      Plan.execute                                                |call diff        0.00 |Recursion Depth      0 |Explore/inline ratio     1.00 |IR Nodes         2704 |Frequency        1.00 |Truffle Callees      5 |Forced          false |Depth               0The --engine.TraceSplitting command prints guest-language splitting decisions:[engine] split   0-4310d43-1     Strength                                                    |ASTSize       6/    6 |Calls/Thres       2/    3 |CallsAndLoop/Thres       2/ 1000 |SourceSection /Users/christianhumer/graal/4dev/js-benchmarks/octane-deltablue.js~139:4062-4089[engine] split   1-4b0d79fc-1     Strength                                                    |ASTSize       6/    6 |Calls/Thres       2/    3 |CallsAndLoop/Thres       2/ 1000 |SourceSection /Users/christianhumer/graal/4dev/js-benchmarks/octane-deltablue.js~140:4119-4150The --engine.TraceTransferToInterpreter command prints a stack trace on explicit internal invalidations:[engine] transferToInterpreter at  BinaryConstraint.output(../../../../4dev/js-benchmarks/octane-deltablue.js:416)    Constraint.satisfy(../../../../4dev/js-benchmarks/octane-deltablue.js:183)    Planner.incrementalAdd(../../../../4dev/js-benchmarks/octane-deltablue.js:597) &amp;lt;split-609bcfb6&amp;gt;    Constraint.addConstraint(../../../../4dev/js-benchmarks/octane-deltablue.js:165) &amp;lt;split-7d94beb9&amp;gt;    UnaryConstraint(../../../../4dev/js-benchmarks/octane-deltablue.js:219) &amp;lt;split-560348e6&amp;gt;    Function.prototype.call(&amp;lt;builtin&amp;gt;:1) &amp;lt;split-1df8b5b8&amp;gt;    EditConstraint(../../../../4dev/js-benchmarks/octane-deltablue.js:315) &amp;lt;split-23202fce&amp;gt;    ...  com.oracle.truffle.api.CompilerDirectives.transferToInterpreterAndInvalidate(CompilerDirectives.java:90)    com.oracle.truffle.js.nodes.access.PropertyCacheNode.deoptimize(PropertyCacheNode.java:1269)    com.oracle.truffle.js.nodes.access.PropertyGetNode.getValueOrDefault(PropertyGetNode.java:305)    com.oracle.truffle.js.nodes.access.PropertyGetNode.getValueOrUndefined(PropertyGetNode.java:191)    com.oracle.truffle.js.nodes.access.PropertyNode.executeWithTarget(PropertyNode.java:153)    com.oracle.truffle.js.nodes.access.PropertyNode.execute(PropertyNode.java:140)    ...The --engine.TracePerformanceWarnings=(call|instanceof|store|all) command prints code which may not be ideal for performance. The call enables warnings when partial evaluation cannot inline the virtual runtime call. The instanceof enables warnings when partial evaluation cannot resolve virtual instanceof to an exact type.The store enables warnings when the store location argument is not a partial evaluation constant:[engine] perf warn        ScaleConstraint.execute                                     |Partial evaluation could not inline the virtual runtime call Virtual to HotSpotMethod&amp;lt;ConditionProfile.profile(boolean)&amp;gt; (167|MethodCallTarget).  Approximated stack trace for [167 | MethodCallTarget:    at com.oracle.truffle.js.nodes.control.IfNode.execute(IfNode.java:158)    at com.oracle.truffle.js.nodes.binary.DualNode.execute(DualNode.java:125)    at com.oracle.truffle.js.nodes.function.FunctionBodyNode.execute(FunctionBodyNode.java:73)    at com.oracle.truffle.js.nodes.function.FunctionRootNode.executeInRealm(FunctionRootNode.java:147)    at com.oracle.truffle.js.runtime.JavaScriptRealmBoundaryRootNode.execute(JavaScriptRealmBoundaryRootNode.java:93)    at org.graalvm.compiler.truffle.runtime.OptimizedCallTarget.executeRootNode(OptimizedCallTarget.java:503)    at org.graalvm.compiler.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:480)The --engine.CompilationStatistics command prints statistics on compilations at the end of the process:[engine] Truffle runtime statistics for engine 1  Compilations                                      : 170    Success                                         : 166    Temporary Bailouts                              : 4      org.graalvm.compiler.core.common.CancellationBailoutException: Compilation cancelled.: 4    Permanent Bailouts                              : 0    Failed                                          : 0    Interrupted                                     : 0  Invalidated                                       : 0  Queues                                            : 479  Dequeues                                          : 315      Target inlined into only caller               : 314      Split call node                               : 1  Splits                                            : 450  Compilation Accuracy                              : 1.000000  Queue Accuracy                                    : 0.342380  Compilation Utilization                           : 0.984846  Remaining Compilation Queue                       : 0  Time to queue                                     : count= 479, sum= 2595151, min=      39, average=     5417.85, max=   19993 (milliseconds), maxTarget=Array  Time waiting in queue                             : count= 170, sum=  681895, min=       0, average=     4011.15, max=    8238 (milliseconds), maxTarget=EditConstraint.isInput  Time for compilation                              : count= 170, sum=   39357, min=       5, average=      231.51, max=    2571 (milliseconds), maxTarget=change    Truffle Tier                                    : count= 166, sum=   23654, min=       4, average=      142.50, max=    1412 (milliseconds), maxTarget=change    Graal Tier                                      : count= 166, sum=   13096, min=       0, average=       78.89, max=    1002 (milliseconds), maxTarget=change    Code Installation                               : count= 166, sum=    1865, min=       0, average=       11.24, max=     190 (milliseconds), maxTarget=deltaBlue  Graal node count                                  :    After Truffle Tier                              : count= 168, sum=  146554, min=      13, average=      872.35, max=    7747, maxTarget=change    After Graal Tier                                : count= 166, sum=  213434, min=       3, average=     1285.75, max=   15430, maxTarget=MeasureDefault  Graal compilation result                          :    Code size                                       : count= 166, sum=  874667, min=      70, average=     5269.08, max=   64913, maxTarget=deltaBlue    Total frame size                                : count= 166, sum=   25328, min=      16, average=      152.58, max=    1248, maxTarget=MeasureDefault    Exception handlers                              : count= 166, sum=     199, min=       0, average=        1.20, max=      41, maxTarget=MeasureDefault    Infopoints                                      : count= 166, sum=    6414, min=       3, average=       38.64, max=     517, maxTarget=MeasureDefault      CALL                                          : count= 166, sum=    4125, min=       3, average=       24.85, max=     357, maxTarget=MeasureDefault      IMPLICIT_EXCEPTION                            : count= 166, sum=    2164, min=       0, average=       13.04, max=     156, maxTarget=MeasureDefault      SAFEPOINT                                     : count= 166, sum=     125, min=       0, average=        0.75, max=       9, maxTarget=change    Marks                                           : count= 166, sum=    1385, min=       5, average=        8.34, max=      52, maxTarget=MeasureDefault    Data references                                 : count= 166, sum=   10219, min=       1, average=       61.56, max=     758, maxTarget=MeasureDefaultThe --engine.CompilationStatisticDetails command prints histogram information on individual Graal nodes in addition to the previous compilation statistics:  Graal nodes after Truffle tier                    :      FrameState                                    : count= 168, sum=   35502, min=       1, average=      211.32, max=    2048, maxTarget=deltaBlue      FixedGuardNode                                : count= 168, sum=   18939, min=       0, average=      112.73, max=    1048, maxTarget=change      LoadFieldNode                                 : count= 168, sum=   14432, min=       0, average=       85.90, max=     814, maxTarget=EditConstraint      ...  Graal nodes after Graal tier                      :      BeginNode                                     : count= 166, sum=   33333, min=       0, average=      200.80, max=    2110, maxTarget=change      FrameState                                    : count= 166, sum=   30591, min=       0, average=      184.28, max=    2393, maxTarget=MeasureDefault      AMD64AddressNode                              : count= 166, sum=   20072, min=       0, average=      120.92, max=    1960, maxTarget=MeasureDefault      ...The --engine.TraceMethodExpansion=truffleTier command prints a tree of all expanded Java methods with statistics after each compilation:[engine] Expansion tree for test after truffleTier:Name                                                                                Frequency | Count    Size  Cycles   Ifs Loops Invokes Allocs | Self Count  Size Cycles   Ifs Loops Invokes Allocs | IRNode ASTNode Lang:File:Line:Chars&amp;lt;root&amp;gt;                                                                                   1.00 |    64      72      42     1     1       0      1 |         34    20      0     0     0       0      0 |  - OptimizedCallTarget.profiledPERoot(Object)                                              1.00 |    30      52      42     1     1       0      1 |          1     2      2     0     0       0      0 |    121  OptimizedCallTarget.injectArgumentsProfile(Object)                                     1.00 |     9      19      16     0     0       0      0 |          4     3      0     0     0       0      0 |      5   OptimizedCallTarget.unsafeCast(Object, Class, Z, Z, Z)                                1.00 |     1       0       0     0     0       0      0 |          1     0      0     0     0       0      0 |     10   OptimizedCallTarget.castArgumentsImpl(Object, Class)                                  1.00 |     4      16      16     0     0       0      0 |          4    16     16     0     0       0      0 |     12  OptimizedCallTarget.executeRootNode(VirtualFrame)                                      1.00 |    20      31      24     1     1       0      1 |          0     0      0     0     0       0      0 |   JavaScriptRealmBoundaryRootNode.execute(VirtualFrame)                                 1.00 |    20      31      24     1     1       0      1 |          1     1      0     0     0       0      0 |     34       0 js:test.js:1:0-100    JavaScriptRealmBoundaryRootNode.getRealm()                                           1.00 |     1       1       0     0     0       0      0 |          0     0      0     0     0       0      0 |              0 js:test.js:1:0-100     JSContext.getRealm()                                                                1.00 |     1       1       0     0     0       0      0 |          0     0      0     0     0       0      0 |      PolyglotReferences$AssumeSingleContext.get()                                       1.00 |     1       1       0     0     0       0      0 |          0     0      0     0     0       0      0 |       PolyglotReferences$WeakSingleContext.get()                                        1.00 |     1       1       0     0     0       0      0 |          1     1      0     0     0       0      0 |     37    FunctionRootNode.executeInRealm(VirtualFrame)                                        1.00 |    18      29      24     1     1       0      1 |          1     1      0     0     0       0      0 |     41       0 js:test.js:1:0-100     FunctionBodyNode.execute(VirtualFrame)                                              1.00 |    17      28      24     1     1       0      1 |          0     0      0     0     0       0      0 |              1 js:test.js:1:0-100      AbstractBlockNode.execute(VirtualFrame)                                            1.00 |    17      28      24     1     1       0      1 |          0     0      0     0     0       0      0 |       AbstractBlockNode.executeVoid(VirtualFrame, JavaScriptNode, I, I)                 1.00 |    16      20      16     1     1       0      0 |          1     1      0     0     0       0      0 |     50       2 js:test.js:1:16-100        WhileNode.executeVoid(VirtualFrame)                                              1.00 |    15      19      16     1     1       0      0 |          0     0      0     0     0       0      0 |              7 js:test.js:3:35-84         OptimizedOSRLoopNode.execute(VirtualFrame)                                    101.00 |    15      19      16     1     1       0      0 |          4     3      2     0     1       0      0 |     46       8 js:test.js:3:35-84          RepeatingNode.executeRepeatingWithValue(VirtualFrame)                          1.00 |    11      16      14     1     0       0      0 |          1     1      0     0     0       0      0 |    100       9 js:test.js:3:35-84           WhileNode$WhileDoRepeatingNode.executeRepeating(VirtualFrame)               101.00 |    10      15      14     1     0       0      0 |          3     2      1     1     0       0      0 |     63       9 js:test.js:3:35-84            AbstractRepeatingNode.executeCondition(VirtualFrame)                       101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |              9 js:test.js:3:35-84             StatementNode.executeConditionAsBoolean(VirtualFrame, JavaScriptNode)     101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |              JSLessThanNodeGen.executeBoolean(VirtualFrame)                           101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |             10 js:test.js:3:51-58               JSLessThanNodeGen.executeBoolean_int_int0(VirtualFrame, J)              101.00 |     1       1       1     0     0       0      0 |          0     0      0     0     0       0      0 |                JSLessThanNode.doInt(I, I)                                             101.00 |     1       1       1     0     0       0      0 |          1     1      1     0     0       0      0 |     59      10 js:test.js:3:51-58            AbstractRepeatingNode.executeBody(VirtualFrame)                            101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |              9 js:test.js:3:35-84             AbstractBlockNode.executeVoid(VirtualFrame)                               101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |              AbstractBlockNode.executeVoid(VirtualFrame, JavaScriptNode, I, I)        101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             13 js:test.js:3:35-84               JSWriteCurrentFrameSlotNodeGen.executeVoid(VirtualFrame)                101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             14 js:test.js:4:71-79                JSWriteCurrentFrameSlotNodeGen.executeInt(VirtualFrame)                101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |             14 js:test.js:4:71-79                 JSAddNodeGen.executeInt(VirtualFrame)                                 101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |                  JSAddNode.doInt(I, I)                                                101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |                   Math.addExact(I, I)                                                 100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     75      15 js:test.js:4:71-74                LocalVarPostfixIncNodeGen.executeInt(VirtualFrame)                     101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |             18 js:test.js:3:60-63                 LocalVarPostfixIncNode.doInt(Frame)                                   101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |             18 js:test.js:3:60-63                  LocalVarIncNode$IncOp.doInt(I)                                       101.00 |     3       6       6     0     0       0      0 |          0     0      0     0     0       0      0 |                   Math.addExact(I, I)                                                 100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     85       AbstractBlockNode.executeGeneric(VirtualFrame, JavaScriptNode, I, I)              1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |              2 js:test.js:1:16-100        ReturnNode$TerminalPositionReturnNode.execute(VirtualFrame)                      1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |             20 js:test.js:6:87-98         JSReadCurrentFrameSlotNodeGen.execute(VirtualFrame)                             1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |          Integer.valueOf(I)                                                             1.00 |     1       8       8     0     0       0      1 |          1     8      8     0     0       0      1 |    139      21 js:test.js:6:94-97The --engine.TraceNodeExpansion=truffleTier command prints a tree of all expanded Truffle nodes with statistics after each compilation.This view groups the method expansion tree by node id:[engine] Expansion tree for test after truffleTier:Name                                                       Frequency | Count    Size  Cycles   Ifs Loops Invokes Allocs | Self Count  Size Cycles   Ifs Loops Invokes Allocs | IRNode ASTNode Lang:File:Line:Chars&amp;lt;call-root&amp;gt;                                                     1.00 |    64      72      42     1     1       0      1 |         44    41     18     0     0       0      0 |      0 FunctionRootNode                                               1.00 |    20      31      24     1     1       0      1 |          3     3      0     0     0       0      0 |     34       0 js:test.js:1:0-100  FunctionBodyNode                                              1.00 |    17      28      24     1     1       0      1 |          0     0      0     0     0       0      0 |              1 js:test.js:1:0-100   ExprBlockNode                                                1.00 |    17      28      24     1     1       0      1 |          1     1      0     0     0       0      0 |     50       2 js:test.js:1:16-100    WhileNode                                                   1.00 |    15      19      16     1     1       0      0 |          0     0      0     0     0       0      0 |              7 js:test.js:3:35-84     OptimizedOSRLoopNode$OptimizedDefaultOSRLoopNode         101.00 |    15      19      16     1     1       0      0 |          4     3      2     0     1       0      0 |     46       8 js:test.js:3:35-84      WhileNode$WhileDoRepeatingNode                          101.00 |    11      16      14     1     0       0      0 |          4     3      1     1     0       0      0 |    100       9 js:test.js:3:35-84       JSLessThanNodeGen                                      101.00 |     1       1       1     0     0       0      0 |          1     1      1     0     0       0      0 |     59      10 js:test.js:3:51-58       VoidBlockNode                                          101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             13 js:test.js:3:35-84        JSWriteCurrentFrameSlotNodeGen                        101.00 |     6      12      12     0     0       0      0 |          0     0      0     0     0       0      0 |             14 js:test.js:4:71-79         JSAddNodeGen                                         100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     75      15 js:test.js:4:71-74         LocalVarPostfixIncNodeGen                            100.00 |     3       6       6     0     0       0      0 |          3     6      6     0     0       0      0 |     85      18 js:test.js:3:60-63    ReturnNode$TerminalPositionReturnNode                       1.00 |     1       8       8     0     0       0      1 |          0     0      0     0     0       0      0 |             20 js:test.js:6:87-98     JSReadCurrentFrameSlotNodeGen                              1.00 |     1       8       8     0     0       0      1 |          1     8      8     0     0       0      1 |    139      21 js:test.js:6:94-97The --engine.MethodExpansionStatistics=truffleTier command prints statistics on expanded Java methods during partial evaluation at the end of a run.This can be useful to detect code that produces too many or certain Graal nodes unexpectedly:[engine] Method expansion statistics after truffleTier:Name                                                                       Count IR Nodes (min avg max)        Size (min avg max)      Cycles (min avg max)       Ifs  Loops Invokes Allocs | Max IRNode ASTNode Unit:Lang:File:Line:Chars  &amp;lt;no-source-position&amp;gt;                                                         1      212 (212 212.0 212)       117 (117 117.0 117)         0 (0 0.0 0)             0      0       0      0 |          0         mandelbrot  OptimizedOSRLoopNode.execute(VirtualFrame)                                   4       13 (0 3.3 5)               9 (0 2.3 3)               6 (0 1.5 2)             0      3       0      0 |        172      60 mandelbrot:js:mandelbrot.js:68:2589-2888  Math.addExact(I, I)                                                          4       12 (3 3.0 3)              24 (6 6.0 6)              24 (6 6.0 6)             0      0       0      0 |        485     103 mandelbrot:js:mandelbrot.js:80:2874-2875  WhileNode$WhileDoRepeatingNode.executeRepeating(VirtualFrame)                4        9 (0 2.3 3)               6 (0 1.5 2)               3 (0 0.8 1)             3      0       0      0 |         88      17 mandelbrot:js:mandelbrot.js:57:2374-3431  JSTypes.intToDouble(I)                                                       7        7 (1 1.0 1)               7 (1 1.0 1)              24 (0 3.4 8)             0      0       0      0 |        144      41 mandelbrot:js:mandelbrot.js:62:2478-2486  OptimizedCallTarget.castArgumentsImpl(Object, Class)                         1        7 (7 7.0 7)              25 (25 25.0 25)           24 (24 24.0 24)          0      0       0      0 |         12         mandelbrot  JSWriteCurrentFrameSlotNodeGen.executeVoid(VirtualFrame)                     6        6 (0 1.0 3)               4 (0 0.7 2)               2 (0 0.3 1)             2      0       0      0 |        563      46 mandelbrot:js:mandelbrot.js:64:2519-2544  AbstractBlockNode.executeVoid(VirtualFrame, JavaScriptNode, I, I)            8        6 (0 0.8 4)               6 (0 0.8 4)               0 (0 0.0 0)             0      0       0      0 |        177      39 mandelbrot:js:mandelbrot.js:61:2459-3416  Math.multiplyExact(I, I)                                                     4        6 (1 1.5 2)              12 (2 3.0 4)              20 (4 5.0 6)             0      0       0      0 |        155      49 mandelbrot:js:mandelbrot.js:64:2529-2534  OptimizedCallTarget.injectArgumentsProfile(Object)                           1        4 (4 4.0 4)               3 (3 3.0 3)               0 (0 0.0 0)             0      0       0      0 |          5         mandelbrot  JSMultiplyNode.doDouble(D, D)                                                4        4 (1 1.0 1)               4 (1 1.0 1)               8 (2 2.0 2)             0      0       0      0 |        280      75 mandelbrot:js:mandelbrot.js:70:2657-2663  IfNode.executeVoid(VirtualFrame)                                             3        3 (0 1.0 3)               2 (0 0.7 2)               1 (0 0.3 1)             1      0       0      0 |        606     126 mandelbrot:js:mandelbrot.js:93:3240-3397  Math.subtractExact(I, I)                                                     1        3 (3 3.0 3)               6 (6 6.0 6)               6 (6 6.0 6)             0      0       0      0 |        589     129 mandelbrot:js:mandelbrot.js:93:3249-3257  JSSubtractNode.doDouble(D, D)                                                3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        167      47 mandelbrot:js:mandelbrot.js:64:2528-2544  JSLessThanNode.doInt(I, I)                                                   3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        187      62 mandelbrot:js:mandelbrot.js:68:2596-2602  JSAddNode.doDouble(D, D)                                                     3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        263      67 mandelbrot:js:mandelbrot.js:69:2623-2639  JSDivideNode.doDouble(D, D)                                                  2        2 (1 1.0 1)               2 (1 1.0 1)              64 (32 32.0 32)          0      0       0      0 |        165      48 mandelbrot:js:mandelbrot.js:64:2528-2540  JSBitwiseXorNode.doInteger(I, I)                                             2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        575     119 mandelbrot:js:mandelbrot.js:90:3170-3173  JSEqualNode.doInt(I, I)                                                      2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        592     127 mandelbrot:js:mandelbrot.js:93:3244-3257  RepeatingNode.executeRepeatingWithValue(VirtualFrame)                        4        1 (0 0.3 1)               1 (0 0.3 1)               0 (0 0.0 0)             0      0       0      0 |        499      61 mandelbrot:js:mandelbrot.js:68:2589-2888  FunctionRootNode.executeInRealm(VirtualFrame)                                1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         53       0 mandelbrot:js:mandelbrot.js:50:2279-3447  OptimizedCallTarget.profiledPERoot(Object)                                   1        1 (1 1.0 1)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |        737         mandelbrot  PolyglotReferences$WeakSingleContext.get()                                   1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         41         mandelbrot  JSLeftShiftNode.doInteger(I, I)                                              1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        619     134 mandelbrot:js:mandelbrot.js:94:3269-3277  Integer.intValue()                                                           1        1 (1 1.0 1)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |         50       4 mandelbrot:js:1:0-0  JSSubtractNode.doInt(I, I)                                                   2        1 (0 0.5 1)               1 (0 0.5 1)               1 (0 0.5 1)             0      0       0      0 |        940     136 mandelbrot:js:mandelbrot.js:94:3282-3295  JSLeftShiftConstantNode.doInteger(I)                                         1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        527     107 mandelbrot:js:mandelbrot.js:83:2907-2922  JSSubtractNodeGen.executeDouble(VirtualFrame)                                3        1 (0 0.3 1)               1 (0 0.3 1)               0 (0 0.0 0)             0      0       0      0 |         33      47 mandelbrot:js:mandelbrot.js:64:2528-2544  JSReadCurrentFrameSlotNodeGen.executeInt(VirtualFrame)                       1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         74      19 mandelbrot:js:mandelbrot.js:57:2381-2382  Integer.valueOf(I)                                                           1        1 (1 1.0 1)               8 (8 8.0 8)               8 (8 8.0 8)             0      0       0      1 |        939     154 mandelbrot:js:mandelbrot.js:105:3442-3445  JSBitwiseOrNode.doInteger(I, I)                                              1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        532     106 mandelbrot:js:mandelbrot.js:83:2907-2931  JSGreaterThanNode.doDouble(D, D)                                             1        1 (1 1.0 1)               1 (1 1.0 1)               2 (2 2.0 2)             0      0       0      0 |        461      93 mandelbrot:js:mandelbrot.js:76:2800-2815  OptimizedCallTarget.unsafeCast(Object, Class, Z, Z, Z)                       1        1 (1 1.0 1)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |         10         mandelbrot  JavaScriptRealmBoundaryRootNode.execute(VirtualFrame)                        1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         38         mandelbrot  JSLeftShiftConstantNodeGen.executeInt(VirtualFrame)                          1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         36     107 mandelbrot:js:mandelbrot.js:83:2907-2922  DualNode.execute(VirtualFrame)                                               1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                  2 mandelbrot:js:mandelbrot.js:50:2279-3447  ...The --engine.NodeExpansionStatistics=truffleTier command prints statistics on expanded Truffle nodes during partial evaluation at the end of a run.This can be useful to detect code that produces too many or certain Graal nodes unexpectedly.It also shows individual specialization combinations as they were observed during compilation:[engine] Node expansion statistics after truffleTier:Name                                                    Count IR Nodes (min avg max)        Size (min avg max)      Cycles (min avg max)       Ifs  Loops Invokes Allocs | Max IRNode ASTNode Unit:Lang:File:Line:Chars  &amp;lt;call-root&amp;gt;                                               1      226 (226 226.0 226)       148 (148 148.0 148)        26 (26 26.0 26)          0      0       0      0 |          0         mandelbrot  OptimizedOSRLoopNode$OptimizedDefaultOSRLoopNode          4       13 (0 3.3 5)               9 (0 2.3 3)               6 (0 1.5 2)             0      3       0      0 |        172      60 mandelbrot:js:mandelbrot.js:68:2589-2888  JSAddConstantRightNumberNodeGen                           4       12 (3 3.0 3)              24 (6 6.0 6)              24 (6 6.0 6)             0      0       0      0 |        485     103 mandelbrot:js:mandelbrot.js:80:2874-2875    [doInt(I)]                                              4       12 (3 3.0 3)              24 (6 6.0 6)              24 (6 6.0 6)             0      0       0      0 |        485     103 mandelbrot:js:mandelbrot.js:80:2874-2875  JSMultiplyNodeGen                                         6       11 (1 1.8 3)              17 (1 2.8 6)              28 (2 4.7 10)            0      0       0      0 |        155      49 mandelbrot:js:mandelbrot.js:64:2529-2534    [doIntALargerZero(I, I), doIntBLargerZero(I, I)]        2        6 (3 3.0 3)              12 (6 6.0 6)              20 (10 10.0 10)          0      0       0      0 |        155      49 mandelbrot:js:mandelbrot.js:64:2529-2534    [doDouble(D, D)]                                        4        5 (1 1.3 2)               5 (1 1.3 2)               8 (2 2.0 2)             0      0       0      0 |        275      75 mandelbrot:js:mandelbrot.js:70:2657-2663  WhileNode$WhileDoRepeatingNode                            4       10 (0 2.5 4)               7 (0 1.8 3)               3 (0 0.8 1)             3      0       0      0 |        499      61 mandelbrot:js:mandelbrot.js:68:2589-2888  JSSubtractNodeGen                                         5        9 (1 1.8 3)              12 (1 2.4 6)              10 (1 2.0 6)             0      0       0      0 |        589     129 mandelbrot:js:mandelbrot.js:93:3249-3257    [doDouble(D, D)]                                        3        5 (1 1.7 2)               5 (1 1.7 2)               3 (1 1.0 1)             0      0       0      0 |         33      47 mandelbrot:js:mandelbrot.js:64:2528-2544    [doInt(I, I)]                                           2        4 (1 2.0 3)               7 (1 3.5 6)               7 (1 3.5 6)             0      0       0      0 |        589     129 mandelbrot:js:mandelbrot.js:93:3249-3257  JSWriteCurrentFrameSlotNodeGen                           18        7 (0 0.4 3)               5 (0 0.3 2)               2 (0 0.1 1)             2      0       0      0 |        563      46 mandelbrot:js:mandelbrot.js:64:2519-2544  JSDivideNodeGen                                           2        5 (2 2.5 3)               5 (2 2.5 3)              88 (40 44.0 48)          0      0       0      0 |        158      48 mandelbrot:js:mandelbrot.js:64:2528-2540    [doDouble(D, D)]                                        2        5 (2 2.5 3)               5 (2 2.5 3)              88 (40 44.0 48)          0      0       0      0 |        158      48 mandelbrot:js:mandelbrot.js:64:2528-2540  VoidBlockNode                                             7        5 (0 0.7 4)               5 (0 0.7 4)               0 (0 0.0 0)             0      0       0      0 |        177      39 mandelbrot:js:mandelbrot.js:61:2459-3416  JSAddNodeGen                                              3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        263      67 mandelbrot:js:mandelbrot.js:69:2623-2639    [doDouble(D, D)]                                        3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        263      67 mandelbrot:js:mandelbrot.js:69:2623-2639  JSLessThanNodeGen                                         3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        187      62 mandelbrot:js:mandelbrot.js:68:2596-2602    [doInt(I, I)]                                           3        3 (1 1.0 1)               3 (1 1.0 1)               3 (1 1.0 1)             0      0       0      0 |        187      62 mandelbrot:js:mandelbrot.js:68:2596-2602  IfNode                                                    4        3 (0 0.8 3)               2 (0 0.5 2)               1 (0 0.3 1)             1      0       0      0 |        606     126 mandelbrot:js:mandelbrot.js:93:3240-3397  JSGreaterThanNodeGen                                      1        2 (2 2.0 2)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |        460      93 mandelbrot:js:mandelbrot.js:76:2800-2815    [doDouble(D, D)]                                        1        2 (2 2.0 2)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |        460      93 mandelbrot:js:mandelbrot.js:76:2800-2815  JSBitwiseXorNodeGen                                       2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        575     119 mandelbrot:js:mandelbrot.js:90:3170-3173    [doInteger(I, I)]                                       2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        575     119 mandelbrot:js:mandelbrot.js:90:3170-3173  JSLeftShiftConstantNodeGen                                1        2 (2 2.0 2)               2 (2 2.0 2)               1 (1 1.0 1)             0      0       0      0 |         36     107 mandelbrot:js:mandelbrot.js:83:2907-2922    [doInteger(I)]                                          1        2 (2 2.0 2)               2 (2 2.0 2)               1 (1 1.0 1)             0      0       0      0 |         36     107 mandelbrot:js:mandelbrot.js:83:2907-2922  JSReadCurrentFrameSlotNodeGen                             2        2 (1 1.0 1)               9 (1 4.5 8)               8 (0 4.0 8)             0      0       0      1 |         74      19 mandelbrot:js:mandelbrot.js:57:2381-2382  JSEqualNodeGen                                            2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        592     127 mandelbrot:js:mandelbrot.js:93:3244-3257    [doInt(I, I)]                                           2        2 (1 1.0 1)               2 (1 1.0 1)               2 (1 1.0 1)             0      0       0      0 |        592     127 mandelbrot:js:mandelbrot.js:93:3244-3257  FunctionRootNode                                          1        2 (2 2.0 2)               2 (2 2.0 2)               0 (0 0.0 0)             0      0       0      0 |         53       0 mandelbrot:js:mandelbrot.js:50:2279-3447  ExprBlockNode                                             1        1 (1 1.0 1)               1 (1 1.0 1)               0 (0 0.0 0)             0      0       0      0 |         69       5 mandelbrot:js:mandelbrot.js:50:2305-3447  JSBitwiseOrNodeGen                                        1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        532     106 mandelbrot:js:mandelbrot.js:83:2907-2931    [doInteger(I, I)]                                       1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        532     106 mandelbrot:js:mandelbrot.js:83:2907-2931  AccessIndexedArgumentNode                                 1        1 (1 1.0 1)               2 (2 2.0 2)               2 (2 2.0 2)             0      0       0      0 |         50       4 mandelbrot:js:1:0-0  JSLeftShiftNodeGen                                        2        1 (0 0.5 1)               1 (0 0.5 1)               1 (0 0.5 1)             0      0       0      0 |        619     134 mandelbrot:js:mandelbrot.js:94:3269-3277    [doInteger(I, I)]                                       1        1 (1 1.0 1)               1 (1 1.0 1)               1 (1 1.0 1)             0      0       0      0 |        619     134 mandelbrot:js:mandelbrot.js:94:3269-3277    &amp;lt;unknown&amp;gt;                                               1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                134 mandelbrot:js:mandelbrot.js:94:3269-3277  FunctionBodyNode                                          1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                  1 mandelbrot:js:mandelbrot.js:50:2279-3447  ReturnNode$TerminalPositionReturnNode                     1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                153 mandelbrot:js:mandelbrot.js:105:3435-3445  DualNode                                                  1        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                  2 mandelbrot:js:mandelbrot.js:50:2279-3447  WhileNode                                                 4        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                 15 mandelbrot:js:mandelbrot.js:57:2374-3431  DirectBreakTargetNode                                     2        0 (0 0.0 0)               0 (0 0.0 0)               0 (0 0.0 0)             0      0       0      0 |                 14 mandelbrot:js:mandelbrot.js:50:2305-3447The --engine.InstrumentBoundaries command prints, at the end of the process, information about runtime calls (@TruffleBoundary) made from compiled code.These cause objects to escape (are black-boxes to further optimization) and should generally be minimized.Also see the Branch Instrumentation guide for more details about instrumenting branches and boundaries.Execution profile (sorted by hotness)=====================================  0: *******************************************************************************  1:com.oracle.truffle.js.nodes.binary.JSAddNode.doStringInt(JSAddNode.java:177) [bci: 2][0] count = 22525269com.oracle.truffle.js.builtins.ConstructorBuiltins$ConstructDateNode.constructDateZero(ConstructorBuiltins.java:837) [bci: 6][1] count = 69510The --engine.InstrumentBranches command prints, at the end of the process, information of branch usage in compiled code:Execution profile (sorted by hotness)=====================================  2: ***************  1: **************  5: *************  4: ************  3: ********* 10: **  8: *  9: * 14: * ...com.oracle.truffle.js.nodes.access.PropertyGetNode.getValueOrDefault(PropertyGetNode.java:301) [bci: 55][2] state = BOTH(if=36486564#, else=44603498#)com.oracle.truffle.js.nodes.control.IfNode.execute(IfNode.java:158) [bci: 12][1] state = BOTH(if=72572593#, else=1305851#)com.oracle.truffle.js.nodes.function.JSFunctionCallNode.executeCall(JSFunctionCallNode.java:233) [bci: 18][5] state = BOTH(if=38703322#, else=32550439#)com.oracle.truffle.js.nodes.access.PropertyCacheNode$PrototypeShapeCheckNode.accept(PropertyCacheNode.java:364) [bci: 4][4] state = ELSE(if=0#, else=64094316#)com.oracle.truffle.js.nodes.control.WhileNode$WhileDoRepeatingNode.executeRepeating(WhileNode.java:230) [bci: 5][3] state = BOTH(if=44392142#, else=7096299#)...The --engine.SpecializationStatistics command prints detailed histograms about Node classes and their usage of Truffle DSL specializations.See Specialization Statistics for a tutorial on how to use it.Note: Specialization statistics require a recompilation of the interpeter. -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSWriteCurrentFrameSlotNodeGen                                               8 (17%)            18 (12%)        Min=         1 Avg=        2.25 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean &amp;lt;boolean&amp;gt;                                                          1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   doInt &amp;lt;int&amp;gt;                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|   doSafeIntegerInt                                                             0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doLong                                                                       0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject                                                                     7 (88%)            16 (89%)        Min=         1 Avg=        2.29 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;DynamicObjectBasic&amp;gt;                                                         6 (86%)            12 (75%)        Min=         1 Avg=        2.00 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;IteratorRecord&amp;gt;                                                             1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~1-8:16-130|     &amp;lt;String&amp;gt;                                                                     2 (29%)             2 (13%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     &amp;lt;Integer&amp;gt;                                                                    1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~6:105-123|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doBoolean]                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   [doInt, doObject]                                                            1 (13%)             4 (22%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5-7:76-128|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5-7:76-128|   [doObject]                                                                   6 (75%)            13 (72%)        Min=         1 Avg=        2.17 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSReadCurrentFrameSlotNodeGen                                                8 (17%)            25 (17%)        Min=         1 Avg=        3.13 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean                                                                    0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doInt &amp;lt;no-args&amp;gt;                                                              1 (13%)             1 (4%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject &amp;lt;no-args&amp;gt;                                                           8 (100%)           24 (96%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doInt, doObject]                                                            1 (13%)             4 (16%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5:81-87|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5:81-87|   [doObject]                                                                   7 (88%)            21 (84%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------The --vm.XX:+TraceDeoptimization command prints deoptimization events, whether the code is compiled by Truffle or conventional compilers (the output of HotSpot and native images may vary for this flag):Uncommon trap   bci=9 pc=0x00000001097f2235, relative_pc=501, method=com.oracle.truffle.js.nodes.access.PropertyNode.executeInt(Ljava/lang/Object;Ljava/lang/Object;)I, debug_id=0Uncommon trap occurred in org.graalvm.compiler.truffle.runtime.OptimizedCallTarget::profiledPERoot compiler=JVMCI compile_id=2686 (JVMCI: installed code name=BinaryConstraint.output#2)  (@0x00000001097f2235) thread=5891 reason=transfer_to_interpreter action=reinterpret unloaded_class_index=-1 debug_id=0The --vm.XX:+TraceDeoptimizationDetails command prints more information (only available for native images):[Deoptimization initiated    name: BinaryConstraint.output    sp: 0x7ffee7324d90  ip: 0x1126c51a8    reason: TransferToInterpreter  action: InvalidateReprofile    debugId: 3  speculation: jdk.vm.ci.meta.SpeculationLog$NoSpeculationReason@10f942aa0[Deoptimization of frame    name: BinaryConstraint.output    sp: 0x7ffee7324d90  ip: 0x1126c51a8    stack trace where execution continues:        at org.graalvm.compiler.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:475) bci 0  return address 0x10aab9e5e            org.graalvm.compiler.truffle.runtime.OptimizedCallTarget.profiledPERoot(OptimizedCallTarget.java:475)            bci: 0  deoptMethodOffset: 35524160  deoptMethod: 0x10aab9e40  return address: 0x10aab9e5e  offset: 0            slot 0  kind: Object  value: com.oracle.svm.truffle.api.SubstrateOptimizedCallTarget@0x112cbbaa0  offset: 64            slot 1  kind: Object  value: [Ljava.lang.Object;@0x1144a7db0  offset: 56]]Controlling What Is CompiledTo make the best use of the former options, limit what is compiled to the methods that you are interested in.      --engine.CompileOnly=foo restricts compilation to methods with foo in their name. Use this in combination with returning a value or taking parameters to avoid code being compiled away.        --engine.CompileImmediately compiles methods as soon as they are run.        --engine.BackgroundCompilation=false compiles synchronously, which can simplify things.        --engine.Inlining=false disables inlining which can make code easier to understand.        --engine.OSR=false disables on-stack-replacement (compilation of the bodies of while loops for example) which can make code easier to understand.        --engine.Compilation=false turns off Truffle compilation all together.  Ideal Graph VisualizerThe Ideal Graph Visualizer (IGV) is a tool to understand Truffle ASTs and the GraalVM compiler graphs.A typical usage is to run with --vm.Dgraal.Dump=Truffle:1 --vm.Dgraal.PrintGraph=Network, which will show you Truffle ASTs, guest-language call graphs, and the Graal graphs as they leave the Truffle phase.If the -Dgraal.PrintGraph=Network flag is omitted then the dump files are placed in the graal_dumps directory, which you should then open in IGV.Use --vm.Dgraal.Dump=Truffle:2 to dump Graal graphs between each compiler phase.C1 VisualizerThe C1 Visualizer is a tool to understand the Low Level IR (LIR), register allocation, andcode generation stages of GraalVM. It is available here.A typical usage is --vm.Dgraal.Dump=:3.Files are put into a graal_dumps directory which you should then open in the C1 Visualizer.DisassemblerTHe --vm.XX:+UnlockDiagnosticVMOptions --vm.XX:+PrintAssembly commands combination prints assembly code.You will need to install hsdis using mx hsdis in graal/compiler, or manually install it into the current directory from here.Typical usage is --vm.Dgraal.Dump --vm.Dgraal.PrintBackendCFG=true. Files areput into a graal_dumps directory which you should then open in theC1 Visualizer.Combine with --vm.XX:TieredStopAtLevel=0 to disable compilation of runtime routines so that it’s easier to find your guest-language method.Note: You can also look at assembly code in the C1 Visualizer.These have been the most common and powerful ways to optimize or debug Truffle interpreters.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/Optimizing/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-options":  {
                    "title": "",
                    "content": "Truffle OptionsYou can list options from the command line with any language launcher:language-launcher --help:expertOr, for options only relevant for Truffle language implementers:language-launcher --help:internalIn addition, the GraalVM compiler options can be listed with:language-launcher --jvm --vm.XX:+JVMCIPrintPropertiesSee graalvm_ce_jdk8_options for a list of GraalVM compiler options.Default Language Launcher Options  --polyglot                                   Run with all other guest languages accessible.  --native                                     Run using the native launcher with limited Java access (default).  --jvm                                        Run on the Java Virtual Machine with Java access.  --vm.[option]                                Pass options to the host VM. To see available options, use &#39;--help:vm&#39;.  --log.file=&amp;lt;String&amp;gt;                          Redirect guest languages logging into a given file.  --log.[logger].level=&amp;lt;String&amp;gt;                Set language log level to OFF, SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST or ALL.  --help                                       Print this help message.  --help:vm                                    Print options for the host VM.  --version:graalvm                            Print GraalVM version information and exit.  --show-version:graalvm                       Print GraalVM version information and continue execution.  --help:languages                             Print options for all installed languages.  --help:tools                                 Print options for all installed tools.  --help:expert                                Print additional options for experts.  --help:internal                              Print internal options for debugging language implementations and tools.Expert Engine OptionsThese are advanced options for controlling the engine.They are useful to users and language and tool implementers.Expert engine options:  --engine.BackgroundCompilation=&amp;lt;Boolean&amp;gt;     Enable asynchronous truffle compilation in background threads  --engine.Compilation=&amp;lt;Boolean&amp;gt;               Enable or disable Truffle compilation.  --engine.CompilerIdleDelay=&amp;lt;Long&amp;gt;            Set the time in milliseconds an idle Truffle compiler thread will wait for new tasks before terminating. New compiler                                               threads will be started once new compilation tasks are submitted. Select &#39;0&#39; to never terminate the Truffle compiler                                               thread. The option is not supported by all Truffle runtimes. On the runtime which does not support it the option has no                                               effect.  --engine.CompilerThreads=&amp;lt;Integer&amp;gt;           Manually set the number of compiler threads  --engine.EncodedGraphCacheCapacity=&amp;lt;Integer&amp;gt; Maximum number of entries in the encoded graph cache (&amp;lt; 0 unbounded, 0 disabled).  --engine.EncodedGraphCachePurgeDelay=&amp;lt;Integer&amp;gt;                                               Delay, in milliseconds, after which the encoded graph cache is dropped when the compile queue becomes idle.The option is                                               only supported on the HotSpot (non-libgraal) Truffle runtime.On runtimes which does not support it the option has no                                               effect.  --engine.FirstTierCompilationThreshold=&amp;lt;Integer&amp;gt;                                               Minimum number of invocations or loop iterations needed to compile a guest language root in first tier.  --engine.FirstTierMinInvokeThreshold=&amp;lt;Integer&amp;gt;                                               Minimum number of invocations or loop iterations needed to compile a guest language root in last tier.  --engine.LastTierCompilationThreshold=&amp;lt;Integer&amp;gt;                                               Minimum number of invocations or loop iterations needed to compile a guest language root when not using multi tier.  --engine.SingleTierCompilationThreshold=&amp;lt;Integer&amp;gt;                                               Minimum number of invocations or loop iterations needed to compile a guest language root when not using multi tier.  --engine.Inlining=&amp;lt;Boolean&amp;gt;                  Enable automatic inlining of guest language call targets.  --engine.InliningExpansionBudget=&amp;lt;Integer&amp;gt;   The base expansion budget for language-agnostic inlining.  --engine.InliningInliningBudget=&amp;lt;Integer&amp;gt;    The base inlining budget for language-agnostic inlining  --engine.InliningNodeBudget=&amp;lt;Integer&amp;gt;        Maximum number of inlined non-trivial AST nodes per compilation unit.  --engine.InliningPolicy=&amp;lt;String&amp;gt;             Explicitly pick a inlining policy by name. Highest priority chosen by default.  --engine.InliningRecursionDepth=&amp;lt;Integer&amp;gt;    Maximum depth for recursive inlining.  --engine.MinInvokeThreshold=&amp;lt;Integer&amp;gt;        Minimum number of calls before a call target is compiled  --engine.Mode=&amp;lt;EngineMode&amp;gt;                   Configures the execution mode of the engine. Available modes are &#39;latency&#39; and &#39;throughput&#39;. The default value balances                                               between the two.  --engine.MultiTier                           Whether to use multiple Truffle compilation tiers by default.  --engine.OSR=&amp;lt;Boolean&amp;gt;                       Enable automatic on-stack-replacement of loops.  --engine.PartialBlockCompilation=&amp;lt;Boolean&amp;gt;   Enable partial compilation for BlockNode.  --engine.PartialBlockCompilationSize=&amp;lt;Integer&amp;gt;                                               Sets the target non-trivial Truffle node size for partial compilation of BlockNode nodes.  --engine.Splitting=&amp;lt;Boolean&amp;gt;                 Enable automatic duplication of compilation profiles (splitting).  --engine.TraceCompilation                    Print information for compilation results.Internal Engine OptionsThese are internal options for debugging language implementations and tools.  --engine.ArgumentTypeSpeculation=&amp;lt;Boolean&amp;gt;   Speculate on arguments types at call sites  --engine.CompilationFailureAction=&amp;lt;ExceptionAction&amp;gt;                                               Specifies the action to take when Truffle compilation fails.%nThe accepted values are:%n    Silent - Print nothing to                                               the console.%n     Print - Print the exception to the console.%n     Throw - Throw the exception to caller.%n  Diagnose                                               - Retry compilation with extra diagnostics enabled.%n    ExitVM - Exit the VM process.  --engine.CompilationStatisticDetails         Print additional more verbose Truffle compilation statistics at the end of a run.  --engine.CompilationStatistics               Print Truffle compilation statistics at the end of a run.  --engine.CompileImmediately                  Compile immediately to test Truffle compilation  --engine.CompileOnly=&amp;lt;String&amp;gt;                Restrict compilation to &#39;,&#39;-separated list of includes (or excludes prefixed with &#39;~&#39;).  --engine.ExcludeAssertions=&amp;lt;Boolean&amp;gt;         Exclude assertion code from Truffle compilations  --engine.InlineAcrossTruffleBoundary         Enable inlining across Truffle boundary  --engine.InstrumentBoundaries                Instrument Truffle boundaries and output profiling information to the standard output.  --engine.InstrumentBoundariesPerInlineSite   Instrument Truffle boundaries by considering different inlining sites as different branches.  --engine.InstrumentBranches                  Instrument branches and output profiling information to the standard output.  --engine.InstrumentBranchesPerInlineSite     Instrument branches by considering different inlining sites as different branches.  --engine.InstrumentExceptionsAreThrown       Propagates exceptions thrown by instruments.  --engine.InstrumentFilter=&amp;lt;String&amp;gt;           Method filter for host methods in which to add instrumentation.  --engine.InstrumentationTableSize=&amp;lt;Integer&amp;gt;  Maximum number of instrumentation counters available.  --engine.IterativePartialEscape              Run the partial escape analysis iteratively in Truffle compilation.  --engine.MaximumGraalNodeCount=&amp;lt;Integer&amp;gt;     Stop partial evaluation when the graph exceeded this many nodes.  --engine.MaximumInlineNodeCount=&amp;lt;Integer&amp;gt;    Ignore further truffle inlining decisions when the graph exceeded this many nodes.  --engine.NodeSourcePositions                 Enable node source positions in truffle partial evaluations.  --engine.OSRCompilationThreshold=&amp;lt;Integer&amp;gt;   Number of loop iterations until on-stack-replacement compilation is triggered.  --engine.PrintExpansionHistogram             Prints a histogram of all expanded Java methods.  --engine.Profiling=&amp;lt;Boolean&amp;gt;                 Enable/disable builtin profiles in com.oracle.truffle.api.profiles.  --engine.ReturnTypeSpeculation=&amp;lt;Boolean&amp;gt;     Speculate on return types at call sites  --engine.ShowInternalStackFrames             Show internal frames specific to the language implementation in stack traces.  --engine.SplittingAllowForcedSplits=&amp;lt;Boolean&amp;gt;                                               Should forced splits be allowed.  --engine.SplittingDumpDecisions              Dumps to IGV information on polymorphic events  --engine.SplittingGrowthLimit=&amp;lt;Double&amp;gt;       Disable call target splitting if the number of nodes created by splitting exceeds this factor times node count  --engine.SplittingMaxCalleeSize=&amp;lt;Integer&amp;gt;    Disable call target splitting if tree size exceeds this limit  --engine.SplittingMaxNumberOfSplitNodes=&amp;lt;Integer&amp;gt;                                               Disable call target splitting if number of nodes created by splitting exceeds this limit  --engine.SplittingMaxPropagationDepth=&amp;lt;Integer&amp;gt;                                               Propagate info about a polymorphic specialize through maximum this many call targets  --engine.SplittingTraceEvents                Trace details of splitting events and decisions.  --engine.TraceAssumptions                    Print stack trace on assumption invalidation  --engine.TraceCompilationAST                 Print the entire AST after each compilation  --engine.TraceCompilationCallTree            Print the inlined call tree for each compiled method  --engine.TraceCompilationDetails             Print information for compilation queuing.  --engine.TraceCompilationPolymorphism        Print all polymorphic and generic nodes after each compilation  --engine.TraceInlining                       Print information for inlining decisions.  --engine.TraceInliningDetails                Print detailed information for inlining (i.e. the entire explored call tree).  --engine.TracePerformanceWarnings=&amp;lt;PerformanceWarningKind&amp;gt;                                               Print potential performance problems  --engine.TraceSplitting                      Print information for splitting decisions.  --engine.TraceSplittingSummary               Used for debugging the splitting implementation. Prints splitting summary directly to stdout on shutdown  --engine.TraceStackTraceLimit=&amp;lt;Integer&amp;gt;      Number of stack trace elements printed by TraceTruffleTransferToInterpreter and TraceTruffleAssumptions  --engine.TraceTransferToInterpreter          Print stack trace on transfer to interpreter.  --engine.TreatPerformanceWarningsAsErrors=&amp;lt;PerformanceWarningKind&amp;gt;                                               Treat performance warnings as error. Handling of the error depends on the CompilationFailureAction option value  --engine.UseConservativeContextReferences    Enables conservative context references. This allows invalid sharing between contexts. For testing purposes only.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/Options/"
                  },
                  
                  "reference-manual-native-image-options":  {
                    "title": "",
                    "content": "Native Image OptionsThe native-image builder needs to provide the classpath for all classesusing the familiar option from the java launcher: -cp is followed by a listof directories or JAR files, separated by :. The name of the class containingthe main method is the last argument, or you can use -jar and provide a JARfile that specifies the main method in its manifest.The syntax of the native-image command is:      native-image [options] class [imagename] [options] to build an executable file for a class in thecurrent working directory. Invoking it executes the native-compiled code of thatclass.        native-image [options] -jar jarfile [imagename] [options] to build an image for a JAR file.  The options passed to native-image are evaluated left-to-right. For more information, see Native Image Build Configuration.The options fall into four categories:image generation options, macro options, non-standard options, and server options.Non-standard and server options are subject to change through a deprecation cycle.Command-line help is available. Run native-image --help to getthe commands overview, and native-image --help-extra to print help on non-standard,macro, and server options.Options to Native Image BuilderDepending on the GraalVM edition, the options to the native image builder (native-image) may differ.The following options are equally supported with both GraalVM Communty and Enterprise editions:  -cp, -classpath, --class-path &amp;lt;class search path of directories and zip/jar files&amp;gt;: a colon separated list of directories, JAR archives, and ZIP archives to search for class files.  -D&amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;: set a system property.  -J&amp;lt;flag&amp;gt;: pass &amp;lt;flag&amp;gt; directly to the JVM running the native image builder.  -O&amp;lt;level&amp;gt;: 0 for no optimizations, or 1 for basic optimizations (default).  --verbose: enable verbose output.  --version: print the product version and exit.  --help: print this help message.  --help-extra: print help on non-standard options.  --allow-incomplete-classpath: allow the image build with an incomplete class path. Report type resolution errors at runtime when they are accessed the first time, instead of during the image build.  --auto-fallback: build a standalone image if possible.  --enable-http: enable http support in a generated image.  --enable-https: enable https support in a generated image.  --enable-url-protocols: list comma-separated URL protocols to enable.  --features: a comma-separated list of fully qualified feature implementation classes.  --force-fallback: force building of a fallback image.  --initialize-at-build-time: a comma-separated list of packages and classes (and implicitly all of their superclasses) that are initialized during the image build. An empty string designates all packages.  --initialize-at-run-time: a comma-separated list of packages and classes (and implicitly all of their subclasses) that must be initialized at runtime and not during the image build. An empty string is currently not supported.  --install-exit-handlers: provide java.lang.Terminator exit handlers for executable images.  --libc: select the libc native library implementation to use (available implementations are glibc and musl).  --native-compiler-options: provide a custom C compiler option used to query code compilation.  --native-compiler-path: provide a custom path to the C compiler used to query code compilationand linking.  --native-image-info: show native toolchain information and image’s build settings.  --no-fallback: build a standalone image or report a failure.  --report-unsupported-elements-at-runtime: report the usage of unsupported methods and fields at runtime when they are accessed the first time, instead of an error during an image building.  --shared: build a shared library.  --static: build a statically-linked executable (requires libc and zlib static libraries).  --target: select the native image compilation target (in - format). It defaults to the host&#39;s OS-architecture pair.  --trace-class-initialization: provide a comma-separated list of fully-qualified class names that a classinitialization is traced for.  --trace-object-instantiation: provide a comma-separated list of fully-qualified class names that an objectinstantiation is traced for.  -da: disable assertions with specified granularity in the generated image. The  -da[:[packagename]|:[classname] or -disableassertions[:[packagename]|:[classname] variants are also supported.  -dsa: disable assertions in all system classes.  -ea: enable assertions with specified granularity in a generated image. The  -ea[:[packagename]|:[classname] or -enableassertions[:[packagename]|:[classname] variants are also supported.  -esa: enable assertions in all system classes.      -g: generate debugging information. Please be informed that debug information produced on GraalVM Community will differ from that generated on GraalVM Enterprise.    GraalVM Enterprise only: --gc=&amp;lt;value&amp;gt;: select the Native Image garbage collector implementation. Allowed options for &amp;lt;value&amp;gt; are G1 for G1 garbage collector or serial for Serial garbage collector (default).  GraalVM Enterprise only: --pgo: a comma-separated list of files from which to read the data collected for profile-guided optimization of AOT compiled code (reads from default.iprof if nothing is specified).  GraalVM Enterprise only: --pgo-instrument: instrument AOT compiled code to collect data for profile-guided optimization into the default.iprof file.Macro Options  --language:nfi: make the Truffle Native Function Interface language available  --language:python: make Python available as a language for the image  --language:R: make R available as a language for the image  --language:regex: make the Truffle Regular Expression engine available  --language:wasm: make WebAssembly available as a language for the image  --language:llvm: make LLVM bitcode available as a language for the image  --language:js: make JavaScript available as a language for the image  --language:ruby: make Ruby available as a language for the image  --tool:coverage: add source code coverage support to a GraalVM supported language  --tool:insight: add support for detailed access to a program’s runtime behavior, allowing users to inspect values and types at invocation or allocation sites  --tool:dap: add support to allow image to open a debugger port serving the Debug Adapter Protocol in IDEs like VS Code  --tool:chromeinspector: add debugging support to a GraalVM supported language  --tool:lsp: add the Language Server Protocol support to later attach compatible debuggers to GraalVM in IDEs like VS Code  --tool:profiler: add profiling support to a GraalVM supported languageThe --language:python, --language:ruby and --language:R polyglot macro options become available once the corresponding languages are added to the base GraalVM installation (see the GraalVM Updater guide).Non-standard Options  --expert-options: list image build options for experts  --expert-options-all : list all image build options for experts (use at your own risk)  --expert-options-detail: display all available help for a comma-separated list of option names. Pass * to show extra help for all options that contain it  --configurations-path &amp;lt;search path of option-configuration directories&amp;gt;: a separated list of directories to be treated as option-configuration directories  --debug-attach[=&amp;lt; port &amp;gt;]: attach to debugger during image building (default port is 8000)  --dry-run: output the command line that would be used for building  -V&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;:  provide values for placeholders in native-image.properties files  --help-experimental-build-server: display help for the image-build server specific optionsNative Image options are also distinguished as hosted and runtime options. Continue reading to the Native Image Hosted and Runtime Options guide.",
                    "url": " /reference-manual/native-image/Options/"
                  },
                  
                  "reference-manual-java-options":  {
                    "title": "",
                    "content": "Compiler Configuration on JVMThe options for configuring the GraalVM compiler on the JVM are in 3 categories.General OptionsThese are general options for setting/getting configuration details.  -XX:-UseJVMCICompiler: This disables use of the GraalVM compiler as the top tier JIT.This is useful when wanting to compare performance of the GraalVM compiler against the native JIT compilers.      -Dgraal.CompilerConfiguration=&amp;lt;name&amp;gt;: Selects the GraalVM compiler configuration to use. If omitted, the compilerconfiguration with the highest auto-selection priority is used. To see the setof available configurations, supply the value help to this option.    The current configurations and their semantics are:          enterprise: To produce highly optimized code with a possible trade-off to compilation time. [GraalVM Enterprise]      community: To produce reasonably optimized code with a faster compilation time.      economy: To compile as fast as possible with less optimal throughput of the generated code.            -Dgraal.ShowConfiguration=none: Prints information about the GraalVM compiler configuration selected.  This option only produces output when the compiler is initialized. By default, the GraalVM compiler is  initialized on the first top-tier compilation. For this reason, the way to use this option  is as follows: java -XX:+EagerJVMCI -Dgraal.ShowConfiguration=info -version.    The accepted values for this option are:          none: To show no information.      info: To print one line of output showing the name of the compiler configuration in use and the location it is loaded from.      verbose: To print detailed compiler configuration information.            -Dgraal.MitigateSpeculativeExecutionAttacks=None: Selects a strategy to mitigate speculative  execution attacks (e.g., SPECTRE).    Accepted values are:          None: No mitigations are used in JIT compiled code.      AllTargets: All branches are protected against speculative attacks. This has a largeperformance impact.      GuardTargets: Only branches that preserve Java memory safety are protected. This hasreduced performance impact.      NonDeoptGuardTargets: Same as GuardTargets except that branches which deoptimize arenot protected since they can not be executed repeatedly.      Performance Tuning Options  -Dgraal.UsePriorityInlining=true: This can be used to disable use of the advanced inliningalgorithm that favours throughput over compilation speed. [GraalVM Enterprise]  -Dgraal.Vectorization=true: This can be used to disable the auto vectorization optimization.[GraalVM Enterprise]  -Dgraal.OptDuplication=true: This can be used to disable the path duplication optimization. [GraalVM Enterprise]  -Dgraal.TuneInlinerExploration=0: This can be used to try tune for better peak performance or faster warmup.It automatically adjusts values governing the effort spent during inlining. The value of the option isa float clamped between -1 and 1 inclusive. Anything below0 reduces inlining effort and anything above 0 increasesinlining effort. In general, peak performance is improved with more inlining effortwhile less inlining effort improves warmup (albeit to a lower peak). Note that thisoption is only a heuristic and the optimal value can differ from application to application. [GraalVM Enterprise]      -Dgraal.TraceInlining=false: Enables tracing of inlining decisions. This can be used  for advanced tuning where it may be possible to change the source code of the program.  The output format is shown below:    compilation of &#39;Signature of the compilation root method&#39;:at &#39;Sig of the root method&#39; [&#39;Bytecode index&#39;]: &amp;lt;&#39;Phase&#39;&amp;gt; &#39;Child method signature&#39;: &#39;Decision made about this callsite&#39;  at &#39;Signature of the child method&#39; [&#39;Bytecode index&#39;]:     |--&amp;lt;&#39;Phase 1&#39;&amp;gt; &#39;Grandchild method signature&#39;: &#39;First decision made about this callsite&#39;     --&amp;lt;&#39;Phase 2&#39;&amp;gt; &#39;Grandchild method signature&#39;: &#39;Second decision made about this callsite&#39;  at &#39;Signature of the child method&#39; [&#39;Bytecode index&#39;]: &amp;lt;&#39;Phase&#39;&amp;gt; &#39;Another grandchild method signature&#39;: &#39;The only decision made about this callsite.&#39;    For example:    compilation of java.lang.Character.toUpperCaseEx(int):at java.lang.Character.toUpperCaseEx(Character.java:7138) [bci: 22]:   ├──&amp;lt;GraphBuilderPhase&amp;gt; java.lang.CharacterData.of(int): no, bytecode parser did not replace invoke   └──&amp;lt;PriorityInliningPhase&amp;gt; java.lang.CharacterData.of(int): yes, worth inlining according to the cost-benefit analysis.at java.lang.Character.toUpperCaseEx(Character.java:7138) [bci: 26]:   ├──&amp;lt;GraphBuilderPhase&amp;gt; java.lang.CharacterDataLatin1.toUpperCaseEx(int): no, bytecode parser did not replace invoke   └──&amp;lt;PriorityInliningPhase&amp;gt; java.lang.CharacterDataLatin1.toUpperCaseEx(int): yes, worth inlining according to the cost-benefit analysis.  at java.lang.CharacterDataLatin1.toUpperCaseEx(CharacterDataLatin1.java:223) [bci: 4]:     ├──&amp;lt;GraphBuilderPhase&amp;gt; java.lang.CharacterDataLatin1.getProperties(int): no, bytecode parser did not replace invoke     └──&amp;lt;PriorityInliningPhase&amp;gt; java.lang.CharacterDataLatin1.getProperties(int): yes, worth inlining according to the cost-benefit analysis.  Diagnostic Options      -Dgraal.CompilationFailureAction=Silent: Specifies the action to take when compilation fails by  throwing an exception.    The accepted values are:          Silent: Print nothing to the console.      Print: Print a stack trace to the console.      Diagnose: Retry the compilation with extra diagnostics enabled. On VM exit, the collected diagnostics are saved to a zip file that can be submitted along with a bug report. A message is printed to the console describing where the diagnostics file is saved:        Graal diagnostic output saved in /Users/graal/graal_dumps/1549459528316/graal_diagnostics_22774.zip            ExitVM: Same as Diagnose except that the VM process exits after retrying.        For all values except for ExitVM, the VM continues executing.    -Dgraal.CompilationBailoutAsFailure=false: The compiler may not complete compilation of a method due to some property or code shape in the method (e.g., exotic uses of the jsr and ret bytecodes). In this case the compilation bails out. If you want to be informed of such bailouts, this option makes GraalVM treat bailouts as failures and thus be subject to the action specified by the -Dgraal.CompilationFailureAction option.  -Dgraal.PrintCompilation=false: Prints an informational line to the console for each completed compilation.For example:    HotSpotCompilation-11  Ljava/lang/Object;                            wait          ()V       |  591ms    12B    92B  4371kBHotSpotCompilation-175 Ljava/lang/String;                            lastIndexOf   (II)I     |  590ms   126B   309B  4076kBHotSpotCompilation-184 Ljava/util/concurrent/ConcurrentHashMap;      setTabAt      ([Ljava/util/concurrent/ConcurrentHashMap$Node;ILjava/util/concurrent/ConcurrentHashMap$Node;)V  |  591ms    38B    67B  3411kBHotSpotCompilation-136 Lsun/nio/cs/UTF_8$Encoder;                    encode        ([CII[B)I |  591ms   740B   418B  4921  Setting Compiler Options with Language LaunchersThe GraalVM compiler properties above are usable with some other GraalVM launchers such asnode, js and lli. The prefix for specifying the properties is slightly different.For example:java -XX:+EagerJVMCI -Dgraal.ShowConfiguration=info -versionBecomes:js --jvm --vm.Dgraal.ShowConfiguration=info -versionNote the -D prefix is replaced by --vm.D.",
                    "url": " /reference-manual/java/options/"
                  },
                  
                  "reference-manual-js-options":  {
                    "title": "",
                    "content": "OptionsRunning JavaScript on GraalVM can be configured with several options.GraalVM JavaScript Launcher OptionsThese options are to control the behaviour of the js launcher:  -e, --eval CODE : evaluate the JavaScript source code, then exit the engine.    js -e &#39;print(1+2);&#39;    -f, --file FILE: load and execute the provided script file. Note that the -f flag is optional and can be omitted in most cases, as any additional argument to js will be interpreted as file anyway.    js -f myfile.js    --version: print the version information of GraalVM JavaScript, then exit.  --strict: execute the engine in JavaScript’s strict mode.GraalVM JavaScript Engine OptionsThese options are to configure the behavior of the GraalVM JavaScript engine.Depending on how the engine is started, the options can be passed either to the launcher or programmatically.Note that most of these options are experimental and require an --experimental-options flag.To the LauncherTo the launcher, the options are passed with --js.&amp;lt;option-name&amp;gt;=&amp;lt;value&amp;gt;:js --js.ecmascript-version=6The following options are currently available:  --js.annex-b: enable ECMAScript Annex B web compatibility features. Boolean value, default is true.  --js.array-sort-inherited: define whether Array.protoype.sort should sort inherited keys (implementation-defined behavior). Boolean value, default is true.  --js.atomics: enable ES2017 Atomics. Boolean value, default is true.  --js.ecmascript-version: emulate a specific ECMAScript version. Integer value (5-13, or 2015-2022), default is the latest stable version.  --js.foreign-object-prototype: provide JavaScript’s default prototype to foreign objects that mimic JavaScript’s own types (foreign Arrays, Objects and Functions). Boolean value, default is false.  --js.intl-402: enable ECMAScript Internationalization API. Boolean value, default is false.  --js.regexp-static-result: provide static RegExp properties containing the results of the last successful match, e.g., RegExp.$1 (legacy). Boolean value, default is true.  --js.shared-array-buffer: enable ES2017 SharedArrayBuffer. Boolean value, default is false.  --js.strict: enable strict mode for all scripts. Boolean value, default is false.  --js.timezone: set the local time zone. String value, default is the system default.  --js.v8-compat: provide better compatibility with Google’s V8 engine. Boolean value, default is false.ProgrammaticallyWhen started from Java via GraalVM’s Polyglot feature, the options are passed programmatically to the Context object:Context context = Context.newBuilder(&quot;js&quot;)                         .option(&quot;js.ecmascript-version&quot;, &quot;6&quot;)                         .build();context.eval(&quot;js&quot;, &quot;42&quot;);See the Polyglot Programming reference for information on how to set options programmatically.Stable and Experimental OptionsThe available options are distinguished in stable and experimental options.If an experimental option is used, an extra flag has to be provided upfront.In the native launchers (js and node), --experimental-options has to be passed before all experimental options.When using a Context, the option allowExperimentalOptions(true) has to be called on the Context.Builder.See ScriptEngine Implementation on how to use experimental options with a ScriptEngine.ECMAScript VersionThis option provides compatibility to a specific version of the ECMAScript specification.It expects an integer value, where both the counting version numbers (5 to 11) and the publication years (starting from 2015) are supported.The default in the development version of GraalVM is the ECMAScript 2021 specification.GraalVM JavaScript implements some features of the future draft specification and of open proposals, if you explicitly select that version and/or enable specific experimental flags.For production settings, it is recommended to set the ecmascript-version to an existing, finalized version of the specification.Available versions are:  5 for ECMAScript 5.x  6 or 2015 for ECMAScript 2015  7 or 2016 for ECMAScript 2016  8 or 2017 for ECMAScript 2017  9 or 2018 for ECMAScript 2018  10 or 2019 for ECMAScript 2019  11 or 2020 for ECMAScript 2020  12 or 2021 for ECMAScript 2021 (default, latest finalized version of the specification)  13 or 2022 for ECMAScript 2022 (future changes and proposals)As of GraalVM 21.2, the flag can also be set to latest or staging, to use the latest stable version (which is the default), or the staging version including experimental functionality under development.intl-402This option enables ECMAScript’s Internationalization API.It expects a Boolean value and the default is false.Strict ModeThis option enables JavaScript’s strict mode for all scripts.It expects a Boolean value and the default is false.",
                    "url": " /reference-manual/js/Options/"
                  },
                  
                  "reference-manual-llvm-options":  {
                    "title": "",
                    "content": "LLI Command OptionsThe syntax to execute programs in LLVM bitcode format with GraalVM is:lli [LLI options] [GraalVM options] [polyglot options] &amp;lt;bitcode file&amp;gt; [program args]Here, &amp;lt;bitcode file&amp;gt; is a compiled program with embedded LLVM bitcode.The following options to lli are available:      --llvm.managed: enable a managed execution mode for LLVM IR code, which means memoryallocations from LLVM bitcode are done on the managed heap. Learn more from Limitations and Differences to Native Execution. Note: Managed execution mode for LLVM bitcode is possible with GraalVM Enterprise only.        --print-toolchain-path: print the path of the LLVM toolchain bundled with GraalVM.This directory contains compilers and tools that can be used to compile C/C++ programsto LLVM bitcode for execution on GraalVM.        --print-toolchain-api-tool &amp;lt;tool&amp;gt;: print the path of a tool from the LLVM toolchain.Valid values for &amp;lt;tool&amp;gt; are CC, CXX, LD, AR, NM, OBJCOPY, OBJDUMP,RANLIB, READELF, READOBJ, or STRIP.        --print-toolchain-api-paths &amp;lt;path&amp;gt;: print a search path for the LLVM toolchain.Valid values for &amp;lt;path&amp;gt; are PATH and LD_LIBRARY_PATH.        --print-toolchain-api-identifier: print a unique identifier of the LLVM toolchain.Different modes of the LLVM runtime (e.g., --llvm.managed) might require compilationof bitcode with a different LLVM toolchain. This identifier can be used as a stabledirectory name to store build outputs for different modes.        -L &amp;lt;path&amp;gt;/--llvm.libraryPath=&amp;lt;path&amp;gt;: a list of paths where GraalVM will search forlibrary dependencies. Paths are delimited by :.        --lib &amp;lt;libs&amp;gt;/--llvm.libraries=&amp;lt;libs&amp;gt;: a list of libraries to load in addition tothe dependencies of the main binary. Files with a relative path are looked up relativeto llvm.libraryPath. Entries are delimited by :.        --version: print the version and exit.        --version:graalvm: print the GraalVM version information and exit.  Expert and Diagnostic OptionsUse --help and --help:&amp;lt;topic&amp;gt; to get a full list of options.",
                    "url": " /reference-manual/llvm/Options/"
                  },
                  
                  "reference-manual-native-image-pgo":  {
                    "title": "",
                    "content": "Profile-Guided OptimizationsGraalVM Enterprise allows to apply profile-guided optimizations (PGO) for additional performance gain and higher throughput of native images.With PGO you can collect the profiling data in advance and then feed it to the native image builder, which will use this information to optimize the performance of the resulting binary.Note: This feature is available with GraalVM Enterprise only.Here is how you can build an optimized native image, using the OptimizedImage.java example program.1. Save this Java program that iterates over ArrayList using a lambda expression to a file and compile it:import java.util.ArrayList;class OptimizedImage {  public static void main(String[] args) {    ArrayList&amp;lt;String&amp;gt; languages = new ArrayList&amp;lt;&amp;gt;();    languages.add(&quot;JavaScript&quot;);    languages.add(&quot;Python&quot;);    languages.add(&quot;Ruby&quot;);    System.out.print(&quot;ArrayList: &quot;);    languages.forEach((e) -&amp;gt; {      System.out.print(e + &quot;, &quot;);    });  }}javac OptimizedImage.java2. Build an instrumented native image by appending the --pgo-instrument option, whose execution will collect the code-execution-frequency profiles:native-image --pgo-instrument OptimizedImage3. Run this instrumented image, saving the result in a profile.iprof file, if nothing else is specified:./optimizedimage4. Lastly, create the second native image by specifying the path to the profile.iprof file and execute it.native-image --pgo=profile.iprof OptimizedImage./optimizedimageYou can collect multiple profile files, by specifying different names, and add them to the image build.",
                    "url": " /reference-manual/native-image/PGO/"
                  },
                  
                  "reference-manual-python-packages":  {
                    "title": "",
                    "content": "Installing Supported PackagesCreate a Virtual EnvironmentThe best way of using GraalVM’s Python runtime is from a virtual environment.This generates wrapper scripts and makes the implementation usable from shell as the standard Python interpreter.To create the virtual environment with GraalVM:graalpython -m venv &amp;lt;venv-dir&amp;gt;To activate the environment in your shell session call:source &amp;lt;venv-dir&amp;gt;/bin/activateUsing ginstallAt the moment, there are not enough standard libraries implemented to run the standard package installers for many packages.As a convenience, a simple module to install packages is provided (including potential patches required for those packages).Try the following to find out more:graalpython -m ginstall --helpAs a slightly more exciting example, try:graalpython -m ginstall install numpyIf all goes well (also consider native dependencies of NumPy), you should be able to import numpy afterwards.The support for more extensions is a high priority.The GraalVM team is actively working to enable support for the Python C API, as well as to make extensions such as NumPy, SciPy, Scikit-learn, Pandas, Tensorflow, and alike, work.Other extensions might currently work, but they are not actively tested.Note that to try extensions on GraalVM’s Python runtime, you have to download, build, and install them manually for now.Using pipThe pip package installer is available and working when using a venv.",
                    "url": " /reference-manual/python/Packages/"
                  },
                  
                  "reference-manual-r-parallelexecution":  {
                    "title": "",
                    "content": "Parallel ExecutionThe FORK cluster and functions depending solely on forking (e.g., mcparallel) are not supported by the GraalVM R runtime at the moment.However, users can use the PSOCK cluster, which should work in the same way on the GraalVM R runtime as on GNU R.Moreover, R can be used as a worker node in a PSOCK cluster computation driven from GNU R.See FastRCluster package for GNU R, which provides helper functions to create PSOCK cluster nodes that run the GraalVM R runtime.",
                    "url": " /reference-manual/r/ParallelExecution/"
                  },
                  
                  "reference-manual-python-parserdetails":  {
                    "title": "",
                    "content": "Python Code Parsing and pyc FilesThis guide elaborates on how Python files are parsed on the GraalVM Python runtime.Parser PerformanceLoading code from serialized .pyc files is faster than parsing the .py file using ANTLR.Creating the abstract syntax tree (AST) for a Python source has two phases.The first one creates a simple syntax tree (SST) and a scope tree.The second phase transforms the SST to the Language Implementation framework tree.For the transformation, the scope tree it needed.The scope tree contains scope locations for variable and function definitions, and information about scopes.The simple syntax tree contains nodes mirroring the source.Comparing the SST and the Language Implementation framework tree, the SST is much smaller.It contains just the nodes representing the source in a simple way.One SST node is usually translated to many the Language Implementation framework nodes.The simple syntax tree can be created in two ways: with ANTLR parsing, or deserialization from an appropriate *.pyc file.If there is no appropriate .pyc file for a source, then the source is parsed with ANTLR.If the Python standard import logic finds an appropriate .pyc file, it will just trigger deserialization of the SST and scope tree from it.The deserialization is much faster than source parsing with ANTLR and needs only roughly 30% of the time that ANTLR needs.Of course, the first import of a new file is a little bit slower – besides parsing with ANTLR, the Python standard library import logic serializes the resulting code object to a .pyc file, which in our case meansthe SST and scope tree are serialized such a file.Creating and Managing pyc Files.pyc files are created automatically by the GraalVM Python runtime when no or an invalid .pyc file is found matching the desired .py file.When a Python source file (module) is imported during an execution for the first time, the appropriate .pyc file is created automatically.If the same module is imported again, then the already created .pyc file is used.That means that there are no .pyc files for source files that were not executed (imported) yet.The creation of .pyc files is done entirely through the FileSystem API, so that embedders can manage the file system access.Every subsequent execution of a script will reuse the already existing .pyc files, or will generate a new one.A .pyc file is regenerated if the timestamp or hashcode of the original source file is changed.The hashcode is generated only based on the Python source by calling source.hashCode(), which is the JDK hash code over the array of source file bytes, calculated with java.util.Arrays.hashCode(byte[]).The .pyc files are also regenerated if a magic number in the Python parser is changed.The magic number is hard-coded in the Python source and can not be changed by the user (unless of course that user has access to the bytecode of Python).The developers of GraalVM’s Python runtime change the magic number when the format of SST or scope tree binary data is altered.This is an implementation detail, so the magic number does not have to correspond to the version of GraalVM’s Python runtime (just like in CPython).The magic number of pyc is a function of the concrete Python runtime Java code that is running.Note that if you use .pyc files, you will need to allow write-access to GraalVM’s Python runtime at least when switching versions or changing the original source code.Otherwise, the regeneration of source files will fail and every import will have the overhead of accessing the old .pyc file, parsing the code, serializing it, and trying (and failing) to write out a new .pyc file.A *.pyc file is never deleted by GraalVM’s Python runtime, only regenerated.It is regenerated when the appropriate source file is changed (timestamp of last modification or hashcode of the content) or the magic number of the Python imnplementation parser changes.Magic number changes will be communicated in the release notes so that embedders or system administrators can delete old .pyc files when upgrading.The folder structure created for .pyc files looks like this:top_folder    __pycache__         sourceA.graalpython.pyc         sourceB.graalpython.pyc    sourceA.py    sourceB.py    sub_folder        __pycache__            sourceX.graalpython.pyc        sourceX.pyBy default the __pycache__ directory is created on the same directory level as a source code file and in this directory all .pyc files from the same directory are stored.This folder may store .pyc files created with different versions of Python (including, e.g., CPython), so the user may see files ending in *.cpython3-6.pyc for example.The current implementation also includes a copy of the original source text in the .pyc file.This is a minor performance optimization so you can create a Source object with the path to the original source file, but you do not need to read the original *.py file, which speeds up the process obtaining the Language Implementation framework tree (just one file is read).The structure of a .graalpython.pyc file is this:MAGIC_NUMBERsource textbinary data - scope treebinary data - simple syntax treeNote that the .pyc files are not an effective means to hide Python library source code from guest code, since the original source can still be recovered.Even if the source were omitted, the syntax tree contains enough information to decompile into source code easily.The serialized SST and scope tree are stored in a Python code object as well, as the content of the attribute co_code (which contains bytecode on CPython). For example:&amp;gt;&amp;gt;&amp;gt; def add(x, y):...   return x+y...&amp;gt;&amp;gt;&amp;gt; add.__code__.co_codeb&#39;x01x00x00x02[]Kxbfxd1x00x00x00x00x00x00x00x00x00x00x00x00 ...&#39;.pyc files are largely managed automatically by the runtime in a manner compatible to CPython. Like on CPython there are options to specify their location, and if they should be written at all, and both of these options can be changed by guest code.The creation of *.pyc files can be controlled in the same ways as on CPython(c.f. https://docs.python.org/3/using/cmdline.html):  GraalVM’s Python launcher (graalpython) reads the PYTHONDONTWRITEBYTECODEenvironment variable. If this is set to a non-empty string, Python will nottry to write .pyc files when importing modules.  The launcher command line option -B, if given, has the same effect as theabove.  A guest language code can change the attribute dont_write_bytecode of thesys built-in module at runtime to change the behavior for subsequentimports.  The launcher reads the PYTHONPYCACHEPREFIX environment variable. If set,the __pycache__ directory will be created at the path pointed to by theprefix, and a mirror of the directory structure of the source tree will becreated on-demand to house the .pyc files.  A guest language code can change the attribute pycache_prefix of the sysmodule at runtime to change the location for subsequent imports.Since the embedder cannot use environment variables or CPython options tocommunicate these options to GraalVM’s implementation of Python, these options are made available asthese language options:  python.DontWriteBytecodeFlag - equivalent to -B or PYTHONDONTWRITEBYTECODE  python.PyCachePrefix - equivalent to PYTHONPYCACHEPREFIXNote that a Python context will not enable writing .pyc files by default.The graalpython launcher enables it by default, but if this is desired in the embedding use case, care should be taken to ensure that the __pycache__ location is properly managed and the files in that location are secured against manipulation just like the source .py files they were derived from.Note also that to upgrade the application sources to GraalVM Enteprise’s Python runtime, old .pycfiles must be removed by the embedder as required.Security ConsiderationsThe serialization of SST and scope tree is hand-written and during deserialization, it is not possible to load classes other than SST Nodes.Java serialization or other frameworks are not used to serialize Java objects.The main reason is performance, but this has the effect that no class loading can be forced by a maliciously crafted .pyc file.All file operations (obtaining the data, timestamps, and writing pyc files)are done through the FileSystem API. Embedders can modify all of these operations by means of custom (e.g., read-only) FileSystem implementations.The embedder can also effectively disable the creation of .pyc files by disabling I/O permissions for GraalVM’s Python runtime.If the .pyc files are not readable, their location is not writable.If the .pyc files’ serialization data or magic numbers are corrupted in any way, the deserialization fails and we just parse the .py file again.This comes with a minor performance hit only for the parsing of modules, which should not be significant for most applications (provided the application does actual work besides loading Python code).",
                    "url": " /reference-manual/python/ParserDetails/"
                  },
                  
                  "reference-manual-r-performance":  {
                    "title": "",
                    "content": "Runtime PerformanceGraalVM optimizes R code that runs for extended periods of time.The speculative optimizations based on the runtime behaviour of the R code and dynamic compilation employed by the GraalVM runtime are capable of removing most of the abstraction penalties incurred by the dynamism and complexity of the R language.Examine the algorithm in the following example which calculates the mutual information of a large matrix:x &amp;lt;- matrix(runif(1000000), 1000, 1000)mutual_R &amp;lt;- function(joint_dist) { joint_dist &amp;lt;- joint_dist/sum(joint_dist) mutual_information &amp;lt;- 0 num_rows &amp;lt;- nrow(joint_dist) num_cols &amp;lt;- ncol(joint_dist) colsums &amp;lt;- colSums(joint_dist) rowsums &amp;lt;- rowSums(joint_dist) for(i in seq_along(1:num_rows)){  for(j in seq_along(1:num_cols)){   temp &amp;lt;- log((joint_dist[i,j]/(colsums[j]*rowsums[i])))   if(!is.finite(temp)){    temp = 0   }   mutual_information &amp;lt;-    mutual_information + joint_dist[i,j] * temp  } } mutual_information}system.time(mutual_R(x))#   user  system elapsed#  1.321   0.010   1.279Algorithms such as this one usually require C/C++ code to run efficiently:1if (!require(&#39;RcppArmadillo&#39;)) {    install.packages(&#39;RcppArmadillo&#39;)    library(RcppArmadillo)}library(Rcpp)sourceCpp(&quot;r_mutual.cpp&quot;)x &amp;lt;- matrix(runif(1000000), 1000, 1000)system.time(mutual_cpp(x))#   user  system elapsed#  0.037   0.003   0.040(Uses r_mutual.cpp.)However, after a few iterations, GraalVM runs the R code efficiently enough to make the performance advantage of C/C++ negligible:system.time(mutual_R(x))#   user  system elapsed#  0.063   0.001   0.077The GraalVM R runtime is primarily aimed at long-running applications.Therefore, the peak performance is usually only achieved after a warmup period.While startup time is currently slower than GNU R’s, due to the overhead from Java class loading and compilation, future releases will contain a native image of R with improved startup.1 When this example is run for the first time, it installs the RcppArmadillo package,which may take a few minutes.Note that this example can be run in both GraalVM’s R runtime and GNU R.",
                    "url": " /reference-manual/r/Performance/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-profiling":  {
                    "title": "",
                    "content": "Profiling Truffle InterpretersThere is no shortage of tools for profiling interpreters written using Truffle.When running in JVM mode you can use standard JVM tooling such as VisualVM, Java Flight Recorder, and Oracle Developer Studio. When running in Native Image you can use callgrind from the Valgrind tool suite, and other system tools such as strace.As a language running on GraalVM, other GraalVM tools can be used.For a broad enough definition of profiling, you can also use the Ideal Graph Visualizer (IGV) and C1 Visualizer to inspect the compiler output.This guide is less about how to use each tool and more about suggestions for extracting the most useful information from the tools, assuming a basic knowledge of their usage.Profiling with CPU SamplerThe simplest way to profile the application level, for example, to find in which guest-language function(s) most of the time is spent, is to use CPU Sampler, which is part of the /tools suite and part of GraalVM.Simply pass --cpusampler to your language launcher:language-launcher --cpusampler --cpusampler.Delay=MILLISECONDS -e &#39;p :hello&#39;You probably want to use a sampling delay with --cpusampler.Delay=MILLISECONDS to only start profiling after warmup. That way, you can easily identify which functions get compiled and which do not and yet take a significant amount of time to execute.See language-launcher --help:tools for more --cpusampler options.Creating a Flame Graph from CPU SamplerThe histogram output from CPUSampler can be quite large, making it difficult to analyze.Additionally, as a flat format it is nto possible to analyze a call graph as that information simply is not encoded in the output.A flame graph shows the entire call graph.Its structure makes it considerably simpler to see where the application time is being spent.Creating the flame graph is a multi-stage process. First, we need to profile the application with the JSON formatter:language-launcher --cpusampler --cpusampler.SampleInternal --cpusampler.Mode=roots --cpusampler.Output=json -e &#39;p :hello&#39; &amp;gt; simple-app.jsonUse the --cpusampler.SampleInternal=true option if you want to profile internal sources, such as standard library functions.Using the --cpusampler.Mode=roots option will sample each function, including inlined functions, which is more intuitive when looking at a flame graph and can often give a better idea of what is contributing to the overall method execution time. However, --cpusampler.Mode=roots adds extra overhead, so you might want to try without too.The default is to not include inlined functions in order to minimize overhead.The JSON formatter encodes call graph information that isn’t available in the histogram format.To make a flame graph out of this output, however, we need to transform it into a format that folds the call stack samples into single lines.This can be done using stackcollapse-graalvm.rb from Benoit Daloze’s fork of FlameGraph.If you have not yet, you should clone this fork of FlameGraph into the parent directory.Now you can run the script to transform the output and pipe it into the script that will generate the SVG data:../FlameGraph/stackcollapse-graalvm.rb simple-app.json | ../FlameGraph/flamegraph.pl &amp;gt; simple-app.svgAt this point, you should open the SVG file in a Chromium-based web browser.Your system might have a different image manipulation application configured as the default application for SVG files.While loading the file in such an application may render a graph, it likely will not handle the interactive components of the flame graph. Firefox may work as well, but Chromium-based browsers currently seem to have better support and performance for the flame graph files.Profiling with Oracle Developer StudioOracle Developer Studio includes aPerformance Analyzer that can be used with GraalVM.Developer Studio can be downloaded from OTN and the current version at time of writing (12.6) provides a perpetual no-cost license for production use and the development of commercial applications.Using the Developer Studio Performance Analyser is straightforward. Include the path to the Developer Studio binaries in your PATH and then prefix your normal command-line with collect.For example:collect js mybenchmark.jsOn completion an “experiment” (.er) directory will have been created containing the profiling data for the command execution, test.1.er by default.To view the profiling results, use the analyzer tool:analyzer test.1.erThe analyzer GUI allows you to view the captured profiling information in several different ways, e.g., the timeline of your application, a flat function list, the call tree, a flame graph, etc.There is also a command-line tool, er_print, which can be used for outputting the profiling information in textual form, for further analysis.For full details, see the Performance Analyzer documentation.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/Profiling/"
                  },
                  
                  "reference-manual-native-image-properties":  {
                    "title": "",
                    "content": "Using System Properties in Native ImagesAssume you have the following Java Program:public class App {    public static void main(String[] args) {        System.getProperties().list(System.out);    }}If you compile that with, e.g., native-image -Dfoo=bar App the system property foo will be available at image build time.For example, whenever you are in the code that is part of your application but executed at image build time (usually static field initializations and static initializers).Thus if you execute the image above it will not contain foo in the list of properties.If, on the other hand, you execute the image with app -Dfoo=bar, it will show foo in the list of properties because you specified it for image run time.In other words:  Passing -D&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; to native-image affects properties seen at image build time.  Passing -D&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; to an image execution affects properties seen at image run time.",
                    "url": " /reference-manual/native-image/Properties/"
                  },
                  
                  "tools-vscode-micronaut-extension":  {
                    "title": "",
                    "content": "Micronaut Visual Studio Code ExtensionThe Micronaut extension for Visual Studio Code (VS Code) provides the basic support for developing applications based on the Micronaut Framework.The extension is Technology Preview.The extension also enables the Micronaut Launch application that allows you to create Micronaut projects through an interface inside VS Code, in addition to using the console CLI.Optionally, if a user provides a path to the Micronaut CLI installation, the option to create a project using the mn executable is also provided.In combination with the GraalVM Extension, you can run Micronaut projects on GraalVM, and debug them directly from the VS Code development environment with different debugging protocols enabled with the extension.The Micronaut extension was also developed to help developers build native images right from the VS Code console.Table of contents    Installation and Setup  Features          Micronaut VS Code Commands      Extension Settings        Create Micronaut Project  Generate Native Images of Micronaut Projects  Deploy Micronaut Projects  Feedback  Privacy Policy  Known IssuesInstallation and SetupInstall the Micronaut extension from the VS Code consolde by clicking on the “Extensions” icon in the Activity Bar (or invoke it with Ctrl+Shift+X). Search for “Micronaut” and install the package. Reload will be required.Note: The Micronaut extension also requires the GraalVM Extension, which provides support for editing and debugging polyglot programs running on GraalVM. Please install it the same way.When installed, the Micronaut extension might check whether there is a registered GraalVM instance, and eventually request to download it or point to a local installation (see GraalVM  Installation and Setup in VS Code).Upon installaiton, the Micronaut Tools Page window opens, which provides you with shortcuts to:  create a new Micronaut project or open an exisiting one  build a native executable of a Micronaut project  acquaint you with available features  redirect you to the documentation availableFeaturesThe Micronaut extension provides:  the Micronaut project creation wizard  installation of Micronaut CLI  editing and debugging capabilities for Micronaut projects  code completion and navigation for Micronaut configuration (yaml) files and java (available with Apache NetBeans Language Server extension).  the ability to build Micronaut projects ahead-of-time into native images with GraalVMMicronaut VS Code CommandsTo begin, invoke the Micronaut commands from the View &amp;gt; Command Palette (Command Palette can be also opened by pressing F1, or the Ctrl+Shift+P hot keys combination for Linux, and Command+Shift+P for macOS):The following commands are available for Micronaut project development:  Micronaut: Show Micronaut Tools Page - show the Micronaut Tools Page  Micronaut: Create Micronaut Project - create a Micronaut project based on https://micronaut.io/launch  Micronaut: Build ... - build a Micronaut project with the user-selected goal/target  Micronaut: Build Native Image - build a native executable of a Micronaut project  Micronaut: Deploy ... - build and deploy Docker image for Micronaut projectExtension SettingsThis extension contributes the following settings:  micronaut.home - the optional path to the Micronaut CLI installation  micronaut.showWelcomePage - show the Micronaut Tools Page on extension activationCreate Micronaut ProjectThe Create Micronaut Project command in VS Code supports generating Micronaut applications, CLI applications, and other types of applications that a regular Micronaut Launch application does. The wizard prompts users to:  pick the application type  pick the Micronaut version  pick the Java version  provide a project name  provide a base package name  pick the project language (Java, Kotlin, Groovy)  pick the project features:  pick the build tool (Maven or Gradle)  pick the test framework (JUnit, Spock, Kotlintest)Finally, you are asked to select the destination folder on your local disk and whether to open the created project in a new editor or add it to the current workspace.The GUI part of the Micronaut extension adds a new view to the Explorer activity, which shows Micronaut projects in the current workspace.Generate Native Images of Micronaut ProjectsThe Micronaut support for VS Code is integrated with GraalVM to get the most from the applications and provide you with rich Native Image capabilities.Having set up GraalVM as the default runtime and debug environment in VS Code, invoke the “Command Palette -&amp;gt; Micronaut: Build…” command, where you can select the build targets (e.g., clean, build, nativeImage, etc.) from a list of available ones.For example, if your project is built with Maven, and you would like to package the compiled code as a GraalVM native image, select nativeImage.That will run the mvnw package -Dpackaging=native-image job.Besides that, you can push a newly-built native executable to the Docker Registry from the VS Code console.For more details, continue reading to the Micronaut documentation.Deploy Micronaut ProjectsThe Micronaut support in VSCode also allows to build and deploy Docker image to docker registry. Use command “Command Palette -&amp;gt; Micronaut: Deploy…” and select “dockerPush” to deploy dockerized Micronaut application or “dockerPushNative” to build and push docker with native executable of Micronaut application.Particular docker registry can be configured in the build, see Micronaut Deploying Application documentation.Feedback  Request a feature  File a bugPrivacy PolicyRead the Oracle Privacy Policy to learn more.Known IssuesThe Micronaut extension 0.5.0 is Technology Preview, meaning the functionality may not be complete.Please be informed that the subsequent runs of a Micronaut project may fail in this version.For example, you create a Gradle Micronaut project using GraalVM, run it with the Run / Run Without Debugging command (Ctrl+F5), and then terminate it. If you re-run the project again using the same Run / Run Without Debugging command (Ctrl+F5), startup may fail with this exception:[main] ERROR i.m.h.server.netty.NettyHttpServer - Unable to start server. Port already 8080 in use.",
                    "url": " /tools/vscode/micronaut-extension/"
                  },
                  
                  "tools-vscode-graalvm-extension":  {
                    "title": "",
                    "content": "GraalVM Visual Studio Code ExtensionThe GraalVM Extension for Visual Studio Code (VS Code) provides basic support for editing and debugging programs running on GraalVM.The extension is Technology Preview.The GraalVM extension on pair with Apache NetBeans Language Server extension will also enable a full-fledged support for Java 8 and higher, as well as Java to scripting languages polyglot debugging in VS Code.GraalVM VSCode Extension enables a polyglot environment in VSCode, thus making it suitable and convenient to work with GraalVM from an integrated development environment, and to allow VS Code users to edit and debug applications written in any of the GraalVM supported languages (Java, JS, Ruby, R, and Python).Table of contents  Features  Installation and Setup  Java Development and Debugging  JavaScript and Node.js Debugging  Python Debugging  R Debugging  Ruby Debugging  Polyglot Applications Debugging  Debug Adapter Protocol  Language Server Protocol Integration  R Language Server  Ruby Language Server  Additional Editor Features  Extension Settings  Recommendations  Feedback  Privacy PolicyFeaturesThe installation wizard for the GraalVM VS Code Extension simplifies setting up the development environment.You can now download and install any available GraalVM distribution right from the user interface, or, alternatively, you can select an existing GraalVM installation from your local disk.The GraalVM Extension brings support for Java projects development and debugging in VS Code.This extension for VS Code also provides editing and debugging capabilities for JavaScript and Node.js, Python, R, and Ruby applications running on GraalVM by default.The GraalVM VS Code Extension is a prerequisite for the Micronaut support in VS Code, which brings many more possibilities for Java developers.The future development of the extension should also enable generating native executables right from the VS Code console.The development team is actively working on further improvements and are focused on tne GraalVM Extension providing high usability to developers.Installation and SetupTo install the GraalVM Extension in VS Code, navigate to Extensions in the left-hand side Activity Bar (or use the Ctrl+Shift+X hot keys combination).Search for “GraalVM” in the search field.Once found, press Install.That action will install the GraalVM Extension from the VS Code Marketplace.Reload will be required.Once installed, notice the “Gr” icon in the left-hand side Activity Bar.By clicking on the icon, a dialogue with the following choices displays:  Download &amp;amp; Install GraalVM  Add Existing GraalVMDownload &amp;amp; Install GraalVMThe Download &amp;amp; Install GraalVM action prompts you to:  Pick the GraalVM distribution: Community (free for all purposes) or Enterprise (free for evaluation and development).  Pick the GraalVM version: Current (20.3), Annual (19.3), Latest Snapshot (Nightly Build 21.0-dev).  Pick a Java version: 8 or 11.  Select the destination folder.If you prefer GraalVM Community Edition, the installation wizard will download the package from Github in the background and display the progress.If you select GraalVM Enterprise Editon, you will be prompted to accept the Oracle Technology Network License Agreement and requested to enter your email address.Providing your email address is optional, but if you do not enter it, the GraalVM Enterprise Edition License will prompt everytime.The installation wizard will download the package from Oracle Software Downloads in the background and display the progress.If you are behind a proxy, setup your proxy configuration by the “Setup Proxy” command or by overriding the http_proxy and https_proxy environment variables.Upon completion, the “Set as Default Java” action is invoked. At the same time, the “Install Optional GraalVM Components” window pops up:Once you confirm, you are taken to the selection list:Note: You can download and install multiple GraalVM distributions and components at the same time.Add Existing GraalVMThe “Add Existing GraalVM” action allows you to select the existing GraalVM installation from your local disk.As in the previous installation scenario, you are prompted to set the GraalVM installation as default, and to install optional components, if not already installed.The “Add Existing GraalVM” action can also be invoked by using an icon on the side of the “GRAALVM: INSTALLATIONS” panel.To make a newly added GraalVM runtime active, you can use the “home” icon by the side of the installation.Alternatively, you can invoke the same actions from the View &amp;gt; Command Palette (Command Palette can be also opened by pressing F1, or the Ctrl+Shift+P  hot keys combination for Linux, and Command+Shift+P for macOS):  GraalVM: Download &amp;amp; Install GraalVM  GraalVM: Install GraalVM Component  GraalVM: Set Active GraalVM InstallationEach registered GraalVM instance displays its installation location and all its available components.The active one is placed on top.Components are either installed or available for download - the context actions to install (the plus icon) or remove (the bucket icon) are displayed when hovering over the component name.All registered GraalVM instances for java.home will be listed in the configuration file under File &amp;gt; Preferences &amp;gt; Settings (Code &amp;gt; Preferences &amp;gt; Settings on macOS).This installation model greatly simplifies setting up the GraalVM development environment in VS Code:  It permits multiple GraalVM and components installations at the same time.  It allows an easy switch from one runtime version to another.  It enables quick removal of unnecessary GraalVM installations from VS Code global storage or even from your local disk.The “Download &amp;amp; Install GraalVM” action is a preferable way, as it eliminates the fuss around setting up environment variables and prepares the GraalVM runtime in VS Code for you.Java Development and DebuggingTo enable support for Java development with GraalVM in VS Code, you have to install the Apache NetBeans Language Server extension. Reload will be required.To start developping or debugging Java applications, ensure GraalVM is used as your Java runtime in VS Code.If the current path is not pointing to the GraalVM folder, go to the User Settings window and use the netbeans.jdkhome value in the settings.json file.This configuration is then used to launch the Java Language Server.The project you create from scratch or a Java project you open in VS Code will run in the GraalVM runtime.To debug a Java application running on GraalVM, creating a launch configuration for the application is necessary.Having opened the file to be debugged or run in VS Code, switch to the Debug view by clicking on the “bug” icon in the left-hand side panel.The newly opened window will suggest you create a launch.json file:Make sure to select the “Java 8+” environment. To start debugging, press F5 or navigate to Run &amp;gt; Start Debugging.To add more launch configurations, navigate to Run &amp;gt; Add Configuration or open the .vscode/launch.json file and press the Add Configuration button in the right-hand corner.JavaScript and Node.js DebuggingTo debug a JavaScript or Node.js application running on GraalVM, creating a launch configuration for the application is necessary.To do so, open the application project folder in VS Code (File &amp;gt; Open Folder), then switch to the Debug view by clicking on the “bug” icon in the left-hand side panel. The newly opened window will suggest you create a launch.json file.If debugging is not yet configured (no launch.json has been created), select GraalVM from the list of available debug environmnets.The following techniques can be used to add a new configuration:  Use IntelliSense if your cursor is located inside the configurations array.  Press the Add Configuration button to invoke snippet IntelliSense at the start of the array.  Choose Add Configuration option in the Debug menu.Note: The attributes available in launch configurations vary from configuration to configuration.You can use IntelliSense suggestions (Ctrl+Space) to find out which attributes exist for a specific debug configuration.Hover help is also available for all attributes.The GraalVM extension provides the following debug configurations that can be used to run and debug JavaScript and Node.js applications running on GraalVM:  Launch Node.js Application - Launches a Node.js Application using GraalVM in a debug mode.  Launch JavaScript - Launches a JavaScript using GraalVM in a debug mode.  Attach - Attaches debugger to a locally running GraalVM runtime.  Attach to Remote - Attaches debugger to the debug port of a remote GraalVM runtime.You now have the possibility to choose which debugging protocol to use (Debug Adapter Protocol or Chrome Dev Tools protocol) by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.For example, to connect to the open Debug Adapter Protocol port, the content of the launch.json should be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Node App&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;debugAdapter&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/App.js&quot;        }    ]}In order to start a debug session, first select the proper configuration using the Configuration drop-down in the Debug view.Once you have your launch configuration set, start your debug session with F5.Alternatively, you can run your configuration through the Command Palette (Command Palette can be opened by pressing F1, or the Ctrl+Shift+P  hot keys combination for Linux, and Command+Shift+P for macOS).Set filtering to Debug: Select and Start Debugging, or type “debug” and select the configuration you want to debug.Python DebuggingTo debug a Python application running on GraalVM, creating a launch configuration for the application is necessary.To do so, open the application project folder in VS Code (File &amp;gt; Open Folder), then switch to the Debug view by clicking on the “bug” icon in the left-hand side panel. The newly opened window will suggest you create a launch.json file.If debugging is not yet configured (no launch.json has been created), select GraalVM from the list of available debug environmnets.Once the launch.json file is opened in the editor, one of the following techniques can be used to add a new configuration:  Use IntelliSense if your cursor is located inside the configurations array.  Press the Add Configuration button to invoke snippet IntelliSense at the start of the array.  Choose Add Configuration option in the Debug menu.The GraalVM Python extension provides the following debug configuration that can be used to debug Python applications/scripts running on GraalVM:  Launch Python Script - Launches a Python script using GraalVM in a debug mode.You now have the possibility to choose which debugging protocol to use (Debug Adapter Protocol or Chrome Dev Tools protocol) by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.For example, to connect to the Chrome Dev Tools protocol port, the content of the launch.json should be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Python App&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;chromeDevTools&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/App.py&quot;        }    ]}When editing debug configurations, you can use IntelliSense suggestions (Ctrl+Space) to find out which attributes exist for a specific debug configuration.Hover help is also available for all attributes.In order to start a debug session, first select the proper configuration using the Configuration drop-down in the Debug view.Once you have your launch configuration set, start your debug session with F5.Alternatively, you can run your configuration through the Command Palette (Command Palette can be also opened by pressing F1, or Ctrl+Shift+P  hot keys combination for Linux and Command+Shift+P for macOS), by filtering on Debug: Select and Start Debugging or typing “debug”, and selecting the configuration you want to debug.R DebuggingTo debug an R application running on GraalVM, creating a launch configuration for the application is necessary.To do so, open the application project folder in VS Code (File &amp;gt; Open Folder), then switch to the Debug view by clicking on the “bug” icon in the left-hand side panel. The newly opened window will suggest you create a launch.json file.If debugging is not yet configured (no launch.json has been created), select GraalVM from the list of available debug environmnets.Once the launch.json file is opened in the editor, one of the following techniques can be used to add a new configuration:  Use IntelliSense if your cursor is located inside the configurations array.  Press the Add Configuration button to invoke snippet IntelliSense at the start of the array.  Choose Add Configuration option in the Debug menu.The GraalVM R extension provides the following debug configurations that can be used to debug R applications/scripts running on GraalVM:  Launch R Script - Launches an R script using GraalVM in a debug mode.  Launch R Terminal - Launches an integrated R terminal running on GraalVM in a debug mode.You now have the possibility to choose which debugging protocol to use (Debug Adapter Protocol or Chrome Dev Tools protocol) by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.For example, to connect to the Chrome Dev Tools protocol port, the content of the launch.json should be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch R Script&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;chromeDevTools&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/App.r&quot;        }    ]}When editing debug configurations, you can use IntelliSense suggestions (Ctrl+Space) to find out which attributes exist for a specific debug configuration.Hover help is also available for all attributes.In order to start a debug session, first select the proper configuration using the Configuration drop-down in the Debug view.Once you have your launch configuration set, start your debug session with F5.Alternatively, you can run your configuration through the Command Palette (Command Palette can be also opened by pressing F1, or Ctrl+Shift+P  hot keys combination for Linux and Command+Shift+P for macOS), by filtering on Debug: Select and Start Debugging or typing “debug”, and selecting the configuration you want to debug.Ruby DebuggingTo debug a Ruby application running on GraalVM, creating a launch configuration for the application is necessary.To do so, open the application project folder in VS Code (File &amp;gt; Open Folder), then switch to the Debug view by clicking on the “bug” icon in the left-hand side panel. The newly opened window will suggest you create a launch.json file.If debugging is not yet configured (no launch.json has been created), select GraalVM from the list of available debug environmnets.Once the launch.json file is opened in the editor, one of the following techniques can be used to add a new configuration:  Use IntelliSense if your cursor is located inside the configurations array.  Press the Add Configuration button to invoke snippet IntelliSense at the start of the array.  Choose Add Configuration option in the Debug menu.The GraalVM Ruby extension provides the following debug configuration that can be used to debug Ruby applications/scripts running on GraalVM:  Launch Ruby Script - Launches a Ruby script using GraalVM in a debug mode.You now have the possibility to choose which debugging protocol to use (Debug Adapter Protocol or Chrome Dev Tools protocol) by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.For example, to connect to the Chrome Dev Tools protocol port, the content of the launch.json should be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Ruby App&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;chromeDevTools&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/App.rb&quot;        }    ]}When editing debug configurations, you can use IntelliSense suggestions (Ctrl+Space) to find out which attributes exist for a specific debug configuration.Hover help is also available for all attributes.In order to start a debug session, first select the proper configuration using the Configuration drop-down in the Debug view.Once you have your launch configuration set, start your debug session with F5.Alternatively, you can run your configuration through the Command Palette (Command Palette can be also opened by pressing F1, or Ctrl+Shift+P  hot keys combination for Linux and Command+Shift+P for macOS), by filtering on Debug: Select and Start Debugging or typing “debug”, and selecting the configuration you want to debug.Polyglot Applications DebuggingTo run a polyglot application on GraalVM in VS Code, you have to either pass the --polyglot option to any of the existing application lauchers (e.g., js --polyglot or node --polyglot), or use an experimental launcher called polyglot that runs code for JavaScript, Python, Ruby, and R without requiring the selection of a primary language.The polyglot launcher does not require the --polyglot option, it is enabled by default.For more information see the GraalVM polyglot documentation.To debug a polyglot application on GraalVM in VS Code, creating a launch configuration for the application is necessary.To do so, open the application project folder in VS Code (File &amp;gt; Open Folder), switch to the Debug view by clicking on the “bug” icon in the left-hand side panel. The newly opened window will suggest to create a launch.json file.If debugging is not yet configured (no launch.json has been created), select GraalVM from the list of available debug environmnets.Once the launch.json file is opened in the editor, one of the following techniques can be used to add a new configuration:  Use IntelliSense if your cursor is located inside the configurations array.  Press the Add Configuration button to invoke snippet IntelliSense at the start of the array.  Choose Add Configuration option in the Debug menu.The GraalVM extension provides the following debug configuration that can be used to debug an applications running on GraalVM using the polyglot launcher:  Launch Polyglot Application - Launches a Polyglot Application in a debug mode.You now have the possibility to choose which protocol (Debug Adapter Protocol or Chrome Dev Tools protocol) to use to debug a polyglot application by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.For example, to connect to the Chrome Dev Tools protocol port, the content of the launch.json can be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Polyglot App&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;chromeDevTools&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/polyglot.js&quot;        }    ]}Alternatively, to pass the --polyglot option to any of the existing application launchers, add the runtimeArgs attribute containing the --polyglot value to their respective debug configurations.Note: In some cases (polyglot application calls Java or R, or native launcher accesses languages installed with gu without rebuilding images), also passing the --jvm option is necessary.Debug Adapter ProtocolWhen creating the Run/Debug Configurations in VS Code, Chrome DevTools Protocol is provisioned by default. However, GraalVM provides a built-in implementation of the Debug Adapter Protocol (DAP) and, with the GraalVM Extention for VS Code, a user now can choose a protocol to use by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.To open a debugger port serving the Debug Adapter Protocol, you need to pass the --dap option to the command-line launcher.Other available options to pass to GraalVM’s Debug Adapter Protocol are:  --dap.Suspend=false: Disable the execution suspension at first source line, enabled by default.  --dap.WaitAttached: Do not execute any source code until debugger client is attached. The default is false.  --dap=&amp;lt;[[host:]port]&amp;gt;: Start the debugger on a different port than default (&amp;lt;host&amp;gt;:4711).Then you need a DAP client to connect to the open DAP port.To connect to the open DAP port, the content of launch.json for a Node.js application, for example, should be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Node App&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;debugAdapter&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/App.js&quot;        }    ]}The advantage of using the Debug Adapter Protocol over Chrome Dev Tools is that (1) it is ‘native’ to Visual Studio Code (VS Code), meaning it does not require any intermediate translatation, and (2) it supports multithreading, which can be particually useful to debug, e.g., a Ruby application.Language Server Protocol IntegrationGraalVM supports smart editing features of development tools used to create guest language applications by providing a built-in implementation of the Language Server Protocol.This allows you to attach compatible development tools such as VS Code to GraalVM and to get features like auto complete, go to declaration, or documentation on hover.Currently, GraalVM’s Language Server Protocol implementation supports the following services:  Text Document Synchronization  Hover Provider  Completion Provider  Signature Help Provider  Document Highlight Provider  Code Action Provider  Code Lens Provider  Execute Command ProviderNote: The Language Server Protocol is offered as a technology preview and requires to pass the --experimental-options option for its activation.To start the Language Server Protocol, pass the --lsp option to the command-line launcher as in the following example with a Node.js application:node --experimental-options --lsp app.js[Graal LSP] Starting server and listening on localhost/127.0.0.1:8123Example app listening on port 3000!Note: GraalVM’s Language Server Protocol itself does not provide the static data usually gathered by parsing the application sources (as these data are sometimes fuzzy in the case of dynamic languages).Instead, it was designed to provide the accurate dynamic data gathered from the application runtime.However, GraalVM’s Language Server Protocol could delegate to the existing language servers written specially for the particular languages (using the --lsp.Delegates launcher option) and merge the static data returned from these servers with its own dynamic data to a single result.This extension works as a client to the Language Server Protocol.By default, a language server is started as a part of every process being executed or debugged via the VS Code user interface.The other possibility (available on option) is a language server started as a separated process that gets informed about every application being executed or debugged.It tries to “dry-run” the same code as the original application and serve the run-time data afterwards.Currently, both approaches start the language server, providing the smart editing features for the following GraalVM-supported languages - JavaScript, Python, R, Ruby, and SimpleLanguage.R Language ServerThis extension provides an option to automatically install and run the languageserver which is an implementation of the Language Server Protocol for the R language.Enabling this option, the GraalVM R installation is checked for the presence of the languageserver package and the user is provided with the option of an automatic installation of the missing package.Once the languageserver package is installed, the R Language Server is automatically started and passed to the Language Server Protocol as delegate when necessary.Ruby Language ServerThis extension provides an option to automatically install and run the solargraph which is an implementation of the Language Server Protocol for the Ruby language.Enabling this option, the GraalVM Ruby installation is checked for the presence of the solargraph gem and the user is provided with the option of an automatic installation of the missing gem.Once the solargraph gem is installed, the Ruby Language Server is automatically started and passed to the Language Server Protocol as delegate when necessary.Additional Editor FeaturesSince the easy writing of polyglot applications is one of the defining features of GraalVM, the code completion invoked inside JavaScript sources provides items for Polyglot.eval(...), Polyglot.evalFile(...), and Java.type(...) calls.Similarly, the code completion invoked inside Python sources provides items for Polyglot.eval(...), Polyglot.eval_file(...), and Java.type(...) calls.The code completion invoked inside R sources provides items for eval.polyglot(...) and new(&quot;&amp;lt;Java type&amp;gt;&quot;, ...) calls.And finally, the code completion invoked inside Ruby sources provides items for Polyglot.eval(...), Polyglot.eval_file(...), and Java.type(...) calls.For JavaScript, Python, R, and Ruby sources opened in the editor, all the Polyglot.eval(...) calls are detected and the respective embedded languages are injected to their locations.For example, having an R code snippet called via the Polyglot API from inside a JavaScript source, the R language code is embedded inside the corresponding JavaScript String and all VS Code’s editing features (syntax highlighting, bracket matching, auto closing pairs, code completion, etc.) treat the content of the String as the R source code.Extension SettingsThis extension contributes the following settings:  graalvm.home - the path to the GraalVM installation  graalvm.installations - all registered GraalVM installations  graalvm.systemDetect - detect GraalVM’s installation from the system environment variables  graalvm.languageServer.currentWorkDir - an absolute path to the working directory of GraalVM’s Language Server Protocol  graalvm.languageServer.inProcessServer - start GraalVM’s Language Server Protocol within processes being run or debugged  graalvm.languageServer.delegateServers - a comma-separated list of language@[host:]port where other language servers run  graalvm.languageServer.startRLanguageServer - start the R Language Server  graalvm.languageServer.startRubyLanguageServer - start the Ruby Language ServerRecommendationsThe GraalVM Extension for VS Code recommends the following extensions:  Python - the Python language support  R - a basic support for the R language  Ruby - the Ruby language support  Apache NetBeans Language Server - the Java 8+ language supportFeedback  Request a feature  File a bugPrivacy PolicyRead the Oracle Privacy Policy to learn more.",
                    "url": " /tools/vscode/graalvm-extension/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework":  {
                    "title": "",
                    "content": "Truffle Language Implementation FrameworkThe Truffle language implementation framework (henceforth “Truffle”) is an open source library for building tools and programming languages implementations as interpreters for self-modifying Abstract Syntax Trees.Together with the open source GraalVM compiler, Truffle represents a significant stepforward in programming language implementation technology in the current era of dynamic languages.The Truffle bits are uploaded to Maven central. You can use them from yourpom.xml file as:&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.truffle&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;truffle-api&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;20.3.0&amp;lt;/version&amp;gt; &amp;lt;!-- or any later version --&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.graalvm.truffle&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;truffle-dsl-processor&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;20.3.0&amp;lt;/version&amp;gt;    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;Implement Your LanguageThe Truffle framework allows you to run programming languages efficiently on GraalVM.It simplifies language implementation by automatically deriving high-performance code from interpreters.Getting StartedInformation on how to get starting building your language can be found in the Language Implementation Tutorial.The reference API documentation is available as part of the Truffle Javadoc.Start with looking at the TruffleLanguage class, which one should subclass to start developing a language.Truffle comes prebuilt with the GraalVM compiler and several language implementations as part of GraalVM.A good way to start implementing your language with Truffle is to fork the SimpleLanguage project and start hacking.SimpleLanguage is a relatively small language implementation, well-documented, and designed to demonstrate most of the Truffle features.You could also try by looking at code in one of the existing open source languages implementations and experiments.Consider reading these publications for a very detailed view into how many of the aspects of Truffle work. However, as with any other software project, the source code is the ground truth.Advanced TopicsImplementing a language using Truffle offers a way to interoperate with other “Truffle” languages.To learn more about verifying that your language is a valid polyglot citizen, read more about using the Polyglot TCK.Somewhat related topics worth exploring are Truffle Libraries, as well as how to use them to implement a language interoperability.Languages implemented with Truffle can also be embedded in Java host applications using the Polyglot API.To better understand how to improve the performance of your language please consult the documentation on profiling and optimizing your language.Also, to better understand how to use Truffle’s automated monomorphization feature (i.e., splitting), look at the related documentation.Implement Your ToolGraalVM provides a framework for creating language-agnostic tools like debuggers, profilers, and other instrumentations.In general, GraalVM provides a standardized way to express and run program code enabling cross-language research and the development of tools that can be developed once and then applied to any language.The reference API documentation is available as part of the Truffle Javadoc.Start with looking at the TruffleInstrument class, which – similar to TruffleLanguage – one should subclass to start developing a tool.If you want to implement your own “Truffle” tool, a good way to start is to fork the SimpleTool project – like the SimpleLanguage project described above – and start hacking.SimpleTool is a well-documented, minimalistic code-coverage tool designed to be a starting point for understanding the tool development process using Truffle.Since tools, developed with Truffle, instrument the language using the same AST-node-based approach, most of the techniques available to language developers in terms of improving performance are available to the tool developers as well.This is why it is recommended that you understand how Truffle works from a language developer’s perspective, in order to get the maximum out of your tool.CompatibilityThe Truffle API is evolved in a backwards-compatible manner from one version to the next.When an API is deprecated, then it will stay deprecated for at least two GraalVM releases, and a minimum of one month, before it will be removed.As a best practice it is recommended to upgrade Truffle only one version at a time.This way you can increment the version and fix deprecation warnings before continuing to the next version.The deprecated Javadoc tags on the deprecated APIs are designed to be a guide on how to upgrade.The latest additions and changes can be seen in the changelog.Modifying TruffleTo understand how to modify Truffle, consult this file, and if you would like to contribute to Truffle, consult the contribution documentation.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/"
                  },
                  
                  "reference-manual-native-image":  {
                    "title": "",
                    "content": "Native ImageNative Image is a technology to ahead-of-time compile Java code to a standalone executable, called a native image.This executable includes the application classes, classes from its dependencies, runtime library classes, and statically linked native code from JDK.It does not run on the Java VM, but includes necessary components like memory management, thread scheduling, and so on from a different runtime system, called “Substrate VM”.Substrate VM is the name for the runtime components (like the deoptimizer, garbage collector, thread scheduling etc.).The resulting program has faster startup time and lower runtime memory overhead compared to a JVM.The Native Image builder or native-image is a utility that processes all classes of an application and their dependencies, including those from the JDK.It statically analyzes these data to determine which classes and methods are reachable during the application execution.Then it ahead-of-time compiles that reachable code and data to a native executable for a specific operating system and architecture.This entire process is called building an image (or the image build time) to clearly distinguish it from the compilation of Java source code to bytecode.Native Image supports JVM-based languages, e.g., Java, Scala, Clojure, Kotlin.The resulting image can, optionally, execute dynamic languages likeJavaScript, Ruby, R or Python. Polyglot embeddings can also be compiledahead-of-time. To inform native-image of a guest language used by anapplication, specify --language:&amp;lt;languageId&amp;gt; for each guest language (e.g.,--language:js).  Install Native Image  Prerequisites  Build a Native Image  Build a Shared Library  How to Determine What Version of GraalVM a Native Image is Generated with  Ahead-of-time Compilation LimitationsLicenseThe Native Image technology is distributed as a separate installable to GraalVM.Native Image for GraalVM Community Edition is licensed under the GPL 2 with Classpath Exception.Native Image for GraalVM Enterprise Edition is available as an Early Adopter feature.Early Adopter features are subject to ongoing development, testing, and modification.For more information, check the [Oracle Technology Network License Agreement for GraalVM Enterprise Edition]https://www.oracle.com/downloads/licenses/graalvm-otn-license.html).Install Native ImageNative Image can be added to GraalVM with the GraalVM Updater tool.Run this command to install Native Image:gu install native-imageAfter this additional step, the native-image executable will become available inthe GRAALVM_HOME/bin directory.The above command will install Native Image from the GitHub catalog for GraalVM Community users.For GraalVM Enterprise users, the manual installation is required.PrerequisitesFor compilation native-image depends on the local toolchain. Install glibc-devel, zlib-devel (header files for the C library and zlib)and gcc, using a package manager available on your OS. Some Linux distributions may additionally require libstdc++-static.On Oracle Linux use yum package manager:sudo yum install gcc glibc-devel zlib-develYou can still install libstdc++-static as long as the optional repositories are enabled (ol7_optional_latest on Oracle Linux 7 and ol8_codeready_builder on Oracle Linux 8).On  Ubuntu Linux use apt-get package manager:sudo apt-get install build-essential libz-dev zlib1g-devOn other Linux distributions use dnf package manager:sudo dnf install gcc glibc-devel zlib-devel libstdc++-staticOn macOS use xcode:xcode-select --installPrerequisites for Using Native Image on WindowsBuilding native images on Windows requires a Microsoft Visual C++ (MSVC) that comes with Visual Studio 2017 15.5.5 or later.In addition, a proper Developer Command Prompt for your version of Visual Studio.On Windows the native-image tool only works when it is executed from the x64 Native Tools Command Prompt.Build a Native ImageA native image can be built as a standalone executable, which is the default, or as a shared library (see Build a Shared Library).For an image to be useful, it needs to have at least one entry point method.For standalone executables, Native Image supports Java main methods with a signature that takes the command line arguments as an array of strings:public static void main(String[] arg) { /* ... */ }The executable images can have an arbitrary number of entry points, for example, to implement callbacks or APIs.To build a native image of a Java class file in the current working directory, use:native-image [options] class [imagename] [options]To build a native image of a JAR file, use:native-image [options] -jar jarfile [imagename] [options]The native-image command needs to provide the class path for all classes usingthe familiar option from the java launcher: -cp followed by a list ofdirectories or JAR files, separated by : on Linux and macOS platforms, or ; on Windows.The name of the class containing themain method is the last argument, or you can use -jar and provide a JARfile that specifies the main method in its manifest.As an example, take this small Java program that reverses a String using recursion:public class Example {    public static void main(String[] args) {        String str = &quot;Native Image is awesome&quot;;        String reversed = reverseString(str);        System.out.println(&quot;The reversed string is: &quot; + reversed);    }    public static String reverseString(String str) {        if (str.isEmpty())            return str;        return reverseString(str.substring(1)) + str.charAt(0);    }}Compile it and build a native image from the Java class:javac Example.javanative-image ExampleThe native image builder ahead-of-time compiles the Example class into astandalone executable, example, in the current working directory. Run the executable:./exampleAnother option to the native image builder that might be helpful is--install-exit-handlers. It is not recommended to register the default signalhandlers when building a shared library. However, it is desirable to includesignal handlers when building a native image for containerized environments, likeDocker containers. The --install-exit-handlers option gives you the samesignal handlers that a JVM does.For more complex examples, visit the native image generation or compiling a Java and Kotlin app ahead-of-time pages.Build a Shared LibraryTo build a native image as a shared library of a Java class file, pass  --shared to the native image builder.The created shared library will have the main method of the given Java class as its entrypoint method.native-image class [libraryname] --sharedTo build a native image as a shared library of a JAR file, use:native-image -jar jarfile [libraryname] --sharedNote: if you build a shared library where you do not specify a main class, you must append the -H:Name= flag to specify the library name: -H:Name=libraryname.As mentioned in the previous section, you need to have at least one entry point method for a native image to be useful.For shared libraries, Native Image provides the @CEntryPoint annotation to specify entry point methods that should be exported and callable from C.Entry point methods must be static and may only have non-object parameters and return types – this includes Java primitives, but also Word types (including pointers). One of the parameters of an entry point method has to be of type IsolateThread or Isolate. This parameter provides the current thread’s execution context for the call.For example:@CEntryPoint static int add(IsolateThread thread, int a, int b) {    return a + b;}When building a shared library, an additional C header file is generated.This header file contains declarations for the C API, which allows creating isolates and attaching threads from C code, as well as declarations for each entry point in the source code. The generated C declaration for the above example is:int add(graal_isolatethread_t* thread, int a, int b);Shared library images and executable images alike can have an arbitrary number of entry points, for example, to implement callbacks or APIs.How to Determine What Version of GraalVM an Image Is Generated withAssuming you have a Java class file, EmptyHello.class , containing an empty main method and have generated an empty shared object emptyhello with the Native Image builder:native-image -cp hello EmptyHello[emptyhello:11228]    classlist:     149.59 ms...If you do not know what GraalVM distribution is set to the PATH environmentvariable, how to determine if a native image was compiled with Community orEnterprise Edition? Run this command:strings emptyhello | grep com.oracle.svm.core.VMThe expected output should match the following:com.oracle.svm.core.VM GraalVM &amp;lt;version&amp;gt; Java 11 EENote:Python source code or LLVM bitcode interpreted or compiled with GraalVM Community Edition will not have the same security characteristics as the same code interpreted or compiled using GraalVM Enterprise Edition.There is a GraalVM string embedded in each image that allows to figure out the version and variant of the base (Community or Enterprise) used to build an image.The following command will query that information from an image:strings &amp;lt;path to native-image exe or shared object&amp;gt; | grep com.oracle.svm.core.VMHere is an example output:com.oracle.svm.core.VM.Target.LibC=com.oracle.svm.core.posix.linux.libc.GLibCcom.oracle.svm.core.VM.Target.Platform=org.graalvm.nativeimage.Platform$LINUX_AMD64com.oracle.svm.core.VM.Target.StaticLibraries=liblibchelper.a|libnet.a|libffi.a|libextnet.a|libnio.a|libjava.a|libfdlibm.a|libzip.a|libjvm.acom.oracle.svm.core.VM=GraalVM &amp;lt;version&amp;gt; Java 11com.oracle.svm.core.VM.Target.Libraries=pthread|dl|z|rtcom.oracle.svm.core.VM.Target.CCompiler=gcc|redhat|x86_64|10.2.1If the image was build with Oracle GraalVM Enterprise Edition the output would instead contain:com.oracle.svm.core.VM=GraalVM &amp;lt;version&amp;gt; Java 11 EEAhead-of-time Compilation LimitationsThere is a small portion of Java features are not susceptible to ahead-of-timecompilation, and will therefore miss out on the performance advantages. To beable to build a highly optimized native executable, GraalVM runs an aggressive staticanalysis that requires a closed-world assumption, which means that all classesand all bytecodes that are reachable at run time must be known at build time.Therefore, it is not possible to load new data that have not been availableduring ahead-of-time compilation. Continue reading to GraalVM Native Image Compatibility and Optimization.",
                    "url": " /reference-manual/native-image/"
                  },
                  
                  "reference-manual-java":  {
                    "title": "",
                    "content": "Java ReferenceAny JVM-based application that runs on Java HotSpot VM can run on GraalVM.GraalVM is based on Java HotSpot VM, but integrates an advanced just-in-time (JIT) compiler, written in Java - the GraalVM compiler.At runtime, the application is loaded and executed normally on the JVM.The JVM passes bytecode to the GraalVM compiler, which compiles that to the machine code and returns it to the JVM.GraalVM’s dynamic compiler can improve the efficiency and the speed of applications written in Java, Scala, Kotlin, or other JVM languages through unique approaches to code analysis and optimization.For example, it assures performance advantages for highly abstracted programs due to its ability to remove costly object allocations.To learn more, go to the Compiler page.The open source compiler’s code is available on GitHub.Compiler Operating ModesThere are two operating modes of the GraalVM compiler when used as a HotSpot JIT compiler:      libgraal: the GraalVM compiler is compiled ahead-of-time into a native shared library.In this operating mode, the shared library is loaded by the HotSpot VM.The compiler uses memory separate from the HotSpot heap and runs fast from the start since it does not need to warmup.This is the default and recommended mode of operation.        jargraal: the GraalVM compiler goes through the same warm-up phase that the rest of the Java application does. That is, it is first interpreted before its hot methods are compiled.This mode is selected with the -XX:-UseJVMCINativeLibrary command-line option.This will delay the time to reach peak performance as the compiler itself needs to be compiled before it produces code quickly.This mode allows you to debug the GraalVM compiler with a Java debugger.  InteroperabilityIn addition to running JVM-based languages on GraalVM, you can also call any other language implemented with the Truffle language implementation framework directly from Java.See the Polyglot Programming and Embedding Languages guides for more information about interoperability with other programming languages.",
                    "url": " /reference-manual/java/"
                  },
                  
                  "reference-manual-ruby":  {
                    "title": "",
                    "content": "TruffleRubyTruffleRuby is the GraalVM high-performance implementationof the Ruby programming language.Getting StartedThere are four ways to install TruffleRuby releases and nightly builds:      Via GraalVM, which includes support forother languages such as JavaScript, R, and Python, and supports both theNative and JVM configurations.Inside GraalVM will then be a bin/ruby command that runs TruffleRuby.We recommend that you use a Ruby managerto use TruffleRuby inside GraalVM.        Via your Ruby manager/installer (RVM, rbenv,chruby, ruby-build, ruby-install). This contains only TruffleRuby, in theNative configuration, making it a smallerdownload. It is meant for users who only want a Ruby implementation and are alreadyusing a Ruby manager.        Via Docker: Oracle Linux-based imagesand Debian-based images.        Via the standalone distributionas a simple binary tarball.  We recommend trying TruffleRuby nightly builds which contain the latest fixes and improvements:RVM:    $ rvm install truffleruby-headrbenv:  $ rbenv install truffleruby-devchruby: $ ruby-build truffleruby-dev ~/.rubies/truffleruby-devSee the Ruby installers documentation for more details.Testing TruffleRuby in CI is easy.On GitHub Actions, you can use:- uses: ruby/setup-ruby@v1  with:    ruby-version: truffleruby # or truffleruby-headSee Testing TruffleRuby in CI for more details and other CIs.You can use gem and bundle to install gems, as usual.Please report any issues you might find on GitHub.AimTruffleRuby aims to:  Run idiomatic Ruby code faster.          TruffleRuby is the fastest Ruby implementation for many CPU-intensive benchmarks.        Run Ruby code in parallel.          TruffleRuby does not have a global interpreter lock and runs Ruby code in parallel.        Support C extensions.          Many C extensions work out of the box, including database drivers.        Add fast and low-overhead interoperability with languages like Java, JavaScript, Python, and R.          Provided by GraalVM, see the Polyglot documentation.        Provide new tooling, such as debuggers and monitoring, that works across languages.          Includes a profiler, debugger, VisualVM, and more. See the Tools documentation.        Provide all of the above while maintaining very high compatibility with the standard implementation of Ruby.TruffleRuby Runtime ConfigurationsThere are two main runtime configurations of TruffleRuby, Native and JVM, which have different trade-offs.            Configuration:      Native (--native, default)      JVM (--jvm)                  Time to start TruffleRuby      about as fast as MRI startup      slower              Time to reach peak performance      faster      slower              Peak performance (also considering GC)      good      best              Java host interoperability      needs reflection configuration      just works      To find out which runtime configuration is being used, run ruby --version on the command line,or check the value of RUBY_DESCRIPTION or TruffleRuby.native? in Ruby code.Runtime configurations are further detailed in Deploying TruffleRuby.System CompatibilityTruffleRuby is actively tested on the following systems:  Oracle Linux 7  Ubuntu 18.04 LTS  Ubuntu 16.04 LTS  Fedora 28  macOS 10.14 (Mojave)  macOS 10.15 (Catalina)Architectures:  AMD64 (aka x86_64): Supported  AArch64 (aka arm64): Supported on Linux (from 20.2)You may find that TruffleRuby will not work if you severely restrict theenvironment, for example, by unmounting system filesystems such as /dev/shm.Dependencies  make and gcc for building C and C++ extensions  libssl for the openssl C extension  zlib for the zlib C extensionWithout these dependencies, many libraries including RubyGems will not work.TruffleRuby will try to print a nice error message if a dependency is missing, but this can only be done on a best effort basis.You may also need to set up a UTF-8 locale.See the contributor workflow document if you wish to build TruffleRuby from source.Current StatusWe recommend that people trying TruffleRuby on their gems and applications get in touch with us for help.TruffleRuby can run Rails and is compatible with many gems, including C extensions.However, TruffleRuby is not 100% compatible with MRI 2.7 yet. Please report any compatibility issues you might find.TruffleRuby passes around 97% of ruby/spec,more than any other alternative Ruby implementation.TruffleRuby might not be fast yet on Rails applications and large programs.Notably, large programs currently take a long time to warmup on TruffleRuby andthis is something the TruffleRuby team is currently working on.Large programs often involve more performance-critical codeso there is a higher chance of hitting an area of TruffleRuby which has not been optimized yet.ReleasesTruffleRuby has the same version, and is released at the same time as GraalVM.There is a release every 3 months. See the release roadmap.Migration from MRITruffleRuby should in most cases work as a drop-in replacement for MRI, but youshould read about our compatibility.Migration from JRubyFor many use cases TruffleRuby should work as a drop-in replacement for JRuby.However, our approach to integration with Java is different to JRuby so youshould read our migration guide.ContactThe best way to get in touch with us is to join the #truffleruby channel onGraalVM Slack.You can also Tweet to @TruffleRuby, or emailbenoit.daloze@oracle.com.Please report security vulnerabilities via the process outlined in the reporting vulnerabilities guide, rather than by something public such as a GitHub issue or a Gitter conversation.Mailing ListAnnouncements about GraalVM, including TruffleRuby, are made on thegraal-dev mailing list.AuthorsThe main authors of TruffleRuby ordered by first contribution are:Chris Seaton, Benoit Daloze, Kevin Menard, Petr Chalupa, Brandon Fish, Duncan MacGregor, Christian Wirth, Rafael França, Alan Wu, Nicolas Laurent, Carol Chen, Nikolay Sverchkov, and Lillian Zhang.SecuritySee SECURITY for how to report security vulnerabilities to Oracle.For known vulnerabilities in Ruby, please refer to the known-cves file.LicenceTruffleRuby is copyright (c) 2013-2021 Oracle and/or its affiliates, and is madeavailable to you under the terms of any one of the following three licenses:  Eclipse Public License version 2.0, or  GNU General Public License version 2, or  GNU Lesser General Public License version 2.1.For further licensing information, see LICENCE, 3rd_party_licenses, and doc/legal/legal.AttributionTruffleRuby includes infrastructure code from JRuby (e.g. parser, JCodings, Joni), core library code from the Rubinius project, as well as code from the standard implementation of Ruby, MRI.",
                    "url": " /reference-manual/ruby/"
                  },
                  
                  "reference-manual-java-on-truffle":  {
                    "title": "",
                    "content": "Java on TruffleUsing GraalVM, you can run Java applications normally on the JVM, in Native Image, and now on Truffle.Java on Truffle is an implementation of the Java Virtual Machine Specification, Java SE 8 and Java SE 11, built upon GraalVM as a Truffle interpreter.It is a minified Java VM that includes all core components of a VM, implements the same API as the Java Runtime Environment library (libjvm.so), and reuses all JARs and native libraries from GraalVM.See the Implementation Details for more information.The project name behind this implementation is “Espresso”.Its open source version is available on GitHub.The Java on Truffle execution mode runs Java via a Java bytecode interpreter, implemented with the Truffle framework – an open-source library for writing interpreters for programming languages.Now Java can be executed by the same principle as other languages in the GraalVM ecosystem (JavaScript, Ruby, Python, R), directly interoperate with those languages, and pass data back and forth in the same memory space.Besides complete language interoperability, with Java on Truffle you can:  run Java bytecodes in a separate context from the host Java VM. It can run either a Java 8 or Java 11 guest or host JVM. In other words, you can embed a Java 8 context in a Java 11 application, by using GraalVM’s Polyglot API.  leverage the whole stack of tools provided by the Truffle framework, not previously available for Java.  have an improved isolation of the host Java VM and the Java program running on Truffle, so you can run less trusted guest code.  run in the context of a native image while still allowing dynamically-loaded bytecodes.Java on Trufle is an experimental technology in GraalVM, but already passes the Java Compatibility Kit (JCK or TCK for Java SE).It is available as of version 21.0.0.Install Java on TruffleTo run Java on Truffle, you need to have GraalVM installed.The Java on Truffle runtime is not available by default, but can be easily added to GraalVM using the GraalVM Updater tool.For GraalVM Community Edition users, run the following command to install Java on Truffle from the GitHub catalog:gu install espressoThe installable’s name, espresso, is the project code-name, it is used to avoid ambiguity with the other ways Java code can run on GraalVM.For GraalVM Enterprise Edition users, download  Java on Truffle from Oracle GraalVM Downloads.Having downloaded the appropriate JAR file in consideration of the operating system and underlying Java SE version, install it with:gu install -L espresso.jarIt installs the jvm runtime library under the GRAALVM_HOME/lib/truffle/ location.Run Java on TruffleYou can run a Java application on Truffle by passing the -truffle flag to the standard java launcher.This is similar to how you used to switch between the -client and -server JVMs.To execute a class file:java -truffle [options] classTo execute a JAR file:java -truffle [options] --jar jarfileUsing Java 11 based GraalVM distribution, you can also run a Java application from the main class in a module, or run a single source-file program:java -truffle [options] -m module[/&amp;lt;mainclass&amp;gt;]java -truffle [options] sourcefileBy default, Java on Truffle runs within GraalVM by reusing all GraalVM’s JARs and native libraries, but it is possible to “cross-version” and specify a different Java installation directory (java.home).It will automatically switch versions regardless of the host JVM.java -truffle --java.JavaHome=/path/to/java/home -versionPerformance ConsiderationsJava on Trufle is an experimental technology in GraalVM, and peak performance is currently 2-3x slower than HotSpot.The startup time will not match the speed offered by the regular GraalVM just-in-time (JIT) execution yet, but having created a fully working Java on Truffle runtime, the development team is now focusing on performance.You can still influence the performance by passing the following options to java -truffle:  --engine.MultiTier=true to enable multi-tier compilation;  --engine.Inlining=false in combination with --java.InlineFieldAccessors=true to make the compilation faster, in exchange for slower performance.The --vm.XX: syntax ensures the option is passed to the underlying native image VM.When using the -XX: syntax, the VM first checks if there is such an option in the Java on Truffle runtime.If there is none, it will try to apply this option to the underlying native image VM.This might be important for options such as MaxDirectMemorySize which can be set independently at both levels: -XX:MaxDirectMemorySize=256M controls how much native memory can be reserved by the Java program running on Truffle (the guest VM), while --vm.XX:MaxDirectMemorySize=256M controls how much native memory can be reserved by native image (the host VM).Start Running ApplicationsFrom Command LineFor the purpose of this guide, GraalVM Enterprise 21.1.0 distribution, based on Java 11 for macOS, is used.To ensure you have successfully installed Java on Truffle, verify its version:java -truffle -versionjava version &quot;11.0.11&quot; 2021-04-20 LTSJava(TM) SE Runtime Environment GraalVM EE 21.1.0 (build 11.0.11+8-LTS-jvmci-21.1-b03)Espresso 64-Bit VM GraalVM EE 21.1.0 (build 11-espresso-21.1.0, mixed mode)Taking this HelloWorld.java example, compile it and run from the command line:public class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}&amp;lt;graalvm&amp;gt;/bin/javac HelloWorld.java&amp;lt;graalvm&amp;gt;/bin/java -truffle HelloWorldHelloWorld.java!Taking some real-world applications, try running Spring PetClinic - a sample web application that demonstrates the use of Spring Boot with Spring MVC and Spring Data JPA.  Clone the project and navigate to the project’s directory:    git clone https://github.com/spring-projects/spring-petclinic.gitcd spring-petclinic    Build a JAR file (Spring PetClinic is built with Maven):    ./mvnw package    Then run it from the command line by selecting the -truffle runtime:    java -truffle -jar target/spring-petclinic-2.4.2.jar    When the application starts, access it on localhost:8000.From IDETo run a Java project on Truffle from an IDE requires setting the Java on Truffle enabled GraalVM as a project’s default JDK.For exampe, to run the Spring PetClinic project using Intellij IDEA, you need to:1. Navigate to File -&amp;gt; Project Structure -&amp;gt; Project -&amp;gt; Project SDK. Expand the drop down, press Add SDK -&amp;gt; JDK and open the folder where you installed GraalVM. For macOS users, JDK home path will be /Library/Java/JavaVirtualMachines/{graalvm}/Contents/Home. Give it a name, and press Apply.2. Generate sources and update folders for the project. In the Maven sidebar, click on the folder with the spinner icon:3. Enable the Java on Truffle execution mode. From the main menu select Run -&amp;gt; Run… -&amp;gt; Edit Configurations &amp;gt; Environment. Put the -truffle -XX:+IgnoreUnrecognizedVMOptions command in the VM options field and press Apply.It is necessary to specify -XX:+IgnoreUnrecognizedVMOptions because Intellij automatically adds a -javaagent argument which is not supported yet.4. Press Run.DebuggingYou do not have to configure anything special to debug applications running Java on Truffle from your favorite IDE debugger.For example, starting a debugger session from IntelliJ IDEA is based on the Run Configurations.To ensure you attach the debugger to your Java application in the same environment, navigate in the main menu to Run -&amp;gt; Debug… -&amp;gt; Edit Configurations, expand Environment, check the JRE value and VM options values.It should show GraalVM as project’s JRE and VM options should include -truffle -XX:+IgnoreUnrecognizedVMOptions: -truffle to run Java on Truffle, and -XX:+IgnoreUnrecognizedVMOptions as a temporary workaround since the Java on Truffle runtime does not yet support attaching Java agents.What to Read NextJava on Truffle enables a seamless Java interoperability with other languages in the GraalVM ecosystem.Check the Interoperability with Truffle Languages guide to learn how to load code written in foreign languages, export and import objects between languages, how to use Java-on-Truffle objects from a foreign language and vice versa to create powerful polyglot programs.To learn about the implementation approach, project’s current status, and known limitations proceed to Implementation Details.You can already run some large applications like the Eclipse IDE, Scala or other languages REPLs, etc. in the Java on Truffle execution mode.We recommend having a look at the collection of Demo Applications.If you have a question, check the available FAQs, or reach us directly over the #espresso channel in GraalVM Slack.",
                    "url": " /reference-manual/java-on-truffle/"
                  },
                  
                  "reference-manual-js":  {
                    "title": "",
                    "content": "GraalVM JavaScript ImplementationGraalVM provides an ECMAScript-compliant runtime to execute JavaScript and Node.js applications.It is fully standard compliant, execute applications with high performance, and provide all benefits from the GraalVM stack, including language interoperability and common tooling.This reference documentation provides information on available JavaScript engine configurations, the Node.js runtime, the javax.script.ScriptEngine implementation, multithreading support details, possible embedding scenarios, and more.To migrate the code previously targeted to the Nashorn or Rhino engines, migration guides are available.Running JavaScriptGraalVM can run plain JavaScript (ECMAScript) code:js [options] [filename...] -- [args]For information about the compatibility of GraalVM JavaScript with existing standards and engines, see JavaScriptCompatibility.Running Node.jsGraalVM is capable of executing unmodified Node.js applications.Applications can import npm modules, including native ones.Since GraalVM 21.1, the Node.js support is packaged in a separate GraalVM component.It can be installed with the GraalVM Updater.$GRAALVM/bin/gu install nodejsThis installs the node and npm binaries in the $GRAALVM/bin directory.Use the node utility to execute Node.js applications:node [options] [filename] [args]To install a Node.js package, use the npm launcher from the GraalVM’s /bin folder.The npm command is equivalent to the default Node.js command and supports all Node.js APIs.1. Install the colors and ansispan packages using npm install as follows:npm install colors ansispanAfter the packages are installed, you can use them from your application.2. Add the following code snippet to a file named app.js and save it in the same directory where you installed the Node.js packages:const http = require(&quot;http&quot;);const span = require(&quot;ansispan&quot;);require(&quot;colors&quot;);http.createServer(function (request, response) {    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});    response.end(span(&quot;Hello Graal.js!&quot;.green));}).listen(8000, function() { console.log(&quot;Graal.js server running at http://127.0.0.1:8000/&quot;.red); });setTimeout(function() { console.log(&quot;DONE!&quot;); process.exit(); }, 2000);3. Execute it on GraalVM using the node command as follows:node app.jsFor more information about running Node.js, continue to Node.js Runtime.Node.js functionality is available when an application is started from the node binary launcher.Certain limits apply when launching a Node.js application or accessing npm packages from a Java context, see Node.js vs. Java Script Context.InteroperabilityGraalVM supports several other programming languages like Ruby, R, Python, andLLVM languages. While GraalVM is designed to run Node.js and JavaScript applications, italso provides interoperability between those languages and lets you executecode from or call methods in any of those languages using GraalVM Polyglot APIs.To enable Node.js or JavaScript interoperability with other languages, pass the--jvm and --polyglot options. For example:node --jvm --polyglotWelcome to Node.js v12.15.0.Type &quot;.help&quot; for more information.&amp;gt; var array = Polyglot.eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;)&amp;gt; console.log(array[2]);42&amp;gt; console.log(Polyglot.eval(&#39;R&#39;, &#39;runif(100)&#39;)[0]);0.8198353068437427For more information about interoperability with other programminglanguages, see Polyglot Programming for a general description.Interoperability with JavaTo access Java from JavaScript, use Java.type, as in the following example:node --jvm&amp;gt; var BigInteger = Java.type(&#39;java.math.BigInteger&#39;);&amp;gt; console.log(BigInteger.valueOf(2).pow(100).toString(16));10000000000000000000000000Vice versa, you can execute JavaScript from Java by embedding the JavaScript context in the Java program:import org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;public class HelloPolyglot {    static String JS_CODE = &quot;(function myFun(param){console.log(&#39;hello &#39;+param);})&quot;;    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.create()) {            Value value = context.eval(&quot;js&quot;, JS_CODE);            value.execute(args[0]);        }    }}By wrapping the function definition (()), you return the function immediately.The source code unit can be represented with a String, as in the example, a file, read from URL, and other means.Run the above Java program:javac HelloPolyglot.javajava HelloPolyglot JavaScriptThis way you can evaluate JavaScript context embedded in Java, but you will not be able tocall a function and set parameters in the function directly from the Java code.The Node.js runtime cannot be embedded into a JVM but has to be started as a separate process.For example, save this code as app.js:var HelloPolyglot = Java.type(&quot;HelloPolyglot&quot;);HelloPolyglot.main([&quot;from node.js&quot;]);console.log(&quot;done&quot;);Then start node with the --jvm option to enable interoperability with Java:node --jvm --vm.cp=. app.jsHello Java!hello from node.jsdoneBy setting the classpath, you instruct node to start a JVM properly. Both Node.js and JVM then run in the same process and the interoperability works using the same Value classes as above.Learn more about language interoperability in the Java Interoperability guide.Further documentationFor additional information, refer to those documentation pages on specific topics around GraalVM JavaScript:  Frequently Asked QuestionsUsing GraalVM JavaScript:  JavaScript Compatibility  Options and Flags to the Engine  Multithreading Support  Java Interoperability  Execute GraalVM JavaScript on a Stock JDKLegacy environments:  Migration Guide from Nashorn  Migration Guide from Rhino  Work with a javax.script.ScriptEngineNode.js support:  Node.js Support  Differences between node’s native launcher and a Java Context",
                    "url": " /reference-manual/js/"
                  },
                  
                  "reference-manual-python":  {
                    "title": "",
                    "content": "GraalVM Python RuntimeGraalVM provides a Python 3.8 compliant runtime.A primary goal of the GraalVM Python runtime is to support SciPy and its constituent libraries, as well as to work with other data science and machine learning libraries from the rich Python ecosystem.At this point, the Python runtime is made available for experimentation and curious end-users.See FAQ for commonly asked questions about this implementation.Installing PythonThe Python runtime is not provided by default, and can be added to GraalVM with the GraalVM Updater, gu, tool:gu install pythonThe above command will install Python from the GitHub catalog for GraalVM Community Edition users.For GraalVM Enterprise users, the manual installation is required.Running PythonGraalVM’s Python support targets Python 3.8 compatibility.While the support is still limited, you can run simple Python commands or programs with the graalpython launcher:graalpython [options] [-c cmd | filename]If no program file or command is given, you are dropped into a simple REPL.GraalVM supports some of the same options as Python 3.8 as well as some additional options to control the underlying Python runtime, GraalVM’s tools, and the execution engine.These can be viewed using the following command:graalpython --help --help:tools --help:languagesInstalling Supported PackagesGraalVM Python runtime comes with a tool called ginstall which may be used to install a small list of packages known to work to some extent with GraalVM’s Python runtime.It is recommended to always create a virtual environment first, using the standard Python module venv.Creating such an environment avoids any incompatible interaction with the local user’s packages that may have beeninstalled using a system installation of CPython:graalpython -m venv my_new_venvsource my_new_venv/bin/activateTo see the list of installable packages, run:graalpython -m ginstall install --helpThis will print a short help document including a comma-separated list of packages youcan install. The installation works as described in that help document:graalpython -m ginstall install pandasNote that when calling Python from Java, the polyglot shell, or another language on GraalVM, you should always evaluate the piece of Python code first to make installed packages available:import siteFor more information, continue reading to the Installing Supported Packages guide.Native Image and JVM RuntimeBy default, GraalVM runs Python from a binary, compiled ahead-of-time with Native Image, yielding faster startup time and lower footprint.Although the ahead-of-time compiled binary includes the Python and LLVM interpreters, in order to interoperate withother languages you have to supply the --jvm argument.This instructs the launcher to run on the JVM instead of in Native Image mode.Thus, you will notice a longer startup time.",
                    "url": " /reference-manual/python/"
                  },
                  
                  "reference-manual-llvm":  {
                    "title": "",
                    "content": "GraalVM LLVM RuntimeThe GraalVM LLVM runtime can execute programming languages that can be transformed to LLVM bitcode.This includes languages like C/C++, Fortran and others.In contrast to static compilation that is normally used for LLVM-based languages, GraalVM’s implementation of the lli tool first interprets LLVM bitcode and then dynamically compiles the hot parts of the program using the GraalVM compiler.This allows seamless interoperability with the dynamic languages supported by GraalVM.Running LLVM Bitcode on GraalVMTo run LLVM-based languages on GraalVM, the binaries need to be compiled with embeddedbitcode. The Compiling guide provides information onhow to compile a program to LLVM bitcode and what file format is expected.The syntax to execute programs in LLVM bitcode format on GraalVM is:lli [LLI options] [GraalVM options] [polyglot options] &amp;lt;bitcode file&amp;gt; [program args]Here, &amp;lt;bitcode file&amp;gt; is a compiled program with embedded LLVM bitcode. See LLI Command Options or use lli --help for options explanations.Note: LLVM bitcode is platform-dependent. The program must be compiled tobitcode for an appropriate platform.",
                    "url": " /reference-manual/llvm/"
                  },
                  
                  "reference-manual-r":  {
                    "title": "",
                    "content": "GraalVM R RuntimeGraalVM provides a GNU-compatible R runtime to run R programs directly or in the REPL mode.It can run R code at unparalleled performance, and seamlessly integrates with the GraalVM ecosystem.The project name behind GraalVM’s R runtime development is FastR.The GraalVM R runtime is an experimental GraalVM component.Installing RThe R language runtime is not provided by default, and can be added to GraalVM with the GraalVM Updater, gu, tool:gu install rAfter this step, the R and Rscript launchers will become available in the GRAALVM_HOME/bin directory.The R language home directory, which will be further referenced as $R_HOME, is located in:  jre/languages/R in JDK8-based GraalVM distributions  languages/R in JDK11-based GraalVM distributionsPrerequisitesGraalVM’s R runtime requires the OpenMP runtime library.The following commands should install this dependency:  Ubuntu 18.04 and 19.10: apt-get install libgomp1  Oracle Linux 7 and 8: yum install libgomp  macOS: libgomp should be already installedAs of version 20.1.0 and later, GraalVM’s R runtime on Linux supports and bundles the GFortran version 3 runtime libraries.On macOS it bundles and supports the GFortran version 8.3.0 runtime libraries.It is not necessary to install the runtime libraries.However, note that a runtime library is only compatible with the GFortran compiler of that same library version or later.On a Linux system, $R_HOME/bin/configure_fastr can be used to check that the necessary libraries are installed, and if not, it will suggest how to install them.Moreover, to install R packages that contain C/C++ or Fortran code, compilers for those languages must be present on the target system.The following packages satisfy the dependencies of the most common R packages:  Ubuntu 18.04 and 19.10:    apt-get install build-essential gfortran libxml2 libc++-dev    Oracle Linux 7 and 8:    yum groupinstall &#39;Development Tools&#39; &amp;amp;&amp;amp; yum install gcc-gfortran bzip2 libxml2-devel    macOS    brew install gcc  Note: If the gfortran executable is not on your system path, you will need to configurethe full path to it in $R_HOME/etc/Makeconf, the FC variable.Search Paths for PackagesThe default R library location is within the GraalVM installation directory.In order to allow installation of additional packages for users who do not have write access to the GraalVM installation directory, edit the R_LIBS_USER variable in the $GRAALVM_HOME/etc/Renviron file.Running RRun R code directly or in the REPL mode with the R and Rscript commands:R [polyglot options] [R options] [filename]Rscript [polyglot options] [R options] [filename]The GraalVM R runtime uses the same polyglot options as other GraalVM languages runtimes and the same R options as GNU R, e.g., bin/R --vanilla.Use --help to print the list of supported options. The most important options include:  --jvm: to enable Java interoperability  --polyglot: to enable interoperability with other GraalVM languages  --vm.Djava.net.useSystemProxies=true: to pass any options to the JVM; this will be translated to -Djava.net.useSystemProxies=true.Note: Unlike other GraalVM languages runtimes, R does not yet ship with a Native Image version of its runtime.Therefore the --native option, which is the default, will still start Rscript on top of the JVM,but for the sake of future compatibility the Java interoperability will not be available in this case.You can optionally build the native image:gu rebuild-images RThe native launcher for R is intended only for curious users and experiments.There are known issues and limitations. Once the native launcher is built, you can usethe --jvm flag to run R again in the JVM mode.GraalVM IntegrationThe R language integration with the GraalVM ecosystem includes:  seamless interoperability with other GraalVM languages and with Java  debugging with Chrome DevTools  CPU and memory profiling  VisualVM integrationTo start debugging R code, start the launcher with the --inspect option:Rscript --inspect myScript.RNote: The GNU-compatible debugging using, for example, debug(myFunction), is also supported.",
                    "url": " /reference-manual/r/"
                  },
                  
                  "reference-manual-wasm":  {
                    "title": "",
                    "content": "GraalVM Implementation of WebAssemblyGraalVM can run programs compiled to WebAssembly. It can interpret and compileWebAssembly code in the binary format or embed it into other programs.The support for WebAssembly is in the early stages of its development.Installing WasmThe support is not available by default, but you can add it to GraalVM using the GraalVM Updater tool:gu install wasmThe above command will install a community version of a component from the GitHub catalog.For GraalVM Enterprise users, the manual component installation is required.Then wasm launcher, which can run compiled WebAssembly binary code, becomes available.Running WebAssembly ProgramsYou can run a program written in the language that compiles to WebAssembly on GraalVM.For example, put the following C program in a file named floyd.c:#include &amp;lt;stdio.h&amp;gt;int main() {  int number = 1;  int rows = 10;  for (int i = 1; i &amp;lt;= rows; i++) {    for (int j = 1; j &amp;lt;= i; j++) {      printf(&quot;%d &quot;, number);      ++number;    }    printf(&quot;.n&quot;);  }  return 0;}Compile it using the most recent Emscripten compiler frontend version. It should produce a standalone floyd.wasm file in the current working directory:emcc -o floyd.wasm floyd.cThen you can run the compiled WebAssembly binary on GraalVM as follows:wasm --Builtins=wasi_snapshot_preview1 floyd.wasmIn this example, the flag --Builtins specifies builtin modules that the Emscripten toolchain requires.Embedding WebAssembly ProgramsThe compiled WebAssembly binary code can be accessed programmatically with GraalVM Polyglot API, which allows embedding GraalVM WebAssembly into user programs. Here is a simple example of how to call WebAssembly code from a Java application:import org.graalvm.polyglot.*;import org.graalvm.polyglot.io.ByteSequence;//Load the WASM contents into a byte arraybyte[] binary = readBytes(&quot;example.wasm&quot;);Context.Builder contextBuilder = Context.newBuilder(&quot;wasm&quot;);Source.Builder sourceBuilder = Source.newBuilder(&quot;wasm&quot;, ByteSequence.create(binary), &quot;example&quot;);Source source = sourceBuilder.build();Context context = contextBuilder.build();context.eval(source);Value mainFunction = context.getBindings(&quot;wasm&quot;).getMember(&quot;main&quot;).getMember(&quot;_start&quot;);mainFunction.execute();For more polyglot examples, visit the Polyglot Programming page.",
                    "url": " /reference-manual/wasm/"
                  },
                  
                  "reference-manual-native-image-reflection":  {
                    "title": "",
                    "content": "Reflection Use in Native ImagesJava reflection support (the java.lang.reflect.* API) enables Java code to examine its own classes, methods, fields and their properties at run time.Native Image has partial support for reflection and needs to know ahead-of-time the reflectively accessed program elements.Examining and accessing program elements through java.lang.reflect.* or loading classes with Class.forName(String) at run time requires preparing additional metadata for those program elements.(Note: loading classes with Class.forName(String) are included here since it is closely related to reflection.)Native Image tries to resolve the target elements through a static analysis that detects calls to the Reflection API.Where the analysis fails, the program elements reflectively accessed at run time must be specified using a manual configuration.See also the guide on assisted configuration of Java resources and other dynamic features.Automatic DetectionThe analysis intercepts calls to Class.forName(String), Class.forName(String, ClassLoader), Class.getDeclaredField(String), Class.getField(String), Class.getDeclaredMethod(String, Class[]), Class.getMethod(String, Class[]), Class.getDeclaredConstructor(Class[]), and Class.getConstructor(Class[]).If the arguments to these calls can be reduced to a constant, Native Image tries to resolve the target elements.If the target elements can be resolved, the calls are removed and instead the target elements are embedded in the code.If the target elements cannot be resolved, e.g., a class is not on the classpath or it does not declare a field/method/constructor, then the calls are replaced with a snippet that throws the appropriate exception at run time.The benefits are twofold.First, at run time there are no calls to the Reflection API.Second, GraalVM can employ constant folding and optimize the code further.The calls are intercepted and processed only when it can be unequivocally determined that the parameters can be reduced to a constant.For example, the call Class.forName(String) will be replaced with a Class literal only if the String argument can be constant folded, assuming that the class is actually on the classpath.Additionally, a call to Class.getMethod(String, Class[]) will be processed only if the contents of the Class[] argument can be determined with certainty.This last restriction is due to the fact that Java does not have immutable arrays.Therefore, all the changes to the array between the time it is allocated and the time it is passed as an argument need to be tracked.The analysis follows a simple rule: if all the writes to the array happen in linear sections of code, i.e., no control flow splits, then the array is effectively constant for the purpose of analyzing the call.That is why the analysis does not accept Class[] arguments coming from static fields, since the contents of those can change at any time, even if the fields are final.Although this may seem too restrictive, it covers the most commonly used patterns of the Reflection API calls.The only exception to the constant arguments rule is that the ClassLoader argument of Class.forName(String, ClassLoader) does not need to be a constant; it is ignored and instead a class loader that can load all the classes on the class path is used.The analysis runs to a fix point which means that a chain of calls like Class.forName(String).getMethod(String, Class[]) will first replace the class constant and then the method will effectively reduce this to java.lang.reflect.Method.Following are examples of calls that can be intercepted and replaced with the corresponding element:Class.forName(&quot;java.lang.Integer&quot;)Class.forName(&quot;java.lang.Integer&quot;, true, ClassLoader.getSystemClassLoader())Class.forName(&quot;java.lang.Integer&quot;).getMethod(&quot;equals&quot;, Object.class)Integer.class.getDeclaredMethod(&quot;bitCount&quot;, int.class)Integer.class.getConstructor(String.class)Integer.class.getDeclaredConstructor(int.class)Integer.class.getField(&quot;MAX_VALUE&quot;)Integer.class.getDeclaredField(&quot;value&quot;)The following ways to declare and populate an array are equivalent from the point of view of the analysis:Class&amp;lt;?&amp;gt;[] params0 = new Class&amp;lt;?&amp;gt;[]{String.class, int.class};Integer.class.getMethod(&quot;parseInt&quot;, params0);Class&amp;lt;?&amp;gt;[] params1 = new Class&amp;lt;?&amp;gt;[2];params1[0] = Class.forName(&quot;java.lang.String&quot;);params1[1] = int.class;Integer.class.getMethod(&quot;parseInt&quot;, params1);Class&amp;lt;?&amp;gt;[] params2 = {String.class, int.class};Integer.class.getMethod(&quot;parseInt&quot;, params2);If a call cannot be processed it is simply skipped.For these situations a manual configuration as described below can be provided.Manual ConfigurationA configuration that specifies the program elements that will be accessed reflectively can be provided during the native image build as follows:-H:ReflectionConfigurationFiles=/path/to/reflectconfigHere, reflectconfig is a JSON file in the following format (use --expert-options for more details):[  {    &quot;name&quot; : &quot;java.lang.Class&quot;,    &quot;allDeclaredConstructors&quot; : true,    &quot;allPublicConstructors&quot; : true,    &quot;allDeclaredMethods&quot; : true,    &quot;allPublicMethods&quot; : true,    &quot;allDeclaredClasses&quot; : true,    &quot;allPublicClasses&quot; : true  },  {    &quot;name&quot; : &quot;java.lang.String&quot;,    &quot;fields&quot; : [      { &quot;name&quot; : &quot;value&quot; },      { &quot;name&quot; : &quot;hash&quot; }    ],    &quot;methods&quot; : [      { &quot;name&quot; : &quot;&amp;lt;init&amp;gt;&quot;, &quot;parameterTypes&quot; : [] },      { &quot;name&quot; : &quot;&amp;lt;init&amp;gt;&quot;, &quot;parameterTypes&quot; : [&quot;char[]&quot;] },      { &quot;name&quot; : &quot;charAt&quot; },      { &quot;name&quot; : &quot;format&quot;, &quot;parameterTypes&quot; : [&quot;java.lang.String&quot;, &quot;java.lang.Object[]&quot;] }    ]  },    {      &quot;name&quot; : &quot;java.lang.String$CaseInsensitiveComparator&quot;,      &quot;methods&quot; : [        { &quot;name&quot; : &quot;compare&quot; }      ]    }]The native image builder generates reflection metadata for all classes, methods, and fields referenced in that file.The allPublicConstructors, allDeclaredConstructors, allPublicMethods, allDeclaredMethods, allPublicFields, allDeclaredFields, allPublicClasses, and allDeclaredClasses attributes can be used to automatically include an entire set of members of a class.However, allPublicClasses and allDeclaredClasses do not automatically register the inner classes for reflective access.They just make them available via Class.getClasses() and Class.getDeclaredClasses() when called on the declaring class.Code may also write non-static final fields like String.value in this example, but other code might not observe changes of final field values in the same way as for non-final fields because of optimizations. Static final fields may never be written.More than one configuration can be used by specifying multiple paths for ReflectionConfigurationFiles and separating them with ,.Also, -H:ReflectionConfigurationResources can be specified to load one or several configuration files from the native image build’s class path, such as from a JAR file.Alternatively, a custom Feature implementation can register program elements before and during the analysis phase of the native image build using the RuntimeReflection class. For example:class RuntimeReflectionRegistrationFeature implements Feature {  public void beforeAnalysis(BeforeAnalysisAccess access) {    try {      RuntimeReflection.register(String.class);      RuntimeReflection.register(String.class.getDeclaredField(&quot;value&quot;));      RuntimeReflection.register(String.class.getDeclaredField(&quot;hash&quot;));      RuntimeReflection.register(String.class.getDeclaredConstructor(char[].class));      RuntimeReflection.register(String.class.getDeclaredMethod(&quot;charAt&quot;, int.class));      RuntimeReflection.register(String.class.getDeclaredMethod(&quot;format&quot;, String.class, Object[].class));      RuntimeReflection.register(String.CaseInsensitiveComparator.class);      RuntimeReflection.register(String.CaseInsensitiveComparator.class.getDeclaredMethod(&quot;compare&quot;, String.class, String.class));    } catch (NoSuchMethodException | NoSuchFieldException e) { ... }  }}To activate the custom feature --features=&amp;lt;fully qualified name of RuntimeReflectionRegistrationFeature class&amp;gt; needs to be passed to native-image. Native Image Build Configuration explains how this can be automated with a native-image.properties file in META-INF/native-image.Use of Reflection during Native Image GenerationReflection can be used without restrictions during a native image generation, for example, in static initializers.At this point, code can collect information about methods and fields and store them in their own data structures, which are then reflection-free at run time.Unsafe AccessesThe Unsafe class, although its use is discouraged, provides direct access to the memory of Java objects. The Unsafe.objectFieldOffset() method provides the offset of a field within a Java object. Note that the offsets that are queried during native image generation can be different from the offsets at run time.",
                    "url": " /reference-manual/native-image/Reflection/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-reportingpolymorphism":  {
                    "title": "",
                    "content": "Reporting Polymorphic Specializations to RuntimeThis guide gives an overview of what is required of language implementers in order to leverage the monomorphization (splitting) strategy.More information on how it works can be found in the Splitting guide.In simple terms, the monomorphization heuristic relies on the language reporting polymorphic specializations for each node that could potentially be returned to a monomorphic state through splitting.In this context a polymorphic specialization is any node rewriting which results in the node changing “how polymorphic” it is. This includes, but is not limited to, activating another specialization, increasing the number of instances of an active specialization, excluding a specialization, etc..Manual Reporting of Polymorphic SpecializationsTo facilitate reporting of polymorphic specializations, a new API was introducedinto the Node class: Node#reportPolymorphicSpecialize.This method can be used to manually report polymorphic specializations, but only in cases when this cannot be automated by using the DSL.Automated Reporting of Polymorphic SpecializationsSince the Truffle DSL automates much of the transitions between specializations, the @ReportPolymorphism annotation for automated reporting of polymorphic specializations was added.This annotation instructs the DSL to include checks for polymorphism after specializations and to call Node#reportPolymorphicSpecialize if needed.For an example on how to use this annotation, consider the com.oracle.truffle.sl.nodes.SLStatementNode. It is the base class for allSimpleLanguage nodes and, since the ReportPolymorphism annotation is inherited, simply annotating this class will enable reporting of polymorphic specializations for all SimpleLanguage nodes.Below is the diff of the change that adds this annotation to SLStatementNode:diff --gita/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.javab/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.javaindex 788cc20..89448b2 100644---a/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.java+++b/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.java@@ -43,6 +43,7 @@ package com.oracle.truffle.sl.nodes; import java.io.File; import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;+import com.oracle.truffle.api.dsl.ReportPolymorphism; import com.oracle.truffle.api.frame.VirtualFrame; import com.oracle.truffle.api.instrumentation.GenerateWrapper; import com.oracle.truffle.api.instrumentation.InstrumentableNode;@@ -62,6 +63,7 @@ import com.oracle.truffle.api.source.SourceSection;  */ @NodeInfo(language = &quot;SL&quot;, description = &quot;The abstract base node for all SLstatements&quot;) @GenerateWrapper+@ReportPolymorphism public abstract class SLStatementNode extends Node implementsInstrumentableNode {     private static final int NO_SOURCE = -1;Controlling Automated Reporting of Polymorphic SpecializationsExcluding particular nodes and specializationsApplying the ReportPolymorphism annotation to all nodes of a language is the simplest way to facilitate the monomorphization, but it could cause reporting of polymorphic specializations in cases where that does not necessarily make sense.In order to give the language developer more control over which nodes and which specializations are taken into consideration for reporting polymorphism, the @ReportPolymorphism.Exclude annotation was introduced which is applicable to classes (disabling automated reporting for the entire class) or to individual specializations (excluding those specializations from consideration when checking for polymorphism).Reporting only on Megamorphic CasesAs of version 20.3.0 a new annotation was added: ReportPolymorphism.Megamorphic.This annotation can only be applied to specializations, as marks that specialization as megamorphic as it is intented to be used on expensive “generic” specializations that should be fixed by monomorphization.The effect of adding this annotation is that, once the annotated specialisation becomes active, the node will report polymorphism to the runtime independant of the state of other specializations.This annotation can be used separately from @ReportPolymorphism, i.e., a node does not need to be annotated with @ReportPolymorphism for the megamorphic annotation to work.If both annotations are used, then both polymorphic and megamorphic activations will be reported as polymorphism.Tools SupportKnowing which nodes should and should not report polymorphic specializations is for the language developer to conclude.This can be done either through domain knowledge (which nodes of the language are expensive when polymorphic), or through experimentation (measuring the effects of including/excluding particular nodes/specializations).To aid language developers in better understanding the impact of reporting polymorphic specializations some tools support was provided.Tracing individual splitsAdding the --engine.TraceSplitting argument to the command line when executing your guest language code will, in real time, print information about each split the runtime makes.A small part of the output from running one of the JavaScript benchmarks with the flag enabled follows....[engine] split   0-37d4349f-1     multiplyScalar |ASTSize      40/   40 |Calls/Thres       2/    3 |CallsAndLoop/Thres       2/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~441-444:12764-12993[engine] split   1-2ea41516-1     :anonymous |ASTSize       8/    8 |Calls/Thres       3/    3 |CallsAndLoop/Thres       3/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~269:7395-7446[engine] split   2-3a44431a-1     :anonymous |ASTSize      28/   28 |Calls/Thres       4/    5 |CallsAndLoop/Thres       4/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~35-37:1163-1226[engine] split   3-3c7f66c4-1     Function.prototype.apply |ASTSize      18/   18 |Calls/Thres       7/    8 |CallsAndLoop/Thres       7/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~36:1182-1219...Tracing a splitting summaryAdding the --engine.TraceSplittingSummary argument to the command line when executing your guest language code will, after the execution is complete, print out a summary of the gathered data regarding splitting.This includes how many splits there were, how large is the splitting budget and how much of it was used, how many splits were forced, a list of split target names and how many times they were split and a list of nodes that reported polymorphic specializations and how many.A slightly simplified output of running one of the JavaScript benchmarks with the flag enabled follows.[engine] Splitting StatisticsSplit count                             :       9783Split limit                             :      15342Split count                             :          0Split limit                             :        574Splits                                  :        591Forced splits                           :          0Nodes created through splitting         :       9979Nodes created without splitting         :      10700Increase in nodes                       :     93.26%Split nodes wasted                      :        390Percent of split nodes wasted           :      3.91%Targets wasted due to splitting         :         27Total nodes executed                    :       7399--- SPLIT TARGETSinitialize                              :         60Function.prototype.apply                :        117Array.prototype.push                    :          7initialize                              :          2magnitude                               :         17:anonymous                              :        117add                                     :          5...--- NODESclass ANode                             :         42class AnotherNode                       :        198class YetAnotherNode                    :          1...Tracing polymorphic specializationsConsider reading the Splitting guide before this section, as the dumped data is directly related to how splitting works.To better understand how reporting polymorphism impacts which call targets are considered for splitting one can use the --engine.SplittingTraceEvents option.This option will print, in real time, a log detailing which nodes are reporting polymorphism and how that is affecting the call targets.See the following examples.Example 1[engine] [poly-event] Polymorphic event! Source: JSObjectWriteElementTypeCacheNode@e3c0e40   WorkerTask.run[engine] [poly-event] Early return: false callCount: 1, numberOfKnownCallNodes: 1            WorkerTask.runThis log section tells that the JSObjectWriteElementTypeCacheNode in the WorkerTask.run method turned polymorphic and reported it.It also tells that this is the first time that WorkerTask.run is being executed (callCount: 1), thus you do not mark it as “needs split” (Early return: false)Example 2[engine] [poly-event] Polymorphic event! Source: WritePropertyNode@50313382                  Packet.addTo[engine] [poly-event] One caller! Analysing parent.                                          Packet.addTo[engine] [poly-event]   One caller! Analysing parent.                                        HandlerTask.run[engine] [poly-event]     One caller! Analysing parent.                                      TaskControlBlock.run[engine] [poly-event]       Early return: false callCount: 1, numberOfKnownCallNodes: 1      Scheduler.schedule[engine] [poly-event]     Return: false                                                      TaskControlBlock.run[engine] [poly-event]   Return: false                                                        HandlerTask.run[engine] [poly-event] Return: false                                                          Packet.addToIn this example the source of the polymorphic specialization is WritePropertyNode in Packet.addTo.Since this call target has only one known caller, you can analyse its parent in the call tree (i.e., the caller).This is, in the example, HandlerTask.run and the same applies to it as well, leading to TaskControlBlock.run, and by the same token to Scheduler.schedule.Scheduler.schedule has a callCount of 1, i.e., this is its first execution, so you do not mark it as “needs split” (Early return: false).Example 3[engine] [poly-event] Polymorphic event! Source: JSObjectWriteElementTypeCacheNode@3e44f2a5  Scheduler.addTask[engine] [poly-event] Set needs split to true                                                Scheduler.addTask[engine] [poly-event] Return: true                                                           Scheduler.addTaskIn this example the source of the polymorphic specialization is JSObjectWriteElementTypeCacheNode in Scheduler.addTask.This call target is immediately marked as “needs split”, since all the criteria to do so are met.Example 3[engine] [poly-event] Polymorphic event! Source: WritePropertyNode@479cbee5                  TaskControlBlock.checkPriorityAdd[engine] [poly-event] One caller! Analysing parent.                                          TaskControlBlock.checkPriorityAdd[engine] [poly-event]   Set needs split to true                                              Scheduler.queue[engine] [poly-event]   Return: true                                                         Scheduler.queue[engine] [poly-event] Set needs split to true via parent                                     TaskControlBlock.checkPriorityAdd[engine] [poly-event] Return: true                                                           TaskControlBlock.checkPriorityAddIn this example the source of the polymorphic specialization is WritePropertyNode in TaskControlBlock.checkPriorityAdd.Since it has only one caller, you look at that caller (Scheduler.queue), and since all the criteria necessary seem to be met, you mark it as “needs split”.Dumping polymorphic specializations to IGVConsider reading the Splitting guide before this section, as the dumped data is directly related to how splitting works.Adding the --engine.SplittingDumpDecisions argument to the command line when executing your guest language code will, every time a call target is marked “needs split”, dump a graph showing a chain of nodes (linked by child connections as well as direct call node to callee root node links) ending in the node that called Node#reportPolymorphicSpecialize.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/ReportingPolymorphism/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-reportingpolymorphism":  {
                    "title": "",
                    "content": "Reporting Polymorphic Specializations to RuntimeThis guide gives an overview of what is required of language implementers in order to leverage the monomorphization (splitting) strategy.More information on how it works can be found in the Splitting guide.In simple terms, the monomorphization heuristic relies on the language reporting polymorphic specializations for each node that could potentially be returned to a monomorphic state through splitting.In this context a polymorphic specialization is any node rewriting which results in the node changing “how polymorphic” it is. This includes, but is not limited to, activating another specialization, increasing the number of instances of an active specialization, excluding a specialization, etc..Manual Reporting of Polymorphic SpecializationsTo facilitate reporting of polymorphic specializations, a new API was introducedinto the Node class: Node#reportPolymorphicSpecialize.This method can be used to manually report polymorphic specializations, but only in cases when this cannot be automated by using the DSL.Automated Reporting of Polymorphic SpecializationsSince the Truffle DSL automates much of the transitions between specializations, the @ReportPolymorphism annotation for automated reporting of polymorphic specializations was added.This annotation instructs the DSL to include checks for polymorphism after specializations and to call Node#reportPolymorphicSpecialize if needed.For an example on how to use this annotation, consider the com.oracle.truffle.sl.nodes.SLStatementNode. It is the base class for allSimpleLanguage nodes and, since the ReportPolymorphism annotation is inherited, simply annotating this class will enable reporting of polymorphic specializations for all SimpleLanguage nodes.Below is the diff of the change that adds this annotation to SLStatementNode:diff --gita/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.javab/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.javaindex 788cc20..89448b2 100644---a/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.java+++b/truffle/src/com.oracle.truffle.sl/src/com/oracle/truffle/sl/nodes/SLStatementNode.java@@ -43,6 +43,7 @@ package com.oracle.truffle.sl.nodes; import java.io.File; import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;+import com.oracle.truffle.api.dsl.ReportPolymorphism; import com.oracle.truffle.api.frame.VirtualFrame; import com.oracle.truffle.api.instrumentation.GenerateWrapper; import com.oracle.truffle.api.instrumentation.InstrumentableNode;@@ -62,6 +63,7 @@ import com.oracle.truffle.api.source.SourceSection;  */ @NodeInfo(language = &quot;SL&quot;, description = &quot;The abstract base node for all SLstatements&quot;) @GenerateWrapper+@ReportPolymorphism public abstract class SLStatementNode extends Node implementsInstrumentableNode {     private static final int NO_SOURCE = -1;Controlling Automated Reporting of Polymorphic SpecializationsExcluding particular nodes and specializationsApplying the ReportPolymorphism annotation to all nodes of a language is the simplest way to facilitate the monomorphization, but it could cause reporting of polymorphic specializations in cases where that does not necessarily make sense.In order to give the language developer more control over which nodes and which specializations are taken into consideration for reporting polymorphism, the @ReportPolymorphism.Exclude annotation was introduced which is applicable to classes (disabling automated reporting for the entire class) or to individual specializations (excluding those specializations from consideration when checking for polymorphism).Reporting only on Megamorphic CasesAs of version 20.3.0 a new annotation was added: ReportPolymorphism.Megamorphic.This annotation can only be applied to specializations, as marks that specialization as megamorphic as it is intented to be used on expensive “generic” specializations that should be fixed by monomorphization.The effect of adding this annotation is that, once the annotated specialisation becomes active, the node will report polymorphism to the runtime independant of the state of other specializations.This annotation can be used separately from @ReportPolymorphism, i.e., a node does not need to be annotated with @ReportPolymorphism for the megamorphic annotation to work.If both annotations are used, then both polymorphic and megamorphic activations will be reported as polymorphism.Tools SupportKnowing which nodes should and should not report polymorphic specializations is for the language developer to conclude.This can be done either through domain knowledge (which nodes of the language are expensive when polymorphic), or through experimentation (measuring the effects of including/excluding particular nodes/specializations).To aid language developers in better understanding the impact of reporting polymorphic specializations some tools support was provided.Tracing individual splitsAdding the --engine.TraceSplitting argument to the command line when executing your guest language code will, in real time, print information about each split the runtime makes.A small part of the output from running one of the JavaScript benchmarks with the flag enabled follows....[engine] split   0-37d4349f-1     multiplyScalar |ASTSize      40/   40 |Calls/Thres       2/    3 |CallsAndLoop/Thres       2/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~441-444:12764-12993[engine] split   1-2ea41516-1     :anonymous |ASTSize       8/    8 |Calls/Thres       3/    3 |CallsAndLoop/Thres       3/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~269:7395-7446[engine] split   2-3a44431a-1     :anonymous |ASTSize      28/   28 |Calls/Thres       4/    5 |CallsAndLoop/Thres       4/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~35-37:1163-1226[engine] split   3-3c7f66c4-1     Function.prototype.apply |ASTSize      18/   18 |Calls/Thres       7/    8 |CallsAndLoop/Thres       7/ 1000 |Inval#              0 |SourceSection octane-raytrace.js~36:1182-1219...Tracing a splitting summaryAdding the --engine.TraceSplittingSummary argument to the command line when executing your guest language code will, after the execution is complete, print out a summary of the gathered data regarding splitting.This includes how many splits there were, how large is the splitting budget and how much of it was used, how many splits were forced, a list of split target names and how many times they were split and a list of nodes that reported polymorphic specializations and how many.A slightly simplified output of running one of the JavaScript benchmarks with the flag enabled follows.[engine] Splitting StatisticsSplit count                             :       9783Split limit                             :      15342Split count                             :          0Split limit                             :        574Splits                                  :        591Forced splits                           :          0Nodes created through splitting         :       9979Nodes created without splitting         :      10700Increase in nodes                       :     93.26%Split nodes wasted                      :        390Percent of split nodes wasted           :      3.91%Targets wasted due to splitting         :         27Total nodes executed                    :       7399--- SPLIT TARGETSinitialize                              :         60Function.prototype.apply                :        117Array.prototype.push                    :          7initialize                              :          2magnitude                               :         17:anonymous                              :        117add                                     :          5...--- NODESclass ANode                             :         42class AnotherNode                       :        198class YetAnotherNode                    :          1...Tracing polymorphic specializationsConsider reading the Splitting guide before this section, as the dumped data is directly related to how splitting works.To better understand how reporting polymorphism impacts which call targets are considered for splitting one can use the --engine.SplittingTraceEvents option.This option will print, in real time, a log detailing which nodes are reporting polymorphism and how that is affecting the call targets.See the following examples.Example 1[engine] [poly-event] Polymorphic event! Source: JSObjectWriteElementTypeCacheNode@e3c0e40   WorkerTask.run[engine] [poly-event] Early return: false callCount: 1, numberOfKnownCallNodes: 1            WorkerTask.runThis log section tells that the JSObjectWriteElementTypeCacheNode in the WorkerTask.run method turned polymorphic and reported it.It also tells that this is the first time that WorkerTask.run is being executed (callCount: 1), thus you do not mark it as “needs split” (Early return: false)Example 2[engine] [poly-event] Polymorphic event! Source: WritePropertyNode@50313382                  Packet.addTo[engine] [poly-event] One caller! Analysing parent.                                          Packet.addTo[engine] [poly-event]   One caller! Analysing parent.                                        HandlerTask.run[engine] [poly-event]     One caller! Analysing parent.                                      TaskControlBlock.run[engine] [poly-event]       Early return: false callCount: 1, numberOfKnownCallNodes: 1      Scheduler.schedule[engine] [poly-event]     Return: false                                                      TaskControlBlock.run[engine] [poly-event]   Return: false                                                        HandlerTask.run[engine] [poly-event] Return: false                                                          Packet.addToIn this example the source of the polymorphic specialization is WritePropertyNode in Packet.addTo.Since this call target has only one known caller, you can analyse its parent in the call tree (i.e., the caller).This is, in the example, HandlerTask.run and the same applies to it as well, leading to TaskControlBlock.run, and by the same token to Scheduler.schedule.Scheduler.schedule has a callCount of 1, i.e., this is its first execution, so you do not mark it as “needs split” (Early return: false).Example 3[engine] [poly-event] Polymorphic event! Source: JSObjectWriteElementTypeCacheNode@3e44f2a5  Scheduler.addTask[engine] [poly-event] Set needs split to true                                                Scheduler.addTask[engine] [poly-event] Return: true                                                           Scheduler.addTaskIn this example the source of the polymorphic specialization is JSObjectWriteElementTypeCacheNode in Scheduler.addTask.This call target is immediately marked as “needs split”, since all the criteria to do so are met.Example 3[engine] [poly-event] Polymorphic event! Source: WritePropertyNode@479cbee5                  TaskControlBlock.checkPriorityAdd[engine] [poly-event] One caller! Analysing parent.                                          TaskControlBlock.checkPriorityAdd[engine] [poly-event]   Set needs split to true                                              Scheduler.queue[engine] [poly-event]   Return: true                                                         Scheduler.queue[engine] [poly-event] Set needs split to true via parent                                     TaskControlBlock.checkPriorityAdd[engine] [poly-event] Return: true                                                           TaskControlBlock.checkPriorityAddIn this example the source of the polymorphic specialization is WritePropertyNode in TaskControlBlock.checkPriorityAdd.Since it has only one caller, you look at that caller (Scheduler.queue), and since all the criteria necessary seem to be met, you mark it as “needs split”.Dumping polymorphic specializations to IGVConsider reading the Splitting guide before this section, as the dumped data is directly related to how splitting works.Adding the --engine.SplittingDumpDecisions argument to the command line when executing your guest language code will, every time a call target is marked “needs split”, dump a graph showing a chain of nodes (linked by child connections as well as direct call node to callee root node links) ending in the node that called Node#reportPolymorphicSpecialize.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/ReportingPolymorphism/"
                  },
                  
                  "reference-manual-native-image-reports":  {
                    "title": "",
                    "content": "Points-to Analysis ReportsThe points-to analysis produces two kinds of reports: analysis call tree andimage object tree. This information is produced by an intermediate step in theimage building process and represents the static analysis view of the call graphand heap object graph. These graphs are further transformed in the imagebuilding process before they are AOT compiled into the image and written intothe image heap, respectively.Call treeThe call tree is a a breadth-first tree reduction of the call graph as seen by the points-to analysis.The points-to analysis eliminates calls to methods that it determines cannot be reachable at runtime, based on the analysed receiver types.It also completely eliminates invocations in unreachable code blocks, e.g., blocks guarded by a type check that always fails.The call tree report is enabled using the -H:+PrintAnalysisCallTree option.It produces a file with the structure:VM Entry Points├── entry &amp;lt;entry-method&amp;gt; id=&amp;lt;entry-method-id&amp;gt;│   ├── directly calls &amp;lt;callee&amp;gt; id=&amp;lt;callee-id&amp;gt; @bci=&amp;lt;invoke-bci&amp;gt;│   │   └── &amp;lt;callee-sub-tree&amp;gt;│   ├── virtually calls &amp;lt;callee&amp;gt; @bci=&amp;lt;invoke-bci&amp;gt;│   │   ├── is overridden by &amp;lt;overide-method-i&amp;gt; id=&amp;lt;overide-method-i-id&amp;gt;│   │   │   └── &amp;lt;callee-sub-tree&amp;gt;│   │   └── is overridden by &amp;lt;overide-method-j&amp;gt; id-ref=&amp;lt;overide-method-j-id&amp;gt;│   └── interfacially calls &amp;lt;callee&amp;gt; @bci=&amp;lt;invoke-bci&amp;gt;│       ├── is implemented by &amp;lt;implementation-method-x&amp;gt; id=&amp;lt;implementation-method-x-id&amp;gt;│       │   └── &amp;lt;callee-sub-tree&amp;gt;│       └── is implemented by &amp;lt;implementation-method-y&amp;gt; id-ref=&amp;lt;implementation-method-y-id&amp;gt;├── entry &amp;lt;entry-method&amp;gt; id=&amp;lt;entry-method-id&amp;gt;│   └── &amp;lt;callee-sub-tree&amp;gt;└── ...The tags between &amp;lt;and &amp;gt; are expanded with concrete values, the rest is printed as presented.The methods are formatted using &amp;lt;qualified-holder&amp;gt;.&amp;lt;method-name&amp;gt;(&amp;lt;qualified-parameters&amp;gt;):&amp;lt;qualified-return-type&amp;gt; and are expanded until no more callees can be reached.Since this is a tree reduction of the call graph each concrete method is expanded exactly once.The tree representation inherently omits calls to methods that have already been explored in a different branch or previously on the same branch.This restriction implicitly fixes the recursion problem.To convey the information that is lost through tree reduction each concrete method is given a unique id.Thus when a method is reached for the first time it declares an identifier as id=&amp;lt;method-id&amp;gt;.Subsequent discoveries of the same method use an identifier reference to point to the previously expansion location: id-ref=&amp;lt;method-id&amp;gt;.Each id=&amp;lt;method-id&amp;gt; and id-ref=&amp;lt;method-id&amp;gt; are followed by a blank space to make it easy to search.Each invoke is tagged with the invocation bci: @bci=&amp;lt;invoke-bci&amp;gt;.For invokes of inline methods the &amp;lt;invoke-bci&amp;gt; is a list of bci values, separated with -&amp;gt;, enumerating the inline locations, backwards to the original invocation location.Image object treeThe image object tree is an exhaustive expansion of the objects included in the native image heap.The tree is obtained by a depth first walk of the native image heap object graph.It is enabled using the -H:+PrintImageObjectTree option.The roots are either static fields or method graphs that contain embedded constants.The printed values are concrete constant objects added to the native image heap.Produces a file with the structure:Heap roots├── root &amp;lt;root-field&amp;gt; value:│   └── &amp;lt;value-type&amp;gt; id=&amp;lt;value-id&amp;gt; toString=&amp;lt;value-as-string&amp;gt; fields:│       ├── &amp;lt;field-1&amp;gt; value=null│       ├── &amp;lt;field-2&amp;gt; toString=&amp;lt;field-2-value-as-string&amp;gt; (expansion suppressed)│       ├── &amp;lt;field-3&amp;gt; value:│       │   └── &amp;lt;field-3-value-type&amp;gt; id=&amp;lt;field-3-value-id&amp;gt; toString=&amp;lt;field-3-value-as-string&amp;gt; fields:│       │       └── &amp;lt;object-tree-rooted-at-field-3&amp;gt;│       ├── &amp;lt;array-field-4&amp;gt; value:│       │   └── &amp;lt;array-field-4-value-type&amp;gt; id=&amp;lt;array-field-4-value-id&amp;gt; toString=&amp;lt;array-field-4-value-as-string&amp;gt; elements (excluding null):│       │       ├── [&amp;lt;index-i&amp;gt;] &amp;lt;element-index-i-value-type&amp;gt; id=&amp;lt;element-index-i-value-id&amp;gt; toString=&amp;lt;element-index-i-value-as-string&amp;gt; fields:│       │       │   └── &amp;lt;object-tree-rooted-at-index-i&amp;gt;│       │       └── [&amp;lt;index-j&amp;gt;] &amp;lt;element-index-j-value-type&amp;gt; id=&amp;lt;element-index-j-value-id&amp;gt; toString=&amp;lt;element-index-j-value-as-string&amp;gt; elements (excluding null):│       │           └── &amp;lt;object-tree-rooted-at-index-j&amp;gt;│       ├── &amp;lt;field-5&amp;gt; value:│       │   └── &amp;lt;field-5-value-type&amp;gt; id-ref=&amp;lt;field-5-value-id&amp;gt; toString=&amp;lt;field-5-value-as-string&amp;gt;│       ├── &amp;lt;field-6&amp;gt; value:│       │   └── &amp;lt;field-6-value-type&amp;gt; id=&amp;lt;field-6-value-id&amp;gt; toString=&amp;lt;field-6-value-as-string&amp;gt; (no fields)│       └── &amp;lt;array-field-7&amp;gt; value:│           └── &amp;lt;array-field-7-value-type&amp;gt; id=&amp;lt;array-field-7-id&amp;gt; toString=&amp;lt;array-field-7-as-string&amp;gt; (no elements)├── root &amp;lt;root-field&amp;gt; id-ref=&amp;lt;value-id&amp;gt; toString=&amp;lt;value-as-string&amp;gt;├── root &amp;lt;root-method&amp;gt; value:│   └── &amp;lt;object-tree-rooted-at-constant-embeded-in-the-method-graph&amp;gt;└── ...The tags between &amp;lt;and &amp;gt; are expanded with concrete values, the rest is printed as presented.The root fields are formatted using &amp;lt;qualified-holder&amp;gt;.&amp;lt;field-name&amp;gt;:&amp;lt;qualified-declared-type&amp;gt;.The non-root fields are formatted using &amp;lt;field-name&amp;gt;:&amp;lt;qualified-declared-type&amp;gt;.The value types are formatted using &amp;lt;qualified-type&amp;gt;.The root methods are formatted using &amp;lt;qualified-holder&amp;gt;.&amp;lt;method-name&amp;gt;(&amp;lt;unqualified-parameters&amp;gt;):&amp;lt;qualified-return-type&amp;gt;No-array objects are expanded for all fields (including null).No-array objects with no fields are tagged with (no fields).Array objects are expanded for all non-null indexes: [&amp;lt;element-index&amp;gt;] &amp;lt;object-tree-rooted-at-array-element&amp;gt;Empty array objects or with all null elements are tagged with (no elements).Each constant value is expanded exactly once to compress the format.When a value is reached from multiple branches it is expanded only the first time and given an identifier: id=&amp;lt;value-id&amp;gt;.Subsequent discoveries of the same value use an identifier reference to point to the previously expansion location: id-ref=&amp;lt;value-id&amp;gt;.Suppressing expansion of valuesSome values, such as String, BigInteger and primitive arrays, are not expanded by default and marked with (expansion suppressed).All the other types are expanded by default.To force the suppression of types expanded by default you can use -H:ImageObjectTreeSuppressTypes=&amp;lt;comma-separated-patterns&amp;gt;.To force the expansion of types suppressed by default or through the option you can use -H:ImageObjectTreeExpandTypes=&amp;lt;comma-separated-patterns&amp;gt;.When both -H:ImageObjectTreeSuppressTypes and -H:ImageObjectTreeExpandTypes are specified -H:ImageObjectTreeExpandTypes has precedence.Similarly, some roots, such as java.lang.Character$UnicodeBlock.map&quot; that prints a lot of strings, are not expanded at all and marked with (expansion suppressed) as well.All the other roots are expanded by default.To force the suppression of roots expanded by default you can use -H:ImageObjectTreeSuppressRoots=&amp;lt;comma-separated-patterns&amp;gt;.To force the expansion of roots suppressed by default or through the option you can use -H:ImageObjectTreeExpandRoots=&amp;lt;comma-separated-patterns&amp;gt;.When both -H:ImageObjectTreeSuppressRoots and -H:ImageObjectTreeExpandRoots are specified -H:ImageObjectTreeExpandRoots has precedence.All the suppression/expansion options above accept a comma-separated list of patterns.For types the pattern is based on the fully qualified name of the type and refers to the concrete type of the constants.(For array types it is enough to specify the elemental type; it will match all the arrays of that type, of all dimensions.)For roots the pattern is based on the string format of the root as described above.The pattern accepts the * modifier:  ends-with: *&amp;lt;str&amp;gt; - the pattern exactly matches all entries that end with &amp;lt;str&amp;gt;  starts-with: &amp;lt;str&amp;gt;* - the pattern exactly matches all entries that start with &amp;lt;str&amp;gt;  contains: *&amp;lt;str&amp;gt;* - the pattern exactly matches all entries that contain &amp;lt;str&amp;gt;  equals: &amp;lt;str&amp;gt; - the pattern exactly matches all entries that are equal to &amp;lt;str&amp;gt;  all: * - the pattern matches all entriesExamplesTypes suppression/expansion:  -H:ImageObjectTreeSuppressTypes=java.io.BufferedWriter - suppress the expansion of java.io.BufferedWriter objects  -H:ImageObjectTreeSuppressTypes=java.io.BufferedWriter,java.io.BufferedOutputStream - suppress the expansion of java.io.BufferedWriter and java.io.BufferedOutputStream objects  -H:ImageObjectTreeSuppressTypes=java.io.* - suppress the expansion of all java.io.* objects  -H:ImageObjectTreeExpandTypes=java.lang.String - force the expansion of java.lang.String objects  -H:ImageObjectTreeExpandTypes=java.lang.String,java.math.BigInteger - force the expansion of java.lang.String and java.math.BigInteger objects  -H:ImageObjectTreeExpandTypes=java.lang.* - force the expansion of all java.lang.* objects  -H:ImageObjectTreeSuppressTypes=java.io.* -H:ImageObjectTreeExpandTypes=java.io.PrintStream - suppress the expansion of all java.io.* but not java.io.PrintStream objects  -H:ImageObjectTreeExpandTypes=* - force the expansion of objects of all types, including those suppressed by defaultRoots suppression/expansion:  -H:ImageObjectTreeSuppressRoots=&quot;java.nio.charset.Charset.lookup(String)&quot; - suppress the expansion of all constants embedded in the graph of com.oracle.svm.core.amd64.FrameAccess.wordSize()  -H:ImageObjectTreeSuppressRoots=java.util.* - suppress the expansion of all roots that start with java.util.  -H:ImageObjectTreeExpandRoots=java.lang.Character$UnicodeBlock.map - force the expansion of java.lang.Character$UnicodeBlock.map static field root  -H:ImageObjectTreeSuppressRoots=java.util.* -H:ImageObjectTreeExpandRoots=java.util.Locale - suppress the expansion of all roots that start with java.util. but not java.util.Locale  -H:ImageObjectTreeExpandRoots=* - force the expansion of all roots, including those suppressed by defaultReport filesThe reports are generated in the reports subdirectory, relative to the image building directory.When executing the native-image executable the image build directory defaults to the working directory and can be modified using the -H:Path=&amp;lt;dir&amp;gt; option.The call tree report name has the structure call_tree_&amp;lt;image_name&amp;gt;_&amp;lt;date_time&amp;gt;.txt.The object tree report name has the structure: object_tree_&amp;lt;image_name&amp;gt;_&amp;lt;date_time&amp;gt;.txt.The image name is the name of the generated image, which can be set with the -H:Name=&amp;lt;name&amp;gt; option.The &amp;lt;date_time&amp;gt; is in the yyyyMMdd_HHmmss format.",
                    "url": " /reference-manual/native-image/Reports/"
                  },
                  
                  "reference-manual-native-image-resources":  {
                    "title": "",
                    "content": "Accessing Resources in Native ImagesBy default, the native image builder will not integrate any of the resources which are on the classpath during the generation into the final image.To make calls such as Class.getResource() or Class.getResourceAsStream() (or the corresponding ClassLoader methods) return specific resources (instead of null), the resources that should be accessible at image run time need to be explicitly specified. This can be done via a configuration file such as the following:{  &quot;resources&quot;: {    &quot;includes&quot;: [      {&quot;pattern&quot;: &quot;&amp;lt;Java regexp that matches resource(s) to be included in the image&amp;gt;&quot;},      {&quot;pattern&quot;: &quot;&amp;lt;another regexp&amp;gt;&quot;},      ...    ],    &quot;excludes&quot;: [      {&quot;pattern&quot;: &quot;&amp;lt;Java regexp that matches resource(s) to be excluded from the image&amp;gt;&quot;},      {&quot;pattern&quot;: &quot;&amp;lt;another regexp&amp;gt;&quot;},      ...    ]  }}The configuration file’s path must be provided to native-image with -H:ResourceConfigurationFiles=/path/to/resource-config.json. Alternatively, individual resource paths can also be specified directly to native-image:native-image -H:IncludeResources=&amp;lt;Java regexp that matches resources to be included in the image&amp;gt; -H:ExcludeResources=&amp;lt;Java regexp that matches resources to be excluded from the image&amp;gt; ...The -H:IncludeResources and -H:ExcludeResources options can be passed several times to define more than one regexp to match or exclude resources, respectively.To see which resources get ultimately included into the image, you can enable the related logging info with -H:Log=registerResource:.Example UsageGiven this project structure:my-app-root└── src    ├── main    │   └── com.my.app    │       ├── Resource0.txt    │       └── Resource1.txt    └── resources        ├── Resource2.txt        └── Resource3.txtThen:  All resources can be loaded with .*/Resource.*txt$, specified as {&quot;pattern&quot;:&quot;.*/Resource.*txt$&quot;} in a configuration file, or -H:IncludeResources=&#39;.*/Resource.*txt$&#39; on the command line.  Resource0.txt can be loaded with .*/Resource0.txt$.  Resource0.txt and Resource1.txt can be loaded with .*/Resource0.txt$ and .*/Resource1.txt$(or alternatively with a single .*/(Resource0|Resource1).txt$).  Also, if we want to include everything except the Resource2.txt file, we can simply exclude it with -H:IncludeResources=&#39;.*/Resource.*txt$&#39; followed by -H:ExcludeResources=&#39;.*/Resource2.txt$&#39;.See also the guide on assisted configuration of Java resources and other dynamic features.LocalesIt is also possible to specify which locales should be included in the image and what should be the default one. Forexample, to switch the default locale to German and also include French and English, one can use the following hostedoptions.native-image -H:DefaultLocale=de -H:IncludeLocales=fr,enThe locales are specified using language tags. Alllocales can be included via -H:+IncludeAllLocales, but please note that it increases the size of the resultingbinary.Resource Bundles in Native ImageJava localization support (java.util.ResourceBundle) enables Java code to load L10N resources and show the right user messages suitable for actual runtime settings like time locale and format, etc.Native Image needs ahead-of-time knowledge of the resource bundles your application needs so that it can load and store the appropriate bundles for usage in the generated binary. The bundles can be specified in the resource configuration file (see above), in the bundles section:{  &quot;bundles&quot;: [    {&quot;name&quot;:&quot;your.pkg.Bundle&quot;},    {&quot;name&quot;:&quot;another.pkg.Resource&quot;},    {&quot;name&quot;:&quot;etc.Bundle&quot;}  ],  &quot;resources&quot;: &amp;lt;see above&amp;gt;}Alternatively, bundles can be specified directly as options to native-image as follows:native-image -H:IncludeResourceBundles=your.pgk.Bundle,another.pkg.Resource,etc.Bundle ...By default, the requested bundles are included for all requested locales. In order to optimize this, it is possible touse IncludeResourceBundles with locale specific substring, forexample -H:+IncludeResourceBundles=com.company.bundles.MyBundle_fr-FR will include the bundle only in French.JVM Mode of LocalizationResource Bundle lookup is a complex and dynamic mechanism which utilizes a lot of the infrastructure of JVM. As a result of that, it causes image size increasefor smaller applications such as Hello World. Therefore, an optimized mode is set by default in which this lookup is simplified utilizing the fact the allbundles are known ahead of time.In case you would like to use the original JVM lookup, use the -H:-LocalizationOptimizedMode option.",
                    "url": " /reference-manual/native-image/Resources/"
                  },
                  
                  "reference-manual-js-rhinomigrationguide":  {
                    "title": "",
                    "content": "Migration Guide from Rhino to GraalVM JavaScriptThis document serves as a migration guide for code previously targeted to the Rhino engine.See the Java Interoperability guide for an overview of supported features.Both Rhino and GraalVM JavaScript support a similar set of syntax and semantics for Java interoperability.The most important differences relevant for migration are listed here.Java.type(typename) instead of java.a.b.c.typenameGraalVM JavaScript does not put available Java classes in the JavaScript scope.You have to explicitly load the classes using Java.type(typename).GraalVM JavaScript supports the Packages global object, but loading the classes explicitly is still encouraged.The following Java package globals are available in Nashorn compatibility mode (js.nashorn-compat option): java, javafx, javax, com, org, edu.Console Output of Java Classes and Java ObjectsGraalVM JavaScript provides a print builtin function.It tries to special-case its behavior on Java classes and Java objects to provide the most useful output.Note that GraalVM JavaScript also provides a console.log function.This is an alias for print in pure JavaScript mode, but uses an implementation provided by Node.js when in Node mode.The behavior around interop objects differs for console.log in Node mode as it does not implement special treatment for such objects.JavaScript vs Java StringsGraalVM JavaScript uses Java strings internally to represent JavaScript strings.This makes it impossible to differentiate whether a specific string was created by JavaScript or by Java code.In GraalVM JavaScript, the JavaScript properties take precedence over Java fields or methods.For instance, you can query the length property (of JavaScript) but you cannot call the length function (of Java) on JavaScript strings - length behaves like a data property, not like a function.JavaImporterThe JavaImporter feature is available only in Nashorn compatibility mode (js.nashorn-compat option).",
                    "url": " /reference-manual/js/RhinoMigrationGuide/"
                  },
                  
                  "reference-manual-js-runonjdk":  {
                    "title": "",
                    "content": "Run GraalVM JavaScript on a Stock JDKGraalVM JavaScript is optimized for execution as part of GraalVM, or in an embedding scenario built on GraalVM.This guarantees best possible performance by using the GraalVM compiler as the optimizing compiler, and potentially Native Image to ahead-of-time compile the engine into a native binary.As GraalVM JavaScript is a Java application, it is possible to execute it on a stock Java VM like OpenJDK.When executed without the GraalVM compiler, JavaScript performance will be significantly worse.While the JIT compilers available on stock JVMs can execute and JIT-compile the GraalVM JavaScript codebase, they cannot optimize it to its full performance potential.This document describes how to run GraalVM JavaScript on stock Java VMs, and shows how you can use the GraalVM compiler as a JIT compiler to guarantee the best possible performance.GraalVM JavaScript on Maven CentralGraalVM JavaScript is open source and regularly pushed to Maven Central Repository by the community.You can find it as package org.graalvm.js.There is an example Maven project for GraalVM JavaScript on JDK11 (or later) using the GraalVM compiler at graal-js-jdk11-maven-demo.The example contains a Maven project for a JavaScript benchmark (a prime number generator).It allows a user to compare the performance of GraalVM JavaScript running with or without the GraalVM compiler as the optimizing compiler.Running with the GraalVM compiler will siginificantly improve the execution performance of any relatively large JavaScript codebase.In essence, the example POM file activates JVMCI to install additional JIT compilers, and configures the JIT compiler to be the GraalVM compiler by providing it on --module-path and --upgrade-module-path.GraalVM JavaScript without Maven - JAR Files from GraalVMTo work without Maven, the JAR files from a GraalVM release can be used as well.GraalVM is available as Enterprise and Community Editions.Both editions’ files can be used.The relevant files are:  $GRAALVM/jre/languages/js/graaljs.jar - core component of GraalVM JavaScript (always required)  $GRAALVM/jre/languages/js/icu4j.jar - ICU4J component for internationalization (always required)  $GRAALVM/jre/languages/regex/tregex.jar - GraalVM’s regular expression engine (always required)  $GRAALVM/jre/lib/boot/graal-sdk.jar - GraalVM’s SDK to implement languages (always required)  $GRAALVM/jre/lib/truffle/truffle-api.jar - GraalVM’s Language API, to implement language interpreters (always required)  $GRAALVM/jre/lib/graalvm/graaljs-launcher.jar - GraalVM JavaScript’s command line interpreter (optional)  $GRAALVM/jre/lib/graalvm/launcher-common.jar - common launcher code shared by all languages (required by graaljs-launcher.jar)  $GRAALVM/jre/lib/boot/graaljs-scriptengine.jar - GraalVM JavaScript’s ScriptEngine/JSR 223 support (optional)The files are displayed here are for a JDK8 build.In a JDK11+ build, the *.jar files are located in different directories.GraalVM JavaScript on JDK 8The following command line executes GraalVM JavaScript on a JDK 8, starting a JavaScript console.Note that this variant does not include the GraalVM compiler as the optimizing compiler, so the performance of GraalVM JavaScript will be suboptimal.See the JDK 11 example below for how to improve on this.On LinuxGRAALVM=/path/to/GraalVMJDK8=/path/to/jdk8$JDK8/bin/java -cp $GRAALVM/jre/lib/graalvm/launcher-common.jar:$GRAALVM/jre/lib/graalvm/graaljs-launcher.jar:$GRAALVM/jre/languages/js/graaljs.jar:$GRAALVM/jre/lib/truffle/truffle-api.jar:$GRAALVM/jre/lib/boot/graal-sdk.jar:$GRAALVM/jre/lib/boot/graaljs-scriptengine.jar:$GRAALVM/jre/languages/regex/tregex.jar:$GRAALVM/jre/languages/js/icu4j.jar com.oracle.truffle.js.shell.JSLauncherOn MacOS - identical to the Linux command except for the path to GraalVM you need to add Contents/Home:GRAALVM=/path/to/graalvm/Contents/HomeOn Windows - GraalVM JavaScript offers preliminary support for Windows:set GRAALVM=c:pathtograalvm%GRAALVM%binjava -cp %GRAALVM%jrelibgraalvmlauncher-common.jar;%GRAALVM%jrelibgraalvmgraaljs-launcher.jar;%GRAALVM%jrelanguagesjsgraaljs.jar;%GRAALVM%jrelibtruffletruffle-api.jar;%GRAALVM%jrelibbootgraal-sdk.jar;%GRAALVM%jrelibbootgraaljs-scriptengine.jar;%GRAALVM%jrelanguagesregextregex.jar;%GRAALVM%jrelanguagesjsicu4j.jar com.oracle.truffle.js.shell.JSLauncherTo start a Java application instead and launch GraalVM JavaScript via GraalVM SDK’s Context (encouraged) or a ScriptEngine (supported, but discouraged), launcher-common.jar and  graaljs-launcher.jar can be omitted (see example below).ScriptEngine JSR 223GraalVM JavaScript can be started via ScriptEngine when graaljs-scriptengine.jar is included on the classpath.The engine registers under several different names, e.g., Graal.js.Note that the Nashorn engine might be available under its names as well.To start GraalVM JavaScript from ScriptEngine, the following code can be used:new ScriptEngineManager().getEngineByName(&quot;graal.js&quot;);To list all available engines:List&amp;lt;ScriptEngineFactory&amp;gt; engines = (new ScriptEngineManager()).getEngineFactories();for (ScriptEngineFactory f: engines) {    System.out.println(f.getLanguageName()+&quot; &quot;+f.getEngineName()+&quot; &quot;+f.getNames().toString());}Assuming this code is called from MyJavaApp.java and is properly compiled to a class file, it can be executed with:GRAALVM=/path/to/GraalVMJDK8=/path/to/jdk8$JDK8/bin/java -cp $GRAALVM/jre/languages/js/graaljs.jar:$GRAALVM/jre/lib/truffle/truffle-api.jar:$GRAALVM/jre/lib/boot/graal-sdk.jar:$GRAALVM/jre/lib/boot/graaljs-scriptengine.jar:$GRAALVM/jre/languages/regex/tregex.jar:$GRAALVM/jre/languages/js/icu4j.jar:. MyJavaAppGraalVM JavaScript on JDK 11+The Maven example given above is the preferred way to start on JDK 11 (or newer).Working without Maven, you can provide the JAR files manually to the java command.Using --upgrade-module-path executes GraalVM JavaScript with the GraalVM compiler, guaranteeing the best performance.The GraalVM JAR files can be downloaded from org.graalvm at Maven, and the ICU4J library from org.ibm.icu at Maven.JARS=/path/to/JARsJDK=/path/to/JDK$JDK/bin/java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler --module-path=$JARS/graal-sdk-21.0.0.jar:$JARS/truffle-api-21.0.0.jar --upgrade-module-path=$JARS/compiler-21.0.0.jar:$JARS/compiler-management-21.0.0.jar -cp $JARS/launcher-common-21.0.0.jar:$JARS/js-launcher-21.0.0.jar:$JARS/js-21.0.0.jar:$JARS/truffle-api-21.0.0.jar:$JARS/graal-sdk-21.0.0.jar:$JARS/js-scriptengine-21.0.0.jar:$JARS/regex-21.0.0.jar:$JARS/icu4j-67.1.jar com.oracle.truffle.js.shell.JSLauncherInspecting the Setup - Is the GraalVM Compiler Used as a JIT Compiler?The --engine.TraceCompilation flag enables a debug output whenever a JavaScript method is compiled by the GraalVM compiler.JavaScript source code with long-enough run time will trigger the compilation and print a log output:&amp;gt; function add(a,b) { return a+b; }; for (var i=0;i&amp;lt;1000*1000;i++) { add(i,i); }[truffle] opt done         add &amp;lt;opt&amp;gt; &amp;lt;split-c0875dd&amp;gt;                                   |ASTSize       7/    7 |Time    99(  90+9   )ms |DirectCallNodes I    0/D    0 |GraalNodes    22/   71 |CodeSize          274 |CodeAddress 0x7f76e4c1fe10 |Source    &amp;lt;shell&amp;gt;:1:1",
                    "url": " /reference-manual/js/RunOnJDK/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-safepoint":  {
                    "title": "",
                    "content": "Truffle Language Safepoint TutorialAs of 21.1 Truffle has support for guest language safepoints.Truffle safepoints allow to interrupt the guest language execution to perform thread local actions submitted by a language or tool.A safepoint is a location during the guest language execution where the state is consistent and other operations can read its state.This replaces previous instrumentation or assumption-based approaches to safepoints, which required the code to be invalidated for a thread local action to be performed.The new implementation uses fast thread local checks and callee register saved stub calls to optimize for performance and keep the overhead minimal.This means that for every loop back-edge and method exit we perform an additional non-volatile read which can potentially lead to slight slow-downs.Use CasesCommon use-cases of Truffle language safepoints are:  Cancellation, requested exit or interruptions during guest language execution. The stack is unwound by submitting a thread local action.  Reading the current stack trace information for other threads than the currently executing thread.  Enumerating all object references active on the stack.  Running a guest signal handler or guest finalizer on a given thread.  Implement guest languages that expose a safepoint mechanism as part of their development toolkit.  Debuggers evaluating expressions in languages that do not support execution on multiple threads.Language SupportSafepoints are explicitly polled by invoking the TruffleSafepoint.poll(Node) method.A Truffle guest language implementation must ensure that a safepoint is polled repeatedly within a constant time interval.For example, a single arithmetic expression completes within a constant number of CPU cycles.However, a loop that summarizes values over an array uses a non-constant time dependent on the actual array size.This typically means that safepoints are best polled at the end of loops and at the end of function or method calls to cover recursion.In addition, any guest language code that blocks the execution, like guest language locks, need to use the  TruffleSafepoint.setBlocked(Interrupter) API to allow cooperative polling of safepoints while the thread is waiting.Please read more details on what steps language implementations need to take to support thread local actions in the javadoc.Thread Local ActionsLanguages and instruments can submit actions using their environment.Usage example:Env env; // language or instrument environmentenv.submitThreadLocal(null, new ThreadLocalAction(true /*side-effecting*/, true /*synchronous*/) {     @Override     protected void perform(Access access) {         assert access.getThread() == Thread.currentThread();     }});Read more in the javadoc.Current LimitationsThere is currently no way to run thread local actions while the thread is executing in boundary annotated methods unless the method cooperatively polls safepoints or uses the blocking API.Unfortunately it is not always possible to cooperatively poll safepoints, for example, if the code currently executes third party native code.A future improvement will allow to run code for other threads while they are blocked.This is one of the reasons why it is recommended to use ThreadLocalAction.Access.getThread() instead of directly using Thread.currentThread().When the native call returns it needs to wait for any thread local action that is currently executing for this thread.This will enable to collect guest language stack traces from other threads while they are blocked by uncooperative native code.Currently the action will be performed on the next safepoint location when the native code returns.Tooling for DebuggingThere are several debug options available:Excercise safepoints with SafepointALotSafepointALot is a tool to exercise every safepoint of an application and collect statistics.If enabled with the --engine.SafepointALot option it prints the statistics on the cpu time interval between safepoints at the end of an execution.For example, running:graalvm/bin/js --engine.SafepointALot js-benchmarks/harness.js -- octane-deltablue.jsPrints the following output to the log on context close:DeltaBlue: 540[engine] Safepoint Statistics  --------------------------------------------------------------------------------------   Thread Name         Safepoints | Interval     Avg              Min              Max  --------------------------------------------------------------------------------------   main                  48384054 |            0.425 us           0.1 us       44281.1 us  -------------------------------------------------------------------------------------   All threads           48384054 |            0.425 us           0.1 us       42281.1 usIt is recommended for guest language implementations to try to stay below 1ms on average.Note that precise timing can depend on CPU and interruptions by the GC.Since GC times are included in the safepoint interval times, it is expected that the maximum is close to the maximum GC interruption time.Future versions of this tool will be able to exclude GC interruption times from this statistic.Trace thread local actionsThe option --engine.TraceThreadLocalActions allows to trace all thread local actions of any origin.Example output:[engine] [tl] submit                 0  thread[main]                action[SampleAction$8@5672f0d1]     all-threads[alive=4]        side-effecting     asynchronous[engine] [tl]   perform-start        0  thread[pool-1-thread-410]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-start        0  thread[pool-1-thread-413]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-start        0  thread[pool-1-thread-412]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-413]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-410]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-start        0  thread[pool-1-thread-411]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-412]   action[SampleAction$8@5672f0d1][engine] [tl]   perform-done         0  thread[pool-1-thread-411]   action[SampleAction$8@5672f0d1][engine] [tl] done                   0  thread[pool-1-thread-411]   action[SampleAction$8@5672f0d1]Printing guest and host stack frames every time interval.The option --engine.TraceStackTraceInterval=1000 allows to set the time interval in milliseconds to repeatedly print the current stack trace.Note that the stack trace is printed on the next safepoint poll and therefore might not be accurate.graalvm/bin/js --engine.TraceStackTraceInterval=1000 js-benchmarks/harness.js -- octane-deltablue.jsPrints the following output:[engine] Stack Trace Thread main: org.graalvm.polyglot.PolyglotExceptionat &amp;lt;js&amp;gt; BinaryConstraint.chooseMethod(octane-deltablue.js:359-381:9802-10557)at &amp;lt;js&amp;gt; Constraint.satisfy(octane-deltablue.js:176:5253-5275)at &amp;lt;js&amp;gt; Planner.incrementalAdd(octane-deltablue.js:597:16779-16802)at &amp;lt;js&amp;gt; Constraint.addConstraint(octane-deltablue.js:165:4883-4910)at &amp;lt;js&amp;gt; UnaryConstraint(octane-deltablue.js:219:6430-6449)at &amp;lt;js&amp;gt; StayConstraint(octane-deltablue.js:297:8382-8431)at &amp;lt;js&amp;gt; chainTest(octane-deltablue.js:817:23780-23828)at &amp;lt;js&amp;gt; deltaBlue(octane-deltablue.js:883:25703-25716)at &amp;lt;js&amp;gt; MeasureDefault(harness.js:552:20369-20383)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSingleBenchmark(harness.js:614:22538-22550)at &amp;lt;js&amp;gt; RunNextBenchmark(harness.js:340:11560-11614)at &amp;lt;js&amp;gt; RunStep(harness.js:141:5673-5686)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSuites(harness.js:160:6247-6255)at &amp;lt;js&amp;gt; runBenchmarks(harness.js:686-688:24861-25023)at &amp;lt;js&amp;gt; main(harness.js:734:26039-26085)at &amp;lt;js&amp;gt; :program(harness.js:783:27470-27484)at org.graalvm.polyglot.Context.eval(Context.java:348)at com.oracle.truffle.js.shell.JSLauncher.executeScripts(JSLauncher.java:347)at com.oracle.truffle.js.shell.JSLauncher.launch(JSLauncher.java:88)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:124)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:71)at com.oracle.truffle.js.shell.JSLauncher.main(JSLauncher.java:73)[engine] Stack Trace Thread main: org.graalvm.polyglot.PolyglotExceptionat &amp;lt;js&amp;gt; EqualityConstraint.execute(octane-deltablue.js:528-530:14772-14830)at &amp;lt;js&amp;gt; Plan.execute(octane-deltablue.js:781:22638-22648)at &amp;lt;js&amp;gt; chainTest(octane-deltablue.js:824:24064-24077)at &amp;lt;js&amp;gt; deltaBlue(octane-deltablue.js:883:25703-25716)at &amp;lt;js&amp;gt; MeasureDefault(harness.js:552:20369-20383)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSingleBenchmark(harness.js:614:22538-22550)at &amp;lt;js&amp;gt; RunNextBenchmark(harness.js:340:11560-11614)at &amp;lt;js&amp;gt; RunStep(harness.js:141:5673-5686)at &amp;lt;js&amp;gt; BenchmarkSuite.RunSuites(harness.js:160:6247-6255)at &amp;lt;js&amp;gt; runBenchmarks(harness.js:686-688:24861-25023)at &amp;lt;js&amp;gt; main(harness.js:734:26039-26085)at &amp;lt;js&amp;gt; :program(harness.js:783:27470-27484)at org.graalvm.polyglot.Context.eval(Context.java:348)at com.oracle.truffle.js.shell.JSLauncher.executeScripts(JSLauncher.java:347)at com.oracle.truffle.js.shell.JSLauncher.launch(JSLauncher.java:88)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:124)at org.graalvm.launcher.AbstractLanguageLauncher.launch(AbstractLanguageLauncher.java:71)at com.oracle.truffle.js.shell.JSLauncher.main(JSLauncher.java:73)Further ReadingDaloze, Benoit, Chris Seaton, Daniele Bonetta, and Hanspeter Mössenböck.“Techniques and applications for guest-language safepoints.”In Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems, pp. 1-10. 2015.https://dl.acm.org/doi/abs/10.1145/2843915.2843921",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/Safepoint/"
                  },
                  
                  "reference-manual-js-scriptengine":  {
                    "title": "",
                    "content": "ScriptEngine ImplementationGraalVM provides a JSR-223 compliant javax.script.ScriptEngine implementation for running JavaScript.Note that this feature is provided for legacy reasons in order to allow easier migration for implementations currently based on a ScriptEngine.We strongly encourage users to use the org.graalvm.polyglot.Context interface in order to control many of the settings directly and benefit from finer-grained security settings in GraalVM.Setting Options via BindingsThe  ScriptEngine interface does not provide a default way to set options.As a workaround, GraalJSScriptEngine supports setting some Context optionsthrough Bindings.These options are:  polyglot.js.allowHostAccess &amp;lt;boolean&amp;gt;  polyglot.js.allowNativeAccess &amp;lt;boolean&amp;gt;  polyglot.js.allowCreateThread &amp;lt;boolean&amp;gt;  polyglot.js.allowIO &amp;lt;boolean&amp;gt;  polyglot.js.allowHostClassLookup &amp;lt;boolean or Predicate&amp;lt;String&amp;gt;&amp;gt;  polyglot.js.allowHostClassLoading &amp;lt;boolean&amp;gt;  polyglot.js.allowAllAccess &amp;lt;boolean&amp;gt;  polyglot.js.nashorn-compat &amp;lt;boolean&amp;gt;  polyglot.js.ecmascript-version &amp;lt;String&amp;gt;These options control the sandboxing rules applied to evaluated JavaScript code and are set to false by default, unless the application was started in the Nashorn compatibility mode (--js.nashorn-compat=true).Note that using ScriptEngine implies allowing experimental options.This is an exhaustive list of allowed options to be passed via Bindings; in case you need to pass additional options to GraalVM JavaScript, you need to manually create a Context as shown below.To set an option via Bindings, use Bindings.put(&amp;lt;option name&amp;gt;, true) before the engine’s script context is initialized. Note thateven a call to Bindings#get(String) may lead to context initialization.The following code shows how to enable polyglot.js.allowHostAccess via Bindings:ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;JavaScript&quot;);Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);bindings.put(&quot;polyglot.js.allowHostAccess&quot;, true);bindings.put(&quot;polyglot.js.allowHostClassLookup&quot;, (Predicate&amp;lt;String&amp;gt;) s -&amp;gt; true);bindings.put(&quot;javaObj&quot;, new Object());engine.eval(&quot;(javaObj instanceof Java.type(&#39;java.lang.Object&#39;));&quot;); // it will not work without allowHostAccess and allowHostClassLookupThis example will not work if the user calls, e.g., engine.eval(&quot;var x = 1;&quot;), before calling bindings.put(&quot;polyglot.js.allowHostAccess&quot;, true);, sinceany call to eval forces context initialization.Setting Options via System PropertiesOptions to the JavaScript engine can be set via system properties before starting the JVM by prepending polyglot.:java -Dpolyglot.js.ecmascript-version=2021 MyApplicationOr, options to the JavaScript engine can be set programmatically from within Java before creating ScriptEngine. This, however, only works for the options passed to the JavaScript engine (like js.ecmascript), not for the six options mentioned above that can be set via the Bindings.Another caveat is that those system properties are shared by all concurrently executed ScriptEngines.Manually Creating Context for More FlexibilityContext options can also be passed to GraalJSScriptEngine directly, via an instance of Context.Builder:ScriptEngine engine = GraalJSScriptEngine.create(null,        Context.newBuilder(&quot;js&quot;)        .allowHostAccess(HostAccess.ALL)        .allowHostClassLookup(s -&amp;gt; true)        .option(&quot;js.ecmascript-version&quot;, &quot;2021&quot;));engine.put(&quot;javaObj&quot;, new Object());engine.eval(&quot;(javaObj instanceof Java.type(&#39;java.lang.Object&#39;));&quot;);This allows setting all options available in GraalVM JavaScript.It does come at the cost of a hard dependency on GraalVM JavaScript, e.g., the GraalJSScriptEngine and Context classes.Supported File ExtensionsThe GraalVM JavaScript implementation of javax.script.ScriptEngine supports the js file extension for JavaScript source files, as well as the mjs extension for ES modules.",
                    "url": " /reference-manual/js/ScriptEngine/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-specializationhistogram":  {
                    "title": "",
                    "content": "Specialization HistogramThis guide explains how to use the --engine.SpecializationHistogram option.The specialization histogram requires Truffle DSL nodes to be generated in a special way.So if you use the plain specialization histogram option it will just print the following:js --engine.SpecializationHistogram test.js[engine] Specialization histogram:No specialization statistics data was collected. Either no node with @Specialization annotations was executed or the interpreter was not compiled with -Atruffle.dsl.GenerateSpecializationStatistics=true e.g as parameter to the javac tool.Follow the advice of the error and recompile our interpreter.For mx users this is as simple as:mx build -c -A-Atruffle.dsl.GenerateSpecializationStatistics=trueAfter the rebuild, the specialization statistics are ready to be used.Make sure that your IDE does not recompile the sources automatically in the meantime.In this tutorial, a simple test.js script will be used:function test() {  var array = [42, &quot;&quot;, {}, []]  var globalVar = true;  for (element of array) {    globalVar = element;  }}test();Now the specialization statistics need to be enabled, in this example using the JavaScript launcher of GraalVM:js --experimental-options --engine.SpecializationStatistics test.jsAfter the script is executed a histogram for each class will be printed.The histograms will be ordered by the sum of executions of each node, whereas the most frequently used node class will be printed last.These are some of the histograms printed when executing test.js:(Note: The output is likely already outdated.) -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSWriteCurrentFrameSlotNodeGen                                               8 (17%)            18 (12%)        Min=         1 Avg=        2.25 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean &amp;lt;boolean&amp;gt;                                                          1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   doInt &amp;lt;int&amp;gt;                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|   doSafeIntegerInt                                                             0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doLong                                                                       0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject                                                                     7 (88%)            16 (89%)        Min=         1 Avg=        2.29 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;DynamicObjectBasic&amp;gt;                                                         6 (86%)            12 (75%)        Min=         1 Avg=        2.00 Max=          5  MaxNode= test.js~5-7:76-128|     &amp;lt;IteratorRecord&amp;gt;                                                             1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~1-8:16-130|     &amp;lt;String&amp;gt;                                                                     2 (29%)             2 (13%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     &amp;lt;Integer&amp;gt;                                                                    1 (14%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~6:105-123|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doBoolean]                                                                  1 (13%)             1 (6%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~4:52-71|   [doInt, doObject]                                                            1 (13%)             4 (22%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5-7:76-128|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5-7:76-128|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5-7:76-128|   [doObject]                                                                   6 (75%)            13 (72%)        Min=         1 Avg=        2.17 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| Name                                                                         Instances          Executions     Executions per instance -----------------------------------------------------------------------------------------------------------------------------------------------------------------------| JSReadCurrentFrameSlotNodeGen                                                8 (17%)            25 (17%)        Min=         1 Avg=        3.13 Max=          5  MaxNode= test.js~5-7:76-128|   doBoolean                                                                    0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doInt &amp;lt;no-args&amp;gt;                                                              1 (13%)             1 (4%)         Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|   doDouble                                                                     0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   doObject &amp;lt;no-args&amp;gt;                                                           8 (100%)           24 (96%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128|   doSafeInteger                                                                0 (0%)              0 (0%)         Min=         0 Avg=        0.00 Max=          0  MaxNode=  -|   --------------------------------------------------------------------------------------------------------------------------------------------------------------------|   [doInt, doObject]                                                            1 (13%)             4 (16%)        Min=         4 Avg=        4.00 Max=          4  MaxNode= test.js~5:81-87|     doInt                                                                        1 (100%)            1 (25%)        Min=         1 Avg=        1.00 Max=          1  MaxNode= test.js~5:81-87|     doObject                                                                     1 (100%)            3 (75%)        Min=         3 Avg=        3.00 Max=          3  MaxNode= test.js~5:81-87|   [doObject]                                                                   7 (88%)            21 (84%)        Min=         1 Avg=        3.00 Max=          5  MaxNode= test.js~5-7:76-128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------The histogram prints two inner tables for every node class.The first table groups specialization and dynamic type combination.For example, in this histogram the node class JSWriteCurrentFrameSlotNodeGen was instantiated 8 and executed 18 times.This is 20% of the total instances and 11% of all node executions of the run.Three specializations were instantiated in this script, namely doBoolean, doObject, and doInt.The doBoolean specialization was instantiated and executed only once which accounts for 13% of all instances and 6% of all executions of this node class.The doObject specializations was invoked using three different input value combinations: DynamicObjectBasic, IteratorRecord, and String.Similar to specializations, we can see the numbers of times per node they were used and how many times they were executed.For each line you can see minimum, average, and maximum execution numbers per instance.The last column prints the source section of the instance with the maximum executions.The second table groups for each combination of specializations that were used by node class.Here are some questions you would want to ask these specialization statistics:  Is a certain specialization combination used only rarely and can it be removed/consolidated into a single specialization?  Is there a specialization with a very common type combination that could benefit from further specialization?  Which specialization combination is common and could deserve its own specialization? This could indicate common polymorphism in the code that could be investigated.  What are common specializations, and does the order match the number of executions? Specializations that are most commonly used should be ordered first in the node class. This may lead to improvements in interpreter performance.  Are there unexpected specializations instantiated? If yes, investigate further using the printed source section.  Which specializations are instantiated often, and should therefore be optimized for memory footprint?  Were there nodes with the name Uncached in the profile? The use of uncached nodes should be rare. If they were used often, it can be worthwhile to dig deeper to see why.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/SpecializationHistogram/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-specializationtesting":  {
                    "title": "",
                    "content": "Testing Truffle DSL SpecializationsThis document discusses the tools for testing Truffle DSL specializations.Slow Path Specializations in Only Compilation ModeThe following example will be used in this guide:abstract class PowNode extends Node {  public abstract double execute(double a, int exp);  @Specialization(guards = &quot;exp==1&quot;)  double doOne(double a, int exp) {    return a;  }  @Specialization(replaces = &quot;doOne&quot;)  int doGeneric(double a, int exp) {    double res = 1;    for (int i = 0; i &amp;lt; exp; i++)      res *= a;    return res;  }}In order to test that doGeneric produces the correct result for argument exp == 1, you first need to execute this node with a different value.For example, you can use exp == 2 to activate the doGeneric specialization and only then with 1, which will nowbe handled by the doGeneric specialization instead of the doOne specialization.With a real-world code, writing a test that covers specializations that replace other specializations can be much more complicated and it leads to fragile tests.Changes in the production code may cause the test to suddenly cover different specializations.This can easily happen unnoticed.Truffle DSL provides a mode where the “fast-path” specializations (those that are “replaced” by some other specialization, doOne in our example) are ignored.This allows you to simply increase test coverage by running the same tests, which now may cover different code paths.When building a language with mx, pass the additional option:mx build -c -A-Atruffle.dsl.GenerateSlowPathOnly=trueAfter the rebuild, the generated code will call only “slow-path” specializations.Make sure that your IDE does not recompile the sources automatically in the meantime.Note that if you compile your dependencies (e.g., Truffle) from source as part of your build, this option will apply to the code of those dependencies as well.You may choose to apply this option only to some classes by using a filter:mx build -c -A-Atruffle.dsl.GenerateSlowPathOnly=true -A-Atruffle.dsl.GenerateSlowPathOnlyFilter=org.my.truffle.language.package",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/SpecializationTesting/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-splitting":  {
                    "title": "",
                    "content": "Splitting AlgorithmThis guide gives an overview of the algorithm used in the implementation of Truffle call target splitting.The new implementation relies on the language implementations providing information on when a particular node turns polymorphic or increases its “degree” of polymorphism by, for example, adding an entry into an inline cache.This event is called a “polymorphic specialize”.This information is provided to the runtime by calling theNode.reportPolymorphicSpecialize method after the specialization is complete.This guide explains what happens after the call to reportPolymorphicSpecialize.You can find more information on how to correctly report polymorphic specializations in the Reporting Polymorphism guide.ApproachDetecting of suitable splitting candidates relies on the languages reporting polymorphic specializations.Once the specialization is reported, you can assume that the polymorphism is coming from somewhere in the caller chain of the call target hosting the newly polymorphic node, and that by splitting the right call target (or call targets) you can return this node to a monomorphic state.You then identify the call targets for which the splitting could result in monomorphization and mark them as “needs split”. During further execution, if the interpreter is about to execute a direct call to a call target that is marked as “needs split”, that call target will be split (provided there are no outstanding factors preventing it such as the root node not being allowed to be split,the AST being too big, etc.).This results in a new call target with a clean profile (i.e., all its nodes are returned to an uninitialized state) to bere-profiled specifically for this call site, since it is the only call site calling this new call target.Following recursive algorithm (expressed as pseudo code) is a simplified version of the approach used to decide which call targets need to be marked “needs split”.This algorithm is applied to every call target once one of its nodes reports a polymorphic specialization.The full implementation can be found in org.graalvm.compiler.truffle.runtime.OptimizedCallTarget#maybeSetNeedsSplit.setNeedsSplit(callTarget)    if callTarget.needsSplit        return false    if sizeof(knownCallers(callTarget)) == 0        return false    if callCount(callTarget) == 1        return false    if sizeof(knownCallers(callTarget)) &amp;gt; 1        callTarget.needsSplit = true    else        callTarget.needsSplit = setNeedsSplit(caller(callTarget))    return callTarget.needsSplitAt the very beginning of the pseudo code you can have early termination conditions.If the call target is already marked as “needs split”, there is need to continue.Also, if the call targets has no known callers (e.g., it is the “main” of the execution) splitting is not applicable since splitting is inherently tied to duplicating ASTs for a particular call site.Finally, if this is happening during the first execution of call target, splitting is pointless since the polymorphic nature of the node is inevitable (i.e., not coming from the callers, but rather an integral property of that call target).In the second part of the pseudo code two cases are differentiated:1) The call target has multiple known callers - in this case you can assume that the polymorphism is coming from one of these multiple callers. Thus, you mark the call target as “needs split”.2) The call target has only one known caller - in this case you know that marking this call target as “needs split” cannot help remove the polymorphism. But, the polymorphism could be coming into this call target from its sole caller, which could have multiple callers and could be a candidate for splitting. Thus, you recursively apply the algorithm to the caller of our call target.Ignore for now the return value of our algorithm and its usage, and consider the following SimpleLanguage example to illustrate why this distinction between one and multiple callers is needed:function add(arg1, arg2) {    return arg1 + arg2;}function double(arg1) {    return add(arg1, arg1);}function callsDouble() {    double(1);    double(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}In this example, the node representing + in the add function will turn polymorphic once double is called with the string argument &quot;foo&quot; and this will be reported to the runtime and our algorithm will be applied to add.All of the early return checks will fail (add is not marked “needs split”, it has known callers and this is not its first execution).Observe that add has only one caller (double), so you apply the algorithm to double.Early returns all fail, and since double has multiple callers, you mark it as “needs split” and on later iterations calls to double are split resulting in the following code representation of the run time state:function add(arg1, arg2) {    return arg1 + arg2; // + is polymorphic}function double(arg1) {    return add(arg1, arg1);}function doubleSplit1(arg1) {    return add(arg1, arg1);}function doubleSplit2(arg1) {    return add(arg1, arg1);}function callsDouble() {    doubleSplit1(1);    doubleSplit2(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}As you can see, the source of the polymorphism was split, but that did not solve the issue, since both slits still call the same add function and the polymorphism remains.This is where the algorithms return value comes in to play.If the algorithm was successful in finding a target to mark than all the transitive callee’s of that target need to be marked “needs split” as well.With this final step in place, the final run time result of our splitting approach for the previous example can be represent as the following source code:function add(arg1, arg2) {    return arg1 + arg2; // + is polymorphic}function addSplit1(arg1, arg2) {    return arg1 + arg2;}function addSplit2(arg1, arg2) {    return arg1 + arg2;}function double(arg1) {    return add(arg1, arg1);}function doubleSplit1(arg1) {    return addSplit1(arg1, arg1);}function doubleSplit2(arg1) {    return addSplit2(arg1, arg1);}function callsDouble() {    doubleSplit1(1);    doubleSplit2(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}Final note to observe at this point is that the splitting does not remove the original call targets, and that they still have polymorphism in their profiles.Thus, even if new calls to these call targets are created, they will also be split.Consider if the main of the previous example looked as follows.function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }    add(1,2); // this line was added}Once the execution reaches the newly added line you do not want it to call the add function with the polymorphic + since the arguments here do not merit the polymorphism.Luckily, since add was already marked as “needs split”, it will remain so during the entire execution, and this final call to add with cause another split of the add functions.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/Splitting/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-splitting-splitting":  {
                    "title": "",
                    "content": "Splitting AlgorithmThis guide gives an overview of the algorithm used in the implementation of Truffle call target splitting.The new implementation relies on the language implementations providing information on when a particular node turns polymorphic or increases its “degree” of polymorphism by, for example, adding an entry into an inline cache.This event is called a “polymorphic specialize”.This information is provided to the runtime by calling theNode.reportPolymorphicSpecialize method after the specialization is complete.This guide explains what happens after the call to reportPolymorphicSpecialize.You can find more information on how to correctly report polymorphic specializations in the Reporting Polymorphism guide.ApproachDetecting of suitable splitting candidates relies on the languages reporting polymorphic specializations.Once the specialization is reported, you can assume that the polymorphism is coming from somewhere in the caller chain of the call target hosting the newly polymorphic node, and that by splitting the right call target (or call targets) you can return this node to a monomorphic state.You then identify the call targets for which the splitting could result in monomorphization and mark them as “needs split”. During further execution, if the interpreter is about to execute a direct call to a call target that is marked as “needs split”, that call target will be split (provided there are no outstanding factors preventing it such as the root node not being allowed to be split,the AST being too big, etc.).This results in a new call target with a clean profile (i.e., all its nodes are returned to an uninitialized state) to bere-profiled specifically for this call site, since it is the only call site calling this new call target.Following recursive algorithm (expressed as pseudo code) is a simplified version of the approach used to decide which call targets need to be marked “needs split”.This algorithm is applied to every call target once one of its nodes reports a polymorphic specialization.The full implementation can be found in org.graalvm.compiler.truffle.runtime.OptimizedCallTarget#maybeSetNeedsSplit.setNeedsSplit(callTarget)    if callTarget.needsSplit        return false    if sizeof(knownCallers(callTarget)) == 0        return false    if callCount(callTarget) == 1        return false    if sizeof(knownCallers(callTarget)) &amp;gt; 1        callTarget.needsSplit = true    else        callTarget.needsSplit = setNeedsSplit(caller(callTarget))    return callTarget.needsSplitAt the very beginning of the pseudo code you can have early termination conditions.If the call target is already marked as “needs split”, there is need to continue.Also, if the call targets has no known callers (e.g., it is the “main” of the execution) splitting is not applicable since splitting is inherently tied to duplicating ASTs for a particular call site.Finally, if this is happening during the first execution of call target, splitting is pointless since the polymorphic nature of the node is inevitable (i.e., not coming from the callers, but rather an integral property of that call target).In the second part of the pseudo code two cases are differentiated:1) The call target has multiple known callers - in this case you can assume that the polymorphism is coming from one of these multiple callers. Thus, you mark the call target as “needs split”.2) The call target has only one known caller - in this case you know that marking this call target as “needs split” cannot help remove the polymorphism. But, the polymorphism could be coming into this call target from its sole caller, which could have multiple callers and could be a candidate for splitting. Thus, you recursively apply the algorithm to the caller of our call target.Ignore for now the return value of our algorithm and its usage, and consider the following SimpleLanguage example to illustrate why this distinction between one and multiple callers is needed:function add(arg1, arg2) {    return arg1 + arg2;}function double(arg1) {    return add(arg1, arg1);}function callsDouble() {    double(1);    double(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}In this example, the node representing + in the add function will turn polymorphic once double is called with the string argument &quot;foo&quot; and this will be reported to the runtime and our algorithm will be applied to add.All of the early return checks will fail (add is not marked “needs split”, it has known callers and this is not its first execution).Observe that add has only one caller (double), so you apply the algorithm to double.Early returns all fail, and since double has multiple callers, you mark it as “needs split” and on later iterations calls to double are split resulting in the following code representation of the run time state:function add(arg1, arg2) {    return arg1 + arg2; // + is polymorphic}function double(arg1) {    return add(arg1, arg1);}function doubleSplit1(arg1) {    return add(arg1, arg1);}function doubleSplit2(arg1) {    return add(arg1, arg1);}function callsDouble() {    doubleSplit1(1);    doubleSplit2(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}As you can see, the source of the polymorphism was split, but that did not solve the issue, since both slits still call the same add function and the polymorphism remains.This is where the algorithms return value comes in to play.If the algorithm was successful in finding a target to mark than all the transitive callee’s of that target need to be marked “needs split” as well.With this final step in place, the final run time result of our splitting approach for the previous example can be represent as the following source code:function add(arg1, arg2) {    return arg1 + arg2; // + is polymorphic}function addSplit1(arg1, arg2) {    return arg1 + arg2;}function addSplit2(arg1, arg2) {    return arg1 + arg2;}function double(arg1) {    return add(arg1, arg1);}function doubleSplit1(arg1) {    return addSplit1(arg1, arg1);}function doubleSplit2(arg1) {    return addSplit2(arg1, arg1);}function callsDouble() {    doubleSplit1(1);    doubleSplit2(&quot;foo&quot;);}function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }}Final note to observe at this point is that the splitting does not remove the original call targets, and that they still have polymorphism in their profiles.Thus, even if new calls to these call targets are created, they will also be split.Consider if the main of the previous example looked as follows.function main() {    i = 0;    while (i &amp;lt; 1000) {        callsDouble();    }    add(1,2); // this line was added}Once the execution reaches the newly added line you do not want it to call the add function with the polymorphic + since the arguments here do not merit the polymorphism.Luckily, since add was already marked as “needs split”, it will remain so during the entire execution, and this final call to add with cause another split of the add functions.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/splitting/Splitting/"
                  },
                  
                  "reference-manual-native-image-staticimages":  {
                    "title": "",
                    "content": "Static Native ImagesStatic native images are statically linked binaries which can be used without any additional library dependencies.This makes them suitable for use in a Docker container.Prerequisites  Right now, this only works on Linux AMD64 on Java 11.  You will need gcc, make, and configure.  Create a directory that will hold the libraries you build. You will refer to this directory as ${RESULT_DIR}.  Download the latest musl release here. This document will use musl-1.2.0.  Download the latest zlib release here. This document will use zlib-1.2.11.## Build a Static Native ImageIf you have musl-gcc on the path, you can build a native image statically linked against muslc with the following options: --static --libc=musl.To verify that musl-gcc is on the path, run musl-gcc -v.To build a static native image, use:native-image --static --libc=musl [other arguments] ClassBuild a Mostly Static Native ImageAs of GraalVM version 20.2, you can build a “mostly static” native image which link statically everything except libc. Native images built this way are convenient to run in Docker containers, for example, based ondistroless minimal Linux, glibc-based systems.To build a mostly-static native image native image, use:native-image -H:+StaticExecutableWithDynamicLibC [other arguments] ClassBuilding musl  Extract the musl release tarball and cd into the extracted directory.  Run ./configure --disable-shared --prefix=${RESULT_DIR}.  Run make.  Run make install.Other than building musl libraries, the build also creates a gcc wrapper called musl-gcc in the ${RESULT_DIR}/bin directory.You should now put this wrapper on your PATH by running export PATH=$PATH:${RESULT_DIR}/bin.Building zlib  Extract the zlib release tarball and cd into the extracted directory.  You need to compile zlib and link it against musl so set CC to musl-gcc: export CC=musl-gcc.  Run ./configure --static --prefix=${RESULT_DIR}.  Run make.  Run make install.Getting libstdc++libstdc++ is obtained by building gcc. There are multiple approaches to obtaining it:  Build gcc with musl-gcc.  Use libstdc++.a from your distribution. If you choose this path, check the FAQs page, “How do I use the musl-gcc wrapper?”:          The existing libstdc++ is actually compatible with musl in most cases and could be used by copying it into the musl library path, but the C++ header files are usually not compatible.Since you do not need C++ header files, this approach should work. If you run into issues, make sure they are not caused by your ditribution’s libstdc++.a.        Take libstdc++.a from Alpine.In each case, libstdc++.a must be placed in ${RESULT_DIR}/lib.",
                    "url": " /reference-manual/native-image/StaticImages/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-tck":  {
                    "title": "",
                    "content": "Polyglot API-based Test Compatibility KitThe Test Compatibility Kit (TCK) is a collection of tests verifying the TruffleLanguage inter-operability and instrumentation.The TCK is based on the org.graalvm.polyglot API.Adding a LanguageTo test your language, implement the LanguageProvider.The LanguageProviders are loaded using the java.util.ServiceLoader, so you need to register your implementation in the META-INF/services/org.graalvm.polyglot.tck.LanguageProvider file.The LanguageProvider should provide the language data types, language expressions (operators), and language control flow statements represented as functions returning the data type or executing the operator (statement).To allow composition of the returned functions, the parameter and return types have to be assigned to them usingthe Snippet.Builder.The LanguageProvider should also provide simple but representative scripts which the TCK can use to test instrumentation.Running TCK Tests with mxThe tests are executed using mx unitest. When running the tests, all LanguageProviders in the primary suite and dependent suites are used. The truffle suite provides the java-host LanguageProvider, creating Java data types and Proxies to test Java inter-operability.To run just the TCK tests use:mx unittest com.oracle.truffle.tck.testsOr, simply use:mx tckTo restrict the TCK tests to test a certain language, use the tck.language property.The following example tests JavaScript with data types from all available languages:mx tck -Dtck.language=jsTo restrict the data types to a certain language, use the tck.values property.The following example tests JavaScript with Java types:mx tck -Dtck.values=java-host -Dtck.language=jsTo run a single test, specify the full test name.For example, to run a test for SimpleLanguage + operator with SimpleLanguage number and big number use:mx tck &#39;ExpressionTest#testExpression[sl::+(sl::number, sl::number)]&#39;To run the TCK tests on GraalVM it is enough to set the mx --java-home to point to GraalVM:mx --java-home=&amp;lt;path_to_graalvm&amp;gt; tckTo disable output and error output use the tck.verbose property:mx tck -Dtck.verbose=falseTo disable output and error output only for a certain test, use the tck.{TestSimpleName}.verbose property:mx tck -Dtck.ErrorTypeTest.verbose=falseYou can also disable output and error output for all tests but one:mx tck -Dtck.verbose=false -Dtck.ErrorTypeTest.verbose=trueRunning TCK Tests without mxThe Python TCK runner can be used to execute the Truffle TCK on top of GraalVM. The script requires Maven for downloading the TCK artifacts.To execute TCK tests on GraalVM use:python tck.py -g &amp;lt;path_to_graalvm&amp;gt;To include your own language and TCK provider use:python tck.py -g &amp;lt;path_to_graalvm&amp;gt; -cp &amp;lt;path_to_tck_provider_jars&amp;gt; -lp &amp;lt;path_to_language_jars&amp;gt;To restrict tests to a certain language, use the language ID as a first unnamed option.The following example executes tests only for the JavaScript language:python tck.py -g &amp;lt;path_to_graalvm&amp;gt; jsTo execute the tests under debugger use the -d or --dbg &amp;lt;port&amp;gt; option:python tck.py -d -g &amp;lt;path_to_graalvm&amp;gt;The TCK tests can be filtered by test names. To execute just the ScriptTest for the JavaScript TCK provider use:python tck.py -g &amp;lt;path_to_graalvm&amp;gt; js default ScriptTestThe TCK tests can be executed in compile mode in which all calltargets are compiled before they are executed.To execute JavaScript tests in compile mode use:python tck.py -g &amp;lt;path_to_graalvm&amp;gt; js compile",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/TCK/"
                  },
                  
                  "reference-manual-python-tooling":  {
                    "title": "",
                    "content": "Tooling Support for PythonGraalVM’s Python runtime is incomplete and cannot launch the standard Python debugger pdb.However, it can run the tools that GraalVM provides.The graalpython --help:tools command will give you more information about tools currently supported on Python.DebuggerTo enable debugging, pass the --inspect option to the graalpython launcher.For example:graalpython --inspect -c &quot;breakpoint(); import os; os.exit()&quot;Debugger listening on port 9229.To start debugging, open the following URL in Chrome:    chrome-devtools://devtools/bundled/js_app.html?ws=127.0.1.1:9229/76fcb6dd-35267eb09c3The standard Python built-in breakpoint() will work using the GraalVM’s Chrome Inspector implementation.You can inspect variables, set watch expressions, interactively evaluate code snippets, etc.However, this only works if you pass --inspect or some other inspect option. Otherwise, pdb is triggered as on CPython (and does not currently work).Code CoverageGraalVM comes with a coverage instrument that can be used with --coverage.Use the graalpython --help:tools command to see details on how to use it.In order to work better with existing Python code, the standard library trace module is partially supported with this low-overhead GraalVM coverage instrument.So you can do this:graalpython -m trace -m -c -s my_script.pyThis will work similarly to how it would run on CPython.The programmatic API also works, with some limitations.For example, it does not currently track calls, only line counts and called functions.ProfilingThe _lsprof built-in module has been implemented using the GraalVM cpusampler tool.Not all profiling features are currently supported, but basic profiling works:graalpython -m cProfile -s sort -m ginstall --helpThe interactive exploration of a stats output file also works:graalpython -m cProfile -o ginstall.profile -m ginstall --helpgraalpython -m pstats ginstall.profileginstall.profile%callers[...]",
                    "url": " /reference-manual/python/Tooling/"
                  },
                  
                  "graalvm-as-a-platform-language-implementation-framework-trufflelibraries":  {
                    "title": "",
                    "content": "Truffle Library GuideTruffle Libraries allow language implementations to use polymorphic dispatch for receiver types with support for implementation-specific caching/profiling and automatic support for uncached dispatch.Truffle Libraries enable modularity and encapsulation for representation types language implementations on top of Truffle.Read this guide first before using them.Getting StartedThis tutorial provides a trace through a use-case on how to use Truffle Libraries.The full API documentation can be found in the Javadoc.This document assumes prior knowledge of Truffle APIs and the use of @Specialization with the @Cached annotation.Motivating ExampleWhen implementing arrays in Truffle Languages it is often necessary to use multiple representations for efficiency.For example, if the array is constructed from an arithmetic sequence of integers (e.g., range(from: 1, step: 2, length: 3)), then it is best represented using the start, stride, and length instead of materializing the full array.Of course, when an array element is written, then the array needs to be materialized.In this example we are going to implement an array implementation with two representations:  Buffer: represents a materialized array representation backed by a Java array.  Sequence: represents an arithmetic sequence of numbers represented by start, stride and length: [start, start + 1 * stride, ..., start + (length - 1) * stride].To keep the example simple we will only support int values and we will ignore index bounds error handling.We will also just implement the read operation and not the typically more complicated write operation.To make the example more interesting, we will implement an optimization that will let the compiler allow constant fold sequenced array accesses even if the array receiver value is not constant.Assume we have the following code snippet range(start, stride, length)[2].In this snippet, the variables start and stride are not known to be constant values, therefore, equivalent code to start + stride * 2 gets compiled.However, if the start and stride values are known to always be the same then the compiler could constant-fold the entire operation.This optimization requires the use of caching.We will later show how this works.In the dynamic array implementation of GraalVM’s JavaScript runtime, we use 20 different representations.There are representations for constant, zero-based, contiguous, holes, and sparse arrays.Some representations are further specialized for the types byte, int, double, JSObject, and Object.The source code can be found here. Note: Currently, JavaScript arrays do not use Truffle Libraries yet.In the following sections, we discuss multiple implementation strategies for the array representations, ultimately describing how Truffle Libraries can be used to achieve this.Strategy 1: Specialization per RepresentationFor this strategy, we will start by declaring classes for the two representations BufferArray and SequenceArray.final class BufferArray {    int length;    int[] buffer;    /*...*/}final class SequenceArray {    final int start;    final int stride;    final int length;    /*...*/}The BufferArray implementation has a mutable buffer and length and is used as the materialized array representation.The sequence array is represented by the final fields start, stride, and length.Now, we specify the basic read operations like this:abstract class ExpressionNode extends Node {    abstract Object execute(VirtualFrame frame);}@NodeChild @NodeChildabstract class ArrayReadNode extends ExpressionNode {    @Specialization    int doBuffer(BufferArray array, int index) {        return array.buffer[index];    }    @Specialization    int doSequence(SequenceArray seq, int index) {        return seq.start + seq.stride * index;    }}The array read node specifies two specializations for the buffer version and the sequence.As mentioned before we are going to ignore error bounds checks for simplicity.Now we try to make the array read specialize on the constant-ness of values of the sequence in order to allow the range(start, stride, length)[2] example to fold if start and stride are constant.To find out whether start and stride are constants we need to profile their value.To profile these values we need to add another specialization to the array read operation like this:@NodeChild @NodeChildclass ArrayReadNode extends ExpressionNode {    /* doBuffer() */    @Specialization(guards = {&quot;seq.stride == cachedStride&quot;,                              &quot;seq.start  == cachedStart&quot;}, limit = &quot;1&quot;)    int doSequenceCached(SequenceArray seq, int index,             @Cached(&quot;seq.start&quot;)  int cachedStart,             @Cached(&quot;seq.stride&quot;) int cachedStride) {        return cachedStart + cachedStride * index;    }    /* doSequence() */}If the speculation guards of this specialization succeed then the start and stride are effectively constant.For example, with the values 3 and 2, the compiler would see 3 + 2 * 2 which is 7.The limit is set to 1 to only try this speculation once.It would likely be inefficient to increase the limit as this would introduce additional control flow to the compiled code.If the speculation does not succeed, i.e., if the operation observes multiple start and stride values, we want to fall back to the normal sequence specialization.To achieve this we change the doSequence specialization by adding replaces = &quot;doSequenceCached&quot; like this:@NodeChild @NodeChildclass ArrayReadNode extends ExpressionNode {    /* doSequenceCached() */    @Specialization(replaces = &quot;doSequenceCached&quot;)    int doSequence(SequenceArray seq, int index) {        return seq.start + seq.stride * index;    }}Now we have achieved the goal of implementing our array representations including additional profiling.The runnable source code for Strategy 1 can be found here.This strategy has some nice properties:  The operation is easy to read and all cases are fully enumerated.  The generated code of the read node only requires a single bit per specialization to remember which representation type was observed at runtime.We would already be done with this tutorial if there would not be some problems with this:  New representations cannot be loaded dynamically; they need to be statically known, making the separation of representation types from operations impossible.  Changing or adding representation types often requires the modification of many operations.  Representation classes need to expose most implementation details to operations (no encapsulation).These problems are the primary motivations for Truffle Libraries.Strategy 2: Java InterfacesNow we will try to address these problems by using Java interfaces.We start by defining an array interface:interface Array {    int read(int index);}The implementations can now implement the Array interface and implement the read method in the representation class.final class BufferArray implements Array {    private int length;    private int[] buffer;    /*...*/    @Override public int read(int index) {        return buffer[index];    }}final class SequenceArray implements Array {    private final int start;    private final int stride;    private final int length;    /*...*/    @Override public int read(int index) {        return start + (stride * index);    }}Finally, we specify the operation node:@NodeChild @NodeChildabstract class ArrayReadNode extends ExpressionNode {    @Specialization   int doDefault(Array array, int index) {        return array.read(index);    }}The problem with this operation implementation is that the partial evaluator does not know which concrete type the array receiver has.Therefore, it needs to stop partial evaluation and emit a slow interface call for the read method call.This is not what we want, but we can introduce a polymorphic type cache to resolve it like this:class ArrayReadNode extends ExpressionNode {    @Specialization(guards = &quot;array.getClass() == arrayClass&quot;, limit = &quot;2&quot;)    int doCached(Array array, int index,           @Cached(&quot;array.getClass()&quot;) Class&amp;lt;? extends Array&amp;gt; arrayClass) {        return arrayClass.cast(array).read(index);    }    @Specialization(replaces = &quot;doCached&quot;)    int doDefault(Array array, int index) {        return array.read(index);    }}We solved the problem of partially evaluating the implementation, but there is no way to express the extra specialization for the constant stride and start index optimization in this solution.This is what we discovered/ solved so far:  Interfaces are existing well-known concept for polymorphism in Java.  New interface implementations can be loaded enabling modularity.  We found a convenient way to use the operations from slow-paths.  Representation types can encapsulate implementation details.But we have introduced new problems:  No representation specific profiling / caching can be performed.  Every interface call requires a polymorphic class cache on the call-site.The runnable source code for Strategy 2 can be found here.Strategy 3: Truffle LibrariesTruffle Libraries work similar to the Java interfaces.Instead of a Java interface, we create an abstract class extending the Library class and annotate it with @GenerateLibrary. We create abstract methods like with the interface, but we insert a receiver argument in the beginning, in our case of type Object.Instead of performing interface type checks we use an explicit abstract method in the library typically named is${Type}.We do this for our example:@GenerateLibrarypublic abstract class ArrayLibrary extends Library {    public boolean isArray(Object receiver) {        return false;    }    public abstract int read(Object receiver, int index);}This ArrayLibrary specifies two messages: isArray and read.At compile time, the annotation processor generates a package protected class ArrayLibraryGen.Unlike generated nodes classes, you never need to refer to this class.Instead of implementing a Java interface, we export the library using the @ExportLibrary annotation on the representation type.Message exports are specified using instance methods on the representation and can, therefore, omit the receiver argument of the library.The first representation we implement this way is the BufferArray representation:@ExportLibrary(ArrayLibrary.class)final class BufferArray {    private int length;    private int[] buffer;    /*...*/    @ExportMessage boolean isArray() {      return true;    }    @ExportMessage int read(int index) {      return buffer[index];    }}This implementation is very similar to the interface version, but in addition, we specify the isArray message.Again, the annotation processor generates the boilerplate code that implements the library abstract class.Next, we implement the sequence representation.We start by implementing it without the optimization for the start and stride value.@ExportLibrary(ArrayLibrary.class)final class SequenceArray {    private final int start;    private final int stride;    private final int length;    /*...*/    @ExportMessage int read(int index) {        return start + stride * index;    }}So far this was equivalent to the interface implementation, but with Truffle Libraries we can now also use specializations in our representations by exporting a message using a class instead of a method.The convention is that the class is named exactly like the exported message, but with the first letter upper-case.Now we implement our stride and start specialization using this mechanism:@ExportLibrary(ArrayLibrary.class)final class SequenceArray {    final int start;    final int stride;    final int length;    /*...*/    @ExportMessage static class Read {        @Specialization(guards = {&quot;seq.stride == cachedStride&quot;,                                  &quot;seq.start  == cachedStart&quot;}, limit = &quot;1&quot;)        static int doSequenceCached(SequenceArray seq, int index,                 @Cached(&quot;seq.start&quot;)  int cachedStart,                 @Cached(&quot;seq.stride&quot;) int cachedStride) {            return cachedStart + cachedStride * index;        }        @Specialization(replaces = &quot;doSequenceCached&quot;)        static int doSequence(SequenceArray seq, int index) {            return doSequenceCached(seq, index, seq.start, seq.stride);        }    }}Since the message is declared using an inner class we need to specify the receiver type.Compared to normal nodes, this class must not extend Node and its methods must be static to allow the annotation processor to generate efficient code for the library subclass.Last, we need to use the array library in our read operation.The Library API provides an annotation called @CachedLibrary that is responsible for dispatching to libraries.The array read operation now looks like this:@NodeChild @NodeChildclass ArrayReadNode extends ExpressionNode {    @Specialization(guards = &quot;arrays.isArray(array)&quot;, limit = &quot;2&quot;)    int doDefault(Object array, int index,                  @CachedLibrary(&quot;array&quot;) ArrayLibrary arrays) {        return arrays.read(array, index);    }}Similar to the type cache we have seen in Strategy 2 we specialize the library to a particular value.The first attribute of @CachedLibrary, &quot;array&quot; specifies the value the library is specialized for.A specialized library can only be used for values they were specialized for.If they are used with other values then the framework will fail with an assertion error.Instead of using the Array type as the parameter type, we use the isArray message in the guard.Using a specialized library requires us to specify the limit on the specialization.The limit specifies how many specializations of a library can be instantiated until the operation should rewrite itself to use an uncached version of the library.In the array example we have only implemented two array representations.Therefore it is impossible that the limit is exceeded.In real array implementations, we are likely to use many more representations.The limit should be set to a value that is unlikely to be exceeded in representative applications, but at the same time does not produce too much code.The uncached or slow-path version of a library can be reached by exceeding the limit of the specialization, but it can also be used manually, e.g., if the array operation needs to be invoked when no node is available.This is usually the case for parts of the language implementation that are invoked infrequently.With the interface strategy (Strategy 2), the array read operation could be used by just invoking the interface method.With Truffle libraries, we need to lookup an uncached version of the library first.Every use of @ExportLibrary generates a cached but also an uncached / slow-path library subclass.The uncached version of the exported library uses the same semantics as @GenerateUncached.Typically, as with our example, the uncached version can be derived automatically.The DSL shows an error if it needs further details on how to generate the uncached version.The uncached version of the library can be invoked like this:ArrayLibrary arrays = LibraryFactory.resolve(ArrayLibrary.class).getUncached();arrays.read(array, index);In order to decrease the verbosity of this example, it is recommended that the library class provides the following optional static utilities:@GenerateLibrarypublic abstract class ArrayLibrary extends Library {    /*...*/    public static LibraryFactory&amp;lt;ArrayLibrary&amp;gt; getFactory() {        return FACTORY;    }    public static ArrayLibrary getUncached() {        return FACTORY.getUncached();    }    private static final LibraryFactory&amp;lt;ArrayLibrary&amp;gt; FACTORY =               LibraryFactory.resolve(ArrayLibrary.class);}The verbose example from above can now be simplified as:ArrayLibrary.getUncached().readArray(array, index);The runnable source code for Strategy 3 can be found here.ConclusionIn this tutorial, we have learned that with Truffle Libraries we no longer need to compromise the modularity of representation types by creating a specialization per representation (Strategy 1) and the profiling is no longer blocked by interface calls (Strategy 2).With Truffle Libraries we now support polymorphic dispatch with type encapsulation but don’t lose the capability of using profiling/caching techniques in representation types.What to do next?      Run and debug all the examples here.        Read the interoperability migration guide, as an example of Truffle Libraries usage here.        Read the Truffle Library reference documentation here.  FAQAre there any known limitations?  Library exports currently cannot explicitly invoke their super implementation. This makes reflective implementations currently infeasible. See the example here.  Boxing elimination for return values is currently not supported. A message can only have one generic return type. Support for this is planned.  Reflection without static dependencies on the Library class is currently not supported. Support for full dynamic reflection is planned.When should I use Truffle Libraries?When to use?  If the representations are modular and cannot be enumerated for an operation (e.g., Truffle Interoperability).  If there is more than one representation of a type and one of the representations needs profiling/caching (e.g., see the motivating example).  If there is a need for a way to proxy all values of a language (e.g., for dynamic taint tracking).When not to use?  For basic types that only have one representation.  For primitive representations that require boxing elimination to speed up the interpreter. Boxing elimination is not supported with Truffle Libraries at the moment.I decided to use a Truffle Library to abstract the language specific types of my language. Should those be exposed to other languages and tools?All libraries are accessible to other languages and tools via the ReflectionLibrary.It is recommended that the language implementation documentation specifies which libraries and messages are intended for external use, and which ones may be subject to breaking changes.What happens when a new method is added to a library but a dynamically loaded implementation hasn’t been updated for it?If the library method was specified abstract then an AbstractMethodError will be thrown.Otherwise the default implementation specified by the library method body will be called.This allows to customize the error in case an abstract method is used.For example, for Truffle interoperability we often throw an UnsupportedMessageException instead of an AbstractMethodError.",
                    "url": " /graalvm-as-a-platform/language-implementation-framework/TruffleLibraries/"
                  },
                  
                  "reference-manual-native-image-urlprotocols":  {
                    "title": "",
                    "content": "URL Protocols in Native ImageURL Protocols in Native Image can be divided into three classes:  supported and enabled by default  supported and disabled by default  HTTPS supportSupported and Enabled by DefaultThese are protocols that are enabled by default and added to every generated native image.Currently, file and resource are the only supported URL protocols, enabled by default.Supported and Disabled by DefaultThese are protocols that are supported but not enabled by default when building a native image.They must be enabled during the native image building by adding --enable-url-protocols=&amp;lt;protocols&amp;gt; to the native-image command.The option accepts a list of comma-separated protocols.The rationale behind enabling protocols on-demand is that you can start with a minimal image and add features as you need them.This way your image will only include the features you use, which helps keep the overall size small.Currently http and https are the only URL protocols that are supported and can be enabled on demand.They can be enabled using the --enable-http and --enable-https options.HTTPS SupportSupport for the https URL protocol relies on the Java Cryptography Architecture (JCA) framework.Thus enabling https will add to the generated image the code required by the JCA, including statically linking native libraries that the JCA may depend on.See the documentation on security services for more details.Not TestedNo other URL protocols are currently tested.They can still be enabled using --enable-url-protocols=&amp;lt;protocols&amp;gt;, however they might not work as expected.",
                    "url": " /reference-manual/native-image/URLProtocols/"
                  },
                  
                  "advanced-tools":  {
                    "title": "",
                    "content": "",
                    "url": " /advanced-tools/"
                  },
                  
                  "java-advantages":  {
                    "title": "",
                    "content": "←BackAccelerating Java performanceGraalVM’s high-performance JIT compiler generates optimized native machine code that runs faster, produces less garbage, and uses less CPU thanks to a battery of advanced compiler optimizations and aggressive and sophisticated inlining techniques.The end results are applications that run faster and consume fewer resources—reducing cloud and infrastructure costs.Figure 1. Speedup vs OpenJDK 11The size of the speedup depends on the type of workload.On the Renaissance benchmark suite, which “contains a range of modern workloads, comprising of various popular systems, frameworks and applications made for the JVM”, GraalVM Enterprise achieves a geomean speedup of 1.55x over OpenJDK 8 and similar results for OpenJDK 11.Oracle Cloud InfrastructureBy running the Oracle Cloud Infrastructure (OCI) Monitoring (telemetry) service on GraalVM Enterprise, a 10% transaction processing rate increase was achieved along with a 25% reduction in garbage collection times, a 17% reduction in GC pause times, and a 5% reduction CPU utilization.These improvements have significant benefits for a memory intensive service that routinely processes tens of millions of data points, ingests billions of metrics, and serves millions of requests coming from an ever growing collection of OCI service offerings.Figure 2. OCI Monitoring Service Throughput (transaction per second)Quick startLower infrastructure costsHigher application performance and lower CPU and memory usage are goals every developer strives for.These goals are definitely laudable, and achieving them is easier with GraalVM, but the real value of these improvements is a reduction in the cost to run an application in production.Faster applications with lower resource requirements translate into fewer servers required to deliver a given service, and fewer servers means lower monthly cloud bills and lower capital and operating costs for on premises deployments.The math is straightforward.Even with no reduction in resource requirements, with just a ~11% improvement in throughput, 9 servers can do what required 10 before.That is one less cloud server to pay for or one less datacenter server to buy and maintain.Oracle GraalVM Enterprise Edition was the performance choice for our Dell EMC Servers. Java workload analysis and SPECjbb®2015 benchmark improving max-jOPS results by almost 8%.— Kurtis Bowman, Director of Architecture, Server Office of the CTO, Dell EMCSomething to Tweet AboutTwitter is one of the most popular social media services in the world running a platform used by millions of users around the globe daily.To keep costs down and performance up, Twitter relies on GraalVM to run core services like Tweet, Social, and News. With the efficiency of the GraalVM JIT compiler, Twitter is able to meet their throughput targets with fewer servers, resulting in significant savings.Being able to see 8–11 percent performance improvements on the same hardware without having to change the underlying code is a once-in-a-lifetime event, leading to substantial cost savings and future flexibility for Twitter.— Chris Thalinger, Staff Software Engineer, TwitterQuick startBetter performance with no code changesWhile the OpenJDK project moves forward with the 6-month release cadence, which offers time-based release model where features get in whenever they are ready, a large part of the Java ecosystem is still using Java 8 and Java 11 in production.GraalVM’s dedication to improving the Java ecosystem comes with support for those major versions which are the most popular.GraalVM includes a compatible JDK and currently offers downloads based on Java 8 or Java 11.To use GraalVM to speed up Java applications, build native executables with the Native Image feature, or incorporate libraries from other languages, you do not have to undergo complex migrations to the latest OpenJDK release.Migrating services to GraalVM mostly consists of replacing the JDK downloads or base container images with the GraalVM based ones without code changes or needing to leverage new language features!Quick startEqually excellent developer productivityOne of the best features of GraalVM is its compatibility with all the tools in the Java ecosystem.GraalVM can run Java applications offering better performance without code changes or any learning curve for developers.GraalVM fits into your workflow, being a compatible JDK it not only runs the applications you are working on, but the Java tools that help you! GraalVM works in your debugger, works with your build tools, it works within your favourite IDE, you can migrate your continuous integration environment to it, run your issue tracker on it and all other Java services you are using.You do not even have to be a Java developer! If other JVM languages are your cup of productivity, that is okay. From Kotlin, to Clojure, to Scala, GraalVM can help you run them all with excellent performance too.GraalVM merges the power of the Java ecosystem and community with a more powerful JDK distribution for the best of all worlds.Quick startSupported by industry-leading Java application frameworksSupported by industry-leading Java application frameworks, GraalVM is often cited as the most exciting innovation in the Java ecosystem.For example, the ability to compile applications into native executables with the Native Image technology revolutionises cloud deployments for Java applications.It is especially important for microservices where individual services are either neatly packed in environments constrained by memory or quickly become a major part of the cloud cost.Luckily, with GraalVM you do not have to rewrite your applications in Go to succeed in the cloud.Most major Java application and microservice frameworks are designed with GraalVM Native Image in mind or are working on adding first-class support.Micronaut, Helidon, Quarkus, or Spring Boot for microservices, PicoCLI for command line applications – whichever task you are facing, there’s a GraalVM Native Image compatible framework available to make your job easier.Quick startExpanding the Java ecosystemThe Java Virtual Machine (JVM) makes it possible to run Java programs on everything from small embedded devices to mainframes.It is a high-performance runtime that abstracts away the details of underlying hardware and operating system platforms to enable code portability.But it turns out the JVM does not actually know anything about the Java language itself as it executes programs compiled to the intermediate Java bytecode format.This means that any language that can be compiled to Java bytecode can be run on the JVM, for example, Scala, Kotlin, and Clojure.However, there are many popular languages that do not compile to Java bytecodes and cannot take advantage of the benefits provided by the JVM and the performance benefits of just-in-time compilation.But thanks to the innovative Truffle language implementation framework, GraalVM does support the execution of a number of popular programming languages including JavaScript/Node.js, Ruby, Python, and R on the JVM.There is also support for C, C++, and other languages compiled to LLVM bitcode or WebAssembly (Wasm).GraalVM and Truffle do not just make it possible to run non-Java bytecode programs on the JVM, Truffle also makes it possible for these languages to benefit from GraalVM’s advanced optimizing compiler technology to run faster and leaner — just like Java applications running on GraalVM.In all cases GraalVM Truffle languages perform as fast as, and typically many times faster, on the JVM than they do when running on their original runtimes.TruffleRuby has high potential in speed, as it is nine times faster than CRuby on optcarrot.— Carol Chen, Software Engineer, ShopifyFigure 4. GraalVM Truffle LanguagesBreaking Down WallsIn addition to GraalVM being able to run programs written in a number of languages, it is also possible to run programs that use more than one!There are thousands of useful Node.js packages, Python libraries, and Java libraries that can be used by any of the languages supported by GraalVM.This enables use cases like Java microservices that incorporate Python machine learning capabilities or JavaScript programs that use R for statistical data analysis.GraalVM’s multilingual support makes it possible for developers with different language and domain expertise to collaborate.For example, the Dutch National Police used GraalVM to integrate R code into Spring Boot web services written in Java and Scala.This allowed their data scientists to write code in R to perform data analysis while their Java and Scala developers built out services that interacted with Apache Kafka.Embedding R code in a Scala/JVM project can be an excellent way to use the powerful data processing packages accessible in R… This means you (or your Data Scientist) can use a specialized editor (e.g. RStudio) to create the R side of your functionality, while you can use your own favourite editor for the JVM side (e.g., IntelliJ).— Nathan Perdijk, Scala Developer, CodestarQuick start",
                    "url": " /java/advantages/"
                  },
                  
                  "community-advisory-board":  {
                    "title": "",
                    "content": "GraalVM Project Advisory BoardWe are announcing the establishment of the GraalVM Project Advisory Board — an advisory committee, composed of key project contributors and partners in the ecosystem with a shared goal of driving the GraalVM project forward. Such organizations can nominate their Representative for the Board. The Representative will act as the main contact point for all project-related matters associated with their company.The Advisory Board Goals  Discuss community engagement and contributor interaction;  Provide cumulative feedback from the community and partner ecosystem;  Discuss ways to drive project awareness and adoption.The Board will meet at least every three months via video call and once per year in person. Board meetings may include additional attendees contributing to specific topics of interest. A summary of the discussions will be published on the project websiteAdvisory Board Members  Bruno Caballero, Microdoc. Work on GraalVM integrations in the embedded space.  Chris Seaton, Shopify. Contributors to TruffleRuby – GraalVM Ruby implementation.  Uma Srinivasan, Twitter. Run GraalVM Community Edition in production on a large scale system and share their experience with the community.  Fabio Niephaus, Hasso Plattner Institute. Academic collaborators and developers of TruffleSqueak – a Squeak/Smalltalk implementation for GraalVM.  Iván López, Object Computing, Inc. Developers of Micronaut – a framework for building microservice and serverless applications, integrated with GraalVM.  Johan Vos, Gluon. Work on the JavaFX and mobile/embedded platform support for GraalVM native images.  Max Rydahl Andersen, Red Hat. Developer on Quarkus - A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.  Michael Simons, Neo4j. Integrate with GraalVM to support polyglot dynamic languages for user-defined-procedures in Neo4j, a JVM-based graph database.  Paul Hohensee, Amazon. Interested in GraalVM Community Edition, GraalVM Native Image, and AWS Lambda on GraalVM.  San-Hong Li, Alibaba. Contribute to the project and share their experience with the community.  Sébastien Deleuze, VMware. Spring Framework committer, works on Spring Native for GraalVM.  Thomas Wuerthinger, Oracle. Key developers and maintainers of GraalVM and related projects.  Xiaohong Gong, Arm Technology China. Works on GraalVM Compiler Optimizations On AArch64.New membersIf your organization has an interest in joining the GraalVM project advisory board, please let us know. We are open to include new members that align with the board’s goals and mission.Meeting notesMeeting notes are published after each of the Board mettings within 5 days. See the previous notes below.February 2020 MeetingSome of the topics discussed:  The goals of the Advisory Board;  Community contributions and ways to support contributors;  Testing and build process;  Possibility to create a security collaboration group;  Enhancement requests.View full meeting notes →May 2020 MeetingSome of the topics discussed:  Project updates and upcoming release;  Security collaboration group: draft charter and further steps;  Release process and backporting;  Release roadmap updates;  Ecosystem updates, project Leyden;  Possibility of adding committer/reviewer roles to the project.View full meeting notes →August 2020 MeetingSome of the topics discussed:  Project updates and upcoming release;  Security collaboration group update;  Release process and supported platforms;  Ecosystem updates;  Advisory Board work evaluation;  Contributing and CI.View full meeting notes  →November 2020 MeetingSome of the topics discussed:  Release schedule and project roadmap  GraalVM Developer survey  Platform support  GraalVM and OpenJDK  Autovectorization  mx, build instructionsView full meeting notes →February 2021 MeetingSome of the topics discussed:  GraalVM Community Survey results  21.0 release and Java on Truffle  Project roadmap, upcoming features  Java versions support in GraalVM  RISC-V, SPARC, PowerPC support  CI automationView full meeting notes →May 2021 MeetingSome of the topics discussed:  Project updates  21.1 and 21.2 releases  Native Image memory usage in Java 8/11/11+  Memory usage during compilation  Plans for M1 builds  CI testingView full meeting notes →",
                    "url": " /community/advisory-board/"
                  },
                  
                  "blog":  {
                    "title": "",
                    "content": "",
                    "url": " /blog/"
                  },
                  
                  "tools-chrome-debugger":  {
                    "title": "",
                    "content": "Chrome DebuggerGraalVM supports debugging of guest language applications and provides abuilt-in implementation ofthe Chrome DevTools Protocol.This allows you to attach compatible debuggers such asChrome Developer Toolsto GraalVM.To debug guest language applications, pass the --inspect option to thecommand line launcher, as in the followingexample with a Node.js HelloWorld program:var http = require(&#39;http&#39;);var server = http.createServer(function (request, response) {  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});  response.end(&quot;Hello World!n&quot;);});server.listen(8000);console.log(&quot;Server running at http://localhost:8000/&quot;);  Save this program as HelloWorld.js and then run:    node --inspect --jvm HelloWorld.jsDebugger listening on port 9229.To start debugging, open the following URL in Chrome: chrome-devtools://devtools/bundled/js_app.html?ws=127.0.1.1:9229/76fcb6dd-35267eb09c3Server running at http://localhost:8000/        Navigate to http://localhost:8000/ in your browser to launch the node application.        Open the chrome-devtools:... link in a separate Chrome browser tab.        Navigate to the HelloWorld.js file and submit a breakpoint at line 4.    Refresh the node.js app and you can see the breakpoint hit.Now you can inspect the stack, variables, evaluate variables, and selected expressionsin a tooltip, and so on. By hovering your cursor over the response variable, forinstance, you can inspect its properties, as seen in the screenshot below:Consult theJavaScript Debugging Referencefor details on Chrome DevTools debugging features.This debugging process applies to all guest languages that GraalVM supports.Other languages such as R and Ruby can be debugged as easily as JavaScript,including stepping through language boundaries during guest languageinteroperability.Inspect OptionsNode LauncherThe Node.js runtime of GraalVM accepts the same options asnode.js built on the V8 JavaScript engine, such as:--inspect[=[host:]&amp;lt;port number&amp;gt;]This enables the inspector agent and listens on port 9229 by default. To listen on adifferent port, specify the optional port number:--inspect-brk[=[host:]&amp;lt;port number&amp;gt;]This applies to the node launcher only.Other Language LaunchersOther guest language launchers such as js, python, Rscript, ruby, lli, and polyglotaccept the --inspect[=[host:]&amp;lt;port number&amp;gt;] option, but suspend on the first line ofthe application code by default.--inspect.Suspend=(true|false)This disables the initial suspension if you specify --inspect.Suspend=false.Additional Common Inspect OptionsAll launchers also accept the following additional options:  --inspect.Path=&amp;lt;path&amp;gt; allows users to specify a custom path that generates the connection URL. Note: any website opened in your browser that has knowledge of this URL can connect to the debugger. A predictable path can thus be abused by a malicious website to execute arbitrary code on your computer, even if you are behind a firewall. Therefore the path is randomly generated by default.  --inspect.SourcePath=&amp;lt;source path&amp;gt; specifies a list of directories or ZIP/JAR files representing the source path. When the inspected application contains relative references to source files, their content is loaded from locations resolved with respect to this source path. It is useful during LLVM debugging, for instance.The paths are delimited by : on UNIX systems and by ; on MS Windows.  --inspect.Secure=(true|false) when true, use TLS/SSL to secure the debugging protocol. Besides changing the WS(web socket) protocol to WSS, the HTTP endpoint that serves metadata about the debuggeeis also changed to HTTPS. This is not compatible, e.g., with achrome://inspect page, which is not able to provide the debuggeeinformation and launch the debugger. Launch debugging via the printed WSS URL directly. Use the standard javax.net.ssl.* system options to provide information about keystore with the TLS/SSL encryption keys, or the following options:          --inspect.KeyStore - keystore file path      --inspect.KeyStoreType - keystore file type (defaults to JKS)      --inspect.KeyStorePassword - keystore password      --inspect.KeyPassword - password for recovering keys, if it’s different from the keystore password        --inspect.WaitAttached=(true|false) when true, no guest language source code is executed until the inspector client is attached. Unlike --inspect.Suspend=true, the execution is resumed rightafter the client is attached. This assures that no execution is missed by theinspector client. It is false by default.Advanced Debug OptionsThe following options are for language experts and language developers:  --inspect.Initialization=(true|false) when true, this option inspects the language initialization phase. When initial suspension is active, this suspends at the beginning of language initialization, not necessarilyat the beginning of the application code. It is false by default.  --inspect.Internal=(true|false)  when true, internal sources are inspected as well. Internal sources may provide language implementation details. It is false by default.Programmatic Launch of Inspector BackendEmbedders can provide the appropriate inspector options to the Engine/Contextto launch the inspector backend. The following code snippet provides an example ofa possible launch:import org.graalvm.polyglot.*;class DebuggerSample {    public static void main(String... args) {        String port = &quot;4242&quot;;        String path = java.util.UUID.randomUUID().toString();        Context context = Context.newBuilder(&quot;js&quot;)                    .option(&quot;inspect&quot;, port)                    .option(&quot;inspect.Path&quot;, path)                    .build();        String hostAdress = &quot;localhost&quot;;        String url = String.format(                    &quot;chrome-devtools://devtools/bundled/js_app.html?ws=%s:%s/%s&quot;,                    hostAdress, port, path);    }}",
                    "url": " /tools/chrome-debugger/"
                  },
                  
                  "tools-code-coverage":  {
                    "title": "",
                    "content": "Code Coverage Command Line ToolAs of version 19.3.0, GraalVM provides a code coverage command line toolthat lets users record and analyze the source code coverage of a particular executionof code.Code coverage, as a percentage of source code lines, functions, or statementscovered, is an important metric for understanding a particular source codeexecution, and is commonly associated with test quality (test coverage).Providing a visual coverage overview for individual lines of code shows thedeveloper which code paths are covered and which are not, giving insight intothe character of the execution which can, for example, inform further testingefforts.The example application below will be used to demonstrate GraalVM’s codecoverage capabilities. This application defines agetPrime function that calculates the n-th prime using a basic prime numbercalculator based on the Sieve of Eratosthenes algorithm. It also has a somewhat naive cache of the first 20 prime numbers.  Copy the following code into a new file named primes.js:class AcceptFilter {    accept(n) {        return true    }}class DivisibleByFilter {    constructor(number, next) {        this.number = number;        this.next = next;    }    accept(n) {        var filter = this;        while (filter != null) {            if (n % filter.number === 0) {                    return false;            }            filter = filter.next;        }        return true;    }}class Primes {    constructor() {        this.number = 2;        this.filter = new AcceptFilter();    }    next() {        while (!this.filter.accept(this.number)) {            this.number++;        }        this.filter = new DivisibleByFilter(this.number, this.filter);        return this.number;    }}function calculatePrime(n) {    var primes = new Primes();    var primesArray = [];    for (let i = 0; i &amp;lt; n; i++) {        primesArray.push(primes.next());    }    return primesArray[n-1];}function getPrime(n) {    var cache = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71];    var n = arguments[0];    if (n &amp;gt; cache.length) { return calculatePrime(n); }    return cache[n-1];}// TESTSconsole.assert(getPrime(1) == 2);console.assert(getPrime(10) == 29);Notice that the last couple of lines are assertions to be treated as unit tests.      Run js primes.js. The example application should print no output, since all the assertions pass. But how well do the assertions test the implementation?    Run js primes.js --coverage to enable code coverage. The code coverage tool should print output for the example application as follows:    js primes.js --coverage--------------------------------------------------------Code coverage histogram.Shows what percent of each element was covered during execution-------------------------------------------------------- Path               |  Statements |    Lines |    Roots-------------------------------------------------------- /path/to/primes.js |      20.69% |   26.67% |   22.22%--------------------------------------------------------    The tracer prints a coverage histogram for each source file. You can see thatstatement coverage is roughly 20%, line coverage is roughly 26%, and root coverage (theterm “root” covers functions, methods, etc.) is 22.22%. This tells your that oursimple tests are not particularly good at exercising the source code. Next youwill figure out which parts of the code are not covered.    Run js primes.js --coverage --coverage.Output=detailed. Prepare for a somewhat verbose output.Specifying the output as detailed will print all the source code lines with acoverage annotation at the beginning. Due to potentially large output, it isrecommended to combine this output mode with the --coverage.OutputFile optionwhich prints the output directly to a file. The output for our exampleapplication is as follows:js primes.js --coverage --coverage.Output=detailed--------------------------------------------------------Code coverage per line of code and what percent of each element was covered during execution (per source)  + indicates the line is covered during execution  - indicates the line is not covered during execution  p indicates the line is part of a statement that was incidentally covered during execution    e.g. a not-taken branch of a covered if statement-------------------------------------------------------- Path               |  Statements |    Lines |    Roots /path/to/primes.js |      20.69% |   26.67% |   22.22%  class AcceptFilter {      accept(n) {-         return true      }  }  class DivisibleByFilter {      constructor(number, next) {-         this.number = number;-         this.next = next;      }      accept(n) {-         var filter = this;-         while (filter != null) {-             if (n % filter.number === 0) {-                     return false;-             }-             filter = filter.next;          }-         return true;      }  }  class Primes {      constructor() {-         this.number = 2;-         this.filter = new AcceptFilter();      }      next() {-         while (!this.filter.accept(this.number)) {-             this.number++;          }-         this.filter = new DivisibleByFilter(this.number, this.filter);-         return this.number;      }  }  function calculatePrime(n) {-     var primes = new Primes();-     var primesArray = [];-     for (let i = 0; i &amp;lt; n; i++) {-         primesArray.push(primes.next());      }-     return primesArray[n-1];  }  function getPrime(n) {+     var cache = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71];+     var n = arguments[0];p     if (n &amp;gt; cache.length) { return calculatePrime(n); }+     return cache[n-1];  }  // TESTS+ console.assert(getPrime(1) == 2);+ console.assert(getPrime(10) == 29);--------------------------------------------------------As the legend at the beginning of the output explains, lines that are covered bythe execution are preceded with a +. Lines not covered by the execution arepreceded with a -. Lines that are covered partially are preceded with p (e.g., when an ifstatement is covered but only one branch is taken, consider the other benchto be incidentally covered).Looking at the output you can see that the calculatePrime function and all itscalls are never executed. Looking again at the assertions and the getPrimefunction, it becomes clear that our tests always hit the cache. Thus most of thecode is never executed. You can improve on that.  Add console.assert(getPrime(30) == 113); to the end of the primes.js fileand run js primes.js --coverage. Since the new assertion added callsgetPrime with 30 (our cache only has 20 entries) the coverage will look likethis:js primes.js --coverage-------------------------------------------------------Code coverage histogram.  Shows what percent of each element was covered during execution------------------------------------------------------- Path               |  Statements |    Lines |    Roots------------------------------------------------------- /path/to/primes.js |     100.00% |  100.00% |  100.00%-------------------------------------------------------Integrating with Other ToolsThe code coverage tool provides ways to integrate with other tools. Runningwith --coverage.Output=lcov produces output in the commonly usedlcov format which is used by multiple tools(e.g., genhtml) to display coverage data. Take a look at the next example thatshows how to visualise coverage of a Node.js app with Visual Studio Code.  Copy the following code into a new file named nodeapp.js:const express = require(&#39;express&#39;)const app = express()const port = 3000app.get(&#39;/&#39;, (req, res) =&amp;gt; {  res.send(&#39;Hello World!&#39;)})app.get(&#39;/neverCalled&#39;, (req, res) =&amp;gt; {  res.send(&#39;You should not be here&#39;)})app.get(&#39;/shutdown&#39;, (req, res) =&amp;gt; {  process.exit();})app.listen(port, () =&amp;gt; console.log(`Example app listening on port ${port}!`))      Install the express module dependency: npm install express.        Launch Visual Studio Code and install a code coverage plugin that supports lcov.The Code Coverage Highlighter is used for this example, but other plugins should work similarly.        Run the nodeapp.js file with coverage enabled and configured:    node --coverage --coverage.Output=lcov --coverage.OutputFile=coverage/lcov.info nodeapp.js  Note that the Code Coverage Highlighter plugin looks for the lcov.info file inthe coverage directory by default, so direct the output of the codecoverage tool there.      Visit localhost:3000/ in your browser, then visit localhost:3000/shutdown to close the app.        Open Visual Studio Code, then open the folder containing the nodeapp.js fileand coverage directory and you should be greeted with an image similar to the following:  If you wish to integrate the data gathered by the GraalVM code coverage toolwith your own visualisation, the --coverage.Output=json option results inthe output being a JSON file with the raw data gathered by the tracker.",
                    "url": " /tools/code-coverage/"
                  },
                  
                  "community":  {
                    "title": "",
                    "content": "The GraalVM project embraces an open and inclusive community. We welcome users and contributors alike. Also, we support projects that extend the platform with new tools, languages or embeddings.Stay Connected  Subscribe to low traffic graalvm-announce@oss.oracle.com for important news about GraalVM.  Follow @graalvm on Twitter and use the #GraalVM hashtag to tweet about the project or to see what others are tweeting.Community SupportWe provide free community support via public channels and always appreciate your feedback or questions.  Join the conversation at our Slack channels to directly connect with the GraalVM team.  Subscribe and post to graalvm-users@oss.oracle.com for GraalVM usability questions.  Create GitHub issues for bug reports, questions or requests for enhancements.  Report a security vulnerability to secalert_us@oracle.com. For additional information see Reporting Vulnerabilities guide.Contribute to GraalVMGraalVM welcomes contributors to the core platform and projects that extend theplatform. There have already been significant contributions from both industryand academia. Please let us know about such efforts that we can support to growthe GraalVM community together.To help to provide immediate feedback to GraalVM developers, there are nightly GraalVM buildsavailable. They are built from the main branch on a nightly basis.  Learn how to become a GraalVM contributor.  Subscribe and post to graalvm-dev@oss.oracle.com for questions related to working with the sources or extending the GraalVM ecosystem by creating new languages, tools or embeddings.",
                    "url": " /community/"
                  },
                  
                  "compatibility":  {
                    "title": "GraalVM Compatibility",
                    "content": "GraalVM Language CompatibilityA key concern when evaluating a new runtime to execute your application is whether theruntime is functionally complete. We run a comprehensive set of language specification testson each push to any of the GraalVM language repositories. Sometimes those test suites areincomplete, in which case we work with third parties to improve the overall ecosystem.We also run regular tests against a subset of popular packages for each of the supportedGraalVM languages. If you are interested in checking if your package is supported, use oneof the two tools below. Specify the name of the module or package you are interested in, or drop in your package.json, Gemfile.lock, or other files containing the list of your dependencies.Note that all the processing is done on the client-side in the browser, no information is sent to any servers.We run tests on the modules from their respective repositories: NPM for node modules, RubyGems for Ruby gems. We try to download the module and run its tests. If the tests pass, the compatibility checker will report the amount of passed tests for the module, for example “100.00% tests pass”. If the tests are not using the testing framework we support running, you will see the “installs but not yet tested” message. Please use the compatibility checker as the initial tool to check the compatibility and assess it further yourself. In general, unless the tests clearly fail, there is a good chance the module will run on GraalVM.            Quickly check if an NPM module or Ruby gem is compatible with GraalVM.                                                            &amp;times;                        Check!                  Sorry, there are no compatibility results found for .        This does not mean  will not work with GraalVM. We just have not had a chance to add it to our regular testing process.          We currently test:            More than 95,000 NPM modules based on mocha, jest, ava, tape, and other test frameworks.      The top 1,000 most popular Ruby gems.          If there is an untested module you would love to see tested by us, please let us know.            Upload your package dependency lock file to  check all your dependencies at once!                                          Drag your file here  or                                          upload                                                                      Name          Version          Status                              ",
                    "url": " /compatibility/"
                  },
                  
                  "reference-manual-ruby-compatibility":  {
                    "title": "",
                    "content": "CompatibilityTruffleRuby aims to be fully compatible with the standard implementation ofRuby, MRI, version 2.7.3, including C extensions.TruffleRuby is still in development, so it is not 100% compatible yet.Any incompatibility with MRI is considered a bug, except for rare cases detailed below.If you find an incompatibility with MRI, please report it.TruffleRuby tries to match the behavior of MRI as much as possible.In a few limited cases, TruffleRuby is deliberately incompatible with MRI in order to provide a greater capability.In the future, TruffleRuby aims to provide compatibility with extra functionality provided by JRuby.IdentificationTruffleRuby defines these constants for identification:  RUBY_ENGINE is &#39;truffleruby&#39;.  RUBY_VERSION is the compatible MRI version.  RUBY_REVISION is the full git commit hash used to build TruffleRuby (similar to MRI 2.7+).  RUBY_RELEASE_DATE is the git commit date.  RUBY_PATCHLEVEL is always zero.  RUBY_ENGINE_VERSION is the GraalVM version, or 0.0- and the Git commit hash if your build is not part of a GraalVM release.In the C API, the preprocessor macro TRUFFLERUBY is defined, which can be checked with #ifdef TRUFFLERUBY.Features Entirely MissingContinuations and callccContinuations are obsolete in MRI, and Fibers are recommended instead.Continuations and callcc are unlikely to ever be implemented in TruffleRuby, as their semantics fundamentally do not match the JVM architecture.ForkYou cannot fork the TruffleRuby interpreter.The feature is unlikely to ever be supported when running on the JVM but could be supported in the future in the native configuration.The correct and portable way to test if fork is available is:Process.respond_to?(:fork)Standard librariesThe following standard libraries are unsupported:  continuation (obsolete in MRI)  dbm  gdbm  sdbm  debug (could be implemented in the future, use --inspect instead)  profile (could be implemented in the future, use --cpusampler instead)  profiler (could be implemented in the future, use --cpusampler instead)  io/console (partially implemented, could be implemented in the future)  io/wait (partially implemented, could be implemented in the future)  pty (could be implemented in the future)  win32 (only relevant on Windows)  win32ole (only relevant on Windows)TruffleRuby provides its own backend implementation for the ffi gem, similar to JRuby.This should be completely transparent and behave the same as on MRI.The implementation should be fairly complete and passes all the specs of the ffi gem except for some rarely-used corner cases.Safe levels$SAFE and Thread#safe_level are 0 and no other levels are implemented.Trying to use level 1 will raise a SecurityError.Other levels will raise ArgumentError as in standard Ruby.See the security notes for more explanation on this.Internal MRI functionalityRubyVM is not intended for users and is not implemented.Features with Major DifferencesThreads run in parallelIn MRI, threads are scheduled concurrently but not in parallel.In TruffleRuby threads are scheduled in parallel.As in JRuby and Rubinius, you are responsible for correctly synchronising access to your own shared mutable data structures, and TruffleRuby will be responsible for correctly synchronising the state of the interpreter.Threads detect interrupts at different pointsTruffleRuby threads may detect that they have been interrupted at different points in the program compared to where they would on MRI.In general, TruffleRuby seems to detect an interrupt sooner than MRI.JRuby and Rubinius are also different from MRI; the behavior is not documented in MRI, and it is likely to change between MRI versions, so it is not recommended to depend on interrupt points.Fibers do not have the same performance characteristics as in MRIMost use cases of fibers rely on them being easy and cheap to start up, and with low memory overheads.In TruffleRuby, fibers are currently implemented using operating system threads, so they have the same performance characteristics as Ruby threads.This will be addressed once the Loom project becomes stable and available in JVM releases.Some classes marked as internal will be differentMRI provides some classes that are described in the documentation as being available only on MRI (CRuby).These classes are implemented if it is practical to do so, but this is not always the case. For example, RubyVM is not available.RegexpRegexp instances are always immutable in TruffleRuby.In CRuby 3.0, all literal Regexp are immutable, but non-literal are still mutable.This limitation means that one cannot define singleton methods on a Regexp instance, and cannot create instances of subclasses of Regexp on TruffleRuby.Features with Subtle DifferencesCommand line switchesThe -y, --yydebug, --dump=, and --debug-frozen-string-literal switches are ignored with a warning as they are unsupported development tools.Programs passed in -e arguments with magic-comments must have an encoding that is UTF-8 or a subset of UTF-8, as the JVM has already decoded arguments by the time we get them.The --jit option and the jit feature have no effect on TruffleRuby and warn. The GraalVM compiler is always used when available.Time is limited to millisecond precisionRuby normally provides microsecond (millionths of a second) clock precision, but TruffleRuby is currently limited to millisecond (thousands of a second) precision.This applies to Time.now and Process.clock_gettime(Process::CLOCK_REALTIME).Strings have a maximum bytesize of 231-1Ruby Strings are represented as a Java byte[].The JVM enforces a maximum array size of 231-1 (by storing the size in a 32-bit signed int), and therefore Ruby Strings cannot be longer than 231-1 bytes.That is, Strings must be smaller than 2GB. This is the same restriction as JRuby.A possible workaround could be to use natively-allocated strings, but it would be a large effort to support every Ruby String operation on native strings.The process title might be truncatedSetting the process title (via $0 or Process.setproctitle in Ruby) is done as best-effort.It may not work, or the title you try to set may be truncated.Polyglot standard I/O streamsIf you use standard I/O streams provided by the Polyglot engine, via the experimental --polyglot-stdio option, reads and writes to file descriptors 0, 1, and 2 will be redirected to these streams.That means that other I/O operations on these file descriptors, such as isatty, may not be relevant for where these streams actually end up, and operations like dup may lose the connection to the polyglot stream.For example, if you $stdout.reopen, as some logging frameworks do, you will get the native standard-out, not the polyglot out.Also, I/O buffer drains, writes on I/O objects with sync set, and write_nonblock will not retry the write on EAGAIN and EWOULDBLOCK, as the streams do not provide a way to detect this.Error messagesError message strings will sometimes differ from MRI, as these are not generally covered by the Ruby Spec Suite or tests.SignalsThe set of signals that TruffleRuby can handle is different from MRI.When using the native configuration, TruffleRuby allows trapping all the same signals that MRI does, as well as a few that MRI does not.The only signals that can’t be trapped are KILL, STOP, and VTALRM.Consequently, any signal handling code that runs on MRI can run on TruffleRuby without modification in the native configuration.However, when run on the JVM, TruffleRuby is unable to trap USR1 or QUIT, as these signals are reserved by the JVM.In such a case trap(:USR1) {} will raise an ArgumentError.Any code that relies on being able to trap those signals will need to fall back to another available signal.Additionally, FPE, ILL, KILL, SEGV, STOP, and VTALRM cannot be trapped, but these signals are also unavailable on MRI.When TruffleRuby is run as part of a polyglot application, any signals that are handled by another language become unavailable for TruffleRuby to trap.GC statisticsTruffleRuby provides similar GC.stat statistics to MRI, but not all statistics are available, and some statistics may be approximations. Use GC.stat.keys to see which are provided with real or approximate values. Missing values will return 0.Features with Very Low PerformanceObjectSpaceUsing most methods on ObjectSpace will temporarily lower the performance of your program.Using them in test cases and other similar ‘offline’ operations is fine, but you probably do not want to use them in the inner loop of your production application.set_trace_funcUsing set_trace_func will temporarily lower the performance of your program.As with ObjectSpace, it is recommended that you do not use this in the inner loop of your production application.BacktracesThrowing exceptions and other operations which need to create a backtrace are slower than on MRI.This is because TruffleRuby needs to undo optimizations that have been applied to run your Ruby code fast in order to recreate the backtrace entries.It is not recommended to use exceptions for control flow on any implementation of Ruby anyway.To help alleviate this problem, backtraces are automatically disabled in cases where we can detect that they will not be used.C Extension CompatibilityIdentifiers may be macros or functionsIdentifiers which are normally macros may be functions, functions may be macros, and global variables may be macros.This may cause problems where they are used in a context which relies on a particular implementation (e.g., taking theaddress of it, assigning to a function pointer variable, and using defined() to check if a macro exists).These issues should all be considered bugs and be fixed.Please report these cases.rb_scan_argsrb_scan_args only supports up to 10 pointers.rb_funcallrb_funcall only supports up to 15 arguments.mark functions of RDATA and RTYPEDDATAThe mark functions of RDATA and RTYPEDDATA are not called during garbage collection, but called periodically.The information about objects is cached as they are assigned to structs, and TruffleRuby periodically runs all mark functions when the cache has become full to represent those object relationships in a way that the garbage collector willunderstand.The process should behave identically to MRI.Compatibility with JRubyRuby to Java interoperabilityTruffleRuby does not support the same interoperability interface to Java as JRuby does.TruffleRuby provides an alternate polyglot API for interoperating with multiple languages, including Java, instead.Java to Ruby interopCalling Ruby code from Java is supported by theGraalVM Polyglot API.Java extensionsUsing Java extensions written for JRuby is not supported.Features Not Yet Supported in Native ConfigurationRunning TruffleRuby in the native configuration is mostly the same as runningon the JVM. There are differences in resource management, as both VMs usedifferent garbage collectors, but functionality-wise, they are essentially onpar with one another.Java Interoperability With the Native ConfigurationJava interoperability works in the native configuration but requires more setup.By default, only some array classes are available in the image for Java interoperability.You can add more classes by compiling a native image including TruffleRuby.See here for more details.Spec Completeness“How many specs are there?” is not a question with an easy, precise answer. Thenumber of specs varies for the different versions of the Ruby language, differentplatforms, and different versions of the specs.The specs for the standard library and C extension API are alsovery uneven and can give misleading results.This blog postsummarizes how many specs TruffleRuby passes.",
                    "url": " /reference-manual/ruby/Compatibility/"
                  },
                  
                  "reference-manual-compiler":  {
                    "title": "",
                    "content": "GraalVM Compiler  Compiler Advantages  Graph Compilation  Ahead-of-time Compilation  Compiler Operating Modes  Diagnostic DataThe GraalVM compiler is a dynamic just-in-time (JIT) compiler, written in Java, that transforms bytecode into machine code.The GraalVM compiler integrates with the Java HotSpot VM, which supports a compatible version of the JVM Compiler Interface (JVMCI). JVMCI is a privileged, low-level interface to the JVM, enabling a compiler written in Java to be used by the JVM as a dynamic compiler (see JEP 243).It can read metadata from the VM, such as method bytecode, and install machine code into the VM .GraalVM includes a version of the HotSpot JVM that supports JVMCI.Compiler AdvantagesThe GraalVM compiler provides optimized performance for programs running on the JVM through unique approaches to code analysis and optimization.It includes multiple optimization algorithms (called “Phases”), like aggressive inlining, polymorphic inlining, and others. For example, the compiler in GraalVM Enterprise includes 62 optimization phases, of which 27 are patented.The GraalVM compiler assures performance advantages for highly-abstracted programs due to its ability to remove costly object allocations.Code using more abstraction and modern Java features like Streams or Lambdas will see greater speedups.Low-level code or code that converges to things like I/O, memory allocation, or garbage collection will see less improvement.Consequently, an application running on GraalVM needs to spend less time doing memory management and garbage collection.For more information on performance tuning, refer to Compiler Configuration on JVM.Graph CompilationTo run guest programming languages, namely JavaScript, Ruby, R, Python, and WebAssembly in the same runtime as the host JVM-based languages, the compiler should work with a language-independent intermediate representation (IR) between the source language and the machine code to be generated.A graph was selected for this role.The graph can represent similar statements of different languages in the same way, like “if” statements or loops, which makes it possible to mix languages in the same program.The GraalVM compiler can then perform language-independent optimization and generate machine code on this graph.GraalVM also includes the Truffle language implementation framework – a library, written in Java – to build interpreters for programming languages, which then run on GraalVM.These languages can consequently benefit from the optimization possibilities of the GraalVM compiler.The pipeline for such compilation is:  The Truffle framework code and data (Abstract Syntax Trees) is partially evaluated toproduce a compilation graph. When such an Abstract Syntax Tree (AST) ishot (i.e., called many times), it is scheduled for compilation by the compiler.  The compilation graph is optimized by the GraalVM compiler to produce machine code.  JVMCI installs this machine code in the VM’s code cache.  The AST will automatically redirect execution to the installed machine code once it is available.Ahead-of-time CompilationBesides the Truffle framework, GraalVM incorporates its optimizing compiler into an advanced ahead-of-time (AOT) compilation technology – Native Image – which translates Java and JVM-based code into a native platform executable.These native executables start nearly instantaneously, are smaller, and consume less resources of the same Java application, making them ideal for cloud deployments and microservices.For more information about AOT compilation, go to Native Image.Compiler Operating ModesThere are two operating modes of the GraalVM compiler when used as the HotSpot JIT compiler: as pre-compiled machine code (“libgraal”), or as dynamically executed Java bytecode (“jargraal”).libgraal: the GraalVM compiler is compiled ahead-of-time into a native shared library.In this operating mode, the shared library is loaded by the HotSpot VM.The compiler uses memory separate from the HotSpot heap.It runs fast from the start since it does not need to warm up.This is the default and recommended mode of operation.jargraal: the GraalVM compiler goes through the same warm-up phase that the rest of the Java application does.That is, it is first interpreted before its hot methods are compiled.This mode is selected with the -XX:-UseJVMCINativeLibrary command line option.Diagnostic DataIf an uncaught exception is thrown by the compiler, the compilation is simply discarded and execution continues. The GraalVM compiler can instead produce diagnostic data (such as immediate representation graphs) that can be submitted along with a bug report.This is enabled with -Dgraal.CompilationFailureAction=Diagnose.The default location of the diagnostics output is in graal_dumps/ under the current working directory of the process but can be changed with the -Dgraal.DumpPath option.During the VM shutdown, the location of the archive containing the diagnostic data is printed to the console.Furthermore, diagnostic data can be produced for any compilation performed by the GraalVM compiler with the -Dgraal.Dump option.This will produce diagnostic data for every method compiled by the compiler.To refine the set of methods for which diagnostic data is produced, use the -Dgraal.MethodFilter=&amp;lt;class&amp;gt;.&amp;lt;method&amp;gt; option.For example, -Dgraal.MethodFilter=java.lang.String.*,HashMap.get will produce diagnostic data only for methods in the java.lang.String class as well as methods named get in a class whose non-qualified name is HashMap.Instead of being written to a file, diagnostic data can also be sent over the network to the Ideal Graph Visualizer.This requires the -Dgraal.PrintGraph=Network option, upon which the compiler will try to send diagnostic data to 127.0.0.1:4445.This network endpoint can be configured with the -Dgraal.PrintGraphHost and -Dgraal.PrintGraphPort options.Note: the Ideal Graph Visualizer is available with Oracle GraalVM Enterprise Editon.",
                    "url": " /reference-manual/compiler/"
                  },
                  
                  "community-conduct":  {
                    "title": "",
                    "content": "Contributor Covenant Code of ConductOur PledgeIn the interest of fostering an open and welcoming environment, we ascontributors and maintainers pledge to making participation in our project andour community a harassment-free experience for everyone, regardless of age, bodysize, disability, ethnicity, gender identity and expression, level of experience,nationality, personal appearance, race, religion, or sexual identity andorientation.Our StandardsExamples of behavior that contributes to creating a positive environmentinclude:  Using welcoming and inclusive language  Being respectful of differing viewpoints and experiences  Gracefully accepting constructive criticism  Focusing on what is best for the community  Showing empathy towards other community membersExamples of unacceptable behavior by participants include:  The use of sexualized language or imagery and unwelcome sexual attention oradvances  Trolling, insulting/derogatory comments, and personal or political attacks  Public or private harassment  Publishing others’ private information, such as a physical or electronicaddress, without explicit permission  Other conduct which could reasonably be considered inappropriate in aprofessional settingOur ResponsibilitiesProject maintainers are responsible for clarifying the standards of acceptablebehavior and are expected to take appropriate and fair corrective action inresponse to any instances of unacceptable behavior.Project maintainers have the right and responsibility to remove, edit, orreject comments, commits, code, wiki edits, issues, and other contributionsthat are not aligned to this Code of Conduct, or to ban temporarily orpermanently any contributor for other behaviors that they deem inappropriate,threatening, offensive, or harmful.ScopeThis Code of Conduct applies both within project spaces and in public spaceswhen an individual is representing the project or its community. Examples ofrepresenting a project or community include using an official project e-mailaddress, posting via an official social media account, or acting as an appointedrepresentative at an online or offline event. Representation of a project may befurther defined and clarified by project maintainers.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may bereported by contacting the project team. Allcomplaints will be reviewed and investigated and will result in a response thatis deemed necessary and appropriate to the circumstances. The project team isobligated to maintain confidentiality with regard to the reporter of an incident.Further details of specific enforcement policies may be posted separately.Project maintainers who do not follow or enforce the Code of Conduct in goodfaith may face temporary or permanent repercussions as determined by othermembers of the project’s leadership.AttributionThis Code of Conduct is adapted from the Contributor Covenant, version 1.4,available here.",
                    "url": " /community/conduct/"
                  },
                  
                  "community-contributors":  {
                    "title": "",
                    "content": "Contribute to GraalVMGraalVM is an open source Oracle project where people from all over the world contribute their work, help each other, and make GraalVM innovative.We are thankful for past contributions both big and small and always welcome new collaborators!Only a large community can make this project a strong language virtualization technology.There are two common ways to collaborate:  By submitting GitHub issues for bug reports, questions, or requests for enhancements. Note, that a security vulnerability should be reported to secalert_us@oracle.com.  By creating GitHub pull requests.If you consider contributing to the GraalVM project, start by learning how to build a GraalVM distribution from sources, using mx – a unique building tool.Learn how to set up a proper development enviroment, load the GraalVM project into the IDE, and see the main classes one could look at to have the basic understanding what the compiler is doing. This video demonstartes the above.                              watch video                                                How to Become a GraalVM Contributor?Further below are some tips for contributing to GraalVM Community Edition and its projects, hosted in the Oracle organization on GitHub.We expect a contributor to abide by the Contributor Covenant Code of Conduct.Overall, there are three stages:I. Create a Pull RequestIf you believe your contribution is valuable for others, create a pull request (PR).The common process is forking a repository, submitting a change and creating a PR.When creating a PR, please make sure to include a clear description of the intention of the change, unless the change is self-explanatory, e.g., a version update.Describe why (1) the change or feature is needed, (2) how it is implemented, and, optionally, (3) what further implications it may have.You can either use the PR request description field or the commit message.It is recommended to address one feature or change per PR request.Once you have created a pull request, the Travis CI service will run some sanity checks on your change.Be sure to address any obvious issues caught by these checks (e.g., formatting violation), but keep in mind that test failures may not be directly related to your changes (no gate is perfect due to infrastructure issues and transient test failures).II. Sign the Oracle Contributor AgreementTo allow your pull request to be accepted, you will need to sign the Oracle Contributor Agreement (OCA).There are two types of OCAs: Individual OCAs and Company OCAs. Sign it online and, once your name or organization shows up in the OCA signatory list, we will add you to the database used to check that pull request authors are covered under the OCA.If it appears to be a delay in your entry showing up in the signatories list, please send an email to oracle-ca_us@oracle.com.If your entry is in the signatories list, but the bot leaves a message on your pull request that you have not signed the OCA, leave a comment on the pull request stating that you are now covered by the OCA.The bot operates from a database separate from the OCA signatories list (since the latter does not necessarily include email details) and must be manually updated.III. Review and MergeAn Oracle employee reviews the proposed change and once the pull request is in a mergeable state, takes responsibility for merging it to the main branch.To ensure extra diligence in terms of verifying externally contributed code meeting these requirements, we have an inbound-check-bot.What to Expect When Submitting a Pull Request?There are many directions to explore from smaller changes like bug fixes or improvements to the API documentation to larger changes that can either speed up theexecution, or give better control over the system.We look forward to extend the GraalVM ecosystem by implementing new languages support with the Truffle framework, providing better tooling for polyglot programming, or proposing new embedding scenarios.The continuous efforts are directed to the machine learning for optimizing compiler configurations.Contributors are welcomed to join the development of a fully meta-circular Java runtime written in Java.We keep on investigating techniques for more efficient memory usage and pursue improving performance for different workloads.To reach GraalVM developers for questions related to working with GraalVM sources, subscribe and post to graalvm-dev@oss.oracle.com.",
                    "url": " /community/contributors/"
                  },
                  
                  "tools-dap":  {
                    "title": "",
                    "content": "Debug Adapter ProtocolGraalVM supports debugging of guest language applications, written in any of the supported languages, i.e., JavaScript/TypeScript, Python R, Ruby, and provides a built-in implementation of the Debug Adapter Protocol (DAP).By definition, Debug Adapter Protocol is to standardize the “communication” between the debugging component and a concrete debugger or runtime.This allows you to attach compatible debuggers such as Visual Studio Code (VS Code) to GraalVM.To open a debugger port serving Debug Adapter Protocol, you need to pass the --dap option to the command line launcher.The usage of Debug Adapter Protocol is similar to the existing Chrome DevTools Protocol implementation in the GraalVM runtime:  --dap.Suspend=false: disable the execution suspension at first source line, enabled by default.  --dap.WaitAttached: do not execute any source code until debugger client is attached. The default is false.  --dap=&amp;lt;[[host:]port]&amp;gt;: start the debugger on a different port than default (&amp;lt;host&amp;gt;:4711).Then you need a DAP client to connect to the open DAP port. VS Code will be used as an example.1. Save this Node.js application in a file named App.js:const express = require(&#39;express&#39;)const app = express()const port = 3000app.get(&#39;/&#39;, (req, res) =&amp;gt; {  res.send(&#39;Hello World!&#39;)})app.get(&#39;/neverCalled&#39;, (req, res) =&amp;gt; {  res.send(&#39;You should not be here&#39;)})app.get(&#39;/shutdown&#39;, (req, res) =&amp;gt; {  process.exit();})app.listen(port, () =&amp;gt; console.log(`Example app listening on port ${port}!`))2. Install the express module dependency in the directory where you saved the file:npm install express3. Run the application with DAP enabled:node --dap App.js[Graal DAP] Starting server and listening on localhost/127.0.0.1:47114. Start VS Code, freshly installed without any extensions:code .5. Open the App.js source in VS Code, and put a breakpoint, for example, at line 6 (res.send(&#39;Hello World!&#39;)).6. Navigate to View &amp;gt; Run to create a launch configuration (Ctrl+Shift+D):7. Then create the launch.json file with the following content:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;name&quot;: &quot;Attach&quot;,            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;attach&quot;,            &quot;debugServer&quot;: 4711        }    ]}8. Start debugging (F5).The other approach is to use VS Code with the GraalVM extension installed.Follow the steps described inNode.js and JavaScript Debugging, and launch the application being debugged directly from VS Code.When debugging a guest language application from VS Code, a user can choose a protocol to use by setting the protocol attribute in the corresponding debug configuration to either chromeDevTools or debugAdapter.To connect to the open DAP port in this scenario, the content of the launch.json should be:{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;graalvm&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Node App&quot;,            &quot;outputCapture&quot;: &quot;std&quot;,            &quot;protocol&quot;: &quot;debugAdapter&quot;,            &quot;program&quot;: &quot;${workspaceFolder}/App.js&quot;        }    ]}The advantage of using Debug Adapter Protocol over Chrome Dev Tools is that (1) it is ‘native’ to Visual Studio Code (VS Code), meaning it does not require any intermediate translatation, and (2) that it supports multithreading, which can be particually useful to debug, e.g., a Ruby application.",
                    "url": " /tools/dap/"
                  },
                  
                  "docs-tools-dashboard":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/tools/dashboard/"
                  },
                  
                  "reference-manual-ruby-debugging":  {
                    "title": "",
                    "content": "Debugging TruffleRubyPrinting ExceptionsThere are two ways to print exceptions, which can be useful to find the source of an error:  the standard Ruby -d flag which prints the file:line where each exception was raised  --backtraces-raise which show the full backtrace on each exception raisedBoth print all exceptions even if the exceptions are later rescued.Java exceptions can be printed with --exceptions-print-uncaught-java or--exceptions-print-java.See other --backtraces-* and --exceptions-* options for more possibilities.Printing Stacktraces and Backtraces of a Running ProcessOne can send the SIGQUIT signal to TruffleRuby to make it print the Java stacktraces of all threads.Ctrl +   can be used to send SIGQUIT to the current process in a terminal.This is useful to debug hangs and deadlocks, or to know what the process is doing.This works on both TruffleRuby Native and JVM.Sending SIGALRM to a TruffleRuby process will print the Ruby backtraces of all threads.Note: Printing the Ruby backtraces of all threads significantly lowers performance, so it should only be used for debugging.More Information in BacktracesTruffleRuby tries to match MRI’s backtrace format as closely as possible.This sometimes means that extra available information is not displayed.When debugging you may want to see this information.An option to show more information is --backtraces-interleave-java=true, which shows you the Java methods involved in executing each Ruby method.When you are interoperating with other languages, including C extensions, backtraces for Java exceptions may be missing information, as the Java frames are gone by the time Ruby has a chance to format them into a backtrace.Printing SubprocessesYou can print all subprocesses created by TruffleRuby using the option --log-subprocess.$ ruby --log-subprocess -e &#39;`ls .`&#39;[ruby] INFO: spawn: ls .",
                    "url": " /reference-manual/ruby/Debugging/"
                  },
                  
                  "reference-manual-ruby-runtimeconfigurations":  {
                    "title": "",
                    "content": "Deploying TruffleRubyIf you are attempting to experiment with deploying TruffleRuby to production we would encourage you to contact us so we can help you understand what is possible at the moment and to help solve any issues for you.This document details TruffleRuby’s different runtime configurations.TruffleRuby Runtime ConfigurationsThere are two main configurations of TruffleRuby - native and JVM.It is important to understand the different configurations of TruffleRuby, as each has different capabilities and performance characteristics.You should pick the execution mode that is appropriate for your application.Native ConfigurationWhen distributed as part of GraalVM, TruffleRuby by default runs in the native configuration.In this configuration, TruffleRuby is ahead-of-time compiled to a standalone native executable.This means that you do not need a JVM installed on your system to use it.The advantages of the native configuration are that it starts about as fast as MRI, it may use less memory, and it becomes fast in less time than the JVMconfiguration.The disadvantages are that you can’t use Java tools like VisualVM, it is less convenient for Java interoperability (see the details here), and peak performance may be lower than on the JVM.The native configuration is used by default, but you can also request it using --native.To use polyglot programming with the native configuration, you need to pass the --polyglot flag.JVM ConfigurationTruffleRuby can also be used in the JVM configuration, where it runs as a normal Java application on the JVM.The advantages of the JVM configuration are that you can use Java interoperability easily, and peak performance may be higher than the native configuration.The disadvantages are that it takes much longer to start and to get fast, and may use more memory.You can select the JVM configuration by passing --jvm.Selecting the Best ConfigurationIf you are running a short-running program you probably want the default, native, configuration.If you are running a long-running program and want the highest possible performance you probably want the JVM configuration, by using --jvm.Getting the Best Startup Time PerformanceTo get the best startup time in most cases you want to use the native configuration, which is the default.Getting the Lowest Memory FootprintTo get the lowest memory footprint you probably initially want to use the native configuration, but as you get a larger working set of objects you may find that the simpler garbage collector and current lack of compressed ordinary object pointers (OOPS) actually increases your memory footprint and you will be better off with the JVM configuration using --jvm to reduce memory use.Getting the Best Peak Performance from TruffleRubyTo get the best peak performance from TruffleRuby for longer-running applications we would in most cases recommend the JVM configuration with --jvm.However to reach this peak performance you need to warm-up TruffleRuby, as you do with most heavily optimising virtual machines.This is done by running the application under load for a period of time.If you monitor the performance (by measuring operation time or response time) you will see it reduce over time and then probably stabilise.LoggingRuby application logging and warning works as in the standard implementation of Ruby.For logging of TruffleRuby internals, standard Java logging is used.The logging level can be set with --log.level=INFO, =FINEST, or so on.",
                    "url": " /reference-manual/ruby/RuntimeConfigurations/"
                  },
                  
                  "downloads":  {
                    "title": "",
                    "content": "",
                    "url": " /downloads/"
                  },
                  
                  "reference-manual-embed-languages":  {
                    "title": "",
                    "content": "Embedding Languages  Compile and Run a Polyglot Application  Define Guest Language Functions as Java Values  Access Guest Languages Directly from Java  Access Java from Guest Languages  Lookup Java Types from Guest Languages  Computed Arrays Using Polyglot Proxies  Access Restrictions  Build Native Images from Polyglot Applications  Code Caching Across Multiple Contexts  Step Through with Execution Listeners  Build a Shell for Many Languages  Configure Sandbox Resource LimitsThe GraalVM Polyglot API lets you embed and run code from guest languages in JVM-based host applications.Throughout this section, you will learn how to create a host application in Java thatruns on GraalVM and directly calls a guest language. You can use the tabsbeneath each code example to choose between JavaScript, R, Ruby, and Python.Ensure you set up GraalVM before you begin.Compile and Run a Polyglot ApplicationGraalVM can run polyglot applications written in any language implemented with the Truffle language implementation framework.These languages are henceforth referenced as guest languages.Complete the steps in this section to create a sample polyglotapplication that runs on GraalVM and demonstrates programming languageinteroperability.1. Create a hello-polyglot project directory.2. In your project directory, add a HelloPolyglot.java file that includesthe following code:                                  // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_js {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.create()) {            context.eval(&quot;js&quot;, &quot;print(&#39;Hello JavaScript!&#39;);&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_R {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.newBuilder()                                   .allowAllAccess(true)                               .build()) {            context.eval(&quot;R&quot;, &quot;print(&#39;Hello R!&#39;);&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_ruby {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.create()) {            context.eval(&quot;ruby&quot;, &quot;puts &#39;Hello Ruby!&#39;&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_python {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.create()) {            context.eval(&quot;python&quot;, &quot;print(&#39;Hello Python!&#39;)&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                JavaScript      R      Ruby      Python       In this code:  import org.graalvm.polyglot.* imports the base API for the Polyglot API.  import org.graalvm.polyglot.proxy.* imports the proxy classes of the Polyglot API, needed in later examples.  Context provides an execution environment for guest languages.R currently requires the allowAllAccess flag to be set to true to run the example.  eval evaluates the specified snippet of guest language code.  The try with resource statement initializes the Context and ensures that itis closed after use. Closing the context ensures that all resources includingpotential native resources are freed eagerly. Closing a context is optional butrecommended. Even if a context is not closed and no longer referenced it will befreed by the garbage collector automatically.3. Run javac HelloPolyglot.java to compile HelloPolyglot.java withGraalVM.4. Run java HelloPolyglot to run the application on GraalVM.You now have a polyglot application that consists of a Java host applicationand guest language code that run on GraalVM. You can use this application withother code examples to demonstrate more advanced capabilities of thePolyglot API.To use other code examples in this section, you simply need to do the following:1. Add the code snippet to the main method of HelloPolyglot.java.2. Compile and run your polyglot application.Define Guest Language Functions as Java ValuesPolyglot applications let you take values from one programming language anduse them with other languages.Use the code example in this section with your polyglot application to showhow the Polyglot API can return JavaScript, R, Ruby, or Python functions asJava values.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_js {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;js&quot;, &quot;x =&amp;gt; x+1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_R {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    Value function = context.eval(&quot;R&quot;, &quot;function(x) x + 1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_ruby {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;ruby&quot;, &quot;proc { |x| x + 1 }&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;} // END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_python {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;python&quot;, &quot;lambda x: x + 1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;} // END-SNIPPET    }}                JavaScript      R      Ruby      Python       In this code:  Value function is a Java value that refers to a function.  The eval call parses the script and returns the guest language function.  The first assertion checks that the value returned by the code snippet can beexecuted.  The execute call executes the function with the argument 41.  The asInt call converts the result to a Java int.  The second assertion verifies that the result was incremented by one as expected.Access Guest Languages Directly from JavaPolyglot applications can readily access most language types and are notlimited to functions. Host languages, such as Java, can directly access guestlanguage values embedded in the polyglot application.Use the code example in this section with your polyglot application to showhow the Polyglot API can access objects, numbers, strings, and arrays.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_js_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;js&quot;,                     &quot;({ &quot;                   +                        &quot;id   : 42, &quot;       +                        &quot;text : &#39;42&#39;, &quot;     +                        &quot;arr  : [1,42,3] &quot;  +                    &quot;})&quot;);    assert result.hasMembers();    int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;    String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);    Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_R_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    Value result = context.eval(&quot;R&quot;,                     &quot;list(&quot;                +                        &quot;id   = 42, &quot;      +                        &quot;text = &#39;42&#39;, &quot;    +                        &quot;arr  = c(1,42,3)&quot; +                    &quot;)&quot;);    assert result.hasMembers();        int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;        String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);        Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_ruby_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;ruby&quot;,                     &quot;o = Struct.new(:id, :text, :arr).new(&quot; +                        &quot;42, &quot;       +                        &quot;&#39;42&#39;, &quot;     +                        &quot;[1,42,3] &quot;  +                    &quot;)&quot;);    assert result.hasMembers();        int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;        String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);        Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_python_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;python&quot;,                     &quot;type(&#39;obj&#39;, (object,), {&quot; +                        &quot;&#39;id&#39;  : 42, &quot;         +                        &quot;&#39;text&#39;: &#39;42&#39;, &quot;       +                        &quot;&#39;arr&#39; : [1,42,3]&quot;     +                    &quot;})()&quot;);    assert result.hasMembers();        int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;        String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);        Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                JavaScript      R      Ruby      Python       In this code:  Value result is an Object that contains three members: a number named id,a string named text, and an array named arr.  The first assertion verifies that the return value can contain members, whichindicates that the value is an object-like structure.  The id variable is initialized by reading the member with the name id fromthe resulting object. The result is then converted to a Java intusing asInt().  The next assert verifies that result has a value of 42.  The text variable is initialized using the value of the member text, which is also converted to a Java String using asString().  The following assertion verifies the result value is equal to theJava String &quot;42&quot;.  Next the arr member that holds an array is read.  Arrays return true for hasArrayElements. R array instances can havemembers and array elements at the same time.  The next assertion verifies that the size of the array equals three. ThePolyglot API supports big arrays, so the array length is of type long.  Finally we verify that the array element at index 1 equals 42. Arrayindexing with polyglot values is always zero-based, even for languages such asR where indices start with one.Access Java from Guest LanguagesPolyglot applications offer bi-directional access between guest languages andhost languages. As a result, you can pass Java objects to guest languages.Use the code example in this section with your polyglot application to show howguest languages can access primitive Java values, objects, arrays, andfunctional interfaces.To permit guest languages to access any public method or field of a Javaobject, set allowAllAccess(true) when the context is built. In this mode, the guestlanguage code must be fully trusted, as it can access other not explicitly exported Java methodsusing reflection.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_js {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getBindings(&quot;js&quot;).putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;js&quot;,               &quot;    javaObj.id         == 42&quot;          +               &quot; &amp;amp;&amp;amp; javaObj.text       == &#39;42&#39;&quot;        +               &quot; &amp;amp;&amp;amp; javaObj.arr[1]     == 42&quot;          +               &quot; &amp;amp;&amp;amp; javaObj.ret42()    == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_R {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getBindings(&quot;R&quot;).putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;R&quot;,               &quot;    javaObj$id         == 42&quot;   +               &quot; &amp;amp;&amp;amp; javaObj$text       == &#39;42&#39;&quot; +               &quot; &amp;amp;&amp;amp; javaObj$arr[[2]]   == 42&quot;   +               &quot; &amp;amp;&amp;amp; javaObj$ret42()    == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_ruby {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getPolyglotBindings().putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;ruby&quot;,               &quot;javaObj = Polyglot.import(&#39;javaObj&#39;)n&quot; +               &quot;    javaObj[:id]         == 42&quot;         +               &quot; &amp;amp;&amp;amp; javaObj[:text]       == &#39;42&#39;&quot;       +               &quot; &amp;amp;&amp;amp; javaObj[:arr][1]     == 42&quot;         +               &quot; &amp;amp;&amp;amp; javaObj[:ret42].call == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                                             // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_python {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getPolyglotBindings().putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;python&quot;,               &quot;import polyglot n&quot;                            +               &quot;javaObj =  polyglot.import_value(&#39;javaObj&#39;)n&quot; +               &quot;javaObj.id                   == 42&quot;            +               &quot; and javaObj.text            == &#39;42&#39;&quot;          +               &quot; and javaObj.arr[1]          == 42&quot;            +               &quot; and javaObj.ret42() == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                JavaScript      R      Ruby      Python       In this code:  The Java class MyClass has four public fields id, text, arr, andret42. The fields are initialized with 42, &quot;42&quot;, new int[]{1, 42, 3}, andlambda () -&amp;gt; 42 that always returns an int value of 42.  The Java class MyClass is instantiated and exported with the name javaObjinto the polyglot scope, which allows the host and guest languages to exchangesymbols.  A guest language script is evaluated that imports the javaObj symbol andassigns it to the local variable which is also named javaObj. To avoidconflicts with variables, every value in the polyglot scope must be explicitlyimported and exported in the top-most scope of the language.  The next two lines verify the contents of the Java object by comparing itto the number 42 and the string &#39;42&#39;.  The third verification reads from the second array position and compares itto the number 42. Whether arrays are accessed using 0-based or 1-based indicesdepends on the guest language. Independently of the language, the Java arraystored in the arr field is always accessed using translated 0-based indices. Forexample, in the R language, arrays are 1-based so the second array element isaccessible using index 2. In the JavaScript and Ruby languages, the secondarray element is at index 1. In all language examples, the Java array is readfrom using the same index 1.  The last line invokes the Java lambda that is contained in the field ret42and compares the result to the number value 42.  After the guest language script executes, validation takes place to ensurethat the script returns a boolean value of true as a result.Lookup Java Types from Guest LanguagesIn addition to passing Java objects to the guest language, it is possibleto allow the lookup of Java types in the guest language.Use the code example in this section with your polyglot application to show howguest languages lookup Java types and instantiate them.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_js {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;js&quot;,            &quot;var BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;);&quot; +            &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_R {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;R&quot;,            &quot;BigDecimal = java.type(&#39;java.math.BigDecimal&#39;);n&quot; +             &quot;BigDecimal$valueOf(10)$pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_ruby {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;ruby&quot;,            &quot;BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;)n&quot; +             &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                                             // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_python {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;python&quot;,            &quot;import javan&quot; +            &quot;BigDecimal = java.type(&#39;java.math.BigDecimal&#39;)n&quot; +             &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                JavaScript      R      Ruby      Python       In this code:  A new context is created with all access enabled (allowAllAccess(true)).  A guest language script is evaluated.  The script looks up the Java type java.math.BigDecimal and stores it in a variable named BigDecimal.  The static method BigDecimal.valueOf(long) is invoked to create newBigDecimals with value 10. In addition to looking up static Java methods, itis also possible to directly instantiate the returned Java type., e.g., inJavaScript using the new keyword.  The new decimal is used to invoke the pow instance method with 20 which calculates  10^20.  The result of the script is converted to a host object by calling asHostObject(). The return value is automatically cast to the BigDecimal type.  The result decimal string is asserted to equal to &quot;100000000000000000000&quot;.Computed Arrays Using Polyglot ProxiesThe Polyglot API includes polyglot proxy interfaces that let youcustomize Java interoperability by mimicking guest language types, such asobjects, arrays, native objects, or primitives.Use the code example in this section with your polyglot application to see howyou can implement arrays that compute their values lazily.Note: The Polyglot API supports polyglot proxies either on the JVM or in Native Image.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;public class proxy_js {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.create()) {        ComputedArray arr = new ComputedArray();        context.getBindings(&quot;js&quot;).putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;js&quot;,                    &quot;arr[1] + arr[1000000000]&quot;)                .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.proxy.ProxyArray;public class proxy_R {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        ComputedArray arr = new ComputedArray();        context.getPolyglotBindings().putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;R&quot;,               &quot;arr &amp;lt;- import(&#39;arr&#39;);&quot; +               &quot;arr[2] + arr[1000000001]&quot;)           .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.proxy.ProxyArray;public class proxy_ruby {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        ComputedArray arr = new ComputedArray();        context.getPolyglotBindings().putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;ruby&quot;,               &quot;arr = Polyglot.import(&#39;arr&#39;) n&quot; +               &quot;arr[1] + arr[1000000000]&quot;)           .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.proxy.ProxyArray;public class proxy_python {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        ComputedArray arr = new ComputedArray();        context.getPolyglotBindings().putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;python&quot;,               &quot;import polyglotn&quot; +               &quot;arr = polyglot.import_value(&#39;arr&#39;) n&quot; +               &quot;arr[1] + arr[1000000000]&quot;)           .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                JavaScript      R      Ruby      Python       In this code:  The Java class ComputedArray implements the proxy interface ProxyArray sothat guest languages treat instances of the Java class like arrays.  ComputedArray array overrides the method get and computes the valueusing an arithmetic expression.  The array proxy does not support write access. For this reason, it throwsan UnsupportedOperationException in the implementation of set.  The implementation for getSize returns Long.MAX_VALUE for its length.  The main method creates a new polyglot execution context.  A new instance of the ComputedArray class is then exported using the name arr.  The guest language script imports the arr symbol, which returns theexported proxy.  The second element and the 1000000000th element is accessed, summed up, andthen returned. Note that array indices from 1-based languages such as R areconverted to 0-based indices for proxy arrays.  The result of the language script is returned as a long value and verified.For more information about the polyglot proxy interfaces, see thePolyglot API JavaDoc.Access RestrictionsThe Polyglot API by default restricts access to certain critical functionality, such as file I/O.These restrictions can be lifted entirely by setting allowAllAccess to true.Note: The access restrictions are currently only supported with JavaScript.Configuring Host AccessIt might be desirable to limit the access of guest applications to the host.For example, if a Java method is exposed that calls System.exit then the guestapplication will be able to exit the host process.In order to avoid accidentally exposed methods, no host access is allowed bydefault and every public method or field needs to be annotated with@HostAccess.Export explicitly.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.HostAccess;import org.graalvm.polyglot.PolyglotException;public class explicit_access_java_from_js {static// BEGIN-SNIPPETpublic class Employee {    private final String name;    Employee(String name) {this.name = name;}    @HostAccess.Export    public String getName() {        return name;    }}//END-SNIPPETstatic//BEGIN-SNIPPETpublic class Services {    @HostAccess.Export    public Employee createEmployee(String name) {        return new Employee(name);    }        public void exitVM() {        System.exit(1);    }}public static void main(String[] args) {    try (Context context = Context.create()) {        Services services = new Services();        context.getBindings(&quot;js&quot;).putMember(&quot;services&quot;, services);        String name = context.eval(&quot;js&quot;,                &quot;let emp = services.createEmployee(&#39;John Doe&#39;);&quot; +                 &quot;emp.getName()&quot;).asString();        assert name.equals(&quot;John Doe&quot;);                try {            context.eval(&quot;js&quot;, &quot;services.exitVM()&quot;);            assert false;        } catch (PolyglotException e) {            assert e.getMessage().endsWith(                    &quot;Unknown identifier: exitVM&quot;);        }    }}// END-SNIPPET}                      JavaScript             In this code:  The class Employee is declared with a field name of type String. Access to the getName method is explicitly allowed by annotating the method with @HostAccess.Export.  The Services class exposes two methods, createEmployee and exitVM. The createEmployee method takes the name of the employee as an argument and creates a new Employee instance. The createEmployee method is annotated with @HostAccess.Export and therefore accessible to the guest application. The exitVM method is not explicitly exported and therefore not accessible.  The main method first creates a new polyglot context in the default configuration, disallowing host access except for methods annotated with @HostAccess.Export.  A new Services instance is created and put into the context as global variable services.  The first evaluated script creates a new employee using the services object and returns its name.  The returned name is asserted to equal the expected name John Doe.  A second script is evaluated that calls the exitVM method on the services object. This fails with a PolyglotException as the exitVM method is not exposed to the guest application.Host access is fully customizable by creating a custom HostAccess policy.Access Privilege ConfigurationIt is possible to configure fine-grained access privileges for guest applications.The configuration can be provided using the Context.Builder class when constructing a new context.The following access parameters may be configured:  Allow access to other languages using allowPolyglotAccess.  Allow and customize access to host objects using allowHostAccess.  Allow and customize host lookup to host types using allowHostClassLookup. Allows the guest application to look up the host application classes permitted by the lookup predicate. For example, a Javascript context can create a Java ArrayList, provided that ArrayList is allowlisted by the classFilter and access is permitted by the host access policy: context.eval(&quot;js&quot;, &quot;var array = Java.type(&#39;java.util.ArrayList&#39;)&quot;)  Allow host class loading using allowHostClassLoading. Classes are only accessible if access to them is granted by the host access policy.  Allow the creation of threads using allowCreateThread.  Allow access to native APIs using allowNativeAccess.  Allow access to IO using allowIO and proxy file accesses using fileSystem.Note: Granting access to class loading, native APIs, or host I/O effectively grants all access, as these privileges can be used to bypass other access restrictions.Build Native Images from Polyglot ApplicationsPolyglot embeddings can also be compiled ahead-of-time using Native Image.By default, no language is included if the Polyglot API is used.To enable guest languages, the --language:&amp;lt;languageId&amp;gt; (e.g., --language:js) option needs to be specified.Currently, it is required to set the --initialize-at-build-time option when building a polyglot native image.All examples on this page can be converted to native executables with the native-image builder.The following example shows how a simple HelloWorld JavaScript application can be built using native-image:javac HelloPolyglot.javanative-image --language:js --initialize-at-build-time -cp . HelloPolyglot./HelloPolyglotIt should be mentioned that you can also include a guest language into the native image, but exclude the JIT compiler by passing the -Dtruffle.TruffleRuntime=com.oracle.truffle.api.impl.DefaultTruffleRuntime option to the builder.Be aware, the flag -Dtruffle.TruffleRuntime=com.oracle.truffle.api.impl.DefaultTruffleRuntime has to placed after all the Truffle language/tool options, so that it will override the default settings.You can build the above example again but this time the created image will only contain the Truffle language interpreter (the GraalVM compiler will not be included in the image) by running:native-image --language:js -Dtruffle.TruffleRuntime=com.oracle.truffle.api.impl.DefaultTruffleRuntime --initialize-at-build-time -cp . HelloPolyglotInterpreterConfiguring Native Host ReflectionAccessing host Java code from the guest application requires Java reflection in order to work.When reflection is used within a native image, the reflection configuration file is required.For this example we use JavaScript to show host access with native executables.Copy the following code in a new file named AccessJavaFromJS.java.import org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;import java.util.concurrent.*;public class AccessJavaFromJS {    public static class MyClass {        public int               id    = 42;        public String            text  = &quot;42&quot;;        public int[]             arr   = new int[]{1, 42, 3};        public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;    }    public static void main(String[] args) {        try (Context context = Context.newBuilder()                                   .allowAllAccess(true)                               .build()) {            context.getBindings(&quot;js&quot;).putMember(&quot;javaObj&quot;, new MyClass());            boolean valid = context.eval(&quot;js&quot;,                   &quot;    javaObj.id         == 42&quot;          +                   &quot; &amp;amp;&amp;amp; javaObj.text       == &#39;42&#39;&quot;        +                   &quot; &amp;amp;&amp;amp; javaObj.arr[1]     == 42&quot;          +                   &quot; &amp;amp;&amp;amp; javaObj.ret42()    == 42&quot;)               .asBoolean();            System.out.println(&quot;Valid &quot; + valid);        }    }}Copy the following code into reflect.json:[  { &quot;name&quot;: &quot;AccessJavaFromJS$MyClass&quot;, &quot;allPublicFields&quot;: true },  { &quot;name&quot;: &quot;java.util.concurrent.Callable&quot;, &quot;allPublicMethods&quot;: true }]Now you can create a native executable that supports host access:javac AccessJavaFromJS.javanative-image --language:js --initialize-at-build-time -H:ReflectionConfigurationFiles=reflect.json -cp . AccessJavaFromJS./accessjavafromjsNote that in case assertions are needed in the image, the -H:+RuntimeAssertions option can be passed to native-image.For production deployments, this option should be omitted.Code Caching Across Multiple ContextsThe GraalVM Polyglot API allows code caching across multiple contexts.Code caching allows compiled code to be reused and allows sources to be parsed only once.Code caching can often reduce memory consumption and warm-up time of the application.By default, code is cached within a single context instance only.To enable code caching between multiple contexts, an explicit engine needs to be specified.The engine is specified when creating the context using the context builder.The scope of code sharing is determined by the engine instance.Code is only shared between contexts associated with one engine instance.All sources are cached by default.Caching may be disabled explicitly by setting cached(boolean cached) to false. Disabling caching may be useful in case the source is known to only be evaluated once.Consider the following code snippet as an example:import org.graalvm.polyglot.*;public class Main {    public static void main(String[] args) {        try (Engine engine = Engine.create()) {            Source source = Source.create(&quot;js&quot;, &quot;21 + 21&quot;);            try (Context context = Context.newBuilder()                .engine(engine)                .build()) {                    int v = context.eval(source).asInt();                    assert v == 42;            }            try (Context context = Context.newBuilder()                .engine(engine)                .build()) {                    int v = context.eval(source).asInt();                    assert v == 42;            }        }    }}In this code:   import org.graalvm.polyglot.* imports the base API for the Polyglot API.  Engine.create() creates a new engine instance with the default configuration.  Source.create() creates a source object for the expression “21 + 21”with “js” language, which is the language identifier for JavaScript.  Context.newBuilder().engine(engine).build() builds a new context withan explicit engine assigned to it. All contexts associated with an engine share the code.  context.eval(source).asInt() evaluates the source and returns the result as Value instance.Build a Shell for Many LanguagesWith just a few lines of code, the GraalVM Polyglot API lets you buildapplications that integrate with any guest language supported by GraalVM.This shell implementation is agnostic to any particular guest language.BufferedReader input = new BufferedReader(new InputStreamReader(System.in));PrintStream output = System.out;Context context = Context.newBuilder().allowAllAccess(true).build();Set&amp;lt;String&amp;gt; languages = context.getEngine().getLanguages().keySet();output.println(&quot;Shell for &quot; + languages + &quot;:&quot;);String language = languages.iterator().next();for (;;) {    try {        output.print(language + &quot;&amp;gt; &quot;);        String line = input.readLine();        if (line == null) {            break;        } else if (languages.contains(line)) {            language = line;            continue;        }        Source source = Source.newBuilder(language, line, &quot;&amp;lt;shell&amp;gt;&quot;)                        .interactive(true).buildLiteral();        context.eval(source);    } catch (PolyglotException t) {        if(t.isExit()) {            break;        }        t.printStackTrace();    }}Step Through with Execution ListenersThe GraalVM Polyglot API allows users to instrument the execution of guest languages through ExecutionListener class. For example, it lets you attach an execution listener that is invoked for every statement of the guest language program. Execution listenersare designed as simple API for polyglot embedders and may become handy in, e.g., single-stepping through the program.import org.graalvm.polyglot.*;import org.graalvm.polyglot.management.*;public class ExecutionListenerTest {    public static void main(String[] args) {        try (Context context = Context.create(&quot;js&quot;)) {            ExecutionListener listener = ExecutionListener.newBuilder()                      .onEnter((e) -&amp;gt; System.out.println(                              e.getLocation().getCharacters()))                      .statements(true)                      .attach(context.getEngine());            context.eval(&quot;js&quot;, &quot;for (var i = 0; i &amp;lt; 2; i++);&quot;);            listener.close();        }    }}In this code:  The Context.create() call creates a new context for the guest language.  Create an execution listener builder by invoking ExecutionListeners.newBuilder().  Set onEnter event to notify when element’s execution is entered and consumed. At least one event consumer and one filtered source element needs to be enabled.  To complete the listener attachment, attach() needs to be invoked.  The statements(true) filters execution listeners to statements only.  The context.eval() call evaluates a specified snippet of guest language code.  The listener.close() closes a listener earlier, however execution listeners are automatically closed with the engine.Enterprise Sandbox Resource LimitsThe 20.3 release of GraalVM introduced the experimental Sandbox Resource Limits feature that allows for the limiting of resources used by guest applications.These resource limits are not available in the community edition of GraalVM.The following document describes how to configure sandbox resource limits using options in the polyglot APIIn general all resource limit options are prefixed with sandbox option group and they can be listed using the help of any language launcher provided in GraalVM e.g. js --help:tools.Polyglot options can be provided through the language launcher, using the polyglot embedding API of the Graal SDK, or on the JVM using a system property.For better understanding of the examples it is recommended to read the polyglot embedding guide of the reference manual first.Currently all sandbox options are experimental therefore in these examples it is assumed that experimental options are enabled (e.g. with --experimental-options).The options are a best effort approach to limiting resource usage of guest applications.The resource limits may be configured using the following options:  --sandbox.MaxStatements=&amp;lt;long&amp;gt; Limit the maximum number of guest language statements.  --sandbox.MaxStatementsIncludeInternal=&amp;lt;boolean&amp;gt; Whether to include internal sources in the max statements computation.  --sandbox.MaxCPUTime=&amp;lt;duration&amp;gt; Limit the total maximum CPU time that was spent running the application.  --sandbox.MaxCPUTimeCheckInterval=&amp;lt;duration&amp;gt; Time interval to check the active CPU time for a context.  --sandbox.MaxStackFrames=&amp;lt;int&amp;gt; Limits the maximum number of guest stack frames.  --sandbox.MaxThreads=&amp;lt;int&amp;gt; Limit the number of threads that can be concurrently used by a context.  --sandbox.MaxASTDepth=&amp;lt;int&amp;gt; Limit the maximum depth of AST nodes for a guest language function.  --sandbox.MaxHeapMemory=&amp;lt;size&amp;gt; Specifies the maximum heap memory that can be retained by the application during its run.  --sandbox.AllocatedBytesCheckInterval=&amp;lt;duration&amp;gt; Time interval to check allocated bytes for an execution context. Exceeding certain number of allocated bytes triggers computation of bytes retained in the heap by the context.  --sandbox.AllocatedBytesCheckEnabled=&amp;lt;boolean&amp;gt; Specifies whether checking of allocated bytes for an execution context is enabled. If disabled, retained size checking for the context can be triggered only by the low memory trigger.  --sandbox.AllocatedBytesCheckFactor=&amp;lt;factor&amp;gt; Specifies a factor of MaxHeapMemory the allocation of which triggers retained heap memory computation. When allocated bytes for an execution context reach the specified factor, computation of bytes retained in the heap by the context is initiated.  --sandbox.RetainedBytesCheckInterval=&amp;lt;duration&amp;gt; Specifies the minimum time interval between two computations of retained bytes in the heap for a single execution context.  --sandbox.RetainedBytesCheckFactor=&amp;lt;factor&amp;gt; Specifies a factor of total heap memory of the host VM the exceeding of which stops the world. When the total number of bytes allocated in the heap for the whole host VM exceeds the factor, the following process is initiated. Execution for all engines with at least one memory-limited execution context (one with sandbox.MaxHeapMemory set) is paused. Retained bytes in the heap for each memory-limited context are computed. Contexts exceeding their limits are cancelled. The execution is resumed. All contexts using the sandbox.MaxHeapMemory option must use the same value for sandbox.RetainedBytesCheckFactor.  --sandbox.UseLowMemoryTrigger=&amp;lt;boolean&amp;gt; Specifies whether stopping the world is enabled. If enabled, engines with at least one memory-limited execution context are paused when the total number of bytes allocated in the heap for the whole host VM exceeds the specified factor of total heap memory of the host VM. If disabled, retained size checking for memory-limited execution contexts can be triggered only by the allocated bytes checker. All contexts using the sandbox.MaxHeapMemory option must use the same value for sandbox.UseLowMemoryTrigger.Different configurations may be provided for each polyglot embedding Context instance.In addition to that the limits may be reset at any point of time during the execution. Resetting is only aplicable to sandbox.MaxStatements and sandbox.MaxCPUTime.A guest language might choose to create an inner context within the outer execution context. The limits are applied to the outer context and all inner contexts it spawns. It is not possible to specify a separate limit for inner contexts and it is also not possible to escape any limit by creating an inner context.Limiting the active CPU timeThe sandbox.MaxCPUTime option allows you to specify the maximum CPU time spent running the application.The maximum CPU time specifies how long a context can be active until it is automatically cancelled and the context is closed.By default the time limit is checked every 10 milliseconds.This can be customized using the sandbox.MaxCPUTimeCheckInterval option.Both maximum CPU time limit and check interval must be positive.By default no CPU time limit is enforced.If the time limit is exceeded then the polyglot context is cancelled and the execution stops by throwing a PolyglotException which returns true for isResourceExhausted().As soon as the time limit is triggered, no further application code can be executed with this context.It will continuously throw a PolyglotException for any method of the polyglot context that will be invoked.The used CPU time of a context typically does not include time spent waiting for synchronization or IO.The CPU time of all threads will be added and checked against the CPU time limit.This can mean that if two threads execute the same context then the time limit will be exceeded twice as fast.The time limit is enforced by a separate high-priority thread that will be woken regularly.There is no guarantee that the context will be cancelled within the accuracy specified.The accuracy may be significantly missed, e.g. if the host VM causes a full garbage collection.If the time limit is never exceeded then the throughput of the guest context is not affected.If the time limit is exceeded for one context then it may slow down the throughput for other contexts with the same explicit engine temporarily.Available units to specify time durations are ms for milliseconds, s for seconds, m for minutes, h for hours and d for days.It is not allowed specify negative values or no time unit with CPU time limit options.Example Usagetry (Context context = Context.newBuilder(&quot;js&quot;)                           .experimentalOptions(true)                           .option(&quot;sandbox.MaxCPUTime&quot;, &quot;500ms&quot;)                           .option(&quot;sandbox.MaxCPUTimeCheckInterval&quot;, &quot;5ms&quot;)                       .build();) {    try {        context.eval(&quot;js&quot;, &quot;while(true);&quot;);        assert false;    } catch (PolyglotException e) {        // triggered after 500ms;        // context is closed and can no longer be used        // error message: Maximum CPU time limit of 500ms exceeded.        assert e.isCancelled();        assert e.isResourceExhausted();    }}Limiting the number of executed statementsSpecifies the maximum number of statements a context may execute until the the context will be cancelled.After the statement limit was triggered for a context, it is no longer usable and every use of the context will throw a PolyglotException that returns true for PolyglotException.isCancelled().The statement limit is independent of the number of threads executing and is applied per context.It is also possible to specify this limit using the ResourceLimits API of the polyglot embedding API.By default there is no statement limit applied. The limit may be set to a negative number to disable it.Whether this limit is applied internal sources only can be configured using sandbox.MaxStatementsIncludeInternal.By default the limit does not include statements of sources that are marked internal.If a shared engine is used then the same internal configuration must be used for all contexts of an engine.The maximum statement limit can be configured for each context of an engine separately.Attaching a statement limit to a context reduces the throughput of all guest applications with the same engine.The statement counter needs to be updated with every statement that is executed.It is recommended to benchmark the use of the statement limit before it is used in production.The complexity of a single statement may not be constant time depending on the guest language.For example, statements that execute JavaScript builtins, like Array.sort, may account for a single statement, but its execution time is dependent on the size of the array.The statement count limit is therefore not suitable to perform time boxing and must be combined with other more reliable measures like the CPU time limit.try (Context context = Context.newBuilder(&quot;js&quot;)                           .experimentalOptions(true)                           .option(&quot;sandbox.MaxStatements&quot;, &quot;2&quot;)                           .option(&quot;sandbox.MaxStatementsIncludeInternal&quot;, &quot;false&quot;)                       .build();) {    try {        context.eval(&quot;js&quot;, &quot;purpose = 41&quot;);        context.eval(&quot;js&quot;, &quot;purpose++&quot;);        context.eval(&quot;js&quot;, &quot;purpose++&quot;); // triggers max statements        assert false;    } catch (PolyglotException e) {        // context is closed and can no longer be used        // error message: Maximum statements limit of 2 exceeded.        assert e.isCancelled();        assert e.isResourceExhausted();    }}Limiting the AST depth of functionsA limit on the maximum expression depth of a guest language function.Only instrumentable nodes count towards the limit.If the limit is exceeded, evaluation of the code fails and the context is canceled.The AST depth can give an estimate of the complexity of a function as well as its stack frame size.Limiting the AST depth can serve as a safeguard against arbitrary stack space usage by a single function.Limiting the number of stack framesSpecifies the maximum number of frames a context can push on the stack.Exceeding the limit results in cancellation of the context.A thread-local stack frame counter is incremented on function enter and decremented on function return.Resetting resource limits does not affect the stack frame counter.The stack frame limit in itself can serve as a safeguard against infinite recursion.If used together with the AST depth limit it can be used to estimate total stack space usage.Limiting the number of active threadsLimits the number of threads that can be used by a context at the same point in time.By default, an arbitary number of threads can be used.If a set limit is exceeded, entering the context fails with a PolyglotException and the polyglot context is canceled.Resetting resource limits does not affect thread limits.Limiting the maximum heap memoryThe sandbox.MaxHeapMemory option allows you to specify the maximum heap memory the application is allowed to retain during its run.sandbox.MaxHeapMemory must be positive. This option is only supported on a HotSpot-based VM. Enabling this option in AOT mode will result in PolyglotException.When exceeding of the limit is detected, the corresponding context is automatically cancelled and then closed.The efficacy of this option (also) depends on the garbage collector used.Example Usagetry (Context context = Context.newBuilder(&quot;js&quot;)                           .experimentalOptions(true)                           .option(&quot;sandbox.MaxHeapMemory&quot;, &quot;100MB&quot;)                       .build()) {    try {        context.eval(&quot;js&quot;, &quot;var r = {}; var o = r; while(true) { o.o = {}; o = o.o; };&quot;);        assert false;    } catch (PolyglotException e) {        // triggered after the retained size is greater than 100MB;        // context is closed and can no longer be used        // error message: Maximum heap memory limit of 104857600 bytes exceeded. Current memory at least...        assert e.isCancelled();        assert e.isResourceExhausted();    }}Implementation details and expert optionsThe limit is checked by retained size computation triggered either based on allocated bytes or onlow memory notification.The allocated bytes are checked by a separate high-priority thread that will be woken regularly. There is one such thread for each memory-limited context (one with sandbox.MaxHeapMemory set).The retained bytes computation is done by yet another high-priority thread that is started from the allocated bytes checking thread as needed. The retained bytes computation thread also cancels the context if the heap memory limit is exeeded. Additionaly, when low memory trigger is invoked,all contexts on engines with at least one memory-limited context are paused together with their allocation checkers. All individual retained size computations are cancelled.Retained bytes in the heap for each memory-limited context are computed by a single high-priority thread. Contexts exceeding their limits are cancelled, and then the execution is resumed.The main goal of the heap memory limits is to prevent heap memory depletion related errors in most cases and thus enable the host VM to run smoothly even in the presence of misbehaving contexts.The implementation is best effort. This means that there is no guarantee on the accuracy of the heap memory limit. There is also no guarantee that setting a heap memory limit will prevent the context from causing OutOfMemory errors.Guest applications that allocate many objects in quick succession have a lower accuracy than applications which allocate objects rarely.The guest code execution will only be paused if the host heap memory is exhausted and a low memory trigger of the host VM is invoked. Note that the scope of the pause is an engine, so a context without the sandbox.MaxHeapMemory option set is also paused in case it shares the engine with other context that is memory-limited.Also note that if one context is cancelled other contexts with the same explicit engine may be slowed down. How the size retained by a context is computed can becustomized using the expert options sandbox.AllocatedBytesCheckInterval, sandbox.AllocatedBytesCheckEnabled, sandbox.AllocatedBytesCheckFactor, sandbox.RetainedBytesCheckInterval, sandbox.RetainedBytesCheckFactor, and sandbox.UseLowMemoryTrigger described below.Retained size computation for a context is triggered when a retained bytes estimate exceeds a certain factor of specified sandbox.MaxHeapMemory. The estimate is based on heap memoryallocated by threads where the context has been active.More precisely, the estimate is the result of previous retained bytes computation, if available, plus bytes allocated since the start of the previous computation.By default the factor of sandbox.MaxHeapMemory is 1.0 and it can be customized by the sandbox.AllocatedBytesCheckFactor option. The factor must be positive.For example, let sandbox.MaxHeapMemory be 100MB and sandbox.AllocatedBytesCheckFactor be 0.5. The retained size computation is first triggered when allocated bytes reach 50MB.Let the computed retained size be 25MB, then the next retained size computation is triggered when additional 25MB is allocated, etc.By default, allocated bytes are checked every 10 milliseconds. This can be configured by sandbox.AllocatedBytesCheckInterval. The smallest possible interval is 1ms. Any smaller value is interpreted as 1ms.The beginnings of two retained size computations of the same context must be by default at least 10 milliseconds apart.This can be configured by the sandbox.RetainedBytesCheckInterval option. The interval must be positive.The allocated bytes checking for a context can be disabled by the sandbox.AllocatedBytesCheckEnabled option. By default it is enabled (“true”). If disabled (“false”),retained size checking for the context can be triggered only by the low memory trigger.When the total number of bytes allocated in the heap for the whole host VM exceeds a certain factor of the total heap memory of the VM, low memory notification is invoked and initiates the following process.The execution for all engines with at least one execution context which has the sandbox.MaxHeapMemory option set is paused,retained bytes in the heap for each memory-limited context are computed, contexts exceeding their limits are cancelled, and then the execution is resumed.The default factor is 0.7. This can be configuted by the sandbox.RetainedBytesCheckFactor option. The factor must be between 0.0 and 1.0. All contexts using the sandbox.MaxHeapMemory option must use the same value for sandbox.RetainedBytesCheckFactor.The described low memory trigger can be disabled by the sandbox.UseLowMemoryTrigger option. By default it is enabled (“true”). If disabled (“false”),retained size checking for the execution context can be triggered only by the allocated bytes checker. All contexts using the sandbox.MaxHeapMemory option must use the same value for sandbox.UseLowMemoryTrigger.If exceeding of the heap memory limit is detected then the polyglot context is cancelled and the execution stops by throwing a PolyglotException which returns true for isResourceExhausted().As soon as the memory limit is triggered, no further application code can be executed with this context.It will continuously throw a PolyglotException for any method of the polyglot context that will be invoked.Available units to specify time durations are ms for milliseconds, s for seconds, m for minutes, h for hours and d for days.It is not allowed to specify negative values or no time unit with max heap memory options.Available units to specify sizes are B for bytes, KB for kilobytes, MB for megabytes, and GB for gigabytes.It is not allowed to specify negative values or no size unit with max heap memory options.Resetting resource limits using Context.resetLimits does not affect the heap memory limit.Resetting Resource LimitsWith the polyglot embedding API it is possible to reset the limits at any point in time using the Context.resetLimits method.This can be useful if a known and trusted initialization script should be excluded from limit. Resetting the limits is not applicable to all limits.Example Usagetry (Context context = Context.newBuilder(&quot;js&quot;)                           .experimentalOptions(true)                           .option(&quot;sandbox.MaxCPUTime&quot;, &quot;500ms&quot;)                       .build();) {    try {        context.eval(&quot;js&quot;, /*... initialization script ...*/);        context.resetLimits();        context.eval(&quot;js&quot;, /*... user script ...*/);        assert false;    } catch (PolyglotException e) {        assert e.isCancelled();        assert e.isResourceExhausted();    }}",
                    "url": " /reference-manual/embed-languages/"
                  },
                  
                  "java-on-truffle":  {
                    "title": "",
                    "content": "",
                    "url": " /java-on-truffle/"
                  },
                  
                  "community-events":  {
                    "title": "",
                    "content": "",
                    "url": " /community/events/"
                  },
                  
                  "examples":  {
                    "title": "",
                    "content": "Example ApplicationsHere you will find example applications written in Java, JavaScript, R, Ruby, and other JVM languages to illustrate the diverse capabilities of GraalVM.The GraalVM compiler, enabled by default in GraalVM, assures performance advantages for highly abstracted programs due to its versatile optimization techniques.Code using more abstraction and modern Java features like Streams or Lambdas will see even greater speedups.Java Performance Examples and Java stream API Benchmark demonstrate this.The Polyglot JavaScript, Java, R Example Application displays GraalVM’s abilities as a polyglot runtime, processing programs written in two or more languages.The Native Image Examples illustrate GraalVM’s unique capabilities to create self-contained executable images that run remarkably fast.Here you can also find an even more sophisticated example of polyglot native executables.The Java/Kotlin Native Image Example demonstrates how to compile a Java and Kotlin application ahead-of-time, and illustrates the performance gain.",
                    "url": " /examples/"
                  },
                  
                  "reference-manual-ruby-faq":  {
                    "title": "",
                    "content": "Frequently Asked QuestionsWhat is TruffleRuby?TruffleRuby is a high-performance implementation of the Ruby programming language built on GraalVM using the Truffle languageimplementation framework and the GraalVM compiler.TruffleRuby is one part of GraalVM, a platform for high-performance polyglot programming.What is Truffle?The Truffle language implementation framework is a Java framework for writing AST interpreters.To implement a language using Truffle, you write an AST for your language and add methods to interpret – perform the action of – each node.Truffle also incorporates the concept of specialization.In most AST interpreters the nodes are megamorphic – they handle all possible types and other possible conditions.In the Truffle framework you write several different nodes for the same semantic action, but for different types and conditions.As runtime conditions change, you switch which nodes you are using.After the program has warmed up you should end up with an AST that is precisely tailored for the types and conditions that you are actually using.If these conditions change, you can just switch nodes again.What is the GraalVM compiler?The GraalVM compiler is a new implementation of a just-in-time compiler (JIT compiler, or we’d normally say dynamic compiler) in the OpenJDK Java Virtual Machine.Unlike the current compilers, Graal is written in Java, and exposes a Java API to the running program.This means that instead of emitting bytecode, a JVM language can directly control the compiler.However this is complicated, so normally the Truffle framework uses the GraalVM compiler on your behalf to partially evaluate your AST interpreter into machine code.What is GraalVM?GraalVM is the platform on which TruffleRuby runs. It is a system for high-performance polyglot programming.More concretely, GraalVM is a modified version of the OracleJDK that includes the Truffle framework, the GraalVM compiler, TruffleRuby, and other languages supported by GraalVM including JavaScript, Python, and R.See how to install GraalVM and TruffleRuby.How do I get TruffleRuby?There are three ways to get TruffleRuby. Please see Getting Started.Why is TruffleRuby slow on a standard JVM?The expected way to run TruffleRuby is using the GraalVM compiler.TruffleRuby isn’t designed to be efficient on a JVM without this.Why is TruffleRuby faster on the GraalVM?When running with the GraalVM compiler, the Truffle framework can use the API exposed by the GraalVM compiler.The Truffle framework gets the bytecode representation of all of the AST interpreter methods involved in running your Ruby method, combines them into something like a single Java method, optimizes them together, and emits a single machine code function.The Truffle framework also provides wrappers for JVM functionality not normally available to Java applications, such as code deoptimization.TruffleRuby uses this to provide a dramatically simpler and faster implementation of Ruby.Where did this code come from?Chris Seaton wrote an implementation of Ruby on Truffle and Graal as part of an internship at Oracle Labs in the first half of 2013. The code was merged into JRuby in early 2014. Benoit Daloze and Kevin Menard joined as researchers in the second half of 2014, then Petr Chalupa in 2015, Brandon Fish in 2016, and Duncan MacGregor in 2017.Since then we have also accepted contributions from people outside Oracle Labs.In 2017 the code was forked back out of JRuby after it had matured.Who do I ask about TruffleRuby?See the Contact section of this README page.How do I know if I’m using TruffleRuby?RUBY_ENGINE will be &#39;truffleruby&#39;.How do I know if I’m using a VM that has the GraalVM compiler?ruby --version will report GraalVM CE or EE.Also, TruffleRuby.jit? will tell you if you are running with the GraalVM compiler.How do I know that I’m using the Community Edition of GraalVM?ruby --version will report GraalVM CE.How do I know that I’m using the Enterprise Edition of GraalVM?ruby --version will report GraalVM EE.How do I know that I’m using the native version of TruffleRuby?ruby --version will report Native.TruffleRuby.native? will return true.How can I see the GraalVM compiler is working?Put this program into test.rb:loop do  14 + 2endWe’ll use the --engine.TraceCompilation to ask the Truffle framework to tell us when it compiles something using the GraalVM compiler.ruby --engine.TraceCompilation test.rb[truffle] opt done         block in &amp;lt;main&amp;gt; test.rb:1 &amp;lt;opt&amp;gt; &amp;lt;split-3a9ffa1b&amp;gt;         |ASTSize       8/    8 |Time   103(  99+4   )ms |DirectCallNodes I    0/D    0 |GraalNodes    24/    3 |CodeSize           69 |CodeAddress 0x11245cf50 |Source   ../test.rb:1Here you can see that Truffle has decided to use the GraalVM compiler to compile the block of 127 - the loop to machine code - just 69 bytes of machine code in all.Why doesn’t TruffleRuby perform well for my benchmark?Benchmarks that we haven’t looked at yet may require new code paths to be specialized.Currently we’ve added specialization for the code paths in the benchmarks and applications that we’ve been using.Adding them is generally not complicated and over time we will have specializations to cover a broad range of applications.Make sure that you are using the Enterprise Edition of GraalVM, and have rebuilt the executable images for the best performance.How is this related to invokedynamic?TruffleRuby doesn’t use invokedynamic, as it doesn’t emit bytecode.However it does have an optimizing method dispatch mechanism that achieves a similar result.Why doesn’t JRuby switch to Truffle as well?JRuby is taking a different approach to optimizing and adding new functionality to Ruby.Both JRuby and TruffleRuby are important projects.Why did you fork from JRuby?We merged into JRuby in order to be able to use large parts of their Java implementation code.We forked back out of JRuby when we had reached the point where the code that we were using needed to be modified for our purposes and we no longer had any dependency on the core part of JRuby.Forking also allowed us to simplify our code base.",
                    "url": " /reference-manual/ruby/FAQ/"
                  },
                  
                  "faq":  {
                    "title": "",
                    "content": "How is GraalVM licensed?GraalVM is distributed as Community and Enterprise editions.GraalVM Community Edition is open source software built from the sourcesavailable on GitHub and distributed underversion 2 of the GNU General Public  License with the “Classpath” Exception, which are the same terms as for Java. We alsorecommend checking the licenses ofthe individual GraalVM components (which are generally derivative of the license of a particular language).GraalVM Community is free to use for any purpose and comes with no strings attached, but also no guarantees orsupport.Oracle GraalVM Enterprise Edition is licensed under the Oracle Technology Network License Agreement for GraalVM Enterprise Edition for testing, evaluation, or for developing non-production applications.For production use, GraalVM Enterprise is available under the Oracle Java SE Subscription Licensing and Support terms. Subscribers to Oracle Java SE Subscription and Oracle Java SE Desktop Subscription are entitled to use GraalVM Enterprise at no additional cost. Read more here.What does the GraalVM Enterprise subscription include?The Oracle Java SE Subscription provides licensing and support for GraalVM Enterprise use on premises, and includes:  Oracle premier support 24x7 by the Oracle GraalVM team  Access to My Oracle Support (MOS)  Java SE Subscription or Java Desktop Subscription at no extra cost  Improved performance and security over GraalVM Community (see GraalVM Enterprise Announcement)For Oracle Cloud customers, GraalVM Enterprise is included in the Oracle Cloud subscription.Where should bugs, security issues, or enhancement requests be reported?Any security vulnerabilities in either GraalVM Community or GraalVM Enterprise should only be reported via email to secalert_us@oracle.com.Please consult our Reporting Vulnerabilities guide for more information on reporting security vulnerabilities.Do not report security issues on GitHub Issues.Please report any bugs or enhancement requests for GraalVM Community using GitHub Issues.GraalVM Enterprise bugs or enhancement requests should be reported using My Oracle Support.How do I contribute to GraalVM?We welcome contributions to GraalVM from the community and are thankful for past contributions both big and small. We are happy to accept pull requests at GitHub Pulls.We require contributors to sign the Oracle Contributor Agreement.How can I receive updates about GraalVM?We maintain three mailing lists:  graalvm-announce@oss.oracle.com – a low traffic announcement list used by the project maintainers;  graalvm-users@oss.oracle.com – an open source user mailing list for general questions and discussions;  graalvm-dev@oss.oracle.com – a list for contributors and language implementors.Additional ways to stay up-to-date with GraalVM development is to track GraalVMat Medium blogging platform, follow the @graalvmTwitter handle, watch the github.com/oracle/graal repository.How do I get support updates?Comprehensive GraalVM Enterprise support is provided by the Oracle GraalVM team via My Oracle Support.Please verify if support services are activated with your account.What is the “readiness” level of GraalVM Windows support?GraalVM builds for Windows, including all components, are experimental.The Windows distribution includes the JDK with the GraalVM compiler enabled, the functional gu utility to install additional components, JavaScript and Node.js support, and the developer tools(e.g., Chrome inspector based debugger, Profiler, etc.).GraalVM Native Image component needs to be installed with gu as with other distributions.Can I run my existing application with GraalVM?The team behind GraalVM aims for compatibility with existing language implementations.Any application that runs on the Java HotSpot VM will run on GraalVM.This includes the code written in other JVM languages, such as Scala or Kotlin.JavaScript and Node.js are expected to run fully compatible out-of-the-box.LLVM-based languages are fully supported via the LLVM bitcode execution environment.For Ruby, R, and Python we are working on improved compatibility.Specific applications may run.Several third parties have started their own development of GraalVM-based language implementations.We continue to grow the ecosystem of GraalVM languages such that GraalVM can truly “run any language”.What makes GraalVM a true ‘polyglot’ VM?GraalVM can not only run individual languages with competitive performance, it also enables high-performance language interoperability.Languages can access each other’s data structures and call each other’s methods.We avoid costly conversions of data structures and instead allow data structures to be shared between languages. Our tooling is built in language-agnostic ways to unify tasks like debugging or profiling.This simplifies deployment and configuration of the runtime environment.Important VM components like the just-in-time-compiler and garbage collector are all fully shared across alllanguages.What does it mean to run any language ‘anywhere’?GraalVM can run embedded in OpenJDK, Oracle JDK or Node.js platforms, standalone, or embedded in data stores like the Oracle Database.In all scenarios, the same underlying compilation and language execution technology runs in-process and with direct access to data structures of the surrounding system.The separation of logical and physical data layout is a first class principle for GraalVM and enables flexible use of data structures without marshalling costs.We encourage the embedding of GraalVM in other projects and publish APIs for that purpose.We envision a future where high-performance and standardized language execution technology is available without the need for provisioning separate VM deployments.Can I use GraalVM with microservices frameworks?GraalVM can run any Java microservices framework.Several Java microservices frameworks have already accepted the GraalVM Native Image technology as a platform.Examples include: Micronaut, Spring, Helidon, Quarkus.For these frameworks Native Image significantly reduces the startup time and runtime memory requirements.Can GraalVM run Spring applications?GraalVM can run Spring applications, compiled with OpenJDK, OracleJDK or other JVMs.Here is a Spring application example that not only runs on GraalVM, but also applies the R language to visualize a plot of the data, using GraalVM polyglot capabilities.Spring Framework support of Native Image is under active development.The Spring Native project provides an incubating support for compiling Spring applications to native executables using GraalVM Native Image, in order to provide a native deployment option designed to be packaged in lightweight containers.In practice, the target is to support a Spring application (typically a Spring Boot one), unmodified, with GraalVM Native Image.What is the status of IDE integration?GraalVM supports major IDEs, as well as major debugging protocols.Eclipse, NetBeans, IntelliJ IDEA, Visual Studio Code are possible IDEs since they support all languages within one environment.IntelliJ Enterprise edition has strong support for all languages even within one file.GraalVM provides a built-in implementation of Chrome DevTools Protocol, Debug Adapter Protocol (DAP), Language Server Protocol (LSP) which, in addition to debugging JavaScript, even enables debugging of R and Ruby applications, separately or across languages.You can get a multilingual stacktrace that way.What are existing real-world production deployments of GraalVM?Several production deployments of GraalVM exist today.For example, Christian Thalinger from Twitter describes the production deployment of GraalVM at Twitter, how it can help save money via improved performance in his interview Accelerating Processing at Twitter , and how they save money using GraalVM.See others listed in the Use Cases section on GraalVM’s home page.We thank early adopters of our technology who give us feedback on the project and help us develop new features.",
                    "url": " /faq/"
                  },
                  
                  "docs-getting-started":  {
                    "title": "",
                    "content": "Get Started with GraalVMGet started with GraalVM – a high-performance JDK distribution.It is designed to accelerate the execution of applications written in Java and other JVM languages while also providing runtimes for JavaScript, Ruby, Python, and a number of other popular languages.GraalVM’s polyglot capabilities make it possible to mix multiple programming languages in a single application while eliminating any foreign language call costs.Here you will find information about installing GraalVM Community Edition, running basic applications with it, and adding support for accompanying features.Further, you will learn about the polyglot capabilities of GraalVM and see how to build platform-specific native executables of JVM-based applications.If you are new to GraaVM, we recommend starting with Introduction to GraalVM, where you will find information about GraalVM’s architecture, distributions available, supported platforms, core and additional features, and much more.If you have GraalVM already installed and have experience using it, you can skip this getting started guide and proceed to the in-depth Reference Manuals.Install GraalVMGetting GraalVM installed and ready-to-go should take a few minutes.Choose the operating system and proceed to the installation steps:  Linux  Linux AArch64  macOS  WindowsStart Running ApplicationsFor demonstration purposes here, we will use GraalVM Community Edition based on OpenJDK 11.The core distribution of GraalVM includes the JVM, the GraalVM compiler, the LLVM runtime, and JavaScript runtime.Having downloaded and installed GraalVM, you can already run Java, JavaScript, and LLVM-based applications.GraalVM’s /bin directory is similar to that of a standard JDK, but includes a set of additional launchers and utilities:  js a JavaScript launcher  lli a LLVM bitcode launcher  gu the GraalVM Updater tool to install additional language runtimes and utilitiesCheck the versions of the runtimes provided by default:java -versionopenjdk version &quot;11.0.11&quot; 2021-04-20OpenJDK Runtime Environment GraalVM CE 21.1.0 (build 11.0.11+5-jvmci-21.1-b03)OpenJDK 64-Bit Server VM GraalVM CE 21.1.0 (build 11.0.11+5-jvmci-21.1-b03, mixed mode, sharing)js -versionGraalVM JavaScript (GraalVM CE Native 21.1.0)lli --versionLLVM 10.0.0 (GraalVM CE Native 21.1.0)Further below you will find information on how to add other optionally available GraalVM runtimes including Node.js, Ruby, R, Python, and WebAssembly.Run JavaThe java launcher runs the JVM with the GraalVM default compiler - the GraalVM compiler.Take a look at this typical HelloWorld class:public class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}Run the following commands to compile this class to bytecode and then execute it:javac HelloWorld.javajava HelloWorldHello World!You can find a collection of larger Java examples on the Examples Applications page.For more information on the GraalVMcompiler, go to Compiler.For more extensive documentation on running Java, proceed to JVM Languages.Run JavaScript and Node.jsGraalVM can execute plain JavaScript code, both in REPL mode and by executing script files directly:js&amp;gt; 1 + 23GraalVM also supports running Node.js applications.Node.js support is not installed by default, but can be easily added with GraalVM Updater:gu install nodejsnode -vv14.16.1More than 100,000 npm packages are regularly tested and are compatible with GraalVM, including modules like express, react, async, request, browserify, grunt, mocha, and underscore.To install a Node.js module, use the npm executable from the &amp;lt;graalvm&amp;gt;/bin folder, which is installed together with node.The npm command is equivalent to the default Node.js command and supports all Node.js APIs.Install the colors and ansispan modules using npm install. After the modules are installed, you can use them from your application.npm install colors ansispanUse the following code snippet and save it as the app.js file in the same directory where you installed the Node.js modules:const http = require(&quot;http&quot;);const span = require(&quot;ansispan&quot;);require(&quot;colors&quot;);http.createServer(function (request, response) {    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});    response.end(span(&quot;Hello Graal.js!&quot;.green));}).listen(8000, function() { console.log(&quot;Graal.js server running at http://127.0.0.1:8000/&quot;.red); });setTimeout(function() { console.log(&quot;DONE!&quot;); process.exit(); }, 2000);Run app.js on GraalVM Enterprise using the node command:node app.jsFor more detailed documentation and information on compatibility with Node.js,proceed to JavaScript and Node.js.Run LLVM LanguagesThe GraalVM LLVM runtime can execute C/C++, Rust, and other programming language that can be compiled to LLVM bitcode.A native program has to be compiled to LLVM bitcode using an LLVM frontend such as clang.The C/C++ code can be compiled to LLVM bitcode using clang shipped with GraalVM via a prebuilt LLVM toolchain.To set up the LLVM toolchain support:gu install llvm-toolchainexport LLVM_TOOLCHAIN=$(lli --print-toolchain-path)As an example, put this C code into a file named hello.c:#include &amp;lt;stdio.h&amp;gt;int main() {    printf(&quot;Hello from GraalVM!n&quot;);    return 0;}Then compile hello.c to an executable hello with embedded LLVM bitcode and run it as follows:$LLVM_TOOLCHAIN/clang hello.c -o hellolli helloFor in-depth documentation and more examples of running LLVM bitcode on GraalVM, go to LLVM Languages.Run PythonWith GraalVM you can run Python applications in the Python 3 runtime environment.The support is not available by default, but you can quickly add it to GraalVM using the GraalVM Updater tool:gu install pythonOnce it is installed, you can run Python programs:graalpython...&amp;gt;&amp;gt;&amp;gt; 1 + 23&amp;gt;&amp;gt;&amp;gt; exit()More examples and additional information on Python support in GraalVM can be found in the Python reference manual.Run RubyGraalVM provides a high-performance Ruby runtime environment including the gem command that allows you to interact with RubyGems, Ruby Bundler, and much more.The Ruby runtime is not available by default in GraalVM, but can be easily added using the GraalVM Updater tool:gu install rubyOnce it is installed, Ruby launchers like ruby, gem, irb, rake, rdoc, and ri become available to run Ruby programs:ruby [options] program.rbGraalVM Ruby runtime environment uses thesame options as the standard implementation of Ruby,with some additions. For example:gem install chunky_pngruby -r chunky_png -e &quot;puts ChunkyPNG::Color.to_hex(ChunkyPNG::Color(&#39;mintcream @ 0.5&#39;))&quot;#f5fffa80More examples and in-depth documentation can be found in the Ruby reference manual.Run RGraalVM provides a GNU-compatible environment to run R programs directly or in the REPL mode.Although the R language support is not available by default, you can add it to GraalVM using the GraalVM Updater tool:gu install RWhen the language is installed, you can execute R scripts and use the R REPL:RR version 4.0.3 (FastR)...&amp;gt; 1 + 1[1] 2More examples and in-depth documentation can be found in the R reference manual.Run WebAssemblyWith GraalVM you can run programs compiled to WebAssembly.The support is not available by default, but you can add it to GraalVM using the GraalVM Updater tool:gu install wasmThen the wasm launcher, that can run compiled WebAssembly binary code, becomes available.For example, put the following C program in a file named floyd.c:#include &amp;lt;stdio.h&amp;gt;int main() {  int number = 1;  int rows = 10;  for (int i = 1; i &amp;lt;= rows; i++) {    for (int j = 1; j &amp;lt;= i; j++) {      printf(&quot;%d &quot;, number);      ++number;    }    printf(&quot;.n&quot;);  }  return 0;}Compile it using the most recent Emscripten compiler frontend version. It should produce a standalone floyd.wasm file in the current working directory:emcc -o floyd.wasm floyd.cThen you can run the compiled WebAssembly binary on GraalVM as follows:wasm --Builtins=wasi_snapshot_preview1 floyd.wasmMore details can be found in the WebAssembly reference manual.Combine LanguagesGraalVM allows you to call one programming language into another and exchange data between them.To enable interoperability, GraalVM provides the --polyglot flag.For example, running js --jvm --polyglot example.js executes example.js in a polyglot context.If the program calls any code in other supported languages, GraalVM executes that code in the same runtime as the example.js application.For more information on running polyglot applications, see Polyglot Programming.Native ImagesWith GraalVM you can compile Java bytecode into a platform-specific, self-contained, native executable - a native image - to achieve faster startup and a smaller footprint for your application.The Native Image functionality is not available bydefault, but can be easily installed with the GraalVM Updater tool:gu install native-imageThe HelloWorld example from above is used here to demonstrate how to generate a native image:// HelloWorld.javapublic class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}Compile HelloWorld.java to bytecode and then build a native image:javac HelloWorld.javanative-image HelloWorldThe last command generates an executable file named helloworld in the current working directory.Invoking it executes the natively compiled code of the HelloWorld class as follows:./helloworldHello, World!More detailed documentation on this innovative technology is available in the Native Image reference manual.Polyglot Capabilities of Native ImagesGraalVM makes it possible to use polyglot capabilities when building native images.Take this example of a JSON pretty-printer Java program that embeds some JavaScript code:// PrettyPrintJSON.javaimport java.io.*;import java.util.stream.*;import org.graalvm.polyglot.*;public class PrettyPrintJSON {  public static void main(String[] args) throws java.io.IOException {    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));    String input = reader.lines()    .collect(Collectors.joining(System.lineSeparator()));    try (Context context = Context.create(&quot;js&quot;)) {      Value parse = context.eval(&quot;js&quot;, &quot;JSON.parse&quot;);      Value stringify = context.eval(&quot;js&quot;, &quot;JSON.stringify&quot;);      Value result = stringify.execute(parse.execute(input), null, 2);      System.out.println(result.asString());    }  }}Compile it and build a native image for it.The --language:js argument ensures that JavaScript is available in the generated image:javac PrettyPrintJSON.javanative-image --language:js --initialize-at-build-time PrettyPrintJSONThe native image generatation will take several minutes as it does not just build the PrettyPrintJSON class, but also builds JavaScript.Additionally, the image building requires large amounts of physical memory, especially if you build an image with the Truffle language implementation framework included, which is the case here.The resulting executable can now perform JSON pretty-printing:./prettyprintjson &amp;lt;&amp;lt;EOF{&quot;GraalVM&quot;:{&quot;description&quot;:&quot;Language Abstraction Platform&quot;,&quot;supports&quot;:[&quot;combining languages&quot;,&quot;embedding languages&quot;,&quot;creating native images&quot;],&quot;languages&quot;: [&quot;Java&quot;,&quot;JavaScript&quot;,&quot;Node.js&quot;, &quot;Python&quot;, &quot;Ruby&quot;,&quot;R&quot;,&quot;LLVM&quot;]}}EOFHere is the JSON output from the native executable:{  &quot;GraalVM&quot;: {    &quot;description&quot;: &quot;Language Abstraction Platform&quot;,    &quot;supports&quot;: [      &quot;combining languages&quot;,      &quot;embedding languages&quot;,      &quot;creating native images&quot;    ],    &quot;languages&quot;: [      &quot;Java&quot;,      &quot;JavaScript&quot;,      &quot;Node.js&quot;,      &quot;Python&quot;,      &quot;Ruby&quot;,      &quot;R&quot;,      &quot;LLVM&quot;    ]  }}The native image runs much faster than running the same code on the JVM directly:time bin/java PrettyPrintJSON &amp;lt; test.json &amp;gt; /dev/nullreal0m1.101suser0m2.471ssys0m0.237stime ./prettyprintjson &amp;lt; test.json &amp;gt; /dev/nullreal0m0.037suser0m0.015ssys0m0.016sWhat to Read NextNew UsersSince this guide is intended mainly for users new to GraalVM, or users who are familiar with GraalVM but may have little experience using it, please consider investigating more complex Example Applications.We also recommend checking our GraalVM Team Blog.Advanced UsersIf you are mostly interested in GraalVM support for a specific language, or want more in-depth details about GraalVM’s diverse technologies, proceed to Reference Manuals.If you are looking for the tooling support GraalVM offers, proceed to Debugging and Monitoring Tools.If you are considering GraalVM as a platform for your future language or tool implementation, go to GraalVM as a Platform.You can find information on GraalVM’s security model in the Security Guide, and rich API documentation in GraalVM SDK Javadoc and Truffle Javadoc.",
                    "url": " /docs/getting-started/"
                  },
                  
                  "graalvm-as-a-platform":  {
                    "title": "",
                    "content": "GraalVM as a PlatformGraalVM is an open ecosystem and allows users to implement a custom language or tool on top of it with the Truffle language implementation framework which offers APIs for writing interpreters for programming languages in the form of Java programs.GraalVM loads and runs the Truffle framework, which itself is a Java program – a collection of JAR files – together with interpreters.These get optimized at runtime into efficient machine code for executing loaded programs.Learn more about this framework from its reference documentation.Implement Your LanguageWith the Language API offered by the Truffle framework, you can implement a language interpreter on top of GraalVM.To get started, proceed to Implement Your Language.Implement Your ToolWith the Instrument API offered by the Truffle framework, you can create language-agnostic tools like debuggers, profilers, or other instruments on top of GraalVM.To get started, proceed to Implement Your Tool.",
                    "url": " /graalvm-as-a-platform/"
                  },
                  
                  "docs-getting-started-container-images":  {
                    "title": "",
                    "content": "GraalVM Community ImagesContainers can simplify application deployment and development.To support container-based development, GraalVM Community container images for each release are published in the GitHub Container Registry.Learn here how to start using GraalVM Community images for Docker containers.  Having the Docker daemon running, pull the image from GitHub with docker pull:    docker pull ghcr.io/graalvm/graalvm-ce:latest    Alternatively, use as the base image in Dockerfile:    FROM ghcr.io/graalvm/graalvm-ce:latest  There are different GraalVM Community container images provided depending on the architecture and the Java version.GraalVM binaries are built for Linux, macOS, and Windows platforms on x86 64-bit systems, and for Linux on ARM 64-bit systems.The images are multi-arch (aarch64 or amd64 will be pulled depending on Docker host architecture), and named per a platform-jdk-version naming scheme, for example, ghcr.io/graalvm/graalvm-ce:latest:ol8-java11-21.1.0.A complete list can be found on the All versions page.The images are based on Oracle Linux and has GraalVM Community downloaded, unzipped and made available.It means that Java, JavaScript, Node.js and the LLVM runtime are available out of the box.You can start a container and enter the bash session with the following run command:docker run -it --rm ghcr.io/graalvm/graalvm-ce:21.1.0 bashCheck that java, js and other commands work as expected.→ docker run -it --rm ghcr.io/graalvm/graalvm-ce:21.1.0 bashbash-4.4# java -versionopenjdk version &quot;11.0.11&quot; 2021-04-20OpenJDK Runtime Environment GraalVM CE 21.1.0 (build 11.0.11+5-jvmci-21.1-b03)OpenJDK 64-Bit Server VM GraalVM CE 21.1.0 (build 11.0.11+5-jvmci-21.1-b03, mixed mode, sharing)bash-4.4# js -versionGraalVM JavaScript (GraalVM CE Native 21.1.0)&amp;gt; 1 + 12&amp;gt; quit()bash-4.4# lli --versionLLVM 10.0.0 (GraalVM CE Native 21.1.0)bash-4.4#Please note that the image contains only the components immediately available in the GraalVM Community core download.However, the GraalVM Updater utility is on the PATH and you can install the support for additional languages and runtimes like Node.js, Ruby, R, Python or WebAssembly at will.However, the GraalVM Updater, gu, utility is included in the container image and may be used to install additional languages and runtimes like Node.js, Ruby, R, Python or WebAssembly.For example, the following command installs the Ruby support (the output below is truncated for brevity):docker run -it --rm ghcr.io/graalvm/graalvm-ce:21.1.0 bashbash-4.4# gu install rubyDownloading: Component catalogProcessing component archive: Component rubyDownloading: Component ruby[######              ]...Here is a sample command that maps the /absolute/path/to/directory/no/trailing/slash directory from the host system to the /path/inside/container inside the container.docker run -it --rm -v /absolute/path/to/directory/no/trailing/slash:/path/inside/container ghcr.io/graalvm/graalvm-ce:21.1.0 bashIf you want to create Docker images that contain GraalVM with Ruby, R, or Python, you can use a Dockerfile like the example below, which uses ghcr.io/graalvm/graalvm-ce:21.1.0 as the base image, installs the Ruby support using the gu utility, then creates and runs a sample Ruby program.FROM ghcr.io/graalvm/graalvm-ce:21.1.0RUN gu install rubyWORKDIR /workdirRUN echo &#39;puts &quot;Hello from Ruby!nVersion: #{RUBY_DESCRIPTION}&quot;&#39; &amp;gt; app.rbCMD ruby app.rbIf you put the above snippet in a Dockerfile in the current directory, you can build and run it with the following commands:docker build -t ruby-demo ....docker run -it --rm ruby-demoHello from Ruby!Version: truffleruby 21.1.0, like ruby 2.7.2, GraalVM CE Native [x86_64-darwin]",
                    "url": " /docs/getting-started/container-images/"
                  },
                  
                  "release-notes":  {
                    "title": "",
                    "content": "GraalVM Community Release NotesThis section highlights changes to GraalVM Community Edition between releases.GraalVM Community is comprised of different components, changes to which are listed separately.Release notes are grouped in descending order for usability reasons.Consult the GraalVM Community Version Roadmap for information on the updates cadence and release dates.",
                    "url": " /release-notes/"
                  },
                  
                  "release-notes-version-roadmap":  {
                    "title": "",
                    "content": "GraalVM Community Version RoadmapMinor Feature releases of GraalVM Community are produced every three months on a predictable schedule, always on the Tuesday closest to the 17th of the months of February, May, August, and November.Once a new Feature release is made available, it supersedes any previous one.There is an Annual release train for each calendar year numbered 19.x, 20.x, 21.x, etc.Each Annual release train is comprised of a series of minor Feature releases.The final Feature release, e.g., 20.3, is supported for 12 months with bug and vulnerability fixes.Critical Patch Updates (CPU) of GraalVM Community are based on the final GA tagged OpenJDK CPU changes and become available shortly after the OpenJDK CPU.  Release Dates:    Nov 19, 2019: 19.3  Jan 14, 2020: 19.3.1 (CPU)  Feb 18, 2020: 20.0  May 12, 2020: 19.3.2 (CPU)  May 19, 2020: 20.1  Aug 04, 2020: 19.3.3 (CPU)  Aug 18, 2020: 20.2  Nov 03, 2020: 19.3.4 (CPU)  Nov 17, 2020: 20.3  Jan 19, 2021: 21.0.0, 20.3.1, 19.3.5  Apr 20, 2021: 21.1.0, 20.3.2, 19.3.6  Jul 20, 2021: 21.2.0, 20.3.3  Oct 19, 2021: 21.3.0, 20.3.4  Version roadmap for GraalVM Enterprise can be found here.",
                    "url": " /release-notes/version-roadmap/"
                  },
                  
                  "tools-graalvm-insight":  {
                    "title": "",
                    "content": "GraalVM InsightGraalVM Insight is a multipurpose, flexible tool for writing reliablemicroservices solutions that traces program runtime behavior and gathers insights.The dynamic nature of the tool helps users to selectively apply tracing pointcuts onalready running applications with no loss of performance. Insightalso provides detailed access to runtime behavior of a program, allowing users toinspect values and types at invocation or allocation sites. GraalVM Insight further permits users tomodify computed values, interrupt execution, and quickly experiment withbehavioral changes without modifying the application code.This page provides information on GraalVM Insight as of the 20.1 version.To learn about Insight on versions 20.0 and 19.3, proceed here.Note: The GraalVM Insight tool is offered as a technology preview and requires the user topass the --experimental-options option in order to enable the --insightinstrument.Start Using GraalVM Insight  Create a simple source-tracing.js script with the following content:    insight.on(&#39;source&#39;, function(ev) { print(`Loading ${ev.characters.length} characters from ${ev.name}`);});    Having set JAVA_HOME to the GraalVM home directory, start the node launcher withthe --insight tool and observe what scripts are being loaded andevaluated:    $JAVA_HOME/bin/node --experimental-options --insight=source-tracing.js --js.print -e &quot;print(&#39;The result: &#39; + 6 * 7)&quot; | tail -n 10Loading 29938 characters from url.jsLoading 345 characters from internal/idna.jsLoading 12642 characters from punycode.jsLoading 33678 characters from internal/modules/cjs/loader.jsLoading 13058 characters from vm.jsLoading 52408 characters from fs.jsLoading 15920 characters from internal/fs/utils.jsLoading 505 characters from [eval]-wrapperLoading 29 characters from [eval]The result: 42    The source-tracing.js script used the provided insight object toattach a source listener to the runtime. Whenever the script was loaded, thelistener got notified of it and could take an action – printing the length andname of the processed script.  The Insight information can be collected to a print statement or a histogram.The following function-histogram-tracing.js script counts all method invocationsand dumps the most frequent ones when the execution of a program is over:var map = new Map();function dumpHistogram() {    print(&quot;==== Histogram ====&quot;);    var digits = 3;    Array.from(map.entries()).sort((one, two) =&amp;gt; two[1] - one[1]).forEach(function (entry) {        var number = entry[1].toString();        if (number.length &amp;gt;= digits) {            digits = number.length;        } else {            number = Array(digits - number.length + 1).join(&#39; &#39;) + number;        }        if (number &amp;gt; 10) print(`${number} calls to ${entry[0]}`);    });    print(&quot;===================&quot;);}insight.on(&#39;enter&#39;, function(ev) {    var cnt = map.get(ev.name);    if (cnt) {        cnt = cnt + 1;    } else {        cnt = 1;    }    map.set(ev.name, cnt);}, {    roots: true});insight.on(&#39;close&#39;, dumpHistogram);The map is a global variable shared inside of the Insight script that allows thecode to share data between the insight.on(&#39;enter&#39;) function and the dumpHistogramfunction. The latter is executed when the node process execution is over(registered via insight.on(&#39;close&#39;, dumpHistogram). Invoke it as:$JAVA_HOME/bin/node --experimental-options --insight=function-histogram-tracing.js --js.print -e &quot;print(&#39;The result: &#39; + 6 * 7)&quot;The result: 42=== Histogram ===543 calls to isPosixPathSeparator211 calls to E211 calls to makeNodeErrorWithCode205 calls to NativeModule198 calls to uncurryThis154 calls to :=&amp;gt;147 calls to nativeModuleRequire145 calls to NativeModule.compile 55 calls to internalBinding 53 calls to :anonymous 49 calls to :program 37 calls to getOptionValue 24 calls to copyProps 18 calls to validateString 13 calls to copyPrototype 13 calls to hideStackFrames 13 calls to addReadOnlyProcessAlias=================Polyglot TracingThe previous examples were written in JavaScript, but due to GraalVM’s polyglotnature, you can take the same instrument and use it in a program written in,e.g., the Ruby language.  Create the source-trace.js file:    insight.on(&#39;source&#39;, function(ev) {if (ev.uri.indexOf(&#39;gems&#39;) === -1) {  let n = ev.uri.substring(ev.uri.lastIndexOf(&#39;/&#39;) + 1);  print(&#39;JavaScript instrument observed load of &#39; + n);}});    Prepare the helloworld.rb Ruby file:    puts &#39;Hello from GraalVM Ruby!&#39;    Apply the JavaScript instrument to the Ruby program:    $JAVA_HOME/bin/ruby --jvm --polyglot --experimental-options --insight=source-trace.js helloworld.rbJavaScript instrument observed load of helloworld.rbHello from GraalVM Ruby!    It is necessary to start the Ruby launcher with the --polyglot parameter, as the source-tracing.js script remains written in JavaScript.  A user can instrument any language on top of GraalVM, but also the Insight scripts can bewritten in any of the GraalVM supported languages (implemented with the Truffle language implementation framework).  Create the source-tracing.rb Ruby file:    puts &quot;Ruby: Initializing GraalVM Insight script&quot;insight.on(&#39;source&#39;, -&amp;gt;(ev) { name = ev[:name] puts &quot;Ruby: observed loading of #{name}&quot;})puts &#39;Ruby: Hooks are ready!&#39;    Launch a Node.js application and instrument it with the Ruby script:    $JAVA_HOME/bin/node --jvm  --polyglot --experimental-options --insight=source-tracing.rb --js.print -e &quot;print(&#39;With Ruby: &#39; + 6 * 7)&quot; | grep RubyRuby: Initializing GraalVM Insight scriptRuby: Hooks are ready!Ruby: observed loading of internal/per_context/primordials.jsRuby: observed loading of internal/per_context/setup.jsRuby: observed loading of internal/per_context/domexception.js....Ruby: observed loading of internal/modules/cjs/loader.jsRuby: observed loading of vm.jsRuby: observed loading of fs.jsRuby: observed loading of internal/fs/utils.jsRuby: observed loading of [eval]-wrapperRuby: observed loading of [eval]With Ruby: 42  Inspecting ValuesGraalVM Insight not only allows one to trace where the program execution is happening,it also offers access to values of local variables and function arguments duringprogram execution. You can, for example, write an instrument that shows the value ofargument n in the function fib:insight.on(&#39;enter&#39;, function(ctx, frame) {   print(&#39;fib for &#39; + frame.n);}, {   roots: true,   rootNameFilter: (name) =&amp;gt; &#39;fib&#39; === name});This instrument uses the second function argument, frame, to get access to values oflocal variables inside every instrumented function. The above scriptalso uses rootNameFilter to apply its hook only to the function named fib:function fib(n) {  if (n &amp;lt; 1) return 0;  if (n &amp;lt; 2) return 1;  else return fib(n - 1) + fib(n - 2);}print(&quot;Two is the result &quot; + fib(3));When the instrument is stored in a fib-trace.js file and the actual code is infib.js, invoking the following command yields detailed information about theprogram execution and parameters passed between function invocations:$JAVA_HOME/bin/node --experimental-options --insight=fib-trace.js --js.print fib.jsfib for 3fib for 2fib for 1fib for 0fib for 1Two is the result 2To learn more about GraalVM Insight, go to Insight Manual.Documentation on the insight object properties and functions is available as part of the Javadoc.",
                    "url": " /tools/graalvm-insight/"
                  },
                  
                  "reference-manual-graalvm-updater":  {
                    "title": "",
                    "content": "GraalVM UpdaterGraalVM Updater, gu, is a command-line utility to install and manage optional GraalVM language runtimes and utilities.Each of these language runtimes and utilities must be downloaded and installed separately.To assist you with the installation, these are pre-packaged as JAR files and referenced in the documentation as “components”.As of version 21.0.0, GraalVM Updater has become more efficient, and can be used to update your local GraalVM installation to a newer version or upgrade from a Community to Enterprise Edition.Read more in Upgrade GraalVM.GraalVM Updater is included in the base GraalVM distribution and can be used with the &amp;lt;graalvm&amp;gt;/bin/gu launcher.The source code of GraalVM Updater is located in the &amp;lt;graalvm&amp;gt;/lib/installer folder.  Component Installation  Component Uninstallation  Upgrade GraalVM  Installation Configuration  Rebuild Images  GraalVM Updater Commands Overview  Configure Proxies  Replace Components and FilesComponent InstallationThe following GraalVM language runtimes and utilities are available for installation.Tools/Utilities:  Native Image – a technology to compile an application ahead-of-time into a native executable  LLVM toolchain –  a set of tools and APIs for compiling native programs to bitcode that can be executed on GraalVM  Java on Truffle – a Java Virtual Machine implementation based on a Truffle interpreter for GraalVMRuntimes:  Node.js – Node.js 14.16.1 compatible  Python – Python 3.8.5-compatible  Ruby – Ruby 2.7.2-compatible  R – GNU R 3.6.1-compatible  Wasm – WebAssembly (Wasm)GraalVM Updater verifies whether or not the version of a component is appropriate for the current GraalVM installation.Components are released for each GraalVM distribution with respective updates, and those downloaded for previous release(s) cannot be used with newer ones.A component may require other components as prerequisites for its operation.GraalVM Updater verifies such requirements and will either attempt to download the required dependencies, or abort the installation if the component’s requirements are not met.Note: Components intended for Oracle GraalVM Enterprise Edition cannot be installed on GraalVM Community Edition.Three modes of a component installation are supported:Installation from CatalogThere is a components catalog available on GitHub, maintained by Oracle, from which you can install a component by its name.  Get a list of IDs and descriptive names of the components available in the catalog:    gu available    Install the component package using the ComponentId value. For example, for ruby:    gu install ruby    GraalVM Updater first downloads the list of components, then uses theinformation in the list to download the actual component package, then installsit. To see more verbose output during the installation, like the downloadprogress bar, print versions, and dependency information, use the -v(--verbose) switch.  If a component being installed depends on another component, GraalVM Updater willsearch the catalog to find an appropriate dependency and install it as well. Ifthe required components cannot be found, installation will fail.When using custom catalog URLs, it is possible, for a convenience, to setthe environment variable GRAALVM_CATALOG pointing to the custom catalog’s URL.GraalVM Updater will use the URL defined by GRAALVM_CATALOG in preference tothe builtin ones. You may setup the environment variable in startup or profilescripts.Note: If you need, for some reason to set the GRAALVM_HOME environment variable, it may affect gu operation.If it is set, it should point to the intended GraalVM installation, same as JAVA_HOME and PATH.Manual Installation      Download a component from the Oracle GraalVM Downloads page in consideration of the operating system, the Java version, and architecture (if applicable).        Having downloaded the appropriate JAR file, install it with:    gu -L install component.jar    For example, to install Native Image for Java 11 GraalVM Enterprise distribution on macOS, run:    gu -L install native-image-installable-svm-java11-darwin-amd64-&amp;lt;version&amp;gt;.jar  The -L option, equivalent to --local-file or --file, installs a component from a downloaded JAR.However, a component may depend on other components (e.g., Ruby depends on the LLVM toolchain).For example, gu -L install component.jar will fail if the required components are not yet installed.If all dependencies are downloaded into the same directory, you can run:gu -L install -DCheck gu --help or gu -C for how to instruct GraalVM Updater to find and process required components.Installation from Local Components CollectionComponents can be downloaded manually in advance to a local file folder, or to a folder shared on the local network.GraalVM Updater can then use that folder instead of the catalog:gu install -C /path/to/downloads/directory ComponentIdSpecify the directory to use for the components collection. It is possible to typea component’s name (like ruby) instead of a filename. GraalVM Updater will alsoattempt to find required dependencies in the local component collection.When installing components from a given directory, you can allow installing allcomponents which have the correct version number for GraalVM using wildcards:./gu install -C ~/Download/Components/ native*This will install the native-image component, or anything that starts with native.Check Installed ComponentsInstalled components can be printed with:gu listGeneric support for Node.js, R, Ruby, Python, and WebAssembly will work out of the box in most cases.It is recommended to fine-tune system-dependent configurations, following the recommendations in the component post-installation messages.Component UninstallationComponents may be uninstalled from GraalVM when no longer needed.To uninstall a specific component, use its ComponentId. Run gu list to find out the exact ComponentId.The command to uninstall the component is:gu remove rubyIf more components end with, for example, ruby, the installer will print an error message that a component’s full name is required (org.graalvm.ruby).The uninstallation removes the files created during the installation.If a file belongs to multiple components, it will be removed when the last component using it is removed.Note that the LLVM toolchain component may fail uninstallation invoked from the command line or the Visual Studio Code user interface if its dependent component(s) remain installed.In this case, remove the dependent component first, or add the -D option, which would remove dependent components in addition to those explicitly selected:gu -D remove llvm-toolchainUpgrade GraalVMGraalVM Updater has the capability to update the existing GraalVM installation on your local machine to the most recent version.Besides that, it can also upgrade the edition from Community to Enterprise.For example, having GraalVM 20.x installed, update to the most recent available version with:gu upgradeGraalVM Updater will attempt to download the latest version of either GraalVM Enterprise or GraalVM Community Edition, if available.It will not rewrite the existing installation, but unpack it into a new directory and print out the location path.It will also verify if you have any optional components installed in the current GraalVM installation and update those as well.If the “parent” installation contains a symlink to the currrent GraalVM installation, that symlink will be updated.If your setup involves some environment variables (e.g., PATH) pointing to a selected GraalVM installation, those variables should be updated manually.By appending the --edition switch, you can switch editions.For example, to upgrade GraalVM Community Edition to Enterprise, run:gu upgrade --edition eeIt will install the newest version of GraalVM Enterprise Edition, next to the current installation.GraalVM Updater will again check for the optional component presence, verify if a component is appropriate for the installation, and upgrade it as well.Note: You can only upgrade GraalVM to a newer version with GraalVM Updater.The downgrades to an older version, and from GraalVM Enterprise to Community Edition are manual.Installation ConfigurationThe installation command of GraalVM Updater accepts multiple options and parameters, and allows this syntax:gu install [-0cCfFiLnorsuvyxY] param [param ...]The following options are currently supported:  -0, --dry-run: dry run, do not change anything  -c, --catalog: treat parameters as component IDs from the GraalVM components catalog. This is the default  -C, --custom-catalog &amp;lt;url&amp;gt;: use a specific catalog URL to locate components  -L, --local-file: treat parameters as local filenames of packaged components  -f, --force: force overwrite, bypass version checks  -i, --fail-existing: fail on an existing component  -n, --no-progress: do not display the downloading progress  -o, --overwrite: overwrite different files  -r, --replace: replace existing components  -s, --no-verify-jars: skip integrity verification of component archives  -u, --url: interpret parameters as URLs of packaged components  -v, --verbose: be verbose. Prints versions and dependency information  -x, --ignore: ignore failures  -y, --only-validate: do not install, just check compatibility and conflicting files  -Y, --validate-before: download, verify, and check file conflicts before any disk change is madeRebuild ImagesGraalVM components for language runtime support may change. For example:  polyglot native libraries become out of sync.  removed languages runtimes may cause the native binary to fail onmissing resources or libraries.To rebuild and refresh the native binaries, use the following command:gu rebuild-images [--verbose] polyglot|libpolyglot|js|llvm|python|ruby [custom native-image args]GraalVM Updater Commands OverviewCommand-line help is available by running gu or gu -h.  Run gu &amp;lt;command&amp;gt; -h to get help specific for the particular command. For example, gu install -h.GraalVM Updater usage options:  gu info [-cClLnprstuvV] &amp;lt;param&amp;gt;: print the information about specific component (from file, URL, or catalog)  gu available [-aClvV] &amp;lt;expr&amp;gt;: list components available in the catalog  gu install [-0cCDfFiLnorsuvyxY] &amp;lt;param&amp;gt;: install a component package  gu list [-clv] &amp;lt;expression&amp;gt;: list installed components or components from catalog  gu remove [-0Dfxv] &amp;lt;id&amp;gt;: uninstall a component  gu update [-cCnLsux] [&amp;lt;ver&amp;gt;] [&amp;lt;param&amp;gt;]: upgrade to the recent GraalVM version  gu rebuild-images: rebuild native images. Use -h for detailed usage  gu upgrade: install the most recent available version of GraalVM  gu upgrade --edition ee: upgrade from GraalVM Community Edition to the most recent available version of GraalVM Enterprise EditionGraalVM Updater common options:  -A, --auto-yes: say YES or ACCEPT to a question  -c, --catalog: treat parameters as component IDs from the catalog of GraalVM components. This is the default  -C, --custom-catalog &amp;lt;url&amp;gt;: use user-supplied catalog at URL  -e, --debug: enable debugging and print stacktraces  -E, --no-catalog-errors: do not stop if at least one catalog is working  -h, --help: print help  -L, --local-file, --file: treat parameters as local filenames of packaged components  -N, --non-interactive: enable non-interactive mode. Fail when input is required  --show-version: print version information and continue  -u, --url: interpret parameters as URLs of packaged components  -v, --verbose: enable verbose output. Print versions and dependency information  --version: print versionOracle GraalVM Enterprise Edition users might need to pass anadditional verification step to login to the Oracle components repository. GraalVMUpdater tool provides options for that:  --public-key / -k &amp;lt;path&amp;gt;: set the path to a custom GPG public key path  --username/-U: enter a usernameRuntime options:  --native: run using the native launcher with limited Java access (default)  --jvm: run on the Java Virtual Machine with Java access  --vm.[option]: pass options to the host VM. To see available options, use --help:vm  --log.file=&amp;lt;String&amp;gt;: redirect guest languages logging into a given file  --log.[logger].level=&amp;lt;String&amp;gt;: set language log level to OFF, SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST, or ALL  --help: print this help message  --help:vm: print options for the host VMConfigure ProxiesIf GraalVM Updater needs to reach the component catalog, or download a componentpackage, it may need to pass through the HTTP/HTTPS proxy, if the network uses one. OnmacOS, the proxy settings are automatically obtained from the OS. On Linux,ensure that the http_proxy and https_proxy environment variables are setappropriately before launching the gu tool. Refer to the distributionand/or desktop environment documentation for the details.GraalVM Updater intentionally does not support an option to disable certificateor hostname verification, for security reasons. A user may try to add a proxy’scertificate to the GraalVM default security trust store. A user can alsodownload a component manually to a folder, and then use gu -L install /path/to/file or gu -C /path/to/download/dir install component to install from a local filesystem.Working without Internet AccessIf your machine cannot access and download the catalog and components fromthe Internet, either because it is behind a proxy, or for security reasons,GraalVM Updater can install components from a local directory, or a directory ona network share accessible on the target machine.You need to prepare a directory, download all components that you want to installand their dependencies (in case they require other GraalVM components to work) intothat directory.Then you can use gu -L install /path/to/file (where the -L option instructs to use local files,equivalent to --local-file or --file). Adding the -D option will instruct GraalVM Updaterto look for potential dependencies in the directory next to theinstallable file. Additionally, gu -C /path/to/download/dir install component can be used, with the specifieddirectory contents acting as a catalog of components.Note that with gu -L you need to specify the component’s file name, while when using gu -C &amp;lt;dir&amp;gt;, the component name must be used:# Specify file locationgu -LD install /tmp/installables/ruby.jar# Specify component namegu -C /tmp/instalables install rubyReplace Components and FilesA component may be only installed once. GraalVM Updater refuses to install acomponent if a component with the same ID is already installed. However, theinstalled component can be replaced. GraalVM Updater first uninstalls thecomponent and then installs a new package.To replace a component, use the -roption, and the -L (--local-file or --file) option to treat parameters as local filename of a packaged component:gu install -L -r component.jargu install -r rubyThe process is the same as if gu remove is run first and gu install next.GraalVM Updater also refuses to overwrite existing files if theto-be-installed and existing versions differ. There are cases when refreshingfile contents may be needed, such as if they were modified or damaged. In this case, use the -o option:gu install -L -o component.jargu install -o rubyGraalVM Updater will then instruct the user to replace the contained files of acomponent. By default, it will not alter anything. Alternatively, use the -f(--force) option, which disables most of the checks, and allows the user toinstall non-matching versions.TroubleshootingIf a language component is not installed, running code that tries to initialize that language context can result in an exception like this:java.lang.ExceptionInInitializerErrorCaused by: com.oracle.truffle.polyglot.PolyglotIllegalArgumentException: A language with id &#39;$language&#39; is not installed. Installed languages are: [js, llvm].If you see a problem like that, install the language runtime component as explained above on this page.",
                    "url": " /reference-manual/graalvm-updater/"
                  },
                  
                  "guides":  {
                    "title": "",
                    "content": "Here you will find information about how to:  Run Java Applications on GraalVM from the CLI  Run Java Applications on GraalVM from an IDE  Debug Java Applications on GraalVM from an IDE  Configure JVM Options for Applications Running on GraalVM  Profile Java Applications on GraalVM with VisualVMRun Java Applications on GraalVM from the CLIAny application that runs on a Java Virtual Machine (JVM) can run on GraalVM.GraalVM includes a JDK based on the Java HotSpot VM, and integrates an optimizing, just-in-time (JIT) compiler, written in Java: the GraalVM compiler.At runtime, an application is loaded and executed normally by the JVM.In order to follow the steps in this guide, you must have GraalVM installed.In case you do not have it installed, getting GraalVM  downloaded and ready-to-go should only take a few minutes.Choose your operating system and proceed to the installation steps:  Linux  Linux AArch64  macOS  WindowsFor the purpose of this guide, GraalVM Enterprise based on Java 11 distribution for macOS platform is used.To ensure you have successfully installed GraalVM, verify it is available in the PATH environment variable and the JAVA_HOME points to it.echo $PATH/Library/Java/JavaVirtualMachines/graalvm-ee-java11-&amp;lt;version&amp;gt;/Contents/Home/bin:...echo $JAVA_HOME/Library/Java/JavaVirtualMachines/graalvm-ee-java11-&amp;lt;version&amp;gt;/Contents/HomeThis guide uses Spring PetClinic as the sample application.This web application demonstrates the use of Spring Boot with Spring MVC and Spring Data JPA.Next, clone the project and navigate to the project’s directory:git clone https://github.com/spring-projects/spring-petclinic.gitcd spring-petclinicThe Spring PetClinic application is built with Maven so you can build a JAR file and then run it from the command line.The basic syntax to launch a Java application from a JAR file with GraalVM is: java -jar &amp;lt;JAR file&amp;gt;.Now you can build the application and run it as with any other JDK../mvnw packagejava -jar target/spring-petclinic-2.3.0.BUILD-SNAPSHOT.jarAlso, you can run this sample application from Maven directly using the Spring Boot Maven plugin:./mvnw spring-boot:runWhen the application starts, access it on localhost:8000.If your Java project is built with Gradle, run ./gradlew build to build the project and then run it from a JAR file as usual (java -jar &amp;lt;JAR file&amp;gt;).Run Java Applications on GraalVM from an IDEIf you find it more comfortable to work with projects from an IDE, for example, Eclipse IDE, Intellij IDEA, NetBeans IDE, and so on, you can also specify GraalVM as a default JDK in the IDE and run applications using GraalVM from then.To run a Java project on GraalVM from an IDE requires setting GraalVM as a project’s default JDK.For example, to run the Spring PetClinic project using Intellij IDEA, you need to:1. Open the project (File -&amp;gt; Open) and browse Spring PetClinic sources from a local drive.2. Generate sources and update folders for the project.Intellij IDEA does not include generated sources automatically, so you need to generate them.In the Maven sidebar, click on the folder with the spinner icon:3. Add GraalVM as the project’s SDK.Navigate to File -&amp;gt; Project Structure -&amp;gt; Project -&amp;gt; Project SDK.Expand the drop down, press Add SDK -&amp;gt; JDK and open the folder where you installed GraalVM.For macOS users, JDK home path will be/Library/Java/JavaVirtualMachines/{graalvm}/Contents/Home.Give it a name, and press Apply.If you wish to add GraalVM SDK platform-wise, navigate to Project Structure -&amp;gt; Platform Settings -&amp;gt; SDK.Then press the plus button (+)  -&amp;gt; Add JDK and open the folder where you installed GraalVM.Give it a name and press Apply.4. Run the project. Setting GraalVM SDK as default for all project modules ensures that you run the project on GraalVM.To double-check that, verify the project’s Run configurations: from the main menu select Run -&amp;gt; Run… -&amp;gt; Edit Configurations, expand Environment, and check the provided value.It should show GraalVM.Press Run.Debug Java Applications on GraalVM from an IDEYou can use your IDE debugger to debug applications running on GraalVM.In the previous section you added GraalVM as the project’s default SDK and ran the sample application from IntelliJ IDEA.You do not have to configure anything specific to start a debugger session from IntelliJ IDEA now, as it is based on the Run configurations.To ensure you attach the debugger to your Java application in the same environment, navigate in the main menu to Run -&amp;gt; Debug… -&amp;gt; Edit Configurations, expand Environment and check the JRE value.It should show GraalVM.Press Debug.This will run the application and start a debugger session in the background.Configure JVM Options for Applications Running on GraalVMYou can use Java HotSpot VM command line options and GraalVM specific options to configure the java process running on GraalVM.If you are running the application from the command line, you need to add the options to the java command.In the IDE, use the IDE specific way to provide the options.For example, you might want to allocate larger memory when starting an application.In Intellij IDEA you can enter the -Xmx1024m -Xms256m values in the VM options field under Run -&amp;gt; Run… -&amp;gt; Edit Configurations -&amp;gt; Environment.Or, for example, you want to print the list of classes loaded.Then pass the -XX:+TraceClassLoading option under Run -&amp;gt; Run… -&amp;gt; Edit Configurations -&amp;gt; Environment -&amp;gt; VM options, and launch the application.Since you are running on GraalVM, you can use GraalVM specific options, for example, passing -XX:+EagerJVMCI -Dgraal.PrintConfiguration=info will gather information about the compiler configuration selected to the console, and then exit the program.Profile Java Applications on GraalVM with VisualVMYou can profile a Java application from an built-in profiler in your IDE, but this guide shows how to apply VisualVM instead.VisualVM is a Java profiling tool shipped with GraalVM.It includes heap analysis features, allows you to measure the methods of your Java application, analyze objects, read JFR snapshots, and so on.You can start VisualVM in two ways:  Download it as a standalone tool from here and launch.  Since you have GraalVM installed and VisualVM is bundled with it, start it simply from the command line:    jvisualvm  Immediately after startup, the tool shows all locally running Java processes in the Applications area, including the VisualVM process itself.To connect to an application running on GraalVM (or another JDK), find it in the processes list.VisualVM enables instrumented profiling of local Java applications from their startup.It is also helpful when profiling short-running processes.If you suspect that you have memory constraint problems, VisualVM is exactly the right tool to investigate those.First, to confirm that you really have a memory leak, enable verbose garbage collection (--verbosegc) when starting the application.Next, connect VisualVM to a running Java application and apply the profiler.When the profiling session starts and the profiled application opens in VisualVM, you can see the live profiling data.To view call trees for CPU data and stack traces for memory allocations, take a snapshot: right-click the application process in VisualVM and invoke the Heap Dump action.A heap dump typically includes detailed information about the type and size of objects.Now you can start analyzing stack traces.Find a block of objects in the heap that should not be there and determine if these objects accumulate instead of get released.Check the transient objects, allocated every time a certain event is triggered in the Java application.If there are too many object instances, that may indicate an application bug.For more information on using VisualVM, check its official documentation.",
                    "url": " /guides/"
                  },
                  
                  "tools-igv":  {
                    "title": "",
                    "content": "Ideal Graph VisualizerIdeal Graph Visualizer (IGV) is a developer tool allowing users to analyze compilationgraphs and investigate performance issues. The tool is essential for anylanguage implementers building on top of Oracle GraalVM Enterprise Edition. It isavailable as a separate download on Oracle Technology Network and requires accepting the Oracle Technology Network Developer License.IGV is developed to view and inspect intermediate representation graphs – a language-independent intermediate representation (IR) between the sourcelanguage and the machine code, generated by the compiler. See Dumping Graphs below.  Unzip the downloaded package and enter bin directory:    cd idealgraphvisualizer/bin    Launch the tool:    idealgraphvisualizer    Save the following code snippet as Test.rb:    require &#39;json&#39;obj = {  time: Time.now,  msg: &#39;Hello World&#39;,  payload: (1..10).to_a}encoded = JSON.dump(obj)js_obj = Polyglot.eval(&#39;js&#39;, &#39;JSON.parse&#39;).call(encoded)puts js_obj[:time]puts js_obj[:msg]puts js_obj[:payload].join(&#39; &#39;)    From another console window, make sure the ruby runtime is available in GraalVM Enterprise,and connect the Test.rb script to the running IGV:    gu listruby --jvm --polyglot --vm.Dgraal.Dump=:1 --vm.Dgraal.PrintGraph=Network Test.rb    This causes GraalVM Enterprise to dump compiler graphs in the IGV format over the network to an IGV process listening on 127.0.0.1:4445. Once the connection is made, you are able to see the graphs in the Outline window.Find, e.g., the java.lang.String.char(int) folder and open its After Parsing graph by double-clicking.If the node has sourceNodePosition property, then the Processing window will attempt to display its location and the entire stacktrace.  Browsing GraphsOnce a specific graph is opened, you can search for nodes by name, ID, or by property=value data, and all matching results will be shown.Another great feature of this tool is the ability to navigate to the original guest language source code.Select a node in the graph and press the Go to Source button in the Stack View window.Graphs navigation is also available from the Context menu, enabled by focusingand right-clicking a specific graph node. The Extract Nodes option will re-rendera graph and display only the selected nodes and their neighbors.If the graph is larger than the screen, manipulate with the Satellite view buttonin the main toolbar to move the viewport rectangle.For user preference, the graph color scheme is adjustable by editingthe Coloring filter, enabled by default in the left sidebar.Viewing Source CodeSource code views can be opened in manual and assisted modes. Once you select a nodein the graph view, the Processing view will open. If the IGV knows where the source codefor the current frame is, the green Go to Source arrow is enabled. If the IGV does notknow where the source is, the line is greyed out and a Looking Glass button appears.Press it and select Locate in Java project to locate the correct project in the dialog.The IGV hides projects which do not contain the required source file.The Source Collections serves to display the stand alone roots added by “Add root of sources” general action.If the source is located using the preferred method (i.e., from a Java project),its project can be later managed on the Project tab. That one is initially hidden,but you can display the list of opened projects using Window -&amp;gt; Projects.Dumping GraphsThe IGV tool is developed to allow GraalVM Enterprise language implementersto optimize their languages assembled with the Language Implentation Framework. As a developmenttool it should not be installed to production environments.To dump the GraalVM compiler graphs from an embedded Java application to the IGV,you need to add options to GraalVM-based processes. Depending on the language/VMused, you may need to prefix the options by --vm. See the particularlanguage’s documentation for the details. The main option to add is-Dgraal.Dump=:1. This will dump graphs in an IGV readable format to the localfile system. To send the dumps directly to the IGV over the network, add-Dgraal.PrintGraph=Network when starting a GraalVM instance. Optionally aport can be specified. Then dumps are sent to the IGV from the running GraalVM onlocalhost. If the IGV does not listen on localhost, Options -&amp;gt; Ideal Graph Settings|Accept Data From Network can be checked. If there is not an IGV instancelistening on 127.0.0.1 or it cannot be connected to, the dumps will beredirected to the local file system. The file system location is graal_dumps/under the current working directory of the process and can be changed with the-Dgraal.DumpPath option.In case an older GraalVM Enterprise is used, you may need to explicitly request that dumpsinclude the nodeSourcePosition property. This is done by adding the-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints options.",
                    "url": " /tools/igv/"
                  },
                  
                  "graalvm-as-a-platform-implement-instrument":  {
                    "title": "",
                    "content": "Getting Started with Instruments in GraalVMTools are sometimes referred to as Instruments within the GraalVM platform.The Instrument API is used to implement such instruments.Instruments can track very fine-grained, VM-level runtime events to profile, inspect, and analyze the runtime behavior of applications running on GraalVM.Simple ToolTo provide an easier starting point for tool developers we have created aSimple Tool example project. This is ajavadoc-rich Maven project which implements a simple code coverage tool.We recommend cloning the repository and exploring the source code as a startingpoint for tool development. The following sections will provide a guided tour ofthe steps needed to build and run a GraalVM tool, using Simple Tool source codeas the running example. These sections do not cover all of the features of theInstrument API so we encourage you to check the javadoc for more details.RequirementsAs mentioned before, Simple Tool is a code coverage tool. Ultimately, itshould provide the developer with information on what percentage of source codelines was executed, as well as exactly which lines were executed. With that inmind, we can define some high-level requirements from our tool:  The tool keeps track of loaded source code.  The tool keeps track of executed source code.  On application exit, the tool calculates and prints per-line coverage information.Instrument APIThe main starting point for tools is subclassing the TruffleInstrument class.Unsurprisingly, the simple tool code base does exactly this, creating the SimpleCoverageInstrument class.TheRegistrationannotation on the class ensures that the newly created instrument is registeredwith the Instrument API, i.e., that it will be automaticallydiscovered by the framework. It also provides some metadata about theinstrument: ID, name, version, which services the instrument provides, andwhether the instrument is internal or not. In order for this annotation to beeffective the DSL processor needs to process this class. This is, in the case of Simple Tool, done automatically by having the DSL processor as a dependency in the Maven configuration.Now we will look back at the implementation of the SimpleCoverageInstrument class, namely which methods from TruffleInstrument it overrides.These are onCreate, onDispose, and getOptionDescriptors.The onCreate and onDispose methods are self-explanatory: they are called by the framework when the instrument is created and disposed.We will discuss their implementations later, but first let us discuss the remaining one: getOptionDescriptors.The Truffle language implementation framework comes with its own system for specifying command-line options.These options allow tool users to control the tool either from the command line or when creating polyglot contexts.It is annotation-based, and examples for such options are the ENABLED and PRINT_COVERAGE fields of SimpleCoverageInstrument.Both of these are static final fields of the type OptionKey annotated with Option which, similar to the Registration annotation, provides some metadata for the option.Again, as with the Registration annotation, for the Option annotation to be effective the DSL processor is needed, which generates a subclass of OptionDescriptors (in our case named SimpleCoverageInstrumentOptionDescriptors).An instance of this class should be returned from the getOptionDescriptors method to let the framework know which options the instrument provides.Returning to the onCreate method, as an argument, we receive an instance of the Env class.This object gives a lot of useful information, but for the onCreate method we are primarily interested in the getOptions method, which can be used to read which options are passed to the tool.We use this to check whether the ENABLED option has been set and if so we enable our tool by calling the enable method.Similarly, in the onDispose method we check the options for the state of the PRINT_COVERAGE option, and if it is enabled we call the printResults method which will print our results.What does it mean “to enable a tool?”In general, it means that we tell the framework about the events we are interested in and how we want to react to them. Looking at our enable method, it does the following:  First, it defines SourceSectionFilter.This filter is a declarative definition of the parts of the source code we are interested in.In our example, we care about all nodes that are considered expressions, and we do not care about internal language parts.  Second, we obtain an instance of anInstrumenterclass which is an object allowing us to specify which parts of the system we wish to instrument.  Finally, using the Instrumenter class, we specify a Source Section Listener and an Execution Event Factory which are both described in the next two sections.Source Section ListenerThe Language API provides the notion of a Source which is the source code unit, and a SourceSection which is one continuous part of a Source, e.g., one method, one statement, one expression, and so on. More details can be found in the respective javadoc.The first requirement for Simple Tool is to keep track of loaded source code.The Instrument API provides the LoadSourceSectionListener which, when subclassed and registered with the instrumenter, allows users to react to the runtime loading source sections.This is exactly what we do with the GatherSourceSectionsListener, which is registered in the enable method of the instrument.The implementation of GatherSourceSectionsListener is quite simple: we override the onLoad method to notify the instrument of each loaded source section.The instrument keeps a mapping from each Source to a Coverage object which keeps a set of loaded source sections for each source.Execution Event NodeGuest languages are implemented as Abstract Syntax Tree (AST) interpreters.The language implementers annotate certain nodes with tags, which allows us toselect which nodes we are interested in, by using the aforementionedSourceSectionFilter, in a language-agnostic manner.The main power of the Instrument API lies in its ability to insert specialisednodes in the AST which “wrap” the nodes of interest. These nodes are built usingthe same infrastructure that the language developers use, and are, from theperspective of the runtime, indistinguishable from the language nodes. Thismeans that all of the techniques used to optimize guest languages into such highperforming language implementations are available to the tool developers aswell.More information about these techniques is available in the language implementation documentation.Suffice it to say that for Simple Tool to meet its second requirement, we need toinstrument all expressions with our own node that will notify us when thatexpression is executed.For this task we use the CoverageNode.It is a subclass of ExecutionEventNode which, as the name implies, is used to instrument events during execution.The ExecutionEventNode offers many methods to override, but we are only interested in onReturnValue.This method is invoked when the “wrapped” node returns a value, i.e., is successfully executed.The implementation is rather simple. We just notify the instrument that the node with this particular SourceSection has been executed, and the instrument updates the Coverage object in its coverage map.The instrument is notified only once per node, as the logic is guarded by the flag.The fact that this flag is annotated with CompilationFinal and that the call to the instrument is preceded by a call to transferToInterpreterAndInvalidate() is a standard technique in Truffle which ensures that once this instrumentation is no longer needed (i.e., a node has been executed), the instrumentation is removed from further compilations, along with any performance overhead.In order for the framework to know how to instantiate the CoverageNode when itis needed, we need to provide a factory for it.The factory is the CoverageEventFactory, a subclass of ExecutionEventNodeFactory.This class just ensures that each CoverageNode knows the SourceSection it is instrumenting by looking it up in the provided EventContext.Finally, when we are enabling the instrument,we tell the instrumenter to use our factory to “wrap” the nodes selected by ourfilter.Interaction Between Users and InstrumentsThe third and final requirement Simple Tool has is to actually interact with its user by printing line coverage to standard output.The instrument overriders the onDispose method which is unsurprisingly called when the instrument is being disposed of.In this method we check that the proper option has been set and, if so, calculate and print the coverage as recorded by our map of Coverage objects.This is a simple way of providing useful information to a user, but it is definitely not the only one.A tool could dump its data directly to a file, or run a web endpoint which shows the information, etc.One of the mechanisms that the Instrument API provides users with is registering instruments as services to be looked up by other instruments.If we look at the Registration annotation of our instrument we can see that it provides a services field where we can specify which services the instrument provides to other instruments.These services need to be explicitly registered.This allows a nicer separation of concerns among instruments so that, for example, we could have a “real time coverage” instrument which would use our SimpleCoverageInstrument to provide on-demand coverage information to a user through a REST API, and an “aborts on low coverage” instrument which stops the execution if coverage drops below a threshold, both using the SimpleCoverageInstrument as a service.Note: For reasons of isolation, instrument services are not available to application code, and instrument services can only be used from other instruments or guest languages.Installing a Tool into GraalVMSo far, Simple Tool seems to meet all requirements but the question remains: how do we use it?As mentioned before, Simple Tool is a Maven project.Setting JAVA_HOME to a GraalVM installation and running mvn package produces a target/simpletool-&amp;lt;version&amp;gt;.jar.This is the Simple Tool distribution form.The Truffle framework offers a clear separation between the language/tooling code and the application code.For this reason, putting the JAR on the class path will not result in the framework realizing a new tool is needed.To achieve this we use --vm.Dtruffle.class.path.append=/path/to/simpletool-&amp;lt;version&amp;gt;.jar as is illustrated in a launcher script for our simple tool.This script also shows we can set the CLI options we specified for Simple Tool.This means that if we execute ./simpletool js example.js, we will launch the js launcher of GraalVM, add the tool to the framework class path, and run the included example.js file with Simple Tool enabled, resulting in the following output:==Coverage of /path/to/simpletool/example.js is 59.42%+ var N = 2000;+ var EXPECTED = 17393;  function Natural() {+     x = 2;+     return {+         &#39;next&#39; : function() { return x++; }+     };  }  function Filter(number, filter) {+     var self = this;+     this.number = number;+     this.filter = filter;+     this.accept = function(n) {+       var filter = self;+       for (;;) {+           if (n % filter.number === 0) {+               return false;+           }+           filter = filter.filter;+           if (filter === null) {+               break;+           }+       }+       return true;+     };+     return this;  }  function Primes(natural) {+     var self = this;+     this.natural = natural;+     this.filter = null;+     this.next = function() {+         for (;;) {+             var n = self.natural.next();+             if (self.filter === null || self.filter.accept(n)) {+                 self.filter = new Filter(n, self.filter);+                 return n;+             }+         }+     };  }+ var holdsAFunctionThatIsNeverCalled = function(natural) {-     var self = this;-     this.natural = natural;-     this.filter = null;-     this.next = function() {-         for (;;) {-             var n = self.natural.next();-             if (self.filter === null || self.filter.accept(n)) {-                 self.filter = new Filter(n, self.filter);-                 return n;-             }-         }-     };+ }- var holdsAFunctionThatIsNeverCalledOneLine = function() {return null;}  function primesMain() {+     var primes = new Primes(Natural());+     var primArray = [];+     for (var i=0;i&amp;lt;=N;i++) { primArray.push(primes.next()); }-     if (primArray[N] != EXPECTED) { throw new Error(&#39;wrong prime found: &#39; + primArray[N]); }  }+ primesMain();Other ExamplesThe following examples are intended to show common use-cases that can be solved with the Instrument API.  Coverage Instrument: a coverage tool example which was used to build up Simple Tool. It is used as the running example in further text where appropriate.  Debugger Instrument: a sketch on how a debugger can be implemented. Note that the Instrument API already provides a Debugger Instrument that can be used directly.  Statement Profiler: a profiler that is able to profile the execution of statements.Instrumentation Event ListenersThe Instrument API is defined in the com.oracle.truffle.api.instrumentation package. Instrumentation agents can be developed by extending the TruffleInstrument class, and can be attached to a running GraalVM instance using the Instrumenter class. Once attached to a running language runtime, instrumentation agents remain usable as long as the language runtime is not disposed. Instrumentation agents on GraalVM can monitor a variety of VM-level runtime events, including any of the following:  Source code-related events: The agent can be notified every time a new Source or SourceSection element is loaded by the monitored language runtime.  Allocation events: The agent can be notified every time a new object is allocated in the memory space of the monitored language runtime.  Language runtime and thread creation events: The agent can be notified as soon as a new execution context or a new thread for a monitored language runtime is created.  Application execution events: The agent gets notified every time a monitored application executes a specific set of language operations. Examples of such operations include language statements and expressions, thus allowing an instrumentation agent to inspect running applications with very high precision.For each execution event, instrumentation agents can define filtering criteria that will be used by the GraalVM instrumentation runtime to monitor only the relevant execution events. Currently, GraalVM instruments accept one of the following two filter types:  AllocationEventFilter to filter allocation events by allocation type.  SourceSectionFilter to filter source code locations in an application.Filters can be created using the provided builder object. For example, the following builder creates a SourceSectionFilter:SourceSectionFilter.newBuilder()                   .tagIs(StandardTag.StatementTag)                   .mimeTypeIs(&quot;x-application/js&quot;)                   .build()The filter in the example can be used to monitor the execution of all JavaScript statements in a given application. Other filtering options such as line numbers or file extensions can also be provided.Source section filters like the one in the example can use Tags to specify a set of execution events to be monitored. Language-agnostic tags such as statements and expressions are defined in the com.oracle.truffle.api.instrumentation.Tag class, and are supported by all GraalVM languages. In addition to standard tags, GraalVM languages may provide other, language-specific, tags to enable fine-grained profiling of language-specific events. (As an example, the GraalVM JavaScript engine provides JavaScript-specific tags to track the usages of ECMA builtin objects such as Array, Map, or Math.)Monitoring Execution EventsApplication execution events enable very precise and detailed monitoring. GraalVM supports two different types of instrumentation agents to profile such events, namely:  Execution listener: an instrumentation agent that can be notified every time a given runtime event happens. Listeners implement the ExecutionEventListener interface, and cannot associate any state with source code locations.  Execution event node: an instrumentation agent that can be expressed using Truffle Framework AST nodes. Such agents extend the ExecutionEventNode class and have the same capabilities of an execution listener, but can associate state with source code locations.Simple Instrumentation AgentA simple example of a custom instrumentation agent used to perform runtime code coverage can be found in the CoverageExample class. What follows is an overview of the agent, its design, and its capabilities.All instruments extend the TruffleInstrument abstract class and are registered in the GraalVM runtime through the @Registration annotation:@Registration(id = CoverageExample.ID, services = Object.class)public final class CoverageExample extends TruffleInstrument {  @Override  protected void onCreate(final Env env) {  }  /* Other methods omitted... */}Instruments override the onCreate(Env env) method to perform custom operations at instrument loading time. Typically, an instrument would use this method to register itself in the existing GraalVM execution environment. As an example, an instrument using AST nodes can be registered in the following way:@Overrideprotected void onCreate(final Env env) {  SourceSectionFilter.Builder builder = SourceSectionFilter.newBuilder();  SourceSectionFilter filter = builder.tagIs(EXPRESSION).build();  Instrumenter instrumenter = env.getInstrumenter();  instrumenter.attachExecutionEventFactory(filter, new CoverageEventFactory(env));}The instrument connects itself to the running GraalVM using the attachExecutionEventFactory method, providing the following two arguments:  SourceSectionFilter: a source section filter used to inform the GraalVM about specific code sections to be tracked.  ExecutionEventNodeFactory: the Truffle AST factory that provides instrumentation AST nodes to be executed by the agent every time a runtime event (as specified by the source filter) is executed.A basic ExecutionEventNodeFactory that instruments the AST nodes of an application can be implemented in the following way:public ExecutionEventNode create(final EventContext ec) {  return new ExecutionEventNode() {    @Override    public void onReturnValue(VirtualFrame vFrame, Object result) {      /*       * Code to be executed every time a filtered source code       * element is evaluated by the guest language.       */    }  };}Execution event nodes can implement certain callback methods to intercept runtime execution events. Examples include:  onEnter: executed before an AST node corresponding to a filtered source code element (e.g., a language statement or an expression) is evaluated.  onReturnValue: executed after a source code element returns a value.  onReturnExceptional: executed in case the filtered source code element throws an exception.Execution event nodes are created on a per code location basis. Therefore, they can be used to store data specific to a given source code location in the instrumented application. As an example, an instrumentation node can simply keep track of all code locations that have already been visited using a node-local flag. Such a node-local boolean flag can be used to track the execution of AST nodes in the following way:// To keep track of all source code locations executedprivate final Set&amp;lt;SourceSection&amp;gt; coverage = new HashSet&amp;lt;&amp;gt;();public ExecutionEventNode create(final EventContext ec) {  return new ExecutionEventNode() {    // Per-node flag to keep track of execution for this node    @CompilationFinal private boolean visited = false;    @Override    public void onReturnValue(VirtualFrame vFrame, Object result) {      if (!visited) {        CompilerDirectives.transferToInterpreterAndInvalidate();        visited = true;        SourceSection src = ec.getInstrumentedSourceSection();        coverage.add(src);      }    }  };}As the above code shows, an ExecutionEventNode is a valid AST node. This implies that the instrumentation code will be optimized by the GraalVM runtime together with the instrumented application, resulting in minimal instrumentation overhead. Furthermore, this allows instrument developers to use the Truffle framework compiler directives directly from instrumentation nodes. In the example, compiler directives are used to inform the GraalVM compiler that visited can be considered compilation-final.Each instrumentation node is bound to a specific code location. Such locations can be accessed by the agent using the provided EventContext object.The context object gives instrumentation nodes access to a variety of information about the current AST nodes being executed. Examples of query APIs available to instrumentation agents through EventContext include:  hasTag: to query an instrumented node for a certain node Tag (e.g., to check if a statement node is also a conditional node).  getInstrumentedSourceSection: to access the SourceSection associated with the current node.  getInstrumentedNode: to access the Node corresponding to the current instrumentation event.Fine-grained Expression ProfilingInstrumentation agents can profile even fractional events such as language expressions. To this end, an agent needs to be initialized providing two source section filters:// What source sections are we interested in?SourceSectionFilter sourceSectionFilter = SourceSectionFilter.newBuilder()  .tagIs(JSTags.BinaryOperation.class)  .build();// What generates input data to track?SourceSectionFilter inputGeneratingLocations = SourceSectionFilter.newBuilder()  .tagIs(StandardTags.ExpressionTag.class)  .build();instrumenter.attachExecutionEventFactory(sourceSectionFilter, inputGeneratingLocations, factory);The first source section filter (sourceSectionFilter, in the example) is a normal filter equivalent to other filters described before, and is used to identify the source code locations to be monitored. The second section filter, inputGeneratingLocations, is used by the agent to specify the intermediate values that should be monitored for a certain source section. Intermediate values correspond to all observable values that are involved in the execution of a monitored code element, and are reported to the instrumentation agent by means of the onInputValue callback. As an example, let us assume an agent needs to profile all operand values provided to sum operations (i.e., +) in JavaScript:var a = 3;var b = 4;// the &#39;+&#39; expression is profiledvar c = a + b;By filtering on JavaScript binary expressions, an instrumentation agent would be able to detect the following runtime events for the above code snippet:  onEnter(): for the binary expression at line 3.  onInputValue(): for the first operand of the binary operation at line 3. The value reported by the callback will be 3, that is, the value of the a local variable.  onInputValue(): for the second operand of the binary operation. The value reported by the callback will be 4, that is, the value of the b local variable.  onReturnValue(): for the binary expression. The value provided to the callback will be the value returned by the expression after it has completed its evaluation, that is, the value 7.By extending the source section filters to all possible events, an instrumentation agent will observe something equivalent to the following execution trace (in pseudocode):// First variable declarationonEnter - VariableWrite    onEnter - NumericLiteral    onReturnValue - NumericLiteral  onInputValue - (3)onReturnValue - VariableWrite// Second variable declarationonEnter - VariableWrite    onEnter - NumericLiteral    onReturnValue - NumericLiteral  onInputValue - (4)onReturnValue - VariableWrite// Third variable declarationonEnter - VariableWrite    onEnter - BinaryOperation        onEnter - VariableRead        onReturnValue - VariableRead      onInputValue - (3)        onEnter - VariableRead        onReturnValue - VariableRead      onInputValue - (4)    onReturnValue - BinaryOperation  onInputValue - (7)onReturnValue - VariableWriteThe onInputValue method can be used in combination with source section filters to intercept very fine-grained execution events such as intermediate values used by language expressions. The intermediate values that are accessible to the Instrumentation framework greatly depend on the instrumentation support provided by each language. Moreover, languages may provide additional metadata associated with language-specific Tag classes.Altering the Execution Flow of an ApplicationThe instrumentation capabilities that we have presented so far enable users to observe certain aspects of a running application. In addition to passive monitoring of an application’s behavior, the Instrument API features support for actively altering the behavior of an application at runtime. Such capabilities can be used to write complex instrumentation agents that affect the behavior of a running application to achieve specific runtime semantics. For example, one could alter the semantics of a running application to ensure that certain methods or functions are never executed (e.g., by throwing an exception when they are called).Instrumentation agents with such capabilities can be implemented by leveraging the onUnwind callback in execution event listeners and factories. As an example, let’s consider the following JavaScript code:function inc(x) {  return x + 1}var a = 10var b = a;// Let&#39;s call inc() with normal semanticswhile (a == b &amp;amp;&amp;amp; a &amp;lt; 100000) {  a = inc(a);  b = b + 1;}c = a;// Run inc() and alter it&#39;s return type using the instrumentreturn inc(c)An instrumentation agent that modifies the return value of inc to always be 42 can be implemented using an ExecutionEventListener, in the following way:ExecutionEventListener myListener = new ExecutionEventListener() {  @Override  public void onReturnValue(EventContext context, VirtualFrame frame, Object result) {    String callSrc = context.getInstrumentedSourceSection().getCharacters();    // is this the function call that we want to modify?    if (&quot;inc(c)&quot;.equals(callSrc)) {      CompilerDirectives.transferToInterpreter();      // notify the runtime that we will change the current execution flow      throw context.createUnwind(null);    }  }  @Override  public Object onUnwind(EventContext context, VirtualFrame frame, Object info) {    // just return 42 as the return value for this node    return 42;  }}The event listener can be executed intercepting all function calls, for example using the following instrument:@TruffleInstrument.Registration(id = &quot;UniversalAnswer&quot;, services = UniversalAnswerInstrument.class)public static class UniversalAnswerInstrument extends TruffleInstrument {  @Override  protected void onCreate(Env env) {    env.registerService(this);    env.getInstrumenter().attachListener(SourceSectionFilter.newBuilder().tagIs(CallTag.class).build(), myListener);  }}When enabled, the instrument will execute its onReturnValue callback each time a function call returns. The callback reads the associated source section (using getInstrumentedSourceSection) and looks for a specific source code pattern (the function call inc(c), in this case). As soon as such code pattern is found, the instrument throws a special runtime exception, called UnwindException, that instructs the Instrumentation framework about a change in the current application’s execution flow. The exception is intercepted by the onUnwind callback of the instrumentation agent, which can be used to return any arbitrary value to the original instrumented application.In the example, all calls to inc(c) will return 42 regardless of any application-specific data. A more realistic instrument might access and monitor several aspects of an application, and might not rely on source code locations, but rather on object instances or other application-specific data.",
                    "url": " /graalvm-as-a-platform/implement-instrument/"
                  },
                  
                  "graalvm-as-a-platform-implement-language":  {
                    "title": "",
                    "content": "Introduction to SimpleLanguageWe have found that the easiest way to get started with implementing your own language is by extending an existing language such as SimpleLanguage.SimpleLanguage is a demonstration language built using the Language API.The SimpleLanguage project provides a showcase on how to use the Language APIs for writing your own language.It aims to use most of the available Truffle language implementation framework (henceforth “Truffle”) features, and documents their use extensively with inline source documentation.To start, ensure Maven3 and GraalVM are available in your system.  Clone the SimpleLanguage repository using:    git clone https://github.com/graalvm/simplelanguage    Set the JAVA_HOME and PATH environment variables to the GraalVM home and bin folders using a command-line shell for Linux:    export JAVA_HOME=/path/to/graalvmexport PATH=/path/to/graalvm/bin:$PATH    For macOS, use:    export JAVA_HOME=/path/to/graalvm/Contents/Homeexport PATH=/path/to/graalvm/Contents/Home/bin:$PATH    Execute mvn package from the SimpleLanguage folder to build the language.The command also builds a slnative executable in the simplelanguage/nativedirectory and a sl-component.jar language component which later can be installedinto GraalVM using the GraalVM Updater tool.Please verify ithat the native-image plugin is available in your GraalVM distributionto avoid build failure:    gu listgu install native-image    You can disable the SimpleLanguage native executable build during the packaging phase by running:    export SL_BUILD_NATIVE=falsemvn package    Run in the SimpleLanguage root folder:    ./sl ./language/tests/HelloWorld.sl  The SimpleLanguage demonstration language is licensed under the Universal Permissive License (UPL).IDE SetupThe Truffle framework provides language-agnostic infrastructure to realize standard IDE features by providing additional APIs. If you would like to experiment with your language and get the benefits of an IDE, consider importing SimpleLanguage as an example.EclipseThe SimpleLanguage teaching project has been tested with Eclipse Neon.2 Release 4.6.2, and Eclipse Oxygen.3A. To import the project folder to the desirable Eclipse environment:  Open Eclipse with a new workspace.  Install the m2e and m2e-apt plugins from the Eclipse marketplace (Help -&amp;gt; Eclipse Marketplace).  Finally, import the SimpleLanguage project from File -&amp;gt; Import -&amp;gt; Maven -&amp;gt; Existing Maven Projects -&amp;gt; browse to the SimpleLanguage folder -&amp;gt; Finish.NetBeansNetBeans provides GUI support for debugging arbitrary languages. In order to upload SimpleLanguage to NetBeans interface, proceed to File -&amp;gt; Open Project -&amp;gt; select simplelanguage folder -&amp;gt; check Open Required Projects -&amp;gt; open Project.IntelliJ IDEAThe SimpleLanguage project has been tested with IntelliJ IDEA. Open IntelliJ IDEA and, from the main menu bar, select  File -&amp;gt; Open -&amp;gt; Navigate to and select the simplelanguage folder -&amp;gt; Press OK. All dependencies will be included automatically.Run SimpleLanguageTo run a SimpleLanguage source file, execute:./sl language/tests/HelloWorld.slTo see assembly code for the compiled functions, run:./sl -disassemble language/tests/SumPrint.slDump GraphsTo investigate performance issues, we recommend the Ideal Graph Visualizer (IGV) – an essential tool for any language implementer building ontop of Oracle GraalVM Enterprise Edition.It is available as a separate download on the Oracle Technology Network Downloads page.  Unzip the downloaded package, enter the bin directory and start IGV:    cd idealgraphvisualizer/binidealgraphvisualizer    Execute the following from the SimpleLanguage root folder to dump graphs to IGV:    ./sl -dump language/tests/SumPrint.sl  DebugTo start debugging the SimpleLanguage implementation with a Java debugger, pass the -debug option to the command-line launcher of your program:./sl -debug language/tests/HelloWorld.slThen attach a Java remote debugger (like Eclipse) on port 8000.SimpleLanguage Component for GraalVMLanguages implemented with the Truffle framework can be packaged as components which later can be installed into GraalVM using the GraalVM Updater tool.Running mvn package in the SimpleLanguage folder also builds a sl-component.jar.This file is the SimpleLanguage component for GraalVM and can be installed byrunning:gu -L install /path/to/sl-component.jarSimpleLanguage Native ImageA language built with Truffle can be AOT compiled using Native Image. Runningmvn package in the SimpleLanguage folder also builds a slnative executablein the native directory. This executable is the full SimpleLanguageimplementation as a single native application, and has no need for GraalVM inorder to execute SimpleLanguage code. Besides this, a big advantage of using thenative executable when compared to running on GraalVM is the greatly fasterstartup time as shown bellow:time ./sl language/tests/HelloWorld.sl== running on org.graalvm.polyglot.Engine@2db0f6b2Hello World!real    0m0.405suser    0m0.660ssys     0m0.108stime ./native/slnativelanguage/tests/HelloWorld.sl== running on org.graalvm.polyglot.Engine@7fd046f06898Hello World!real    0m0.004suser    0m0.000ssys     0m0.000sThis snipped shows a timed execution of a “Hello World” program using the sllauncher script, which runs SimpleLanguage on GraalVM, using NativeImage. We can see that when running on GraalVM the execution takes 405ms. Sinceour SimpleLanguage program does just one print statement, we can conclude thatalmost all of this time is spent starting up GraalVM and initializing thelanguage itself. When using the native executable we see that the execution takesonly 4ms, showing two orders of magnitude faster startup than running onGraalVM.For more information on the native-image tool consider reading the reference manual.Disable SimpleLanguage Native Image BuildBuilding the native executable through Maven is attached to the Maven packagephase. Since the native executable build can take a bit of time, we provide theoption to skip this build by setting the SL_BUILD_NATIVE environment variableto false like so:export SL_BUILD_NATIVE=falsemvn package...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building simplelanguage-graalvm-native[INFO] ------------------------------------------------------------------------[INFO][INFO] --- exec-maven-plugin:1.6.0:exec (make_native) @ simplelanguage-graalvm-native ---Skipping the native image build because SL_BUILD_NATIVE is set to false.[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------...Run SimpleLanguage with the Newest Compiler 21.1.0In the outstanding case that you need to execute SimpleLanguage with the newestversion of the GraalVM compiler, please follow these instructions:  Download the latest JVMCI JDK 8 and point JAVA_HOME at it:    export JAVA_HOME=/path/to/openjdk-8u292-jvmci-21.1-b04    Clone the “Graal” repository from the SimpleLanguage folder:    cd /path/to/simplelanguagegit clone https://github.com/oracle/graal.git    Clone the mx repository:    git clone https://github.com/graalvm/mx.git    Add mx to your path:    export PATH=/path/to/mx:$PATH    Navigate to the compiler folder:    cd /path/to/graal/compiler    Build the GraalVM compiler:    mx build    Run SimpleLanguage using the mx command:    mx -v --jdk=jvmci vm -cp /path/to/simplelanguage/launcher/target/launcher-21.1.0-SNAPSHOT.jar:/path/to/simplelanguage/language/target/simplelanguage.jar com.oracle.truffle.sl.launcher.SLMain  /path/to/simplelanguage/language/tests/SlScript.sl  Run SimpleLanguage Using Command LineExecuting SimpleLanguage code is normally done with the sl script which setsup the necessary command line depending on whether JAVA_HOME points toGraalVM or another JVM installation. The following subsections describe thecommand line for both cases.Run SimpleLanguage with GraalVM as JAVA_HOMEAssuming JAVA_HOME points to the GraalVM installation and that the currentworking directory is the simplelanguage directory, to run SimpleLanguage oneshould execute the following command:$JAVA_HOME/bin/java     -cp launcher/target/launcher-21.1.0-SNAPSHOT.jar     -Dtruffle.class.path.append=language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.slIn short, we place the launcher JAR on the class path and execute its mainclass, but we inform GraalVM of the presence of SimpleLanguage by using the-Dtruffle.class.path.append option and providing it the path to the fatlanguage JAR. Having the language on a separate class path ensures a strongseparation between the language implementation and its embedding context (inthis case, the launcher).Disable Class Path SeparationNOTE! This should only be used during development.For development purposes it is useful to disable the class path separation and enable having thelanguage implementation on the application class path (for example, for testingthe internals of the language).For the GraalVM distribution based on JDK 8, you can add the -XX:-UseJVMCIClassLoaderoption. This disables the class path isolation, enabling the languageimplementation to be placed on the application class path. The command line canbe as follows:$JAVA_HOME/bin/java     -XX:-UseJVMCIClassLoader -Dgraalvm.locatorDisabled=true     -cp launcher/target/launcher-21.1.0-SNAPSHOT.jar:language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.slFor the JDK 11-based distribution of GraalVM, the -XX:-UseJVMCIClassLoader optionis not valid. The Java Module System isolation is used. You can achieve the same behaviorusing --add-exports or --upgrade-module-path. The latter is preferable.The Language API JAR on Maven Central exports all API packages in its module-info. Apply the --upgrade-module-path option together with -Dgraalvm.locatorDisabled=true and this JAR to export Language API packages:-Dgraalvm.locatorDisabled=true --module-path=&amp;lt;yourModulePath&amp;gt;:${truffle.dir} --upgrade-module-path=${truffle.dir}/truffle-api.jarA sample POM using --upgrade-module-path to export Language API packages can be found in the Simple Language POM.xml file.Other JVM ImplementationsUnlike GraalVM, which includes all the dependencies needed to run a languageimplemented with Truffle, other JVM implementations need additionalJARs to be present on the class path. These are the Language API and GraalVM SDKJARs available from Maven Central.Assuming JAVA_HOME points to a stock JDK installation, and that the currentworking directory is the simplelanguage directory and the Language API andGraalVM SDK JARs are present in that directory, one can execute SimpleLanguagewith the following command:$JAVA_HOME/bin/java     -cp graal-sdk-21.1.0.jar:truffle-api-21.1.0.jar:launcher/target/launcher-21.1.0-SNAPSHOT.jar:language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.sl",
                    "url": " /graalvm-as-a-platform/implement-language/"
                  },
                  
                  "":  {
                    "title": "",
                    "content": "",
                    "url": " /"
                  },
                  
                  "reference-manual-ruby-installinggraalvm":  {
                    "title": "",
                    "content": "Using TruffleRuby with GraalVMGraalVM is the platform on which TruffleRuby runs.Installing GraalVM enables you to run TruffleRuby both in the --native and --jvm runtime configurations.DependenciesTruffleRuby’s dependencies need to be installed for TruffleRuby to run correctly.Community Edition and Enterprise EditionGraalVM is available in a Community Edition, which is open-source, and an Enterprise Edition which has better performance and scalability.See the website for a comparison.Installing the Base ImageGraalVM starts with a base image which provides the platform for high-performance language runtimes.The Community Edition base image can be installed from GitHub, under an open source licence.The Enterprise Edition base image can be installed from Oracle Downloads page by accepting the Oracle License Agreement.Nightly builds of the GraalVM Community Edition are also available.Whichever edition you choose, you will obtain a tarball which you can extract.There will be a bin directory (Contents/Home/bin on macOS) which you can add to your $PATH if you want to.Installing with asdfUsing asdf and asdf-java installation is as easy asasdf install java graalvm-20.1.0+java11 (look up versions via asdf list-all java | grep graalvm).Installing Ruby and Other LanguagesAfter installing GraalVM you then need to install the Ruby language into it.This is done using the gu command.The Ruby package is the same for both editions of GraalVM and comes from GitHub:gu install rubyThis command will show a message regarding running a post-install script.This is necessary to make the Ruby openssl C extension work with your system libssl.Please run that script now.The path of the script will be:# Java 8jre/languages/ruby/lib/truffle/post_install_hook.sh# Java 11+languages/ruby/lib/truffle/post_install_hook.sh# Generic$(path/to/graalvm/bin/ruby -e &#39;print RbConfig::CONFIG[&quot;prefix&quot;]&#39;)/lib/truffle/post_install_hook.shYou can also download the latest Ruby component (ruby-installable-...) manually from GitHub.Then install it with gu install --file path/to/ruby-installable-....If you are installing Ruby into GraalVM Enterprise, then you need to download the RubyEnterprise installable from Oracle Downloads page and install using --file in the same way.After installing Ruby you may want to rebuild other images so that they can use the new language.Rebuilding the executable images can take a few minutes and you should have about 10 GB of RAM available.gu rebuild-images polyglot libpolyglotTo be able to do so, you may need to install the native-image component if you have not done so already:gu install native-imageUsing a Ruby ManagerInside GraalVM is a jre/languages/ruby or languages/ruby directory which has the usual structure of a Ruby implementation. It is recommended to add this directory to a Ruby manager.See configuring Ruby managers for more information.",
                    "url": " /reference-manual/ruby/InstallingGraalVM/"
                  },
                  
                  "reference-manual-ruby-installinglibssl":  {
                    "title": "",
                    "content": "Installing libsslTruffleRuby provides the openssl module but not the native libssl system library that the module uses.TruffleRuby supports both versions 1.0.2 and 1.1.0.If you experience openssl-related errors, it might help to recompile the openssl module by running lib/truffle/post_install_hook.sh.This is done automatically by Ruby managers, and mentioned in the post-install message when installing TruffleRuby via gu install in GraalVM.RedHat-based: Fedora, Oracle Linux, etcsudo dnf install openssl-develDebian-based: Ubuntu, etcsudo apt-get install libssl-devmacOSOn macOS the system version is too old.HomebrewWe recommend installing libssl via Homebrew.brew install opensslMacPortsMacPorts should also work but is not actively tested.sudo port install openssl",
                    "url": " /reference-manual/ruby/Installinglibssl/"
                  },
                  
                  "reference-manual-ruby-installingllvm":  {
                    "title": "",
                    "content": "Installing Make and GCCSince TruffleRuby 19.3.0, TruffleRuby ships with its own LLVM toolchain.Therefore, it is no longer necessary to install LLVM.If you are using an older version, see the documentation for that version.The make utility as well as the dependencies of the toolchain still need to be available to build C and C++ extensions.RedHat-based: Fedora, Oracle Linux, etc.sudo dnf install make gccDebian-based: Ubuntu, etc.sudo apt-get install make gccMandriva-based and other Linux distributionsNote: Such distributions are not tested and not supported.First, install the make and gcc dependencies.Mandriva uses a not-yet-upstreamed patch to let clang find the GCC installation (see this comment).Therefore the internal LLVM toolchain cannot find the necessary libgcc_s by default.The proper fix is for those distributions to upstream their changes to LLVM.A workaround is to create a symlink explicitly so that the LLVM toolchain can find libgcc_s:cd /usr/lib/gccsudo ln -s x86_64-mandriva-linux-gnu x86_64-linux-gnumacOSOn macOS, make sure you have installed the command line developer tools from Xcode:xcode-select --installYou might need to add export SDKROOT=$(xcrun --show-sdk-path) in your shell profile.",
                    "url": " /reference-manual/ruby/InstallingLLVM/"
                  },
                  
                  "reference-manual-ruby-installingzlib":  {
                    "title": "",
                    "content": "Installing zlibTruffleRuby provides the zlib module but not the native zlib system library that the module uses.RedHat-based: Fedora, Oracle Linux, etcsudo dnf install zlib-develDebian-based: Ubuntu, etcsudo apt-get install libz-devmacOSOn macOS the system version can be used.",
                    "url": " /reference-manual/ruby/Installingzlib/"
                  },
                  
                  "community-internship":  {
                    "title": "",
                    "content": "",
                    "url": " /community/internship/"
                  },
                  
                  "docs-introduction":  {
                    "title": "GraalVM Documentation",
                    "content": "Introduction to GraalVMGraalVM is a high-performance JDK distribution designed to accelerate the execution of applications written in Java and other JVM languages along with support for JavaScript, Ruby, Python, and a number of other popular languages.GraalVM’s polyglot capabilities make it possible to mix multiple programming languages in a single application while eliminating foreign language call costs.This page provides an architectural overview of GraalVM and its runtime modes, supported platforms, available distributions, core and additional functionalities, and support levels for various features.  GraalVM Architecture  Runtime Modes  Available Distributions  Distribution Components List  Licensing and Support  Features Support  What to Read NextGraalVM ArchitectureGraalVM adds an advanced just-in-time (JIT) optimizing compiler, which is written in Java, to the HotSpot Java Virtual Machine.In addition to running Java and JVM-based languages, GraalVM’s Truffle language implementation framework makes it possible to run JavaScript, Ruby, Python, and a number of other popular languages on the JVM.With GraalVM Truffle, Java and other supported languages can directly interoperate with each other and pass data back and forth in the same memory space.Runtime ModesGraalVM is unique as a runtime environment offering several modes of operation: JVM runtime mode, Native Image, Java on Truffle (the same Java applications can be run on either).JVM Runtime ModeWhen running programs on the HotSpot JVM, GraalVM defaults to the GraalVM compiler as the top-tier JIT compiler.At runtime, an application is loaded and executed normally on the JVM.The JVM passes bytecodes for Java or any other JVM-native language to the compiler, which compiles that to the machine code and returns it to the JVM.Interpreters for supported languages, written on top of the Truffle framework, are themselves Java programs that run on the JVM.Native ImageNative Image is an innovative technology that compiles Java code into a standalone binary executable or a native shared library.The Java bytecode that is processed during the native image build includes all application classes, dependencies, third party dependent libraries, and any JDK classes that are required.A generated self-contained native executable is specific to each individual operating systems and machine architecture that does not require a JVM.Java on TruffleJava on Truffle is an implementation of the Java Virtual Machine Specification, built with the Truffle language implementation framework.It is a complete Java VM that includes all core components, implements the same API as the Java Runtime Environment library, and reuses all JARs and native libraries from GraalVM.Java on Trufle is an experimental technology in GraalVM, available as of version 21.0.0.Available DistributionsGraalVM is available as GraalVM Enterprise and GraalVM Community editions and includes support for Java 8, Java 11 and Java 16.GraalVM Enterprise is based on Oracle JDK while GraalVM Community is based on OpenJDK.GraalVM is available for Linux, macOS, and Windows platforms on x86 64-bit systems, and for Linux on ARM 64-bit system.The base GraalVM binary including all components is experimental on Linux/ARM and Windows.The GraalVM distribution based on Oracle JDK 16 is experimental with several known limitations.Depending on the platform, the distributions are shipped as .tar.gz or .zip archives.See the Getting Started guide for installation instructions.Distribution Components ListGraalVM consists of core and additional components.The core components enable using GraalVM as a runtime platform for programs written in JVM-based languages or embeddable polyglot applications.Core ComponentsRuntimes  Java HotSpot VM  JavaScript runtime  LLVM runtimeLibraries (JAR files)  GraalVM compiler - the top-tier JIT compiler  Polyglot API – the APIs for combining programming languages in a shared runtimeUtilities  JavaScript REPL with the JavaScript interpreter  lli tool to directly execute programs from LLVM bitcode  GraalVM Updater to install additional functionalitiesAdditional ComponentsGraalVM core installation can be extended with more languages runtimes and utilities.Tools/Utilities:  Native Image – a technology to compile an application ahead-of-time into a native executable.  LLVM toolchain –  a set of tools and APIs for compiling native programs to bitcode that can be executed with on the GraalVM runtime.  Java on Truffle – a JVM implementation built upon the Truffle framework to run Java via a Java bytecode interpreter.Runtimes:  Node.js – the Node.js 14.16.1 runtime for JavaScript  Python – Python 3.8.5 compatible  Ruby – Ruby 2.7.2 compatible  R – GNU R 4.0.3 compatible  GraalWasm – WebAssembly (Wasm)Licensing and SupportGraalVM Community Edition is open source software built from the sources available on GitHub and distributed underversion 2 of the GNU General Public  License with the “Classpath” Exception, which are the same terms as for Java.Check the licenses of individual GraalVM components which are generally derivative of the license of a particular language and may differ.GraalVM Community is free to use for any purpose and comes with no strings attached, but also no guarantees or support.Features SupportGraalVM technologies are distributed as production-ready and experimental.Experimental features are being considered for future versions of GraalVM and are not meant to be used in production.The development team welcomes feedback on experimental features, but users should be aware that experimental features might never be included in a final version, or might change significantly before being considered production-ready.The following table lists production-ready and experimental features in GraalVM Community Edition 21 by platform.            Feature      Linux AMD64      Linux ARM64      macOS      Windows                  Native Image      stable      experimental      stable      experimental              LLVM runtime      stable      experimental      stable      not available              LLVM toolchain      stable      experimental      stable      not available              JavaScript      stable      experimental      stable      experimental              Node.js      stable      experimental      stable      experimental              Java on Truffle      experimental      not available      experimental      experimental              Python      experimental      not available      experimental      not available              Ruby      experimental      not available      experimental      not available              R      experimental      not available      experimental      not available              WebAssembly      experimental      experimental      experimental      experimental      What to Read NextWhether you are new to GraalVM or have little experience using it, continue to Get Started with GraalVM.Install GraalVM on your local machine, try running the examples provided in the guide, or test GraalVM with your workload.After that we suggest you to look at more complex Examples Applications.Developers who have GraalVM already installed or have experience using, can skip the getting started guide and proceed to the Reference Manuals for in-depth coverage of GraalVM technologies.To start coding with the GraalVM Polyglot APIs, check out the GraalVM SDK Java API Reference.If you cannot find the answer you need in the available documentation or have a troubleshooting query, you can ask for help in a slack channel or submit a GitHub issue.",
                    "url": " /docs/introduction/"
                  },
                  
                  "examples-java-kotlin-aot":  {
                    "title": "",
                    "content": "Build a Native Image of a Java and Kotlin ApplicationThis example demonstrates how to compile a Java and Kotlin applicationahead-of-time into a native executable, and illustrates the advantages.PreparationThis example requires the Maven build tool.1. Download or clone the repository and navigate into the java-kotlin-aot directory:git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/java-kotlin-aotThis is a simple Java and Kotlin application showing how easy it is tointeroperate between JVM-based languages. A Java method accesses a String fromKotlin and calls a Kotlin function, which later accesses a String from a Javaclass. Before running this example, you need to build the application.Note: You can use any JDK for building the application. However, javac from GraalVMin the build script is used to simplify the prerequisites so another JDK does not need to be installed.2. Having installed GraalVM, export the home directory as $GRAALVM_HOME and add $GRAALVM_HOME/binto the path, using a command-line shell for Linux:export GRAALVM_HOME=/home/${current_user}/path/to/graalvmFor macOS, use:export GRAALVM_HOME=/Users/${current_user}/path/to/graalvm/Contents/HomeNote that your paths are likely to be different depending on the download location.3. Install Native Image to make use of the native-image utility.4. Then execute:./build.shHave a look at the build.sh script which creates a native executable from a Java class.The native-image utility compiles the application ahead-of-time for faster startup and lower general overhead at runtime.$GRAALVM_HOME/bin/native-image -cp ./target/mixed-code-hello-world-1.0-SNAPSHOT.jar -H:Name=helloworld -H:Class=hello.JavaHello -H:+ReportUnsupportedElementsAtRuntime --allow-incomplete-classpathIt takes a few parameters: the classpath, the main class of the application with-H:Class=..., and the name of the resulting executable with -H:Name=....After executing the native-image command, check the directory. It should haveproduced the executable file, helloworld.Running the ApplicationTo run the application, you need to execute the JAR file in the target dir.You can run it as a normal Java application using java.Or, since we have a native executable prepared, you can run that directly.The run.sh file executes both, and times them with the time utility:java -cp ./target/mixed-code-hello-world-1.0-SNAPSHOT-jar-with-dependencies.jar hello.JavaHello./helloworldAn output close to the following should be produced:→ ./run.sh+ java -cp ./target/mixed-code-hello-world-1.0-SNAPSHOT-jar-with-dependencies.jar hello.JavaHelloHello from Kotlin!Hello from Java!real0m0.129suser0m0.094ssys0m0.034s+ ./helloworldHello from Kotlin!Hello from Java!real0m0.010suser0m0.003ssys0m0.004sThe performance gain of the native version is largely due to the faster startup.LicenseThis sample application is taken from the JetBrains Kotlin-examples repository.It is distributed under the Apache License 2.0.",
                    "url": " /examples/java-kotlin-aot/"
                  },
                  
                  "examples-java-performance-examples":  {
                    "title": "",
                    "content": "Java Performance ExamplesThe GraalVM compiler achieves excellent performance, especially for highlyabstracted programs, due to its versatile optimization techniques. Code usingmore abstraction and modern Java features like Streams or Lambdas will seegreater speedups. The examples below demonstrate this.Running ExamplesStreams API ExampleA simple example based on the Streams APIis used here to demonstrate performance gains when using the GraalVM compiler.This example counts the number of uppercase characters in a body of text. Tosimulate a large load, the same sentence is processed 10 million times:1. Save the following code snippet to a file named CountUppercase.java:public class CountUppercase {    static final int ITERATIONS = Math.max(Integer.getInteger(&quot;iterations&quot;, 1), 1);    public static void main(String[] args) {        String sentence = String.join(&quot; &quot;, args);        for (int iter = 0; iter &amp;lt; ITERATIONS; iter++) {            if (ITERATIONS != 1) System.out.println(&quot;-- iteration &quot; + (iter + 1) + &quot; --&quot;);            long total = 0, start = System.currentTimeMillis(), last = start;            for (int i = 1; i &amp;lt; 10_000_000; i++) {                total += sentence.chars().filter(Character::isUpperCase).count();                if (i % 1_000_000 == 0) {                    long now = System.currentTimeMillis();                    System.out.printf(&quot;%d (%d ms)%n&quot;, i / 1_000_000, now - last);                    last = now;                }            }            System.out.printf(&quot;total: %d (%d ms)%n&quot;, total, System.currentTimeMillis() - start);        }    }}2. Compile it and run as follows:javac CountUppercase.javajava CountUppercase In 2021 I would like to run ALL languages in one VM.1 (297 ms)2 (452 ms)3 (136 ms)4 (88 ms)5 (107 ms)6 (135 ms)7 (88 ms)8 (87 ms)9 (78 ms)total: 69999993 (1550 ms)The warmup time depends on numerous factors like the source code or howmany cores a machine has. If the performance profile of CountUppercase on yourmachine does not match the above, run it for more iterations by adding-Diterations=N just after java for some N greater than 1.3. Add the -Dgraal.PrintCompilation=true option to see statistics for the compilations:java -Dgraal.PrintCompilation=true CountUppercase In 2021 I would like to run ALL languages in one VM.This option prints a line after each compilation that shows the methodcompiled, time taken, bytecodes processed (including inlined methods), sizeof machine code produced, and amount of memory allocated during compilation.4. Use the -XX:-UseJVMCICompiler option to disable the GraalVM compiler anduse the native top tier compiler in the VM to compare performance:java -XX:-UseJVMCICompiler CountUppercase In 2021 I would like to run ALL languages in one VM.1 (747 ms)2 (806 ms)3 (640 ms)4 (771 ms)5 (606 ms)6 (582 ms)7 (623 ms)8 (564 ms)9 (682 ms)total: 69999993 (6713 ms)The preceding example demonstrates the benefits of partial escape analysis (PEA)and advanced inlining, which combine to significantly reduce heap allocation.The results were obtained using Oracle GraalVM Enterprise Edition.The GraalVM Community Edition still has good performance compared to the native top-tiercompiler as shown below. You can simulate the Community Edition on the Enterprise Editionby adding the option -Dgraal.CompilerConfiguration=community.Sunflow ExampleSunflow is an open source rendering engine.The following example is a simplified version of the Sunflow engine core code.It performs calculations to blend various values for a point of light in arendered scene.1. Save the following code snippet to a file named Blender.java:public class Blender {    private static class Color {        double r, g, b;        private Color(double r, double g, double b) {            this.r = r;            this.g = g;            this.b = b;        }        public static Color color() {            return new Color(0, 0, 0);        }        public void add(Color other) {            r += other.r;            g += other.g;            b += other.b;        }        public void add(double nr, double ng, double nb) {            r += nr;            g += ng;            b += nb;        }        public void multiply(double factor) {            r *= factor;            g *= factor;            b *= factor;        }    }    private static final Color[][][] colors = new Color[100][100][100];    public static void main(String[] args) {        for (int j = 0; j &amp;lt; 10; j++) {            long t = System.nanoTime();            for (int i = 0; i &amp;lt; 100; i++) {                initialize(new Color(j / 20, 0, 1));            }            long d = System.nanoTime() - t;            System.out.println(d / 1_000_000 + &quot; ms&quot;);        }    }    private static void initialize(Color id) {        for (int x = 0; x &amp;lt; colors.length; x++) {            Color[][] plane = colors[x];            for (int y = 0; y &amp;lt; plane.length; y++) {                Color[] row = plane[y];                for (int z = 0; z &amp;lt; row.length; z++) {                    Color color = new Color(x, y, z);                    color.add(id);                    if ((color.r + color.g + color.b) % 42 == 0) {                         // PEA only allocates a color object here                         row[z] = color;                    } else {                         // Here the color object is not allocated at all                    }                }            }        }    }}2. Compile it and run as follows:javac Blender.javajava Blender1156 ms916 ms925 ms980 ms913 ms904 ms862 ms863 ms919 ms868 msIf you would like to check how it would behave when using GraalVM Community, use the following configuration flag:java -Dgraal.CompilerConfiguration=community Blender3. Use the -XX:-UseJVMCICompiler option to disable the GraalVM compiler and run with the default HotSpot JIT compiler:java -XX:-UseJVMCICompiler Blender2546 ms2522 ms1710 ms1741 ms1724 ms1722 ms1763 ms1742 ms1714 ms1733 msThe performance improvement comes from the partial escape analysis moving the allocation of color in initialize down to the point where it is stored into colors (i.e., the point at which it escapes).Check the Compiler Configuration on JVM reference for other performance tuning options.",
                    "url": " /examples/java-performance-examples/"
                  },
                  
                  "examples-java-simple-stream-benchmark":  {
                    "title": "",
                    "content": "Simple Java Stream BenchmarkThis application is a small benchmark of the Java Stream API. It demonstrates howthe GraalVM compiler can achieve better performance for highlyabstracted programs like those using Streams, Lambdas, or other Java features.PreparationThis example requires the Maven build tool.1. Download or clone the repository and navigate into the java-simple-stream-benchmark directory:git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/java-simple-stream-benchmark2. Build the benchmark. You can manually execute mvn package, but there is alsoa build.sh script included for your convenience:./build.sh3. Export the GraalVM home directory as the $GRAALVM_HOME and add $GRAALVM_HOME/binto the path, using a command-line shell for Linux:export GRAALVM_HOME=/path/to/graalvmFor macOS:export GRAALVM_HOME=/path/to/graalvm/Contents/HomeNow you are all set to execute the benchmark and compare the results between different JVMs.Running the BenchmarkTo run the benchmark, you need to execute the target/benchmarks.jar file.You can run it with the following command:java -jar target/benchmarks.jarIf you would like to run the benchmark on a different JVM, you can run it withwhatever java you have. However, if you just want to run it on the same JVM,but without the GraalVM compiler, you may add the -XX:-UseJVMCICompiler optioninto the same command:java -XX:-UseJVMCICompiler -jar target/benchmarks.jarThis way, the GraalVM compiler will not be used as the JVMCI compiler and the JVM will use its default one.Note about ResultsThe benchmark mode is AverageTime in nanoseconds per operation, which meanslower numbers are better. Note that the results you see can be influenced by thehardware you are running this benchmark on, the CPU load, and other factors.Interpret them responsibly.",
                    "url": " /examples/java-simple-stream-benchmark/"
                  },
                  
                  "java":  {
                    "title": "",
                    "content": "",
                    "url": " /java/"
                  },
                  
                  "javascript":  {
                    "title": "JavaScript",
                    "content": "",
                    "url": " /javascript/"
                  },
                  
                  "reference-manual-ruby-jrubymigration":  {
                    "title": "",
                    "content": "Migration from JRuby to TruffleRubyWhen trying TruffleRuby on your gems and applications, you are encouraged to get in touch with the TruffleRuby team for help.DeploymentIf you are migrating from JRuby, probably the easiest way to use TruffleRuby is via GraalVM, which gives you a JVM, JavaScript, Ruby, and other languages in one package.If you do not need the Java interoperability capabilities of TruffleRuby, then you could also install via your Ruby manager/installer as with any other implementation of Ruby.You can also use the standalone distribution as a simple tarball.The standalone distribution does not allow for Java interoperability.Using Ruby from JavaJRuby supports many different ways to embed Ruby in Java, including JSR 223 (also know as javax.script), the Bean Scripting Framework (BSF), JRuby Embed (also known as Red Bridge), and the JRuby direct embedding API.Thes best way to embed TruffleRuby is to use the Polyglot API, which is part of GraalVM.The API is different because it is designed to support many languages, not just Ruby.TruffleRuby also supports JSR 223, compatible with JRuby, to make it easier to run legacy JRuby code.You will need to use GraalVM to use both of these APIs.See the polyglot documentation for more information about how to use Ruby from other languages including Java; this document only shows the comparison to JRuby.Creating a ContextIn JRuby with JSR 223 you would have written:ScriptEngineManager m = new ScriptEngineManager();ScriptEngine scriptEngine = m.getEngineByName(&quot;ruby&quot;);Or with BSF you would have written:BSFManager.registerScriptingEngine(&quot;jruby&quot;, &quot;org.jruby.embed.bsf.JRubyEngine&quot;, null);BSFManager bsfManager = new BSFManager();Or with JRuby Embed you would have written:ScriptingContainer container = new ScriptingContainer();Or with the direct embedding API you would have written:Ruby ruby = Ruby.newInstance(new RubyInstanceConfig());In TruffleRuby you now write:Context polyglot = Context.newBuilder().allowAllAccess(true).build();The allowAllAccess(true) method allows the permissive access privileges that Ruby needs for full functionality.GraalVM by default disallows many privileges which may not be safe, such as native file access, but a normal Ruby installation uses these so we enable them.You can decide not to grant those privileges, but this will restrict some of Ruby’s functionality.// No privileges granted, restricts functionalityContext polyglot = Context.newBuilder().build();You would normally create your context inside a try block to ensure it is properly disposed:try (Context polyglot = Context.newBuilder().allowAllAccess(true).build()) {}See the Context API for detailed documentation about Context.Setting OptionsYou can set TruffleRuby options via system properties, or via the .option(name, value) builder method.Evaluating CodeIn JRuby where you would have written one of these JRuby examples, the options available are given:scriptEngine.eval(&quot;puts &#39;hello&#39;&quot;);bsfManager.exec(&quot;jruby&quot;, &quot;&amp;lt;script&amp;gt;&quot;, 1, 0, &quot;puts &#39;hello&#39;&quot;);container.runScriptlet(&quot;puts &#39;hello&#39;&quot;);ruby.evalScriptlet(&quot;puts &#39;hello&#39;&quot;);In TruffleRuby you now write this:polyglot.eval(&quot;ruby&quot;, &quot;puts &#39;hello&#39;&quot;);Note that eval supports multiple languages, so you need to specify the language each time.Evaluating Code with ParametersIn JRuby with JSR 223 you can pass parameters, called bindings, into a script:Bindings bindings = scriptEngine.createBindings();bindings.put(&quot;a&quot;, 14);bindings.put(&quot;b&quot;, 2);scriptEngine.eval(&quot;puts a + b&quot;, bindings);In TruffleRuby the eval method does not take parameters. Instead you should return a proc which does take parameters, and then call execute on this value:polyglot.eval(&quot;ruby&quot;, &quot;-&amp;gt; a, b { puts a + b }&quot;).execute(14, 2);Primitive ValuesThe different embedding APIs handle primitive values in different ways.In JSR 223, BSF, and JRuby Embed, the return type is Object and can be cast to a primitive like long and checked with instanceof.In the direct embedding API the return is the root IRubyObject interface and you will need to convert a primitive to an Integer, and from there to a Java long:(long) scriptEngine.eval(&quot;14 + 2&quot;);(long) bsfManager.eval(&quot;jruby&quot;, &quot;&amp;lt;script&amp;gt;&quot;, 1, 0, &quot;14 + 2&quot;);(long) container.runScriptlet(&quot;14 + 2&quot;);ruby.evalScriptlet(&quot;14 + 2&quot;).convertToInteger().getLongValue();In TruffleRuby the return value is always an encapsulated Value object, which can be accessed as a long if that is possible for the object. fitsInLong() can test this:polyglot.eval(&quot;ruby&quot;, &quot;14 + 2&quot;).asLong();Calling MethodsTo call a method on an object you get from an eval, or any other object, in the JRuby embedding APIs you either need to ask the context to invoke the method, or in the case of direct embedding you need to call a method on the receiver and marshal the arguments into JRuby types yourself.The BSF does not appear to have a way to call methods:((Invocable) scriptEngine).invokeMethod(scriptEngine.eval(&quot;Math&quot;), &quot;sin&quot;, 2);container.callMethod(container.runScriptlet(&quot;Math&quot;), &quot;sin&quot;, 2);ruby.evalScriptlet(&quot;Math&quot;).callMethod(ruby.getCurrentContext(), &quot;sin&quot;, new IRubyObject[]{ruby.newFixnum(2)})In TruffleRuby the Value class has a getMember method to return Ruby methods on an object, which you can then call by calling execute.You do not need to marshal the arguments:polyglot.eval(&quot;ruby&quot;, &quot;Math&quot;).getMember(&quot;sin&quot;).execute(2);To call methods on a primitive, use a lambda:polyglot.eval(&quot;ruby&quot;, &quot;-&amp;gt; x { x.succ }&quot;).execute(2).asInt();Passing BlocksBlocks are a Ruby-specific language feature, so they don’t appear in language agnostic APIs like JSR 223 and BSF.The JRuby Embed API and direct embedding do allow passing a Block parameter to the callMethod method, but it is not clear how you would create a Block object to use this.In TruffleRuby you should return a Ruby lambda that performs your call, passing a block that executes a Java lambda that you pass in:polyglot.eval(&quot;ruby&quot;, &quot;-&amp;gt; block { (1..3).each { |n| block.call n } }&quot;)  .execute(polyglot.asValue((IntConsumer) n -&amp;gt; System.out.println(n)));Creating ObjectsJRuby embedding APIs don’t have support for creating new objects, but you can just call the new method yourself:((Invocable) scriptEngine).invokeMethod(scriptEngine.eval(&quot;Time&quot;), &quot;new&quot;, 2021, 3, 18);container.callMethod(container.runScriptlet(&quot;Time&quot;), &quot;new&quot;, 2021, 3, 18)ruby.evalScriptlet(&quot;Time&quot;).callMethod(ruby.getCurrentContext(), &quot;new&quot;,  new IRubyObject[]{ruby.newFixnum(2021), ruby.newFixnum(3), ruby.newFixnum(8)})In TruffleRuby you can create an object from a Ruby class using newInstance.You can use canInstantiate to see if this will be possible:polyglot.eval(&quot;ruby&quot;, &quot;Time&quot;).newInstance(2021, 3, 18);Handling StringsIn JRuby’s embedding APIs you would use toString to convert to a Java String.Use asString in TruffleRuby (and isString to check).Accessing ArraysJRuby’s arrays implement List&amp;lt;Object&amp;gt;, so you can cast to this interface to access them:((List) scriptEngine.eval(&quot;[3, 4, 5]&quot;)).get(1);((List) container.runScriptlet(&quot;[3, 4, 5]&quot;)).get(1);((List) bsfManager.eval(&quot;jruby&quot;, &quot;&amp;lt;script&amp;gt;&quot;, 1, 0, &quot;[3, 4, 5]&quot;)).get(1);((List) ruby.evalScriptlet(&quot;[3, 4, 5]&quot;)).get(1);In TruffleRuby you can use getArrayElement, setArrayElement, andgetArraySize, or you can use as(List.class) to get a List&amp;lt;Object&amp;gt;:polyglot.eval(&quot;ruby&quot;, &quot;[3, 4, 5]&quot;).getArrayElement(1);polyglot.eval(&quot;ruby&quot;, &quot;[3, 4, 5]&quot;).as(List.class).get(1);Accessing HashesJRuby’s hashes implement Map&amp;lt;Object, Object&amp;gt;, so you can cast to thisinterface to access them:((Map) scriptEngine.eval(&quot;{&#39;a&#39; =&amp;gt; 3, &#39;b&#39; =&amp;gt; 4, &#39;c&#39; =&amp;gt; 5}&quot;)).get(&quot;b&quot;);((Map) scriptEngine.eval(&quot;{3 =&amp;gt; &#39;a&#39;, 4 =&amp;gt; &#39;b&#39;, 5 =&amp;gt; &#39;c&#39;}&quot;)).get(4);In TruffleRuby there is currently no uniform way to access hashes or dictionary-like data structures.At the moment we recommend using a lambda accessor:Value hash = polyglot.eval(&quot;ruby&quot;, &quot;{&#39;a&#39; =&amp;gt; 3, &#39;b&#39; =&amp;gt; 4, &#39;c&#39; =&amp;gt; 5}&quot;);Value accessor = polyglot.eval(&quot;ruby&quot;, &quot;-&amp;gt; hash, key { hash[key] }&quot;);accessor.execute(hash, &quot;b&quot;);Implementing InterfacesYou may want to implement a Java interface using a Ruby object (example copied from the JRuby wiki):interface FluidForce {  double getFluidForce(double a, double b, double depth);}class EthylAlcoholFluidForce  def getFluidForce(x, y, depth)    area = Math::PI * x * y    49.4 * area * depth  endendEthylAlcoholFluidForce.newString RUBY_SOURCE = &quot;class EthylAlcoholFluidForcen  def getFluidForce...&quot;;In JSR 223 you can use getInterface(object, Interface.class).In JRuby Embed you can use getInstance(object, Interface.class).In direct embedding you can use toJava(Interface.class).BSF does not appear to support implementing interfaces:FluidForce fluidForce = ((Invocable) scriptEngine).getInterface(scriptEngine.eval(RUBY_SOURCE), FluidForce.class);FluidForce fluidForce = container.getInstance(container.runScriptlet(RUBY_SOURCE), FluidForce.class);FluidForce fluidForce = ruby.evalScriptlet(RUBY_SOURCE).toJava(FluidForce.class);fluidForce.getFluidForce(2.0, 3.0, 6.0);In TruffleRuby you can get an interface implemented by your Ruby object by using as(Interface.class):FluidForce fluidForce = polyglot.eval(&quot;ruby&quot;, RUBY_SOURCE).as(FluidForce.class);fluidForce.getFluidForce(2.0, 3.0, 6.0);JRuby allows the name of the Ruby method to be get_fluid_force, using Ruby conventions, instead of getFluidForce, using Java conventions.TruffleRuby does not support this at the moment.Implementing LambdasAs far as we know, JSR 223, BSF, JRuby Embed, and direct embedding do not have a convenient way to get a Java lambda from a Ruby lambda.In TruffleRuby you can get a Java lambda (really an implementation of a functional interface) from a Ruby lambda by usingas(FunctionalInterface.class):BiFunction&amp;lt;Integer, Integer, Integer&amp;gt; adder = polyglot.eval(&quot;ruby&quot;, &quot;-&amp;gt; a, b { a + b }&quot;).as(BiFunction.class);adder.apply(14, 2).intValue();Parse Once Run Many TimesSome of the JRuby embedding APIs allow a script to be compiled once and then eval’d several times:CompiledScript compiled = ((Compilable) scriptEngine).compile(&quot;puts &#39;hello&#39;&quot;);compiled.eval();In TruffleRuby you can simply return a lambda from parsing and execute this many times.It will be subject to optimization like any other Ruby code:Value parsedOnce = polyglot.eval(&quot;ruby&quot;, &quot;-&amp;gt; { run many times }&quot;);parsedOnce.execute();Using Java from RubyTruffleRuby provides its own scheme for Java interoperability that is consistent for use from any GraalVM language, to any other GraalVM language.This is not compatible with existing JRuby-Java interoperability, so you will need to migrate.Polyglot programming in general is documented elsewhere - this section describes it relative to JRuby.This example is from the JRuby wiki:require &#39;java&#39;# With the &#39;require&#39; above, you now can refer to things that are part of the# standard Java platform via their full paths.frame = javax.swing.JFrame.new(&quot;Window&quot;) # Creating a Java JFramelabel = javax.swing.JLabel.new(&quot;Hello&quot;)# You can transparently call Java methods on Java objects, just as if they were defined in Ruby.frame.add(label)  # Invoking the Java method &#39;add&#39;.frame.setDefaultCloseOperation(javax.swing.JFrame::EXIT_ON_CLOSE)frame.packframe.setVisible(true)In TruffleRuby we would write that this way instead:Java.import &#39;javax.swing.JFrame&#39;Java.import &#39;javax.swing.JLabel&#39;frame = JFrame.new(&quot;Window&quot;)label = JLabel.new(&quot;Hello&quot;)frame.add(label)frame.setDefaultCloseOperation(JFrame[:EXIT_ON_CLOSE])frame.packframe.setVisible(true)Instead of using Ruby metaprogramming to simulate a Java package name, we explicitly import classes.Java.import is similar to JRuby’s java_import, and does ::ClassName = Java.type(&#39;package.ClassName&#39;).Constants are read by reading properties of the class rather than using Ruby notation.Require JavaDo not require &#39;java&#39; in TruffleRuby. However, you do need to run in --jvm mode.This is only available in GraalVM - not in the standalone distribution installed by Ruby version managers and installers.Referring to ClassesIn JRuby, Java classes can either be referenced in the Java module, such as Java::ComFoo::Bar, or if they have a common TLD they can be referenced as com.foo.Bar. java_import com.foo.Bar will define Bar as a top-level constant.In TruffleRuby, Java classes are referred to using either Java.type(&#39;com.foo.Bar&#39;), which you would then normally assign to a constant, or you can use Java.import &#39;com.foo.Bar&#39; to have Bar defined as a top-level constant.Wildcard Package ImportsJRuby lets you include_package &#39;com.foo&#39; which will make all classes in that package available as constants in the current scope.In TruffleRuby you refer to classes explicitly.Calling Methods and Creating InstancesIn both JRuby and TruffleRuby you call Java methods as you would a Ruby method.JRuby will rewrite method names such as my_method to the Java convention of myMethod, and convert getFoo to foo, and setFoo to foo=.TruffleRuby does not perform these conversions.Referring to ConstantsIn JRuby, Java constants are modelled as Ruby constants, MyClass::FOO.In TruffleRuby you use the read notation to read them as a property,MyClass[:FOO].Using Classes from JAR filesIn JRuby you can add classes and JARs to the classpath using require.In TruffleRuby at the moment you use the -classpath JVM flag as normal.Additional Java-Specific MethodsJRuby defines these methods on Java objects; use these equivalents instead.java_class - use class.java_kind_of? - use is_a?java_object - not supported.java_send - use __send__.java_method - not supported.java_alias - not supported.Creating Java ArraysIn JRuby you use Java::byte[1024].new.In TruffleRuby you would use Java.type(&#39;byte[]&#39;).new(1024).Implementing Java InterfacesJRuby has several ways to implement an interface.For example, to add an action listener to a Swing button we could do any of the following three things:class ClickAction  include java.awt.event.ActionListener  def actionPerformed(event)   javax.swing.JOptionPane.showMessageDialog nil, &#39;hello&#39;  endendbutton.addActionListener ClickAction.newbutton.addActionListener do |event|  javax.swing.JOptionPane.showMessageDialog nil, &#39;hello&#39;endbutton.addActionListener -&amp;gt; event {  javax.swing.JOptionPane.showMessageDialog nil, &#39;hello&#39;}In TruffleRuby we’d always use the last option to generate an interface:button.addActionListener -&amp;gt; event {  JOptionPane.showMessageDialog nil, &#39;hello&#39;}Generating Java Classes at RuntimeJRuby supports converting a Ruby class to a concrete Java class using become_java!.TruffleRuby does not support this.We recommend using a proper Java interface as your interface between Java and Ruby.Reopening Java ClassesJava classes cannot be reopened in TruffleRuby.Subclassing Java ClassesJava classes cannot be subclassed in TruffleRuby. Use composition or interfaces instead.Extending TruffleRuby Using JavaJRuby supports extensions written in Java. These extensions are written against an informal interface that is simply the entire internals of JRuby, similar to how the MRI C extension interface works.TruffleRuby does not support writing these kind of Java extensions at the moment.We recommend using Java interop as described above.ToolingStandalone Classes and JARsJRuby supports compiling to standalone source classes and compiled JARs from Ruby using jrubyc.TruffleRuby does not support compiling Ruby code to Java. We recommend using the Polyglot API as your entry point from Java to Ruby.WarblerJRuby supports building WAR files for loading into enterprise Java web servers.TruffleRuby does not support this at the moment.VisualVMVisualVM works for TruffleRuby as for JRuby.Additionally, the VisualVM included in GraalVM understands Ruby objects, rather than Java objects, when you use the heap dump tool.",
                    "url": " /reference-manual/ruby/JRubyMigration/"
                  },
                  
                  "reference-manual-ruby-knowncves":  {
                    "title": "",
                    "content": "SecurityPlease report security vulnerabilities via the process outlined in the reporting vulnerabilities guide.Specific guidelines for reporting security issues of the GraalVM project, including TruffleRuby, can be found in the SECURITY file.Unimplemented Security FeaturesRuby’s $SAFE feature adds additional checks regarding how tainted data is used, but they are not always correct.The checks for tainted data are likewise inconsistent and their implementation has been the subject of many vulnerabilities,including regressions of previously fixed vulnerabilities, as detailed below.Consensus in the Ruby community is that $SAFE is a broken security feature that does not provide genuine safety and it will eventually be removed.For these reasons, TruffleRuby will not let you enable the $SAFE feature.This does not disable a security feature that would normally be enabled - it prevents you from using a broken security feature.This has the effect that $SAFE and Thread#safe_level are 0 and no other levels are implemented.Trying to use level 1 will raise a SecurityError.Other levels will raise an ArgumentError as in standard Ruby.MRI VulnerabilitiesVulnerabilities reported against MRI may apply to the design of Ruby or to code that we share with MRI.We list reported MRI vulnerabilities here and document how MRI has mitigated the vulnerability, if the mitigation is testedby anything, and how TruffleRuby has mitigated. We have not investigated all legacy vulnerabilities, as it is often very hard to work out the details from older reports.Cross-reference with the details on the MRI website.            Number      Description      Their Mitigation      Test      Our Mitigation                  CVE-2021-28966      Path traversal in Tempfile on Windows      Sanitization of paths in tmpdir.rb      In test/mri/tests/test_tmpdir.rb      Sanitization of paths in tmpdir.rb              CVE-2021-28965      XML round-trip vulnerability in REXML      Update to REXML 3.2.5      In ruby/rexml      Update to REXML 3.2.5              CVE-2020-10663      Unsafe Object Creation Vulnerability in JSON (Additional fix)      Fix      Spec      The pure Ruby version of JSON we use is safe              CVE-2019-16255      A code injection vulnerability of Shell#[] and Shell#test      Fix      MRI test      Same              CVE-2019-16254      HTTP response splitting in WEBrick (Additional fix)      Fix      MRI test      Same              CVE-2019-15845      A NUL injection vulnerability of File.fnmatch and File.fnmatch?      Fix      MRI test      Check for NUL bytes              CVE-2019-16201      Regular Expression Denial of Service vulnerability of WEBrick’s Digest access authentication      Fix      MRI test      Same              CVE-2012-6708      Multiple jQuery vulnerabilities in RDoc      Remove jquery.js      N/A      Same              CVE-2015-9251      Multiple jQuery vulnerabilities in RDoc      Remove jquery.js      N/A      Same              CVE-2019-8320      Delete directory using symlink when decompressing tar      Check the expanded path      Tested in MRI test/rubygems/test_gem_package.rb      Applied the same patch              CVE-2019-8321      Escape sequence injection in verbose      Sanitise message      Tested in ruby/spec :security      Applied the same patch              CVE-2019-8322      Escape sequence injection in gem owner      Sanitise message      Tested in ruby/spec :security      Applied the same patch              CVE-2019-8323      Escape sequence injection vulnerability in API response handling      Sanitise message      Tested in ruby/spec :security      Applied the same patch              CVE-2019-8324      Installing a malicious gem may lead to arbitrary code execution      Verifying gems before pre-install checks      Tested in MRI test/rubygems/test_gem_installer.rb      Applied the same patch              CVE-2019-8325      Escape sequence injection in errors      Sanitise error messages      Tested in ruby/spec :security      Applied the same patch              CVE-2018-16395      OpenSSL::X509::Name equality check does not work correctly                                   CVE-2018-16396      Tainted flags are not propagated in Array#pack and String#unpack with some directives      Additional taint operations      Tested in ruby/spec :security      Additional taint operations              CVE-2018-6914      Unintentional file and directory creation with directory traversal in tempfile and tmpdir      Sanitization of paths      Tested in ruby/spec :security      Sanitization of paths              CVE-2018-8779      Unintentional socket creation by poisoned NUL byte in UNIXServer and UNIXSocket      Check for NUL bytes      Tested in ruby/spec :security      Check for NUL bytes              CVE-2018-8780      Unintentional directory traversal by poisoned NUL byte in Dir      Check for NUL bytes      Tested in ruby/spec :security      Check for NUL bytes              CVE-2018-8777      DoS by large request in WEBrick      Logic for header length      Tested in MRI test/webrick/test_httpserver.rb      Applied the same mitigation              CVE-2017-17742      HTTP response splitting in WEBrick      Logic for invalid headers      Tested in ruby/spec :security      Applied the same mitigation              CVE-2018-8778      Buffer under-read in String#unpack      A range check      Tested in ruby/spec :security      A range check              CVE-2017-17405      Command injection vulnerability in Net::FTP      Treat paths in commands explicitly as paths, not general IO commands      Tested in MRI test/net/ftp/test_ftp.rb      Applied the same mitigation              CVE-2017-10784      Escape sequence injection vulnerability in the Basic authentication of WEBrick      Proper escaping of logs      Tested in MRI test/webrick/test_httpauth.rb      Applied the same mitigation              CVE-2017-0898      Buffer underrun vulnerability in Kernel.sprintf                                   CVE-2017-14033      Buffer underrun vulnerability in OpenSSL ASN1 decode                                   CVE-2017-14064      Heap exposure vulnerability in generating JSON                                   CVE-2017-0902, CVE-2017-0899, CVE-2017-0900, CVE-2017-0901      Multiple vulnerabilities in RubyGems                                   CVE-2015-7551      Unsafe tainted string usage in Fiddle and DL (regression of the mitigation of CVE-2009-5147)      Additional taint checks      Tested in MRI test/mri/tests/fiddle/test_handle.rb      Not applicable as we do not support $SAFE, and the DL module was removed in Ruby 2.2.0              CVE-2015-1855      Ruby OpenSSL Hostname Verification                                   CVE-2014-8090      Another Denial of Service XML Expansion                                   CVE-2014-8080      Denial of Service XML Expansion             Tested in ruby/spec :security                     None      Changed default settings of ext/openssl                                   CVE-2014-2734      Dispute of Vulnerability                                   CVE-2014-0160      OpenSSL Severe Vulnerability in TLS Heartbeat Extension                                   CVE-2014-2525      Heap Overflow in YAML URI Escape Parsing                                   CVE-2013-4164      Heap Overflow in Floating Point Parsing             Tested in ruby/spec :security                     CVE-2013-4073      Hostname check bypassing vulnerability in SSL client                                   CVE-2013-2065      Object taint bypassing in DL and Fiddle in Ruby      Additional taint checks      Tested in MRI test/mri/tests/fiddle/test_func.rb      Not applicable as we do not support $SAFE, and the DL module was removed in Ruby 2.2.0              CVE-2013-1821      Entity expansion DoS vulnerability in REXML                                   CVE-2013-0269      Denial of Service and Unsafe Object Creation Vulnerability in JSON                                   CVE-2013-0256      XSS exploit of RDoc documentation generated by rdoc                                   CVE-2012-5371      Hash-flooding DoS vulnerability for ruby 1.9                                   CVE-2012-4522      Unintentional file creation caused by inserting a illegal NUL character                                   CVE-2012-4464, CVE-2012-4466      $SAFE escaping vulnerability about Exception#to_s / NameError#to_s                    Not applicable as we do not support $SAFE              None      Security Fix for RubyGems: SSL server verification failure for remote repository                                   CVE-2011-3389      Security Fix for Ruby OpenSSL module: Allow 0/n splitting as a prevention for the TLS BEAST attack                                   CVE-2011-4815      Denial of service attack was found for Ruby’s Hash algorithm (cross-reference CVE-2011-4838, CVE-2012-5370, CVE-2012-5372)      Hashes are made non-deterministic by incorporating process start time      Tested in ruby/spec :security      Hashes are made non-deterministic by incorporating a seed from /dev/urandom              None      Exception methods can bypass $SAFE                    Not applicable as we do not support $SAFE              None      FileUtils is vulnerable to symlink race attacks                                   CVE-2010-0541      XSS in WEBrick                                   None      Buffer over-run in ARGF.inplace_mode=                                   None      WEBrick has an Escape Sequence Injection vulnerability                                   CVE-2009-5147      DL::dlopen opens libraries with tainted names      Additional taint checks      The DL module does not exist in modern Ruby      Not applicable as we do not support $SAFE, and the DL module was removed in Ruby 2.2.0              CVE-2009-4124      Heap overflow in String                                   None      DoS vulnerability in BigDecimal                                   None      DoS vulnerability in REXML                                   CVE-2008-1447      Multiple vulnerabilities in Ruby                                   CVE-2008-2662, CVE-2008-2663, CVE-2008-2725, CVE-2008-2726, CVE-2008-2664, CVE-2008-1891      Arbitrary code execution vulnerabilities                                   None      File access vulnerability of WEBrick                                   None      Net::HTTPS Vulnerability                                   JVN#84798830      Another DoS Vulnerability in CGI Library                                   CVE-2006-5467      DoS Vulnerability in CGI Library                                   VU#160012      Ruby vulnerability in the safe level settings                    Not applicable as we do not support $SAFE      JRuby VulnerabilitiesTruffleRuby uses code from JRuby, so vulnerabilities reported against JRuby may apply to TruffleRuby.            Number      Description      Their Mitigation      Test      Our Mitigation                  CVE-2012-5370      JRuby computes hash values without properly restricting the ability to trigger hash collisions predictably (cross-reference CVE-2011-4815, CVE-2011-4838, CVE-2012-5372)      Hashes are made non-deterministic by incorporating process start time      Tested in ruby/spec :security      Hashes are made non-deterministic by incorporating a seed from /dev/urandom              CVE-2011-4838      JRuby before 1.6.5.1 computes hash values without restricting the ability to trigger hash collisions predictably (cross-reference CVE-2011-4815, CVE-2012-5370, CVE-2012-5372)      Hashes are made non-deterministic by incorporating process start time      Tested in ruby/spec :security      Hashes are made non-deterministic by incorporating a seed from /dev/urandom      Rubinius VulnerabilitiesTruffleRuby uses code from Rubinius, so vulnerabilities reported against Rubinius may apply to TruffleRuby.            Number      Description      Their Mitigation      Test      Our Mitigation                  CVE-2012-5372      Rubinius computes hash values without properly restricting the ability to trigger hash collisions predictably (cross-reference CVE-2011-4815, CVE-2011-4838, CVE-2012-5370)      Hashes are made non-deterministic by incorporating output from /dev/urandom      Tested in ruby/spec :security      Hashes are made non-deterministic by incorporating a seed from /dev/urandom      Java Dependency VulnerabilitiesJONINo vulnerabilities are known.JCodings            Number      Description      Their Mitigation      Test      Our Mitigation                  CVE-2010-1330      The regular expression engine in JRuby before 1.4.1, when $KCODE is set to &#39;u&#39;, does not properly handle characters immediately after a UTF-8 character      Check byte sequences for the UTF-8 encoding when perform regexp operations      Tested in ruby/spec :security      Applied the same mitigation      Other Dependency VulnerabilitieszlibNo vulnerabilities are known, but consider potential vulnerabilities in your system zlib.libsslConsider potential vulnerabilities in your system libssl.FFI            Number      Description      Their Mitigation      Test      Our Mitigation                  CVE-2018-1000201      A DLL loading issue can be hijacked on Windows when a Symbol is used for the library name      Treat Symbols the same as Strings in ffi_lib             Applied the same mitigation, by using a version of FFI which fixed this vulnerability      Notes on HashingTruffleRuby uses MurmurHash2 hashing with a seed from /dev/urandom - it cannot be configured to use any other hashing algorithm.For hashing strings, TruffleRuby uses Java’s hash algorithm (and then MurmurHash2 on top).",
                    "url": " /reference-manual/ruby/KnownCVEs/"
                  },
                  
                  "release-notes-known-issues":  {
                    "title": "",
                    "content": "Known Issues  GraalVM distributions based on Oracle JDK 16 and OpenJDK 16 are currently under development and provided for evaluation and testing purposes.These distributions include the GraalVM compiler, the GraalVM Updater tool, the JavaScript runtime, and development tools (e.g., Chrome inspector based debugger, Profiler, etc.).The core installation can be extended with Native Image, Node.js, GraalVM LLVM toolchain support, and the R runtime.However, several limitations remain when using Native Image with this distribution:          Limited support for default Proxy methods which can result in unexpected method: proxyClassLookup at image build time. See  JDK-8159746.      Using lambda expressions in classes that are initialized at run time will result in jdk.vm.ci.common.JVMCIError: Unknown JvmConstant tag 17. See #3310.      JFR support is not available.            On GraalVM 20.3, language REPLs that migrated to JLine 3 will crash on startup when launched in the rxvt terminal emulator. It is a known bug in JLine that has already been fixed in the most recent version 3.15. Please consider upgrading JLine.    With macOS 10.15, Apple introduced new requirements for software notarization.The GraalVM distribution is not currently notarized and will be quarantined bydefault. To install GraalVM, you will need to run the following command toremove from quarantine:    sudo xattr -r -d com.apple.quarantine /path/to/GRAALVM_HOME    Due do the issue with the underlying platform Java Mission control freezes at startup on macOS. Because of that we removed the jmc utility from the distribution. For more information and workarounds please see the JMC known issues page.",
                    "url": " /release-notes/known-issues/"
                  },
                  
                  "reference-manual-languages":  {
                    "title": "",
                    "content": "Languages ReferencesGraalVM is designed to accelerate the execution of applications written in Java and other JVM languages while also providing a high performance runtime for JavaScript, Ruby, Python, and a number of other popular languages.GraalVM’s polyglot capabilities make it possible to mix multiple programming languages in a single application while eliminating any foreign language call costs.If you are mostly interested in GraalVM’s support for a specific language, here you can find the most extensive documentation:  Java  Java on Truffle  JavaScript and Node.js  LLVM Languages  Python  R  Ruby  WebAssembly",
                    "url": " /reference-manual/languages/"
                  },
                  
                  "docs-getting-started-linux-aarch64":  {
                    "title": "",
                    "content": "Installation on Linux ARM64 systemsAs of version 21.0, we provide GraalVM Community Edition for Linux on ARM 64-bit system, based on OpenJDK 11 for AArch64 architecture.This distribution can be installed on Linux systems for AArch64 CPU architecture, version 7.6 or higher.Note: The base GraalVM Community distribution including all components is experimental on Linux ARM 64-bit systems.You can install the GraalVM distribution for Linux ARM64 systems from an archive file (.tar.gz).This allows you to install GraalVM for the current user into any location, without affecting other JDK installations.  Navigate to the GraalVM Releases repository on GitHub. Depending on the workload, select Java 11 or 16 based distribution for the Linux AArch64 architecture, and download.  Change the directory to the location where you want to install GraalVM, then move the .tar.gz archive to it.  Unzip the archive:    tar -xzf graalvm-ce-java&amp;lt;version&amp;gt;-linux-aarch64-&amp;lt;version&amp;gt;.tar.gz    There can be multiple JDKs installed on the machine. The next step is to configure the runtime environment:          Point the PATH environment variable to the GraalVM Enterprise bin directory:          export PATH=/path/to/&amp;lt;graalvm&amp;gt;/bin:$PATH            Set the JAVA_HOME environment variable to resolve to the installation directory:          export JAVA_HOME=/path/to/&amp;lt;graalvm&amp;gt;              To check whether the installation was successful, run the java -version command.Optionally, you can specify GraalVM as the default JRE or JDK installation in your Java IDE.For Oracle GraalVM Enterprise Edition users, find the installation instructions here.Supported FunctionalitiesThe 64-bit GraalVM Community distribution for Linux platforms includes OpenJDK with the GraalVM compiler enabled, the GraalVM Updater, gu, tool, the JavaScript runtime, and some developer tools (e.g., Chrome inspector based debugger, Visual VM).Support for Native Image, Node.js, LLVM and WebAssembly runtimes can be installed with gu.Runtimes for Python, FastR, and Ruby languages are not available in this distribution yet.",
                    "url": " /docs/getting-started/linux-aarch64/"
                  },
                  
                  "docs-getting-started-linux":  {
                    "title": "",
                    "content": "Installation on Linux PlatformsFollow these steps to install GraalVM Community Edition on the Linux operating system.  Navigate to the GraalVM Releases repository on GitHub. Depending on the workload, select Java 11 based or Java 8 based distribution for the Linux AMD64 architecture, and download.  Change the directory to the location where you want to install GraalVM, then move the .tar.gz archive to it.  Unzip the archive:    tar -xzf graalvm-ce-java&amp;lt;version&amp;gt;-linux-amd64-&amp;lt;version&amp;gt;.tar.gz    There can be multiple JDKs installed on the machine. The next step is to configure the runtime environment:          Point the PATH environment variable to the GraalVM Enterprise bin directory:          export PATH=/path/to/&amp;lt;graalvm&amp;gt;/bin:$PATH            Set the JAVA_HOME environment variable to resolve to the installation directory:          export JAVA_HOME=/path/to/&amp;lt;graalvm&amp;gt;              To check whether the installation was successful, run the java -version command.Optionally, you can specify GraalVM as the default JRE or JDK installation in your Java IDE.For Oracle GraalVM Enterprise Edition users, find the installation instructions here.Supported FunctionalitiesThe base distribution of GraalVM Community Edition for Linux (AMD64) platforms includes OpenJDK with the GraalVM compiler enabled, LLVM and JavaScript runtimes.The base installation can be extended with:Tools/Utilities:  Native Image – a technology to compile an application ahead-of-time into a native executable  LLVM toolchain –  a set of tools and APIs for compiling native programs to bitcode that can be executed with on the GraalVM runtime  Java on Truffle – a Java Virtual Machine implementation based on a Truffle interpreter for GraalVMRuntimes:  Node.js – Node.js 14.16.1 compatible  Python – Python 3.8.5 compatible  Ruby – Ruby 2.7.2 compatible  R – GNU R 4.0.3 compatible  Wasm – WebAssembly (Wasm)​These runtimes are not part of the GraalVM Community base distribution and must be installed separately.To assist a user with installation, GraalVM includesGraalVM Updater, a command line utility to install and manage additionalfunctionalities. Proceed to the installation stepsto add any necessary language runtime or utility from above to GraalVM.",
                    "url": " /docs/getting-started/linux/"
                  },
                  
                  "logo":  {
                    "title": "",
                    "content": "The purpose of this page is to provide GraalVM community with quality images andusage guidance for events, social media, online content, and other possible usecases. All open source logos stewarded by Oracle should follow the samesystematic branding principles.GraalVM LogoWe welcome and encourage GraalVM users to download and use our official logo files, available in PNG, EPS or SVG formats.Use the logo you need as displayed on the website. You may scale itto fit your placement, but please avoid changing colors, design, or altering thegraphics in any way. While placing the logo on dark backgrounds, please use theversion with white background.Color SchemeThe official color palette for open source community logo is comprised ofOSC Blue and OSC Orange.TypefaceIf you want to follow GraalVM logo typeface in your slides or banner design, thetypeface you are looking for is Sun Sans SemiBold.If you have some questions or requests regarding GraalVM branding, please reachus via this email.",
                    "url": " /logo/"
                  },
                  
                  "tools-lsp":  {
                    "title": "",
                    "content": "Language Server ProtocolGraalVM supports Language Server Protocol (LSP) for guest languages. It provides features like code-completion, find usages and alike for the client tools – IDEs like Visual Studio Code.To start the GraalVM Language Server, pass the --lsp option to the commandline launcher as in the following example with a Node.js application.Note: The GraalVM Language Server is offered as a technology preview and requires theuser to pass the --experimental-options option for its activation.node --experimental-options --lsp app.js[Graal LSP] Starting server and listening on localhost/127.0.0.1:8123Example app listening on port 3000!GraalVM Enterprise-provided code completion for R script, part of the Node.js Polyglot applicationThe GraalVM Language Server itself does not provide the static data usually gathered by parsing the application sources (as these data are sometimes fuzzy in the cases of dynamic languages). Instead, the Language Server was designed to provide the accurate dynamic data gathered from the application runtime.However, the Language Server could delegate to the existing language servers written specially for the particular languages (using the --lsp.Delegates launcher option) and merge the static data returned from these servers with its own dynamic data to a single result.For more information about the GraalVM Language Server and its usage in GraalVM Visual Studio Code Extension, see Visual Studio Code Marketplace documentation.",
                    "url": " /tools/lsp/"
                  },
                  
                  "docs-getting-started-macos":  {
                    "title": "",
                    "content": "Installation on macOS PlatformsGraalVM Community Edition can be installed for a single user and administrator privileges are not required.However, if GraalVM is meant to become a default JDK, administrator privileges are required.GraalVM Community Edition does not provide the installation wizard, unlike OpenJDKdistributions for macOS that come with the .dmg download.It can be installed from an archive file (.tar.gz).Note that in macOS, the JDK installation path is: /Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home.Follow these steps to install GraalVM Community on the macOS operating system:  Navigate to GraalVM Releases repository on GitHub. Depending on the workload, select Java 11 based or Java 8 based distribution for macOS, and download.  Unzip the archive:     tar -xzf graalvm-ce-java&amp;lt;version&amp;gt;-darvin-amd64-&amp;lt;version&amp;gt;.tar.gz    Alternatively, open the file in Finder.    Move the downloaded package to its proper location, the /Library/Java/JavaVirtualMachines directory. Since this is a system directory, sudo is required:    sudo mv graalvm-ce-java&amp;lt;version&amp;gt;-&amp;lt;version&amp;gt; /Library/Java/JavaVirtualMachines    To verify if the move is successful and to get a list of all installed JDKs, run /usr/libexec/java_home -V.    There can be multiple JDKs installed on the machine. The next step is to configure the runtime environment:          Point the PATH environment variable to the GraalVM bin directory:          export PATH=/Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home/bin:$PATH            Set the JAVA_HOME environment variable to resolve to the GraalVM installation directory:          export JAVA_HOME=/Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home              To check whether the installation was successful, run the java -version command.Optionally, you can specify GraalVM as the default JRE or JDK installation in your Java IDE.For Oracle GraalVM Enterprise Edition users, find the installation instructions here.Installation NotesOn Software NotarizationIf you are using macOS Catalina and later you may need to remove the quarantine attribute from the bits before you can use them.To do this, run the following:sudo xattr -r -d com.apple.quarantine /path/to/GRAALVM_HOMEOn JAVA_HOME CommandThe information property file, Info.plist, is in the top level Contentsfolder. This means that GraalVM participates in the macOS-specific/usr/libexec/java_home mechanism. Depending on other JDK 8 installation(s)available, it is now possible that /usr/libexec/java_home -v1.8 returns/Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home.You can run /usr/libexec/java_home -v1.8 -V to see the complete list of 1.8JVMs available to the java_home command. This command sorts the JVMsin decreasing version order and chooses the top one as the default for thespecified version. Within a specific version, the sort order appears to bestable but is unspecified.Supported FunctionalitiesThe base distribution of GraalVM Community Edition for macOS includes OpenJDK with the GraalVM compiler enabled, LLVM and JavaScript runtimes.The base installation can be extended with:Tools/Utilities:  Native Image – a technology to compile an application ahead-of-time into a native executable  LLVM toolchain –  a set of tools and APIs for compiling native programs to bitcode that can be executed with on the GraalVM runtime  Java on Truffle – a Java Virtual Machine implementation based on a Truffle interpreter for GraalVMRuntimes:  Node.js – Node.js 14.16.1 compatible  Python – Python 3.8.5 compatible  Ruby – Ruby 2.7.2 compatible  R – GNU R 4.0.3 compatible  Wasm – WebAssembly (Wasm)​These runtimes are not part of the GraalVM Community base distribution and must be installed separately.To assist a user with installation, GraalVM includesGraalVM Updater, a command line utility to install and manage additionalfunctionalities. Proceed to the installation stepsto add any necessary language runtime or utility from above to GraalVM.",
                    "url": " /docs/getting-started/macos/"
                  },
                  
                  "examples-mle-oracle":  {
                    "title": "",
                    "content": "Oracle Database Multilingual Engine (MLE) Based on JavaScript moduleThis repository contains instructions on how to run the Oracle Database Multilingual Engine (MLE),based on the JavaScript module, with functions stored as procedures in the database.PreparationDownload the Docker container of the Oracle database with experimentalsupport for the Multilingual Engine from Oracle Database MLE.2. Load the Docker image:docker load --input mle-docker-0.2.7.tar.gz3. Run the container (note that you can also choose to configure non-default credentials):docker run mle-docker-0.2.74. From another console window, run the docker ps command to show only running containers and find a necessary container ID.5. Shell into the docker container:docker exec -ti &amp;lt;container_id&amp;gt; bash -liWait for the database to start. It may take time forthe first run. Next runs are faster.6. To verify the database has started, run the sqlplus from a new command shell:sqlplus scott/tiger@localhost:1521/ORCLCDBNote: scott/tiger is the default login/password.ORCLCDB is a site identifier (SID). There can be more than one database onthe same Oracle_HOME, which is why SID is required to identify them.If you have changed the default login/password, change the command respectively.If sqlplus works, the database is ready. Exit sqlplus.7. Create a directory, initialize an empty node package, install the validatormodule from NPM, and install the TypeScript types for the validator module:mkdir crazyawesomecd crazyawesomeecho &quot;{}&quot; &amp;gt; package.jsonnpm install validatornpm install @types/validator8. Deploy the validator module to the database. In the following command,validator is the module name:dbjs deploy -u scott -p tiger -c localhost:1521/ORCLCDB validator9. Start sqlplus again:sqlplus scott/tiger@localhost:1521/ORCLCDB10. Use the validator module functions as the stored procedures. Make sure to put a semicolon after the query:select validator.isEmail(&#39;oleg.selaev@oracle.com&#39;) from dual;select validator.isEmail(&#39;oleg.selaev&#39;) from dual;",
                    "url": " /examples/mle-oracle/"
                  },
                  
                  "examples-native-image-examples":  {
                    "title": "",
                    "content": "Ahead-of-Time Compilation of Java and Polyglot ApplicationsBelow are sample applications illustrating GraalVM’s uniquecapabilities to create self-contained executable images which can runincredibly fast. Here you will also find a more sophisticated example displayingGraalVM’s ability to create polyglot native executables.Preparation1. Download or clone the repository and navigate into the native-list-dir directory:git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/native-list-dirThere are two Java classes, but you will start by building ListDir.java for thepurposes of this demo. You can manually execute javac ListDir.java, and there isalso a build.sh script included for your convenience.Note that you can useany JDK for compiling the Java classes. However, we refer to javac from GraalVMin the build script to simplify the prerequisites so another JDK does not need to be installed.2. Having installed GraalVM, export the home directory as $GRAALVM_HOME and add $GRAALVM_HOME/binto the path, using a command-line shell for Linux:export GRAALVM_HOME=/home/${current_user}/path/to/graalvmFor macOS, use:export GRAALVM_HOME=/Users/${current_user}/path/to/graalvm/Contents/HomeNote that your paths are likely to be different depending on the download location.3. Install Native Image to make use of the native-image utility.4. Then execute:./build.shThe build.sh script creates a native executable from the Java class.Look at it in more detail:$GRAALVM_HOME/bin/native-image ListDirThe native-image utility ahead-of-time compiles the ListDir class into astandalone binary in the current working directory. After running thecommand, the executable file listdir should have been produced.Running the ApplicationTo run the application, you need to either execute the ListDir classas a normal Java application using java, or since we have a native executableprepared, run that directly.The run.sh file executes both, and times them with the time utility:time java ListDir $1time ./listdir $1To make it more interesting, pass it to a parent directory: ./run.sh .., where .. isthe parent of the current directory (the one containing all the demos).Depending on the directory content you pass this script for, the output will be different than this:java ListDir ..Walking path: ..Total: 141 files, total size = 14448801 bytesreal0m0.320suser0m0.379ssys0m0.070s./listDir ..Walking path: ..Total: 141 files, total size = 14448801 bytesreal0m0.030suser0m0.005ssys0m0.011sThe performance gain of the native version is largely due to the faster startup.Polyglot CapabilitiesYou can also experiment with a more sophisticated ExtListDir example,which takes advantage of GraalVM’s Java and JavaScript polyglot capabilities.$GRAALVM_HOME/bin/javac ExtListDir.javaBuilding the native executable command is similar to the one above, but since the example uses JavaScript, you need to inform the native-image utility about that by passing the --language:js option.Note that it takes a bit more time because it needs to include the JavaScript support.$GRAALVM_HOME/bin/native-image --language:js ExtListDirThe execution is the same as in the previous example:$ time java ExtListDir $1$ time ./extlistdir $1Profile-Guided Optimizations for High ThroughputOracle GraalVM Enterprise Edition offers extra benefits for building native executables. These are profile-guided optimisations (PGO). As an example, a program demonstrating Java streams will be used.1. Run the application with java to see the output:javac Streams.java$GRAALVM_HOME/bin/native-image Streams./streams 1000000 200...Iteration 20 finished in 1955 milliseconds with checksum 6e36c560485cdc012. Build an instrumented image and run it to collect profiles:$GRAALVM_HOME/bin/native-image --pgo-instrument Streams./streams 1000 200Profiles collected from this run are now stored in the default.iprof file. Note that the profiling now runs with a much smaller data size.3. Use the profiles gathered at the previous step to build an optimized native executable:$GRAALVM_HOME/bin/native-image --pgo Streams4. Run that optimized native executable:./streams 1000000 200...Iteration 20 finished in 827 milliseconds with checksum 6e36c560485cdc01You should see more than 2x improvements in performance.",
                    "url": " /examples/native-image-examples/"
                  },
                  
                  "community-opensource":  {
                    "title": "",
                    "content": "GraalVM Open SourceGraalVM Community Edition is built from the sources of  3.6 million lines ofcode originated by the GraalVM team and collaborators, and additionally million lines of sources from projects we depend on like Java, Node.js and others.We invite you to explore the current state of the project, contribute, or get intouch in case you have questions or suggestions.ContributorsWe are grateful for contributions to the project, coming from our academic, industrial and individual collaborators.You can contribute to further project development by submitting a PR, reporting an issue, or providing feedback for using GraalVM in your deployment.GraalVM Open Source RepositoriesGraalVM Core Repository includes:  GraalVM compiler is written in Java and supports both dynamic and static compilation;  Truffle is the Truffle language implementation framework for creating languages and instrumentations for GraalVM;  Substrate VM is a framework that allows ahead-of-time (AOT) compilation of Java applications under closed-world assumption into executable images or shared objects;  Sulong is an engine for running LLVM bitcode on GraalVM;  other.Related repositories are:  GraalJS — GraalVM implementation of JavaScript (ECMAScript 2020 compatible) and Node.js v12.18.0;  FastR — GraalVM implementation of the 3.6.1 programming language;  GraalPython — GraalVM implementation of the Python 3.8 programming language;  TruffleRuby — GraalVM implementation of the Ruby 2.6.6 programming language;  SimpleLanguage — a simple demonstration language for the GraalVM;  VisualVM — a visual tool integrating command line JDK tools and lightweight profiling capabilities.  VS Code — extensions to Visual Studio Code that support development of polyglot applications using GraalVM.EcosystemWe also contribute to the ecosystem by joining efforts with other open-source projects. If you see how your project can benefit from using GraalVM, feel free to reach us.      RESTHeart  is a low code framework for microservices with declarative access control and Instant Data API on MongoDB. RESTHeart fully supports GraalVM: services and interceptors can be developed in Java, Kotlin, JavaScript, and TypeScript leveraging the GraalVM polyglot programming model that can be built as native images. Learn more at restheart.org.        Eclipse Vert.x is a tool-kit for building reactive applications on the JVM. It’s even-driven, non-blocking, and supports languages like Java, JavaScript, Groovy, Ruby, Ceylon, Scala and Kotlin. Use this guide for building a Vert.x native image with GraalVM: how-to.vertx.io/graal-native-image-howto.        Fn Project is an open-source, container-native, polyglot FaaS (Function as a Service) platform. Fn users can employ GraalVM AOT compilation capabilities for serverless Java functions. Learn more: medium.com/fnproject/serverless-functions-some-like-it-aot-ea8b46951335.        Gluon Client Plugin leverages GraalVM, OpenJDK and JavaFX 11+, by compiling into native code the Java Client application and all its required dependencies, so it can directly be executed as a native application on the target platform. Learn more: docs.gluonhq.com/client/.        Helidon is a collection of Java libraries for writing microservices that run on a fast web core powered by the Netty framework. It supports MicroProfile and provides familiar APIs like JAX-RS, CDI and JSON-P/B.  Starting with version 1.0.3, Helidon supports the GraalVM native-image capability. now you can easily compile your Helidon application into a native executable. Learn more about GraalVM support in Helidon: medium.com/oracledevs/helidon-flies-faster-with-graalvm-eea85287d2dc.        Micronaut is a modern, JVM-based, full-stack framework for building modular, easily testable microservice and serverless applications. It offers extensive GraalVM support out of the box. Create your first Micronaut application: guides.micronaut.io/micronaut-creating-first-graal-app/guide/index.html.        Picocli is a Java command line parser with both an annotations API and a programmatic API, featuring usage help with ANSI colors, autocomplete and nested subcommands. Picocli-based applications can be ahead-of-time compiled to GraalVM native images. Learn more: https://picocli.info/picocli-on-graalvm.html.        Quarkus is a Cloud Native, (Linux) Container First framework for writing Java applications. Quarkus tailors your application for GraalVM to offer instant startup and reduce memory consumption. Get started: quarkus.io/get-started/.  ",
                    "url": " /community/opensource/"
                  },
                  
                  "reference-manual-ruby-optcarrot":  {
                    "title": "",
                    "content": "Running OptcarrotRunning the DemoStart by installing GraalVM.Then add GraalVM/bin in PATH (or use a Ruby manager):export PATH=&quot;/path/to/graalvm/bin:$PATH&quot;You also need to install SDL2:  brew install sdl2 on macOS  sudo yum install SDL2-devel for RedHat-based Linux  sudo apt-get install libsdl2-dev for Debian-based LinuxThen clone the optcarrot repository:git clone https://github.com/eregon/optcarrot.gitcd optcarrotThen you can play the Lan Master game.On Linux:ruby --jvm bin/optcarrot --print-fps --sdl2 --audio=none examples/Lan_Master.nesOn macOS, you need an extra flag, --vm.XstartOnFirstThread, for the GUI to appear:ruby --jvm --vm.XstartOnFirstThread bin/optcarrot --print-fps --sdl2 --audio=none examples/Lan_Master.nesNote: --audio=none is used since the audio it not nice at non-60FPS speeds.To play, use keys 1…7 (not on numpad) to scale the screen, X for OK/turn right, S for turn left, arrows to move around, and Q to quit.More information can be found in this blog post.Here is a recording of a talk running the demo on TruffleRuby and MRI.Running on Other Ruby implementationsYou can also run it on MRI for comparison.You will need to install the FFI gem with:gem install --user ffiruby bin/optcarrot --print-fps --sdl2 --audio=none examples/Lan_Master.nesYou can also run it on JRuby if desired:jruby bin/optcarrot --print-fps --sdl2 --audio=none examples/Lan_Master.nesRunning as a Benchmark from the TruffleRuby RepositoryIf you have a local checkout of TruffleRuby, you can also use the version of OptCarrot under bench/optcarrot.See the Benchmarking documentation for details.",
                    "url": " /reference-manual/ruby/Optcarrot/"
                  },
                  
                  "reference-manual-ruby-options":  {
                    "title": "",
                    "content": "TruffleRuby Options and Command LineTruffleRuby has the same command-line interface as our compatible MRI version.Usage: truffleruby [switches] [--] [programfile] [arguments]  -0[octal]       specify record separator (0, if no argument)  -a              autosplit mode with -n or -p (splits $_ into $F)  -c              check syntax only  -Cdirectory     cd to directory before executing your script  -d, --debug     set debugging flags (set $DEBUG to true)  -e &#39;command&#39;    one line of script. Several -e&#39;s allowed. Omit [programfile]  -Eex[:in], --encoding=ex[:in]                  specify the default external and internal character encodings  -Fpattern       split() pattern for autosplit (-a)  -i[extension]   edit ARGV files in place (make backup if extension supplied)  -Idirectory     specify $LOAD_PATH directory (may be used more than once)  -l              enable line ending processing  -n              assume &#39;while gets(); ... end&#39; loop around your script  -p              assume loop like -n but print line also like sed  -rlibrary       require the library before executing your script  -s              enable some switch parsing for switches after script name  -S              look for the script using PATH environment variable  -v              print the version number, then turn on verbose mode  -w              turn warnings on for your script  -W[level=2|:category]                  set warning level; 0=silence, 1=medium, 2=verbose  -x[directory]   strip off text before #!ruby line and perhaps cd to directory  --copyright     print the copyright  --enable={gems|rubyopt|...}[,...], --disable={gems|rubyopt|...}[,...]                  enable or disable features. see below for available features  --external-encoding=encoding, --internal-encoding=encoding                  specify the default external or internal character encoding  --verbose       turn on verbose mode and disable script from stdin  --version       print the version number, then exit  --help          show this message, -h for short messageFeatures:  gems            rubygems (default: enabled)  did_you_mean    did_you_mean (default: enabled)  rubyopt         RUBYOPT environment variable (default: enabled)  frozen-string-literal                  freeze all string literals (default: disabled)Warning categories:  deprecated      deprecated features  experimental    experimental featuresTruffleRuby also reads the RUBYOPT environment variable, as in standardRuby, if run from the Ruby launcher.Unlisted Ruby SwitchesMRI has some extra Ruby switches which are not normally listed in help outputbut are documented in the Ruby manual page.  -Xdirectory     cd to directory before executing your script (same as -C)  -U              set the internal encoding to UTF-8  -K[EeSsUuNnAa]  sets the source and external encoding  --encoding=external[:internal]                  the same as --external-encoding=external and optionally --internal-encoding=internalTruffleRuby OptionsTruffleRuby options are set via --option=value, or you can use --ruby.option=value from any launcher.You can omit =value to set to true.Available options and documentation can be seen with --help:languages.Additionally, set --help:expert and --help:internal to see those categories of options.All options all experimental and subject to change at any time.Options can also be set as JVM system properties, where they have a prefix polyglot.ruby..For example, --vm.Dpolyglot.ruby.cexts.remap=true, or via any other way of setting JVM system properties.Finally, options can be set as GraalVM polyglot API configuration options.The priority for options is the command line first, then the Graal-SDK polyglot API configuration, then system properties last.TruffleRuby options, as well as conventional Ruby options and VM options, can also be set in the TRUFFLERUBYOPT and RUBYOPT environment variables, if run from the Ruby launcher.-- or the first non-option argument stops processing of TrufflRuby and VM options in the same way it stops processing of Ruby arguments.VM OptionsTo set options in the underlying VM, use --vm., valid for both the native configuration and the JVM configuration.For example, --vm.Dsystem_property=value or --vm.ea.To set the classpath, use the = notation, rather than two separate arguments.For example, --vm.cp=lib.jar or --vm.classpath=lib.jar.Other Binary SwitchesOther binaries, such as irb, gem, and so on, support exactly the same switches as in standard Ruby.Determining the TruffleRuby HomeTruffleRuby needs to know where to locate files such as the standard library.These are stored in the TruffleRuby home directory.The Ruby home is always the one that the Truffle framework reports.If the Ruby home appears not to be correct, or is unset, a warning will be given but the program will continue and you will not be able to require standard libraries.You can tell TruffleRuby not to try to find a home at all using the no-home-provided option.",
                    "url": " /reference-manual/ruby/Options/"
                  },
                  
                  "examples-polyglot-javascript-java-r":  {
                    "title": "",
                    "content": "Polyglot JavaScript, Java, R Example ApplicationThis page describes an example of a polyglot application you can run with GraalVM.Preparation1. Download or clone the repository and navigate into the polyglot-javascript-java-r directory:git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/polyglot-javascript-java-r2. Install GraalVM on your platform.3. To run the demo, you need to enable Node.js support in GraalVM:gu install nodejs4. This application contains R code. The R language support is not enabled by default in GraalVM and you should add it too:gu install R5. Build the benchmark. You can manually execute npm install, but there is also a build.sh script included for your convenience:./build.shNow you are all set to run the polyglot JavaScript, Java, R application.Running the ApplicationTo run the application, you need to execute the server.js file.You can run it with the following command (or run the run.sh script):$GRAALVM_HOME/bin/node --polyglot --jvm server.jsIf you would like to run the benchmark on a different instance of Node,you can run it with whatever node you have. However, presumably, the polyglotcapability will not be supported.Open localhost:3000 and see the output of the polyglot app.Play with the source code and restart the application to see what elseyou can do with the mix of JavaScript, Java, and R.Debugging Polyglot ApplicationsGraalVM also supports debugging of polyglot applications and provides a built-inimplementation of the Chrome DevTools Protocol. Add the --inspect parameter to the command line, open the URL the applicationprints at the startup in the Chrome browser, and start debugging: set breakpoints,evaluate expressions of this app in JavaScript and R code alike, and so on.Note about the ApplicationFor brevity, this sample application contains large snippets of codeinside the strings. This is not the best approach for structuring polyglot applications,but it is the easiest way to demonstrate polyglot capabilities in a single file.",
                    "url": " /examples/polyglot-javascript-java-r/"
                  },
                  
                  "reference-manual-polyglot-programming":  {
                    "title": "",
                    "content": "Polyglot Programming  Running Polyglot Applications  Polyglot Launcher  Polyglot Options  Passing Options for Language Launchers  Passing Options Programmatically  Passing Options Using JVM ArgumentsGraalVM allows users to write polyglot applications that seamlesslypass values from one language to another by means of the Truffle language implementation framework (henceforth “Truffle”).Truffle is a Java library for building programming languages implementations as interpreters for self-modifying Abstract Syntax Trees.When writing a language interpreter with Truffle, it will automatically use the GraalVM compiler as a just-in-time compiler for the language.By having access to this framework, a Ruby application, for example, can run on the same JVM as a Java application.Also, a host JVM-based language and a guest language can directly interoperate with each other and pass data back and forth in the same memory space.In order to provide foreign polyglot values in the languages implemented with Truffle, the so-called polyglot interoperability protocol has been developed. Thisinteroperability protocol consists of a set of standardized messages that everylanguage implements and uses for foreign polyglot values. The protocol allowsGraalVM to support interoperability between any combination of languages withoutrequiring them to know of each other. For more details, proceed to theHigh-Performance Cross-Language Interoperability in a Multi-Language Runtime paper.Throughout this section you learn how to combine multiple languages using GraalVM Polyglot APIs.Running Polyglot ApplicationsThe following examples are designed to get you started with a basic polyglot application.Select a section for your Start Language and then select a tab for the Target Language.Ensure you set up GraalVM before you begin.The below examples work:  on a JVM, by passing --polyglot --jvm.  on native launchers with --polyglot (e.g., js --polyglot).It might be required to rebuild images to access languages installed with gu.  with native executables (e.g., native-image --language:js).For native launchers and native executables using Java as a Target Languageand accessing classes other than Java arrays, it is required to recompile the image and providea reflection configuration file.Note: To start an application with LLVM as a Target Language, make sureto precompile the polyglot.c file provided below.Start from JavaScript / Node.jsCreate the file polyglot.js:                                  // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;)console.log(array[2]);// END-SNIPPET                                            // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;)console.log(array[2]);// END-SNIPPET                                            // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;)console.log(array[2]);// END-SNIPPET                                            // BEGIN-SNIPPETvar array = new (Java.type(&quot;int[]&quot;))(4);array[2] = 42;console.log(array[2])// END-SNIPPET                                            // BEGIN-SNIPPETvar cpart = Polyglot.evalFile(&quot;llvm&quot;, &quot;polyglot&quot;);cpart.main()// END-SNIPPET              R      Ruby      Python      Java      LLVM            Target Language      Run:js --polyglot --jvm polyglot.js42node --polyglot --jvm polyglot.js42Start Language RCreate the file polyglot.R:                                   # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;js&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;python&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETarray &amp;lt;- new(&quot;int[]&quot;, 4)array[3L] &amp;lt;- 42print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETcpart &amp;lt;- eval.polyglot(&quot;llvm&quot;, path=&quot;polyglot&quot;)cpart$main()# END-SNIPPET                JS      Ruby      Python      Java      LLVM            Target Language      Run:Rscript --polyglot --jvm polyglot.R[1] 42Start Language RubyCreate the file polyglot.rb:                                  # BEGIN-SNIPPETarray = Polyglot.eval(&#39;js&#39;, &#39;[1,2,42,4]&#39;)puts array[2]# END-SNIPPET                                              # BEGIN-SNIPPETarray = Polyglot.eval(&#39;R&#39;, &#39;c(1L,2L,42L,4L)&#39;)puts array[2]# END-SNIPPET                                              # BEGIN-SNIPPETarray = Polyglot.eval(&#39;python&#39;, &#39;[1,2,42,4]&#39;)puts array[2]# END-SNIPPET                                              # BEGIN-SNIPPETarray = Java.type(&#39;int[]&#39;).new(4)array[2] = 42print(array[2])# END-SNIPPET                                              # BEGIN-SNIPPETcpart = Polyglot.eval_file(&#39;llvm&#39;, &#39;polyglot&#39;)cpart.main()# END-SNIPPET                JS      R      Python      Java      LLVM            Target Language      Run:ruby --polyglot --jvm polyglot.rb42Start Language PythonCreate the file polyglot.py:                                  # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;js&quot;, string=&quot;[1,2,42,4]&quot;)print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;R&quot;, string=&quot;c(1L,2L,42L,4L)&quot;)print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;ruby&quot;, string=&quot;[1,2,42,4]&quot;)print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport javaarray = java.type(&quot;int[]&quot;)(4)array[2] = 42print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport polyglotcpart = polyglot.eval(language=&quot;llvm&quot;, path=&quot;polyglot&quot;)cpart.main()# END-SNIPPET              JS      R      Ruby      Java      LLVM            Target Language      Run:graalpython --polyglot --jvm polyglot.py42Start Language JavaCreate the file Polyglot.java:                                  // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.create();        Value array = polyglot.eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        Value array = polyglot.eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        Value array = polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context context = Context.newBuilder().allowIO(true).build();        Value array = context.eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport java.io.*;import org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) throws IOException {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        File file = new File(&quot;polyglot&quot;);        Source source = Source.newBuilder(&quot;llvm&quot;, file).build();        Value cpart = polyglot.eval(source);        cpart.execute();    }}// END-SNIPPET              JS      R      Ruby      Python      LLVM            Target Language      Run:javac Polyglot.javajava Polyglot42Start Language CCreate the file polyglot.c:                                   // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;graalvm/llvm/polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 42);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET              JS      R      Ruby      Python      Java            Target Language      The example C code has to be compiled to LLVM bitcode using the LLVM frontendsuch as clang. A user can use clang shipped with GraalVM by installing apre-built LLVM toolchain support:gu install llvm-toolchainexport LLVM_TOOLCHAIN=$(lli --print-toolchain-path)Run:$LLVM_TOOLCHAIN/clang polyglot.c -lgraalvm-llvm -o polyglotlli --polyglot polyglot42Polyglot LauncherWith polyglot applications it is often impossible to decide what the primarylanguage of an application is. Therefore, an experimental newlauncher, called polyglot, has been added to GraalVM. For the moment, this launcher runs codefor JavaScript, Ruby, and R without requiring the selection of a primarylanguage. The polyglot launcher does not require the --polyglot option; it isenabled by default.This is how you can run a polyglot application by using the examples from above:polyglot --jvm polyglot.js polyglot.R polyglot.rbWe have also included a basic experimental shell for multiple languages calledthe Polyglot Shell. It is useful to quickly test the interactivity oflanguages implemented with the Truffle framework.This is how you can start it:polyglot --jvm --shellGraalVM MultiLanguage Shell 21.1.0Copyright (c) 2013-2021, Oracle and/or its affiliatesJava version 1.8|11JavaScript version 21.1.0Python version 3.8.5R version 4.0.3Ruby version 2.7.2Usage:  Use Ctrl+n to switch language and Ctrl+d to exit.  Enter -usage to get a list of available commands.java&amp;gt;Note: The polyglot launcher and the Polyglot Shell are experimental features in GraalVM.Polyglot OptionsYou can configure a language engine for better throughput or startup.  --engine.Mode=default configures the execution mode of the engine. The execution mode automatically tunes the polyglot engine towards latency or throughput.          throughput collects the maximum amount of profiling information and compiles using the  maximum number of optimizations. This mode results in slower application startup  but better throughput. This mode uses the compiler configuration community or  enterprise if not specified otherwise.      default uses a balanced engine configuration. This mode uses the compiler configuration community or enterprise if not specified otherwise.      latency collects only minimal profiling information and compiles as fast as possible  with less optimal-generated code. This mode results in faster application  startup but less optimal throughput. This mode uses the compiler configuration  economy if not specified otherwise.      Passing Options for Language LaunchersEvery language launcher has been extended with a set of so called polyglot options.Polyglot options allow users of any language launcher to access theoptions of other languages supported by GraalVM (implemented with the Truffle language implementation framework).The format is: --&amp;lt;languageID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.For example, the R launcher also supports the --js.atomics=true JavaScript option.Allowed values for the languageID are:  js: options for JavaScript  python: options for Python  r: options for R  ruby: options for Ruby  llvm: options for LLVMUse --help:languages to find out which options are available.Options for polyglot tools work in the same way with the following format: --&amp;lt;toolID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.Allowed values for &amp;lt;toolID&amp;gt; are:  inspect: allows debugging with Chrome DevTools  cpusampler: collects data about CPU usage  cputracer: captures trace information about CPU usage  memtracer: captures trace information about memory usageUse --help:tools to find out which options are available.Passing Options ProgrammaticallyOptions can also be passed programmatically using the Java polyglot API.Create a file called OptionsTest.java:import org.graalvm.polyglot.*;class OptionsTest {    public static void main(String[] args) {        Context polyglot = Context.newBuilder()            .allowExperimentalOptions(true)            .option(&quot;js.shared-array-buffer&quot;, &quot;true&quot;)            .build();        // the use of shared array buffer requires the &#39;js.shared-array-buffer&#39; option to be &#39;true&#39;        polyglot.eval(&quot;js&quot;, &quot;new SharedArrayBuffer(1024)&quot;);    }}Run:javac OptionsTest.javajava OptionsTestNote: Tools options can be passed in the same way.Options cannot be modified after the context was created.Passing Options Using JVM ArgumentsEvery polyglot option can also be passed as a Java system property.Each available option translates to a system property with the polyglot. prefix.For example, -Dpolyglot.js.strict=true sets the default value for a strict interpretation for all JavaScript code that runs in the JVM.Options that were set programmatically take precedence over Java system properties.For languages the following format can be used: -Dpolyglot.&amp;lt;languageID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt; and for tools it is: -Dpolyglot.&amp;lt;toolID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.Create a file called SystemPropertiesTest.java:import org.graalvm.polyglot.*;class SystemPropertiesTest {    public static void main(String[] args) {        Context polyglot = Context.newBuilder()        .allowExperimentalOptions(true)        .build();        // the use of shared array buffer requires the &#39;js.shared-array-buffer&#39; option to be &#39;true&#39;        polyglot.eval(&quot;js&quot;, &quot;new SharedArrayBuffer(1024)&quot;);    }}Run:javac SystemPropertiesTest.javajava -Dpolyglot.js.strict=true SystemPropertiesTestNote: System properties are read once when the polyglot context is created. Subsequent changes have no effect.",
                    "url": " /reference-manual/polyglot-programming/"
                  },
                  
                  "reference-manual-ruby-polyglot":  {
                    "title": "",
                    "content": "Polyglot ProgrammingTruffleRuby allows you to interface with any other Truffle language to create polyglot programs – programs written in more than one language.This guide describes how to load code written in foreign languages, how to export and import objects between languages, how to use Ruby objects from a foreign language, how to use foreign objects from Ruby, how to load Java types to interface with Java, and how to embed in Java.If you are using the native configuration, you will need to use the --polyglot flag to get access to other languages.The JVM configuration automatically has access to other languages.  Running Ruby code from another language  Loading code written in foreign languages  Exporting Ruby objects to foreign languages  Importing foreign objects to Ruby  Using Ruby objects from a foreign language  Using foreign objects from Ruby  Accessing Java objects  Strings  Threading and interop  Embedded configurationRunning Ruby Code from Another LanguageWhen you eval Ruby code from the Context API in another language and mark the Source as interactive, the same interactive top-level binding is used each time.This means that if you set a local variable in one eval, you will be able to use it from the next.The semantics are the same as the Ruby semantics of calling INTERACTIVE_BINDING.eval(code) for every Context.eval() call with an interactive Source.This is similar to most REPL semantics.Loading Code Written in Foreign LanguagesPolyglot.eval(id, string) executes code in a foreign language identified by its ID.Polyglot.eval_file(id, path) executes code in a foreign language from a file, identified by its language ID.Polyglot.eval_file(path) executes code in a foreign language from a file, automatically determining the language.Exporting Ruby Objects to Foreign LanguagesPolyglot.export(name, value) exports a value with a given name.Polyglot.export_method(name) exports a method, defined in the top-level object.Importing Foreign Objects to RubyPolyglot.import(name) imports and returns a value with a given name.Polyglot.import_method(name) imports a value, which should be IS_EXECUTABLE, with a given name, and defines it in the top-level object.Using Ruby Objects from a Foreign LanguageUsing JavaScript as an example: the left example is JavaScript, the right one is the corresponding action it takes on the Ruby object expressed in Ruby code.object[name/index] calls object[name/index] if the object has a method [], or reads an instance variable if the name starts with @, or returns a bound method with the name.object[name/index] = value calls object[name/index] = value if the object has a method []=, or sets an instance variable if the name starts with @.delete object.name calls object.delete(name).delete object[name/index] calls object.delete(name).object.length calls object.size.Object.keys(hash) gives the hash keys as strings.Object.keys(object) gives the methods of an object as functions, unless the object has a [] method, in which case it returns an empty array.object(args...) calls a Ruby Proc, Method, UnboundMethod, etc.object.name(args...) calls a method on the Ruby object.new object(args...) calls object.new(args...).&quot;length&quot; in obj returns true for a Ruby Array.object == null calls object.nil?.Notes on Creating Ruby Objects for Use in Foreign LanguagesIf you want to pass a Ruby object to another language for fields to be read and written, a good object to pass is usually a Struct, as this will have both the object.foo and object.foo = value accessors for you to use from Ruby, and they will also respond to object[&#39;foo&#39;] and object[&#39;foo&#39;] = value, which means they will work from other languages sending read and write messages.Using Foreign Objects from Rubyobject[name/index] will read a member from the foreign object.object[name/index] = value will write a value to the foreign object.object.delete(name/index) will remove a value from the foreign object.object.size will get the size or length of the foreign object.object.keys will get an array of the members of the foreign object.object.call(*args) will execute the foreign object.object.name(*args) will invoke a method called name on the foreign object.object.new(*args) will create a new object from the foreign object (as if it is some kind of class).object.class on a Java Class object will give you an object on which you can call instance methods, rather than static methods.object.respond_to?(:size) will tell you if the foreign object has a size or length.object.nil? will tell you if the foreign object represents the language’s equivalent of null or nil.object.respond_to?(:call) will tell you if a foreign object can be executed.object.respond_to?(:new) will tell you if a foreign object can be used to create a new object (if it’s a class).object.respond_to?(:keys) will tell you if a foreign object can give you a list of members.object.respond_to?(:class) will tell you if an object is a Java class.Polyglot.as_enumerable(object) will create a Ruby Enumerable from the foreign object, using its size or length, and reading from it.Where boolean value is expected (e.g., in if conditions) the foreign value is converted to boolean if possible or considered to be true.Accessing Java ObjectsTruffleRuby’s Java interoperability interface is similar to the interface from the Nashorn JavaScript implementation, as also implemented by GraalVM’s JavaScript implementation.It is easier to use Java interoperability in JVM mode (--jvm). Java interoperability is also supported in native mode but requires more setup.See herefor more details.Java.type(&#39;name&#39;) returns a Java class object, given a name such as java.lang.Integer or int[]. With the class object, .new will create an instance, .foo will call the static method foo, [:FOO] will read the fieldFOO, and so on.To access instance methods use .class, such as MyClass.class.getName.To import a Java class as a top-level constant, use Java.import &#39;name&#39;.Embedding in JavaTruffleRuby is embedded via the Polyglot API, which is part of GraalVM.You will need to use GraalVM to use this API.import org.graalvm.polyglot.*;class Embedding {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().allowAllAccess(true).build();        Value array = polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}Using Ruby Objects from Embedding JavaRuby objects are represented by the Value class when embedded in Java.Accessing Arraysboolean hasArrayElements()Value getArrayElement(long index)void setArrayElement(long index, Object value)boolean removeArrayElement(long index)long getArraySize()Accessing Methods in Objectsboolean hasMembers()boolean hasMember(String identifier)Value getMember(String identifier)Set&amp;lt;String&amp;gt; getMemberKeysvoid putMember(String identifier, Object valueboolean removeMember(String identifier)Executing Procs, Lambdas, and Methodsboolean canExecute()Value execute(Object... arguments)void executeVoid(Object... arguments)Instantiating Classesboolean canInstantiate() {Value newInstance(Object... arguments)Accessing Primitivesboolean isString()String asString()boolean isBoolean()boolean asBoolean()boolean isNumber()boolean fitsInByte()byte asByte()boolean fitsInShort()short asShort()boolean fitsInInt()int asInt()boolean fitsInLong()long asLong()boolean fitsInDouble()double asDouble()boolean fitsInFloat()float asFloat()boolean isNull()The JRuby migration guide includes some more examples.StringsRuby strings and symbols are converted to Java strings when they are passed to foreign languages, and Java strings are converted to Ruby strings when they are passed into Ruby.Threading and InteropRuby is designed to be a multi-threaded language and much of the ecosystem expects threads to be available.This may be incompatible with other Truffle languages which do not support threading, so you can disable the creation ofmultiple threads with the option --single-threaded.This option is set by default unless the Ruby launcher is used, as part of the embedded configuration, described below.When this option is enabled, the timeout module will warn that the timeouts are being ignored, and signal handlers will warn that a signal has been caught but will not run the handler, as both of these features would require starting new threads.Embedded ConfigurationWhen used outside of the Ruby launcher - such as from another language’s launcher via the polyglot interface, embedded using the native polyglot library, or embedded in a Java application via the GraalVM SDK - TruffleRuby will be automatically configured to work more cooperatively within another application.This includes options such as not installing an interrupt signal handler, and using the I/O streams from the Graal SDK.It also turns on the single-threaded mode, as described above.It will also warn when you explicitly do things that may not work well when embedded, such as installing your own signal handlers.This can be turned off even when embedded, with the embedded option (--ruby.embedded=false from another launcher, or-Dpolyglot.ruby.embedded=false from a normal Java application).It is a separate option, but in an embedded configuration you may want to set allowNativeAccess(false) in your Context.Builder, or use the experimental --platform-native=false option, to disable use of the NFI for internalfunctionality.Also, the experimental option --cexts=false can disable C extensions.Note: Unlike for example pure JavaScript, Ruby is more than a self-contained expression language.It has a large core library that includes low-level I/O and system and native-memory routines which may interfere with other embedded contexts or the host system.",
                    "url": " /reference-manual/ruby/Polyglot/"
                  },
                  
                  "community-assets":  {
                    "title": "",
                    "content": "The GraalVM team regularly presents at various conferences and meetups. We are delighted to learn that you have taken interest in GraalVM and would like to share this interest with your network. Whether you are presenting at a conference, a meetup, or writing an article, you can use the images on this page in your creative work.These images are the intellectual property of the Oracle and cannot be altered without Oracle’s permission. Please use it responsibly. For the proper use guidelines please contact us: graalvm-users@oss.oracle.com.Please attribute them back to this website, so more people could find it. And please make sure to state your affiliation with the GraalVM project, whether you’re a part of the team or just a fan.GraalVM logoGraalVM overviewGraalVM supports many languages and runs in various environments.GraalVM componentsGraalVM functionality is enabled by several layers: it uses JVM as a platform, uses Java level compiler interface, JVMCI to integrate with it, uses the Truffle framework to run languages it has interpreters for, and through the LLVM bitcode interpreter, Sulong, it can run native code.Performance comparison with best competition (2017)The Practical partial evaluation for high-performance dynamic language runtimes paper byThomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöß, Lukas Stadler, Chris Seaton, Gilles Duboscq, Doug Simon, Matthias Grimmer compared performance of GraalVM against other runtimes. Here is a one-image summary of the findings. For proper interpretation, please read the paper.Sample applicationsYou can find several sample applications to play with and refer to on the examples page.",
                    "url": " /community/assets/"
                  },
                  
                  "community-press":  {
                    "title": "",
                    "content": "In Case You MissedIn-Process Polyglot with GraalVM (May 16, 2020)GraalVM Native Image Tips &amp;amp; Tricks (May 7, 2020)Oracle’s GraalVM finds its place in Java app ecosystem (May 4, 2020)Spring Graal Native 0.6.0 released (April 9, 2020)Optimizing Ruby Lazy Initialization in TruffleRuby with Deoptimization (March 31, 2020)Spring and Isomorphic React 1: Setup with GraalVM (March 17, 2020)GraalVM 20.0: Run Tomcat as Native Image on Windows (March 15, 2020)Experiments with GraalVM (blog post series) (March 15, 2020)Graal vs C2 who runs Kotlin faster? (March 14, 2020)Build Great Native CLI Apps in Java with Graalvm and Picocli (March 7, 2020)Polyglot Programming on the GraalVM (March 6, 2020)The Competitive Programmer - airhacks.fm podcast (March 1, 2020)GraalVM upgrade improves Windows builds (February 27, 2020)On the way to a polyglot future – GraalVM Project Advisory Board founded (February 25, 2020)Optimization Strategies of the GraalVM (February 23, 2020)Pros and Cons for Using GraalVM Native-Images (February 20, 2020)Showing some love for GraalVM: Hibernate ORM 5.4.12.Final is here (February 14, 2020)Running Spring Boot Applications as GraalVM Native Images (February 12, 2020)Polyglot inception with GraalVM. Why? Because it’s fun (February 6, 2020)Quarkus 1.2.0.Final released - GraalVM 19.3.1 support, Metrics, Cache extension, and more (January 28, 2020)How Oracle GraalVM Supercharged Twitter’s Microservices Platform (December 11, 2019)Watch GraalVM Turn Your Java Into Binaries(November 27, 2019)GraalVM adds Java 11 support(November 22, 2019)Node JS application running on GraalVM – interoperating with Java, Python, R and more(November 5, 2019)Calling out from Java to JavaScript (with call back) – leveraging interoperability support of GraalVM(October 24, 2019)Building a programming language on GraalVM(October 13, 2019)Oracle pits GraalVM against Google Go(September 19, 2019)Lightbend Launches Open Source Project CloudState to Advance Stateful Workloads on Knative / Kubernetes Serverless Stack(August 27, 2019)Developing Microservices with GraalVM Enterprise Edition + Micronaut on Oracle Cloud(July 29, 2019)Thomas Wuerthinger on GraalVM and Optimizing Java with Ahead-of-Time Compilation(July 19, 2019)Helidon Supports GraalVM for Native Executable Applications(July 19, 2019)Die GraalVM: Javas Sprung in die Gegenwart?(German) (July 12, 2019)React Server Side Rendering with GraalVM for Clojure(July 8, 2019)Venkat Subramaniam: Kotlin And Python Are Fun, But Java Developers Are Semantically Aligned With The Future(July 1, 2019)Small &amp;amp; fast Docker images using GraalVM’s native-image(May 30, 2019)Meet the Team That Built GraalVM, An Energy-Saving Multilingual Compiler Written Entirely in Java(May 8, 2019)Sharing is Caring! Domain objects in BOTH Scala and R with GraalVM Polyglot bindings(May 1, 2019)Learn how you can reduce Maven build time by compiling javac as a GraalVM native image(Apr 29, 2019)Helidon flies faster with GraalVM(Apr 17, 2019)Mixing NodeJS and OpenJDK(Apr 4, 2019)GraalVM with Groovy and Grape - creating native image of a standalone script(Jan 16, 2019)GraalVM: the holy Graal of polyglot JVM?(Jan 3, 2019)Comparing Kotlin Performance with Graal and C2(Dec 9, 2018)How to make Beautiful Ruby Plots with Galaaz(Nov 26, 2018)Running Reactive Spring Boot on GraalVM in Docker(Nov 1, 2018)Ruby Plotting with Galaaz: An example of tightly coupling Ruby and R in GraalVM(Oct 19, 2018)GraalVM and Groovy - how to start?(Oct 3, 2018)Micronaut 1.0 RC1 and the power of ahead-of-time compilation(Sep 30, 2018)Part 2: Native microservice in GraalVM(Sep 24, 2018)Part 1: Java to native using GraalVM(Sep 20, 2018)The GraalVM frenzy(Sep 6, 2018)Getting to Know Graal, the New Java JIT Compiler(Jul 16, 2018)Serverless Native Java Functions using GraalVM and Fn Project(Jun 24, 2018)Using GraalVM to run Native Java in AWS Lambda with Golang(Jun 11, 2018)Evaluating JavaScript in Java with GraalVM(Jun 8, 2018)Why the Java community should embrace GraalVM(Jun 5, 2018)Eclipse Vert.x goes Native(Jun 4, 2018)Java Web Server in a 20 MB Docker Image(Jun 4, 2018)A 7MB native-image Java app that runs in 30ms and uses only 4MB of RAM!(May 28, 2018)GraalVM: смешались в кучу C и Scala(Russian) (May 18, 2018)Running PlayFramework on GraalVM(May 10, 2018)Native Clojure with GraalVM(Apr 28, 2018)High-Performance Interpreters for JetBrains MPS(Apr 27, 2018)Oracle Releases GraalVM 1.0, a Polyglot Virtual Machine and Platform(Apr 27, 2018)GraalVM: Virtuelle Maschine der besonderen Art(German) (Apr 26, 2018)Oracles GraalVM für “Native Java”?(German) (Apr 25, 2018)オラクル、JavaやJavaScript、Ruby、Pythonなど多言語対応を単一ランタイムで実現する「GraalVM」をオープンソースで公開。Twitterが本番環境で採用(Japanese) (Apr 20, 2018)Meet GraalVM, Oracle’s polyglot virtual machine(Apr 18, 2018)What’s new in Oracle’s GraalVM multilanguage virtual machine(Apr 18, 2018)GraalVM 1.0 Gives Developers a Speedy Polyglot Runtime–And Helps Twitter Save Money(Apr 18, 2018)Oracle announces polyglot virtual machine, GraalVM(Apr 17, 2018)JavaScript, Java, какая теперь разница?(Russian) (Apr 17, 2018)A Typical Truffle Specialization Pitfall(Apr 17, 2018)",
                    "url": " /community/press/"
                  },
                  
                  "tools-profiling":  {
                    "title": "",
                    "content": "Profiling Command Line ToolsGraalVM profiling command line tools help you optimize your codethrough analysis of CPU and memory usage.Most applications spend 80% of their runtime in 20% of the code. For thisreason, to optimize the code, it is essential to know where the applicationspends its time. In this section, we use an example application to demonstratethe three main profiling capabilities that GraalVM offers: CPU Tracer, CPUSampler, and Memory Tracer.This example application uses a basic primenumber calculator based on the Sieve of Eratosthenesalgorithm.      Copy the following code into a new file named primes.js:     class AcceptFilter {     accept(n) {         return true     } } class DivisibleByFilter {     constructor(number, next) {         this.number = number;         this.next = next;     }     accept(n) {         var filter = this;         while (filter != null) {             if (n % filter.number === 0) {                 return false;             }             filter = filter.next;         }         return true;     } } class Primes {     constructor() {         this.number = 2;         this.filter = new AcceptFilter();     }     next() {         while (!this.filter.accept(this.number)) {             this.number++;         }         this.filter = new DivisibleByFilter(this.number, this.filter);         return this.number;     } } var primes = new Primes(); var primesArray = []; for (let i = 0; i &amp;lt; 5000; i++) {     primesArray.push(primes.next()); } console.log(`Computed ${primesArray.length} prime numbers. ` +             `The last 5 are ${primesArray.slice(-5)}.`);    Run js primes.js. The example application should print output as follows:     js primes.js Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611.    This program takes a moment to compute. Next you will check where the time is spent.    Run js primes.js --cpusampler to enable CPU sampling. CPU Sampler should print output for the example application as follows:     js primes.js --cpusampler Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. --------------------------------------------------------------------------------------------------- Sampling Histogram. Recorded 1184 samples with period 1ms   Self Time: Time spent on the top of the stack.   Total Time: Time the location spent on the stack.   Opt %: Percent of time spent in compiled and therfore non-interpreted code. ---------------------------------------------------------------------------------------------------  Name        |      Total Time     |  Opt % ||       Self Time     |  Opt % | Location ---------------------------------------------------------------------------------------------------  next        |       1216ms  98.5% |  87.9% ||       1063ms  85.9% |  99.0% | primes.js~31-37:564-770  accept      |        159ms  11.2% |  22.7% ||        155ms  12.5% |  14.8% | primes.js~13-22:202-439  :program    |       1233ms 100.0% |   0.0% ||         18ms   1.5% |   0.0% | primes.js~1-47:0-1024  constructor |          1ms   0.1% |   0.0% ||          1ms   0.1% |   0.0% | primes.js~7-23:72-442 ---------------------------------------------------------------------------------------------------    The sampler prints an execution time histogram for each JavaScript function. By default, CPU sampling takes a sample every single millisecond. From the result, we can see that roughly 96% of the time is spent in the DivisibleByFilter.accept function.     accept(n) {     var filter = this;     while (filter != null) {         if (n % filter.number === 0) {             return false;         }         filter = filter.next;     }     return true; }    Now you can find out more about this function by filtering the samples, and include statements in the profile in addition to methods.    Run js primes.js --cpusampler --cpusampler.Mode=statements --cpusampler.FilterRootName=*acceptto collect statement samples for all functions that end with accept:     js primes.js --cpusampler --cpusampler.Mode=statements --cpusampler.FilterRootName=*accept Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ---------------------------------------------------------------------------------------------------- Sampling Histogram. Recorded 1567 samples with period 1ms   Self Time: Time spent on the top of the stack.   Total Time: Time the location spent on the stack.   Opt %: Percent of time spent in compiled and therfore non-interpreted code. ----------------------------------------------------------------------------------------------------  Name         |      Total Time     |  Opt % ||       Self Time     |  Opt % | Location ----------------------------------------------------------------------------------------------------  accept~16-18 |        436ms  27.8% |  94.3% ||        435ms  27.8% |  94.5% | primes.js~16-18:275-348  accept~15    |        432ms  27.6% |  97.0% ||        432ms  27.6% |  97.0% | primes.js~15:245-258  accept~19    |        355ms  22.7% |  95.5% ||        355ms  22.7% |  95.5% | primes.js~19:362-381  accept~17    |          1ms   0.1% |   0.0% ||          1ms   0.1% |   0.0% | primes.js~17:322-334 ----------------------------------------------------------------------------------------------------    Roughly 30% of the time is spent in this if condition:     if (n % filter.number === 0) {     return false; }    The if condition contains an expensive modulo operation, which might explain the runtime of the statement.    Now use CPU Tracer to collect execution counts of each statement:    Run js primes.js --cputracer --cputracer.TraceStatements --cputracer.FilterRootName=*acceptto collect execution counts for all statements in methods ending with accept:     js primes.js --cputracer --cputracer.TraceStatements --cputracer.FilterRootName=*accept Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ----------------------------------------------------------------------------------------- Tracing Histogram. Counted a total of 351278226 element executions.   Total Count: Number of times the element was executed and percentage of total executions.   Interpreted Count: Number of times the element was interpreted and percentage of total executions of this element.   Compiled Count: Number of times the compiled element was executed and percentage of total executions of this element. -----------------------------------------------------------------------------------------  Name     |          Total Count |    Interpreted Count |       Compiled Count | Location -----------------------------------------------------------------------------------------  accept   |     117058669  33.3% |         63575   0.1% |     116995094  99.9% | primes.js~15:245-258  accept   |     117053670  33.3% |         63422   0.1% |     116990248  99.9% | primes.js~16-18:275-348  accept   |     117005061  33.3% |         61718   0.1% |     116943343  99.9% | primes.js~19:362-381  accept   |         53608   0.0% |          1857   3.5% |         51751  96.5% | primes.js~14:215-227  accept   |         53608   0.0% |          1857   3.5% |         51751  96.5% | primes.js~13-22:191-419  accept   |         48609   0.0% |          1704   3.5% |         46905  96.5% | primes.js~17:322-334  accept   |          4999   0.0% |           153   3.1% |          4846  96.9% | primes.js~21:409-412  accept   |             1   0.0% |             1 100.0% |             0   0.0% | primes.js~2-4:25-61  accept   |             1   0.0% |             1 100.0% |             0   0.0% | primes.js~3:52-55 -----------------------------------------------------------------------------------------    The output shows execution counters for each statement, instead of timing information. Tracing histograms often provides insights into the behavior of the algorithm that needs optimization.    Run js primes.js --experimental-options --memtracer to display source code locations andcounts of reported allocations. Note that the Memory Tracer tool for capturing allocations is currently anexperimental feature in GraalVM. As such, --memtracer mustbe preceded by the --experimental-options command line option.     js primes.js --experimental-options --memtracer Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ------------------------------------------------------------  Location Histogram with Allocation Counts. Recorded a total of 5013 allocations.    Total Count: Number of allocations during the execution of this element.    Self Count: Number of allocations in this element alone (excluding sub calls). ------------------------------------------------------------  Name        |      Self Count |     Total Count |  Location ------------------------------------------------------------  next        |     5000  99.7% |     5000  99.7% | primes.js~31-37:537-737  :program    |       11   0.2% |     5013 100.0% | primes.js~1-46:0-966  Primes      |        1   0.0% |        1   0.0% | primes.js~25-38:454-739 ------------------------------------------------------------    This output shows the number of allocations which were recorded per function. For each prime number that was computed, the program allocates one object in next and one in constructor of DivisibleByFilter. Allocations are recorded independently of whether they could get eliminated by the compiler.    The GraalVM compiler is particularly powerful in optimizing allocations and can push allocations into infrequent branches to increase execution performance. The GraalVM team plans to add information about memory optimizations to the memory tracer in the future.  Tools OptionsUse the --help:tools option in all guest language launchers to displayreference information for CPU Sampler, CPU Tracer, and Memory Tracer.The current set of available options is as follows:CPU Sampler Options  --cpusampler: enables CPU Sampler. Disabled by default.  --cpusampler.Delay=&amp;lt;Long&amp;gt;: delays the sampling for the given number of milliseconds (default: 0).  --cpusampler.FilterFile=&amp;lt;Expression&amp;gt;: applies a wildcard filter for sourcefile paths, for example, *program*.sl. The default is ∗.  --cpusampler.FilterLanguage=&amp;lt;String&amp;gt;: profiles languages only with thematching mime-type, for example, +. The default is no filter.  --cpusampler.FilterRootName=&amp;lt;Expression&amp;gt;: applies a wildcard filter forprogram roots, for example, Math.*. The default is ∗.  --cpusampler.GatherHitTimes: saves a timestamp for each taken sample. The default is false.  --cpusampler.Mode=&amp;lt;Mode&amp;gt;:  describes the level of sampling detail. Please note that increased detail can lead to reduced accuracy.          exclude_inlined_roots: samples roots excluding inlined functions (enabled by default)      roots: samples roots including inlined functions      statements: samples all statements        --cpusampler.Output=&amp;lt;Output&amp;gt;: prints a histogram or calltree as output.The default is histogram.  --cpusampler.Period=&amp;lt;Long&amp;gt;: specifies the period, in milliseconds, tosample the stack.  --cpusampler.SampleInternal: captures internal elements. The default isfalse.  --cpusampler.StackLimit=&amp;lt;Integer&amp;gt;: specifies the maximum number of stackelements.  --cpusampler.SummariseThreads : prints sampling output as a summary of all per thread profiles. The default is false.CPU Tracer Options  --cputracer: enables the CPU tracer. Disabled by default.  --cputracer.FilterFile=&amp;lt;Expression&amp;gt;: applies a wildcard filter for sourcefile paths, for example, *program*.sl. The default is ∗.  --cputracer.FilterLanguage=&amp;lt;String&amp;gt;: profiles languages only with thematching mime-type, for example, +. The default is no filter.  --cputracer.FilterRootName=&amp;lt;Expression&amp;gt;: applies a wildcard filter forprogram roots, for example, Math.*. The default is ∗.  --cputracer.Output=&amp;lt;Output&amp;gt; prints a histogram or json as output. The default is histogram.  --cputracer.TraceCalls: captures calls when tracing. The default is false.  --cputracer.TraceInternal: traces internal elements. The default is false.  --cputracer.TraceRoots=&amp;lt;Boolean&amp;gt;: captures roots when tracing. The defaultis true.  --cputracer.TraceStatements: captures statements when tracing. The defaultis false.Memory Tracer OptionsThe memory tracer tool is currently an experimental tool. Make sure to prepend the --experimental-options flag to enable --memtracer.  --memtracer: enables the memory tracer. Disabled by default.  --memtracer.FilterFile=&amp;lt;Expression&amp;gt;: applies a wildcard filter for source file paths, for example, *program*.sl. The default is ∗.  --memtracer.FilterLanguage=&amp;lt;String&amp;gt;: profiles languages only with the matching mime-type, for example, +. The default is no filter.  --memtracer.FilterRootName=&amp;lt;Expression&amp;gt;: applies a wildcard filter for program roots, for example, Math.*. The default is ∗.  --memtracer.Output=&amp;lt;Format&amp;gt;: prints a typehistogram, histogram, or calltree as output. The default is histogram.  --memtracer.StackLimit=&amp;lt;Integer&amp;gt;: sets the maximum number of maximum stack elements.  --memtracer.TraceCalls: captures calls when tracing. The default is false.  --memtracer.TraceInternal: captures internal elements. The default is false.  --memtracer.TraceRoots=&amp;lt;Boolean&amp;gt;: captures roots when tracing. The default is true.  --memtracer.TraceStatements: captures statements when tracing. The default is false.",
                    "url": " /tools/profiling/"
                  },
                  
                  "community-publications":  {
                    "title": "",
                    "content": "PublicationsHere you can find all publications related to GraalVM. If you are doing research related to GraalVM and want us to include your publication, please send us a pull request to add your paper.Selected PapersWe recommend the following papers as a starting point for learning about Graal:GraalVM Native Image uses a novel iterative application of points-to analysis and heap snapshotting, followed by ahead-of-time compilation with an optimizing compiler.Initialization code can run at build time, i.e., executables can be tailored to a particular application configuration. We recommend reading:  Peter Hofer, Codrut Stancu, Vojin Jovanovic, Peter Kessler, Christian Wimmer, Thomas Wuerthinger, Oleg Pliss, Paul WoegererInitialize Once, Start Fast: Application Initialization at Build TimeIn Proceedings of the ACM on Programming LanguagesLanguage implementations on GraalVM are based on the Truffle framework.User applications are transformed to an abstract syntax tree, which is then partially evaluated. If you want to learn more about how to build Truffle languages, how partial evaluation works, and how the Truffle framework allows you to guide the GraalVM compiler, we recommend reading:  Thomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöß, Lukas Stadler, Chris Seaton, Gilles Duboscq, Doug Simon, Matthias GrimmerPractical partial evaluation for high-performance dynamic language runtimesIn Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017)Truffle language implementations abstract the differences between programming languages, which enables efficient cross-language interoperability. We recommend reading:  Matthias Grimmer, Chris Seaton, Roland Schatz, Würthinger, Hanspeter MössenböckHigh-Performance Cross-Language Interoperability in a Multi-Language RuntimeIn Proceedings of the 11th Dynamic Language Symposium (DLS)The GraalVM compiler ensures that the languages on top of the GraalVM run at full speed.The core of the compiler is its intermediate representation. We recommend reading:  Gilles Duboscq, Thomas Würthinger, Lukas Stadler, Christian Wimmer, Doug Simon, Hanspeter MössenböckAn intermediate representation for speculative optimizations in a dynamic compilerIn Proceedings of the 7th ACM workshop on Virtual machines and intermediate languages (VMIL ‘13)Speculative assumptions based on profiling information and deoptimizations allow GraalVM heavily optimize dynamically typed languages like JavaScript and ensure native speed. We recommend reading:  Gilles Duboscq, Thomas Würthinger, Hanspeter MössenböckSpeculation without regret: reducing deoptimization meta-data in the Graal compilerIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ ‘14)A powerful escape analysis with scalar replacement ensures that all interpreter data structures are removed when optimizing a Truffle AST. We recommend reading:  Lukas Stadler, Thomas Würthinger, Hanspeter MössenböckPartial Escape Analysis and Scalar Replacement for JavaIn Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO ‘14)Full List of Papers2019      Aleksandar Prokopec, Gilles Duboscq, David Leopoldseder, Thomas WuerthingerAn Optimization-Driven Incremental Inline Substitution Algorithm for Just-In-Time CompilersIn Proceedings of the 2019 International Symposium on Code Generation and Optimization (CGO 2019)        Aleksandar Prokopec, Andrea Rosà, David Leopoldseder, Gilles Duboscq, Petr Tůma, Martin Studener, Lubomír Bulej, Yudi Zheng, Alex Villazón, Doug Simon, Thomas Würthinger, Walter BinderRenaissance: benchmarking suite for parallel applications on the JVMIn Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2019)        Christian Humer, Tim Felgentreff, Robert Hirschfeld, Fabio Niephaus, Daniel StolpeLanguage-independent Development Environment Support For Dynamic RuntimesIn Proceedings of the 15th ACM SIGPLAN International Symposium on Dynamic Languages        Florian Latifi, David LeopoldsederPractical Second Futamura ProjectionIn Proceedings Companion of the 2019 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity        Jacob Kreindl, Hanspeter Moessenboeck, Daniele BonettaTowards Efficient, Multi-Language Dynamic Taint AnalysisIn Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes        Peter Hofer, Codrut Stancu, Vojin Jovanovic, Peter Kessler, Christian Wimmer, Thomas Wuerthinger, Oleg Pliss, Paul WoegererInitialize Once, Start Fast: Application Initialization at Build TimeIn Proceedings of the ACM on Programming Languages        Raphael Mosaner, Hanspeter Moessenboeck, Manuel Rigger, Roland Schatz, David LeopoldsederSupporting On-Stack Replacement in Unstructured Languages by Loop Reconstruction and ExtractionIn Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes        Robert Hirschfeld, Christian Humer, Fabio Niephaus, Daniel Stolpe, Tim FelgentreffLanguage-independent Development Environment Support For Dynamic RuntimesIn Proceedings of the 15th ACM SIGPLAN International Symposium on Dynamic Languages        Stefan Marr, Manuel Rigger, Bram Adams, Hanspeter MoessenboeckUnderstanding GCC Builtins to Develop Better ToolsIn Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering        Fabio Niephaus, Tim Felgentreff, and Robert Hirschfeld GraalSqueak: Toward a Smalltalk-based Tooling Platform for Polyglot ProgrammingIn Proceedings of the International Conference on Managed Programming Languages and Runtimes (MPLR 2019)        Daniel Stolpe, Tim Felgentreff, Christian Humer, Fabio Niephaus, and Robert Hirschfeld Language-independent Development Environment Support for Dynamic RuntimesIn Proceedings of the Dynamic Languages Symposium (DLS 2019)        Fabio Niephaus, Tim Felgentreff, Tobias Pape, and Robert Hirschfeld Efficient Implementation of Smalltalk Activation Records in Language Implementation FrameworksIn Proceedings of the Workshop on Modern Language Runtimes, Ecosystems, and VMs (MoreVMs) 2019, companion volume to International Conference on the Art, Science, and Engineering of Programming        Fabio Niephaus, Eva Krebs, Christian Flach, Jens Lincke, and Robert Hirschfeld PolyJuS: A Squeak/Smalltalk-based Polyglot Notebook System for the GraalVMIn Proceedings of the Programming Experience 2019 (PX/19) Workshop, companion volume to International Conference on the Art, Science, and Engineering of Programming        Fabio Niephaus, Tim Felgentreff, and Robert Hirschfeld Towards Polyglot Adapters for the GraalVMIn Proceedings of the Interconnecting Code Workshop (ICW) 2019, companion volume to International Conference on the Art, Science, and Engineering of Programming  2018      David Leopoldseder, Lukas Stadler, Manuel Rigger, Thomas Würthinger, Hanspeter Mössenböck A Cost Model for a Graph-Based Intermediate-Representation in a Dynamic CompilerIn Proceedings of the 10th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages        Kevin Menard, Chris Seaton, Benoit Daloze Specializing Ropes for RubyIn Proceedings of the 15th International Conference on Managed Languages &amp;amp; Runtimes (ManLang’18)        B. Daloze, A. Tal, S. Marr, H. Mössenböck, E. Petrank Parallelization of Dynamic Languages: Synchronizing Built-in CollectionsIn Proceedings of the Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2018)        David Leopoldseder, Roland Schatz, Lukas Stadler, Manuel Rigger, Thomas Wuerthinger, Hanspeter Moessenboeck Fast-Path Loop Unrolling of Non-Counted Loops to Enable Subsequent Compiler OptimizationsIn Proceedings of the 15th International Conference on Managed Languages &amp;amp; Runtimes, Article No. 2 (ManLang’18)        David Leopoldseder, Lukas Stadler, Thomas Würthinger,Josef Eisl, Doug Simon, Hanspeter Mössenböck Dominance-based duplication simulation (DBDS): code duplication to enable compiler optimizationsIn Proceedings of the 2018 International Symposium on Code Generation and Optimization (CGO 2018)        Matthias Grimmer, Roland Schatz, Chris Seaton, Thomas Wuerthinger, Mikel Lujan Cross-Language Interoperability in a Multi-Language RuntimeIn ACM Transactions on Programming Languages and Systems (TOPLAS), Vol. 40, No. 2, 2018        Manuel Rigger, Roland Schatz, Jacob Kreindl, Christian Haeubl, Hanspeter Moessenboeck Sulong, and Thanks for All the FishMoreVMs Workshop on Modern Language Runtimes, Ecosystems, and VMs (MoreVMs 2018)        Michael Van De Vanter, Chris Seaton, Michael Haupt, Christian Humer, Thomas WürthingerFast, Flexible, Polyglot Instrumentation Support for Debuggers and other ToolsIn The Art, Science, and Engineering of Programming, Vol. 2, No. 3, 2018, article 14  2017      Thomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöß, Lukas Stadler, Chris Seaton, Gilles Duboscq, Doug Simon, Matthias GrimmerPractical partial evaluation for high-performance dynamic language runtimesIn Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017)        Aleksandar Prokopec, David Leopoldseder, Gilles Duboscq, Thomas WürthingerMaking collection operations optimal with aggressive JIT compilationIn Proceedings of the 8th ACM SIGPLAN International Symposium on Scala (Scala 2017)        Michael Van De VanterBuilding Flexible, Low-Overhead Tooling Support into a High-Performance Polyglot VM (Extended Abstract)MoreVMs Workshop on Modern Language Runtimes, Ecosystems, and VMs  2016      Benoit Daloze, Stefan Marr, Daniele Bonetta, Hanspeter MössenböckEfficient and Thread-Safe Objects for Dynamically-Typed LanguagesAccepted for the Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications 2016 (OOPSLA)        Manuel Rigger, Matthias Grimmer, Hanspeter MössenböckSulong – Execution of LLVM-Based Languages on the JVMIn Proceedings of International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS)        Josef Eisl, Matthias Grimmer, Doug Simon, Thomas Würthinger, Hanspeter MössenböckTrace-based Register Allocation in a JIT CompilerIn Proceedings of the 13th International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ ‘16)        Stefan Marr, Benoit Daloze, Hanspeter MössenböckCross-language compiler benchmarking: are we fast yet?In Proceedings of the 12th Symposium on Dynamic Languages (DLS 2016)        Manuel Rigger, Matthias Grimmer, Christian Wimmer, Thomas Würthinger, Hanspeter MössenböckBringing low-level languages to the JVM: efficient execution of LLVM IR on TruffleIn Proceedings of the 8th International Workshop on Virtual Machines and Intermediate Languages (VMIL 2016)        Manuel RiggerSulong: Memory Safe and Efficient Execution of LLVM-Based LanguagesIn Proceedings of the ECOOP 2016 Doctoral Symposium        Luca Salucci, Daniele Bonetta, Walter BinderEfficient Embedding of Dynamic Languages in Big-Data AnalyticsIn Proceedings of the International Conference on Distributed Computing Systems Workshops (ICDCSW 2016)        Lukas Stadler, Adam Welc, Christian Humer, Mick JordanOptimizing R language execution via aggressive speculationIn Proceedings of the 12th Symposium on Dynamic Languages (DLS 2016)        Daniele Bonetta, Luca Salucci, Stefan Marr, Walter BinderGEMs: shared-memory parallel programming for Node.jsIn Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2016)        Luca Salucci, Daniele Bonetta, Walter BinderLightweight Multi-language Bindings for Apache SparkIn Proceedings of the European Conference on Parallel Processing (Euro-Par 2016)        Luca Salucci, Daniele Bonetta, Stefan Marr, Walter BinderGeneric messages: capability-based shared memory parallelism for event-loop systemsIn Proceedings of the 21st ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP 2016)        Stefan Marr, Chris Seaton, Stéphane DucasseZero-overhead metaprogramming: reflection and metaobject protocols fast and without compromisesIn Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2016)  2015      Matthias Grimmer, Chris Seaton, Thomas Würthinger, Hanspeter MössenböckDynamically Composing Languages in a Modular Way: Supporting C Extensions for Dynamic Languages.In Proceedings of the 14th International Conference on Modularity        Michael Van De VanterBuilding Debuggers and Other Tools: We Can “Have it All” (Position Paper)In Proceedings of the 10th Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems Workshop (ICOOOLPS)        Josef EislTrace register allocationIn Companion Proceedings of the 2015 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity (SPLASH Companion 2015)        Matthias Grimmer, Chris Seaton, Roland Schatz, Thomas Würthinger, Hanspeter MössenböckHigh-performance cross-language interoperability in a multi-language runtimeIn Proceedings of the 11th Symposium on Dynamic Languages (DLS 2015)        Matthias Grimmer, Roland Schatz, Chris Seaton, Thomas Würthinger, Hanspeter MössenböckMemory-safe Execution of C on a Java VMIn Proceedings of the 10th ACM Workshop on Programming Languages and Analysis for Security (PLAS’15)        Matthias Grimmer, Chris Seaton, Thomas Würthinger, Hanspeter MössenböckDynamically composing languages in a modular way: supporting C extensions for dynamic languagesIn Proceedings of the 14th International Conference on Modularity (MODULARITY 2015)        Doug Simon, Christian Wimmer, Bernhard Urban, Gilles Duboscq, Lukas Stadler, Thomas WürthingerSnippets: Taking the High Road to a Low LevelACM Transactions on Architecture and Code Optimization (TACO)        David Leopoldseder, Lukas Stadler, Christian Wimmer, Hanspeter MössenböckJava-to-JavaScript translation via structured control flow reconstruction of compiler IRIn Proceedings of the 11th Symposium on Dynamic Languages (DLS 2015)        Codruţ Stancu, Christian Wimmer, Stefan Brunthaler, Per Larsen, Michael FranzSafe and efficient hybrid memory management for JavaIn Proceedings of the 2015 International Symposium on Memory Management (ISMM’15)        Gülfem Savrun-Yeniçeri, Michael L. Van de Vanter, Per Larsen, Stefan Brunthaler, Michael FranzAn Efficient and Generic Event-based Profiler Framework for Dynamic LanguagesIn Proceedings of the Principles and Practices of Programming on The Java Platform (PPPJ’15)        Michael L. Van De VanterBuilding debuggers and other tools: we can “have it all”In Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS’15)        Benoit Daloze, Chris Seaton, Daniele Bonetta, Hanspeter MössenböckTechniques and applications for guest-language safepointsIn Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS’15)  2014      Matthias GrimmerHigh-performance language interoperability in multi-language runtimesIn Proceedings of the companion publication of the 2014 ACM SIGPLAN conference on Systems, Programming, and Applications: Software for Humanity (SPLASH Companion)        Matthias Grimmer, Manuel Rigger, Roland Schatz, Lukas Stadler, Hanspeter MössenböckTruffle C: Dynamic Execution of C on the Java Virtual MachineIn Proceedings of the International Conference on Principles and Practice of Programming in Java (PPPJ)        Matthias Grimmer, Thomas Würthinger, Andreas Wöß, Hanspeter MössenböckAn Efficient Approach to Access Native Binary Data from JavaScriptIn Proceedings of the 9th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS)        Wei Zhang, Per Larsen, Stefan Brunthaler, Michael FranzAccelerating iterators in optimizing AST interpretersIn Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages &amp;amp; Applications (OOPSLA’14)        Matthias Grimmer, Manuel Rigger, Roland Schatz, Lukas Stadler, Hanspeter Mössenböck TruffleC: dynamic execution of C on a Java virtual machine In Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)        Matthias Grimmer, Thomas Würthinger, Andreas Wöß, Hanspeter MössenböckAn efficient approach for accessing C data structures from JavaScriptIn Proceedings of the 9th International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems PLE (ICOOOLPS’14)        Christian Humer, Christian Wimmer, Christian Wirth, Andreas Wöß, Thomas WürthingerA domain-specific language for building self-optimizing AST interpretersIn Proceedings of the 2014 International Conference on Generative Programming: Concepts and Experiences (GPCE 2014)        Gilles Duboscq, Thomas Würthinger, Hanspeter MössenböckSpeculation without regret: reducing deoptimization meta-data in the Graal compilerIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)        Thomas WürthingerGraal and truffle: modularity and separation of concerns as cornerstones for building a multipurpose runtimeIn Proceedings of the companion publication of the 13th international conference on Modularity (MODULARITY’14)        Lukas Stadler, Thomas Würthinger, Hanspeter MössenböckPartial Escape Analysis and Scalar Replacement for JavaIn Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO’14)        Christian Häubl, Christian Wimmer, Hanspeter MössenböckTrace transitioning and exception handling in a trace-based JIT compiler for javaACM Transactions on Architecture and Code Optimization (TACO)        Chris Seaton, Michael L. Van De Vanter, Michael HauptDebugging at Full SpeedIn Proceedings of the Workshop on Dynamic Languages and Applications (Dyla’14)        Andreas Wöß, Christian Wirth, Daniele Bonetta, Chris Seaton, Christian Humer, Hanspeter MössenböckAn object storage model for the Truffle language implementation frameworkIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)        Codruţ Stancu, Christian Wimmer, Stefan Brunthaler, Per Larsen, Michael FranzComparing points-to static analysis with runtime recorded profiling dataIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)  2013      Thomas Würthinger, Christian Wimmer, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Christian Humer, Gregor Richards, Doug Simon, Mario WolczkoOne VM to Rule Them AllIn Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming &amp;amp; software (Onward! 2013)        Matthias Grimmer, Manuel Rigger, Lukas Stadler, Roland Schatz, Hanspeter MössenböckAn efficient native function interface for JavaIn Proceedings of the International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ)        Matthias GrimmerRuntime Environment for the Truffle/C VMMaster’s thesis, Johannes Kepler University Linz, November 2013        Gilles Duboscq, Thomas Würthinger, Lukas Stadler, Christian Wimmer, Doug Simon, Hanspeter MössenböckAn intermediate representation for speculative optimizations in a dynamic compilerIn Proceedings of the 7th ACM workshop on Virtual machines and intermediate languages (VMIL’13)        Lukas Stadler, Gilles Duboscq, Hanspeter Mössenböck, Thomas Würthinger, Doug SimonAn experimental study of the influence of dynamic compiler optimizations on Scala performanceIn Proceedings of the 4th Workshop on Scala (SCALA ‘13)        Gilles Duboscq, Lukas Stadler, Thomas Würthinger, Doug Simon, Christian Wimmer, Hanspeter MössenböckGraal IR: An Extensible Declarative Intermediate RepresentationIn Proceedings of the Asia-Pacific Programming Languages and Compilers Workshop, 2013        Christian Häubl, Christian Wimmer, Hanspeter MössenböckContext-sensitive trace inlining for JavaSpecial issue on the Programming Languages track at the 27th ACM Symposium on Applied ComputingComputer Languages, Systems &amp;amp; Structures        Christian Wimmer, Stefan BrunthalerZipPy on truffle: a fast and simple implementation of pythonIn Proceedings of the 2013 companion publication for conference on Systems, programming, &amp;amp; applications: software for humanity (SPLASH’13)        Christian Häubl, Christian Wimmer, Hanspeter MössenböckDeriving code coverage information from profiling data recorded for a trace-based just-in-time compilerIn Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ’13)  2012      Thomas Würthinger, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Doug Simon, Christian WimmerSelf-optimizing AST interpretersIn Proceedings of the 8th symposium on Dynamic languages (DLS’12)        Christian Wimmer, Thomas WürthingerTruffle: a self-optimizing runtime systemIn Proceedings of the 3rd annual conference on Systems, programming, and applications: software for humanity (SPLASH’12)        Lukas Stadler, Gilles , Hanspeter Mössenböck, Thomas WürthingerCompilation queuing and graph caching for dynamic compilersIn Proceedings of the 6th ACM workshop on Virtual machines and intermediate languages (VMIL’12’)        Christian Häubl, Christian Wimmer, Hanspeter MössenböckEvaluation of trace inlining heuristics for JavaIn Proceedings of the 27th Annual ACM Symposium on Applied Computing (SAC’12)  If you are interested in deeper collaboration with us, please send us an email.",
                    "url": " /community/publications/"
                  },
                  
                  "python":  {
                    "title": "",
                    "content": "",
                    "url": " /python/"
                  },
                  
                  "java-quickstart":  {
                    "title": "",
                    "content": "←BackQuick Start GuideGraalVM is a high-performance runtime for Java and other JVM languages.It contains a compatible JDK and offers distributions based on Java 8 and Java 11.GraalVM comes with multiple compiler optimizations, designed to accelerate Java applications performance while consuming fewer resources.To start using GraalVM, or to migrate from another JDK distribution, you do not have to change any source code.Any application that runs on the Java HotSpot VM will run on GraalVM.Here you will find information about installing GraalVM, running Java applications with it, and adding support for its accompanying features.Further, you will learn how to build platform-specific native executables of Java-based applications.If you are new to GraaVM or have little experience using it, we recommend starting with Architectural Overview of GraalVM.There you will find information about GraalVM’s architecture, distributions available, supported platforms, core and additional features, and much more.Install GraalVMGetting GraalVM installed and ready-to-go only takes a few minutes.1. Navigate to GraalVM Downloads. Be sure to download the package appropriate for your operating system and the Java version you need (Java 8 or 11).2. Unzip the archive to your file system:  on Linux or macOS      tar -xzf &amp;lt;graalvm-archive&amp;gt;.tar.gz    on Windows      unzip &amp;lt;graalvm-archive&amp;gt;.zip  3. Required for macOS only. Move the downloaded package to its proper location, the /Library/Java/JavaVirtualMachines directory. Since it is a system directory, sudo is required:  sudo mv &amp;lt;graalvm&amp;gt; /Library/Java/JavaVirtualMachinesTo verify if the move is successful, and to get a list of all installed JDKs, run /usr/libexec/java_home -V.4. Configure the environment variables.  Set the JAVA_HOME environment variable to resolve to the installation directory:      #Linux  export JAVA_HOME=&amp;lt;graalvm&amp;gt;      #macOS  export JAVA_HOME=/Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home      #Windows  setx /M JAVA_HOME &quot;C:Progra~1Java&amp;lt;graalvm&amp;gt;&quot;    Point the PATH environment variable to the GraalVM bin directory:      #Linux  export PATH=&amp;lt;graalvm&amp;gt;/bin:$PATH      #macOS  export PATH=/Library/Java/JavaVirtualMachines/&amp;lt;graalvm&amp;gt;/Contents/Home/bin:$PATH      #Windows  setx /M PATH &quot;C:Progra~1Java&amp;lt;graalvm&amp;gt;bin;%PATH%&quot;  5. Restart the Command Prompt/Terminal to reload the environment variables. Then use thefollowing command to check whether the variables were set correctly:  on Linux and macOS      echo $PATH  echo $JAVA_HOME    on Windows      echo %PATH%  echo %JAVA_HOME%  6. Optionally, specify GraalVM as the JRE or JDK installation in your Java IDE.Run Java ApplicationsGraalVM includes a JDK based on the Java HotSpot VM, and integrates an optimizing just-in-time (JIT) compiler, written in Java.At run time, an application is loaded and executed normally by the JVM.For demonstration purposes, GraalVM Enterprise based on Java 8 is used.Check your current Java version:java version &quot;1.8.0_281&quot;Java(TM) SE Runtime Environment (build 1.8.0_281-b09)Java HotSpot(TM) 64-Bit Server VM GraalVM EE 21.0.0 (build 25.281-b09-jvmci-21.0-b05, mixed mode)The java launcher runs the JVM with the GraalVM default compiler - the GraalVM compiler.Take a look at this typical HelloWorld class:public class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}Run the following commands to compile this class to bytecode and then execute it:javac HelloWorld.javajava HelloWorldHello World!Native ImageWith GraalVM Native Image technology you can compile Java bytecode into a platform-specific, self-contained, native executable to achieve faster startup and smaller footprint for your application.Native Image is not available by default, but can be easily added using the GraalVM Updater tool:gu install native-imageThe native-image executable will become available in the &amp;lt;graalvm&amp;gt;/bin directory.Compile the same HelloWorld.java example from above, and then build a native image from Java bytecode:javac HelloWorld.javanative-image HelloWorldThe last command generates an executable file named helloworld in the current working directory.Invoking it executes the natively compiled code of the HelloWorld class as follows:./helloworldHello, World!Note: For compilation, Native Image depends on the local toolchain.Ensure you meet the requirements for your platform.What to Read NextNew UsersSince this Quick Start guide is intended mainly for users new to GraalVM, or userswho are familiar with GraalVM but may have little experience using it, consider investigating more complex Java examples.Oracle Cloud UsersOracle Cloud users considering GraalVM for their cloud workloads areinvited to read GraalVM Enterprise on OCI.This page focuses on using GraalVM Enterprise with the Oracle Cloud Infrastructure Virtual Machine compute instance.Advanced UsersIf you want more in-depth details about the GraalVM compiler, go to its reference page. For more extensive documentation on running Java, proceed to Java Reference.More detailed documentation on the Native Image technology is available here.If you are looking for the tooling support GraalVM offers, proceed to Debugging and Monitoring Tools.If you are considering GraalVM as a platform for your future language or tool implementation, go to GraalVM as a Platform.You can find information on GraalVM security model, and rich API documentation in GraalVM SDK Javadoc.",
                    "url": " /java/quickstart/"
                  },
                  
                  "python-quickstart":  {
                    "title": "",
                    "content": "←BackPython Quick StartGraalVM is not just a Java Virtual Machine to run Java.It is also a high-performance multilingual runtime and provides support for a number of languages beyond Java, allowing different languages and libraries to interoperate with no performance penalty.Python is one of the supported languages and GraalVM provides the Python 3 runtime environment.The key to GraalVM’s polyglot support is language compliance, and a primary goal of the GraalVM Python runtime is to support SciPy and its constituent libraries, to work with other data science and machine learning libraries from the rich Python ecosystem.The Python runtime is yet experimental in GraalVM, but it already offers performance 5-6 times faster than CPython 3.8 (after warm-up) or 6-7x faster than Jython.Apart the performance benefits, GraalVM’s Python runtime enables the support for native extensions that Jython never supported, the possibility to create native platform binaries using the Native Image, a managed execution mode to run, for example, NumPy extensions in a safe manner, and many more.Here you will find information about installing GraalVM and Python support, running Python applications, creating a virtual environment, and adding supported packages.If you have experience using GraalVM’s Python runtime, you can skip this getting started guide and proceed to the in-depth Python reference manual.Install GraalVMTo run Python on GraalVM, you need to have GraalVM installed first.Choose the platform and proceed to the installation steps:  Linux  macOS  Windows  Docker containerInstall PythonThe Python runtime is not shipped with the default GraalVM installation package, but can be quickly added usingthe updater utility, gu:gu install pythonThe Python runtime requires the LLVM toolchain for its operation, and you will be prompted to install this dependency, if not yet installed:gu install llvm-toolchainOnce Python’s runtime is installed, the graalpython binary appears in the GRAALVM_HOME/bin/ directory.Run Python ApplicationsGraalVM’s Python support targets Python 3.8 compatibility.The support is still limited at this stage, but you can run simple Python commands or programs with the graalpython launcher:graalpython [options] [-c cmd | filename]If no program file or command is given, you will be dropped into the Python shell and run Python scripts interactively:graalpython&amp;gt;&amp;gt;&amp;gt; 1 + 23&amp;gt;&amp;gt;&amp;gt; exit()GraalVM supports some of the same options as Python 3.8 as well as some additional options to control the underlying Python runtime, GraalVM’s tools, and the execution engine.These can be viewed using the following command:graalpython --help --help:tools --help:languagesCreate a Virtual Environment and Install Supported PackagesThe recommended way of using GraalVM’s Python runtime is from a virtual environment.Creating a virtual environment prevents any incompatible interaction with the local user’s packages that may have been installed using a system installation of CPython.  Create the virtual environment with GraalVM:    graalpython -m venv &amp;lt;venv-dir&amp;gt;    Activate the environment in the shell session:    source &amp;lt;venv-dir&amp;gt;/bin/activate  There are not enough standard libraries to run the standard package installers for many packages with GraalVM Python runtime yet.As a convenience, GraalVM’s Python runtime provides a tool called ginstall to install the available packages.To see the list of installable packages, run:graalpython -m ginstall install --helpTo install the package, provide the name:graalpython -m ginstall install &amp;lt;package name&amp;gt;For more information, continue reading to the Installing Supported Packages guide.What to Read NextFor more extensive user documentation, proceed to the Python reference manual.If you consider GraalVM’s Python runtime as a replacement for Jython, consult the Jython Migration guide.The code base of GraalVM’s Python implementation is available on GitHub.",
                    "url": " /python/quickstart/"
                  },
                  
                  "reference-manual":  {
                    "title": "",
                    "content": "GraalVM Reference ManualsHere you will find the in-depth documentation for technologies offered by GraalVM.These manuals are aimed at software engineers and developers who already work with GraalVM, or are considering it as anenvironment for their workloads.TechnologiesNative Image - learn in detail about Native Image: GraalVM’s innovative technology that can ahead-of-time compile Java code to a self-contained native executable.Compiler - learn about the uniqueness of the GraalVM compiler and its advantages.Updater - learn how to add more capabilities and upgrade the core GraalVM installation.Polyglot Programming - learn how to write polyglot applications and allow languages to directly interoperate with each other in the same memory space.Embedding Languages - learn how to embed polyglot applications in Java host applications or native images.Specific LanguagesIf you are mostly interested in the GraalVM support for a specific language, here you can find the most extensive documentation:  Java  Java on Truffle  JavaScript and Node.js  LLVM Languages  Python  R  Ruby  WebAssembly",
                    "url": " /reference-manual/"
                  },
                  
                  "release-notes-release-candidates":  {
                    "title": "",
                    "content": "GraalVM Release Candidates1.0-RC16(2019-04-23)JavaWe addressed several benchmarks that had slower performance when running with the GraalVM compiler built as a native library, also known as libgraal, a mode selected as the default in the last release candidate. We fixed an issue causing a delay when shutting down the virtual machine process at the end of the execution of an application(see #1140).Native ImageWe improved the structure of the org.graalvm.nativeimage API: classes that canonly be used during image generation are now in the packageorg.graalvm.nativeimage.hosted, to clearly separate them from the classes thatcan be used at image run time. In order to stay backwards compatible, theoriginal classes are still present, but marked as deprecated. They will bedeleted in the next release candidate, so please update to the new classes.We fixed several bugs that were reported on GitHub, including anissue with the logging framework which materialized as an error that no instances of java.util.logging.SimpleFormatter are allowed in the image heap.As a result, native images work now correctly with Helidon, a Javaframework designed for writing microservices which recently announced theirsupport for GraalVM native images:Helidon flies faster with GraalVM.RubyA complete changelog for the Ruby component is available on GitHub. The highlights include:  Rounding modes have been implemented or improved for Float, Rational, BigDecimal classes (see #1509).  Added a pure-Ruby implementation of Foreign Function Interface (FFI) which passes almost all Ruby FFI specs (see #1529).  The KeyError raised from ENV#fetch and Hash#fetch now matches MRI’s message formatting (see #1633).JavaScriptA complete changelog for the JavaScript component is available on GitHub. The highlights include:  Loading JavaScript source code from URLs is now guarded by thejs.load-from-url command line option and prohibited by default.RA complete changelog for the R component is available on GitHub. The highlights include:  Allow parsing any letter in identifiersincluding, e.g., Japanese, with lexer starting from 1.0-RC16, which matchesGNU-R behavior.Python  Improved startup time of the graalpython native launcher.LLVM Runtime  The lli launcher now starts with the locale set to C.1.0-RC15(2019-04-05)JavaBy default,libgraal is nowused when running the java launcher or when using the --jvm mode for thelanguage launchers. The libgraal library is a version of the GraalVM compilerpre-compiled by native-image. In addition to improving startup time, libgraalcompletely prevents the GraalVM compiler from interfering with the heap usage andprofiles of application code. It has execution properties similar to othernative HotSpot compilers such as C1 and C2.JavaScript  Enabled Polyglot builtin based on Context.Builder.allowPolyglotAccess().  Added rest and spread properties support for foreign objects. For example, this spread syntax is now supported:    var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1 = [...arr1, ...arr2]; // arr1 is now [0, 1, 2, 3, 4, 5]  To see a complete list of changes, please refer to the project changelog.RNew Features  Implemented gzcon builtin for URL connections.Changes  Truffle interoperability API converts double values to int values if theyfit in the integer range. See the changes in the spectests.Bug Fixes  R incorrectly allowed Java interoperability when not started with --jvm.Starting from 1.0-RC15, --jvm flag is again necessary to enable interoperability with Java.A complete project changelog  is available on GitHub.RubyAn extensive list of changes is available on GitHub.Here is a short list of the most notable ones:Changes  Our experimental JRuby-compatible Java interop has been removed – use Polyglot and Java instead.  Process.clock_getres has been implemented.  debug, profile, profiler, which were already marked as unsupported, have been removed.Bug Fixes  autoload :C, &quot;path&quot;; require &quot;path&quot; now correctly triggers the autoload.  The shell standard library can now be require-d.Compatibility  Improved compatibility with MRI’s Float#to_s formatting #1626.  Added support for the base keyword argument to Dir.{[], glob}.PythonChanges  Migrated to the new Truffle libraries for interoperability support.  Added support for importing Java classes from the java namespace using normal Python import syntax, e.g., from java.util import ArrayList.  Implemented PEP 487 and PEP 560 to make the typing module work.More details can be found in the project changelog on GitHub.LLVM Interpreter  Added  a preliminary support for bitcode produced by LLVM 8.Native ImageBased on the feedback and bug reports, we improved the agent that traces reflectionand JNI usage on the JavaHotSpot VM. We also changed the implementation languageof the agent from C to Java. The agent is now a Native Image itself.The native-image-maven-plugin now supports multiline buildArgs andboolean parameter skip (skip image building if true).API changes for GraalVM integrators (SDK + Truffle)This version of GraalVM includes a major revision of the TruffleInteroperabilityAPIs.Most existing APIs for Truffle Interoperability were deprecated. Thecompatibility layer may cause significant performance reduction forinteroperability calls. Please see the Interop MigrationGuidefor an overview and individual @deprecated javadoc tags for guidance.We added Truffle Library API that allows language implementations to usepolymorphic dispatch for receiver types with support for implementation specificcaching/profiling with support for uncached dispatch. Please see the TruffleLibraryTutorialfor further details.The numerous changes were introduced to the GraalVM SDK Polyglot API as well:  Renamed Graal SDK to GraalVM SDK.  Experimental options now require --experimental-options on the command line tobe passed to the GraalVM language launchers, orContext.Builder#allowExperimentalOptions andEngine.Builder#allowExperimentalOptions to be set in other scenarios.For example, to diagnose the memory allocations of a JavaScript application with --memtracer profiling tool,you should prepend --experimental-options option:js --experimental-options --memtracer program.js.  Added a possibility to set an encoding in Source builder.  Added a new API for target type mappings using the new HostAccess API.We summarized all Truffle and SDK changes between GraalVM versions in separate changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsChrome Inspector  Object Preview feature added for GraalVM implementation of JavaScript.  Implemented a Custom Preview experimental feature for all languages supported by GraalVM.Ideal Graph Visualizer (IGV)Starting with 1.0-RC15 version of GraalVM, Ideal Graph Visualizer will beprovided as standalone download from Oracle Technology Network Downloads page. It is not part of GraalVM Community or Enterprise editions.1.0-RC14(2019-03-18)Introducing --vm.&amp;lt;option&amp;gt;We introduced a uniform --vm.&amp;lt;option&amp;gt; which allows to pass options in a uniform way, without knowing which VM mode (--jvm, or --native) will be used. It replaces  --jvm.&amp;lt;option&amp;gt; and --native.&amp;lt;option&amp;gt; command line options, e.g., the option to configure the maximum amount of memory used for the heap --jvm.Xmx=5G becomes --vm.Xmx=5G.This applies to all languages.JavalibgraalThis is the first release to include a prebuilt libgraal shared library. This shared library is produced by the native-image and contains a pre-compiled version of the GraalVM compiler. In addition to improving startup, libgraal completely avoids interfering with the heap usage and profiling of the application code. That is, it has execution properties similar to other native HotSpot compilers such as C1 and C2. To try it out, add -XX:+UseJVMCINativeLibrary to your java command line. Note that this is still a work in progress and we are focusing on improving its stability and ensuring it does not compromise peak performance.Default Failure BehaviorThe default behavior has changed for a failure (i.e., uncaught exception) duringthe compilation. These are now silently ignored and nothing is printed to theconsole. To get the old behavior of a message being printed to the console andfor collecting diagnostics about the failure, you now need to specify-Dgraal.CompilationFailureAction=Diagnose option.Native ImagesNew FeaturesWe introduced a tracing agent for the Java HotSpot VM that records usages of reflection and JNI that can then be converted to configuration files for the native image generator. This simplifies the process of getting new applications working as native images. For details, please look at the documentation.We improved support for the java.util.logging API. See the GitHub docs for details.The javax.script.ScriptEngine API is now supported. Please note that the Nashorn JavaScript engine does not work in native images and is therefore always excluded. However, Truffle based language implementations such as the GraalVM JavaScript engine are available when, e.g., the native image is built with the option --language:js.Implemented the Class.getSimpleName method for the native images (see 1020).Bugfixes      Fixed an NPE during native image generation at accessing annotations metadata on the classes opened for reflection (see 1048).        Fixed createTempFile() providing non-default filesystem and failing (see 1035).        Fixed a segfault due to incorrect socket address length value (see 1025).  JavaScriptHTML-like CommentsWe added support for HTML-like comments.var s = &quot;Introducing html-like comments&quot;;alert(s);&amp;lt;!-- this is a comment --&amp;gt;Changes  Renamed the option js.experimental-array-prototype to js.experimental-foreign-object-prototype.More details can be found in the project changelog on GitHub.RThe GraalVM implementation of R in this release comes with various bug fixes and improvements.Error PropagationAccording to the R semantics, errors are handled immediately at the point where they are raised. However, in language embedding or polyglot scenarios, it is more useful to have the errors propagate out of the R scope, so that they can be handled correctly. We changed the behavior of FastR in this regard so that now R errors are propagated. Note that this only happens if this is possible without causing unexpected side effect in R code,i.e., if there are no options(error = ...) or on.exit(...) handlers on the stack.Experimental OptionsAll specific options (NOT those GNU-R compatible like --save) are experimental except for --R.PrintErrorStacktracesToFile, which is an option that enables logging of FastR internal errors for bug reporting purposes. Experimental options can be unlocked using --experimental-options or with ContextBuilder#allowExperimentalOptions.To see a complete list of changes, please refer to the project changelog.RubyThis version of GraalVM features new methods implementations and other updates for Ruby implementation.New Features  Implemented Dir.children and Dir#children, String#delete_prefix, #delete_suffix and related methods.Changes  -Xlog= has been removed. Use --log.level= instead.  -J flag has been removed. Use --vm.* instead.  -J-cp lib.jar and similar have been removed. You should use --vm.cp=lib.jar or --vm.classpath=lib.jar instead.  The -X option now works as in MRI.An extensive list of changes is available on GitHub.PythonPython 3.7.0The standard library was updated to Python 3.7.0 from 3.6.5.Changes  Defined a subset of the graalpython launcher options as “stable”. All other options are subject to change and need to be unlocked explicitly on the command line.  Added the support for  -I flag to ignore the user environment and not add the working directory to sys.path.More details can be found in the project changelog on GitHub.LLVM Runtime  Various bug fixes.API Changes for GraalVM Integrators (SDK + Truffle)New Features  Added Context.Builder#allowExperimentalOptions to control whether experimental options can be passed to a Context.  Added Engine.Builder#allowExperimentalOptions to control whether experimental instrument and engine options can be passed.  The @Option annotation can now specify the stability of an option.  Added engine bound TruffleLogger for instruments. The engine bound logger can be used by threads executing without any context.Changes  Multiple deprecated elements were removed from  the Truffle language implementation framework, i.e., TruffleException.isTimeout, EventBinding.getFilter etc..We summarized GraalVM Truffle and GraalVM SDK changes between GraalVM versions in the separate changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC13(2019-03-05)ToolsIdeal Graph VisualizerWith GraalVM 1.0-RC13 release, there has been a significant change to theIdeal Graph Visualizer developer tool. The default behavior of the Dgraal.Dumpoption has changed in that IGV dumps are now written to the local file system by default.To get the old behavior of dumping straight to an IGV instance listening on 127.0.0.1:4445,you need to add -Dgraal.PrintGraph=Network option.If a network connection cannot be opened, dumping falls back to file system dumping.Graal VisualVMAnother developer tool, Graal VisualVM, now allows Heap monitoring of native-image processes.This functionality is available with GraalVM Enterprise Edition.R  R specific command line options are now passed as –R.PrintErrorStackTracesToFile=true instead of using JVM properties (–jvm.R:+PrintErrorStackTracesToFile). You can view available options with --help:languages.  Optional post installation script, configure_fastr, also regenerates etc/Renviron and etc/ldpaths files according to the target system.  R vectors are not writeable from other languages, because this would violate the R language semantics.A list of changes to GraalVM implementation of R is available on GitHub.JavaScript  Node.js updated from 10.15.0 to version 10.15.2.  Made JavaScript and Java interoperability available in native images. Note that you have to configure the accessible classes and methods at native image build time (see reflection configuration).  Node.js Worker class should be used instead of deprecated experimental Java.Worker API now.  A deprecated NashornJavaInterop mode was removed.More details can be found in the project changelog on GitHub.LLVM Runtime  Added the support for embedded bitcode in Mach-O files. We support bitcode in the __bitcode section of Mach-O object files, as well as bitcode files in an embedded xar archive in the __bundle section of executables or dylibs. For example, on OS X, you can compile your code with clang -fembed-bitcode -flto hello.c -o hello, creating a native executable with embedded bitcode. You can then run it natively (./hello) or with GraalVM ($GRAALVM_HOME/bin/lli ./hello).The full project changelog is available on GitHub.RubyThis release of GraalVM is rich in performance and compatibility improvements,multiple changes and bug fixes for Ruby implementation.An extensive list of all updates is available on  Github.  Here is a short list of most notable ones:New features:  Host interoperability with Java now works on SubstrateVM too.Changes:  -Xoptions has been deprecated and will be removed. Use --help:languages instead.  -Xlog= has been deprecated and will be removed. Use --log.level= instead.  -J has been deprecated and will be removed. Use --jvm. instead.  -J-cp lib.jar and so on have been deprecated and will be removed. Use--jvm.cp=lib.jar or --jvm.classpath=lib.jar instead.  -J-cmd, --jvm.cmd, JAVA_HOME, JAVACMD, and JAVA_OPTS do not work in any releasedconfiguration of TruffleRuby, so have been removed.  -Xoption=value has been deprecated and will be removed. Use --option=value instead.  TracePoint.trace and TracePoint#inspect have been implemented.Compatibility:  Improved the exception when an -S file is not found.  Removed the message from exceptions raised by bare raise to better match MRI #1487.  TracePoint now handles the :class event.Note that GraalVM 1.0-RC13 implementation of Ruby is built on Ruby 2.4.4, and itis still vulnerable to CVE-2018-16395. This will be fixed in the next release.PythonNew feature:  Allow installation of NumPy in a venv. Just run e.g., bin/graalpython -m venv numpy_env; source numpy_env/bin/activate; graalpython -m ginstall install numpy. Note that not all NumPy features work at the moment.To see a complete list of changes, please refer to the project changelog.API Changes for GraalVM Integrators (SDK + Truffle)  Added Debugger.getSessionCount() to return the number of active debugger sessions.  TruffleLanguage class now can register additional services. This change also deprecates the automatic registration of the language class as a service.  OptionCategory.DEBUG has been renamed to OptionCategory.INTERNAL for clarity.  Added static member to class objects that provides access to the class’s static members.  OptionStabilityhas been added for specifying the stability of an option.All GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC12(2019-02-04)Native Image GenerationNative images now check the remaining available stack size on every method call,and throw a StackOverflowError on stack overflows.We continued the work on the support of incomplete classpaths. There were no big changes,but only small bug fixes based on users feedback. The support for incomplete classpathsnow allows to run the native image generator with bytecode verification,i.e., the option --no-verify is no longer passed to the Java HotSpot VMwhen running the native image generator.RAn extensive list of changes to GraalVM implementation of R is available on GitHub. Here is a short list of most notable ones:  FastR now uses the R base function print to implement TruffleLanguage#toString, so that tools and debuggers (like the Chrome Dev Tools console) format values (e.g., data.frame objects) in a familiar, R-like, way.  GraalVM implementation of R provides GNU-R compatible parseData for expressions parsed via parse(...,keep.source=T), which enables packages that use this functionality (like lambda.r and plumber) to work.  Added a dummy implementation of the ALTREP framework to avoid linking problems.JavaScript  Updated Node.js from 10.9.0 to version 10.15.0.  A new option js.experimental-array-prototype added to set prototype of array-like non-JS objects (like ProxyArray or Java List) to Array.prototype. It makes it possible to use functions like map or forEach on these objects directly.More details can be found in the project changelog on GitHub.LLVM Runtime  In order to streamline the polyglot APIs in LLVM Runtime, we deprecated the truffle_* builtin functions. We also broke binary compatibility to bitcode compiled with polyglot.h from version 1.0.0-RC2 (or older).  Read-only globals are now placed in read-only memory. This was necessary to accommodate some changes in mac OS Mojave’s libc that raise errors when format strings are placed in the writable memory.The project changelog is available on GitHub.RubyThis version came with the compatibility improvements:  Change to a new system for handling Ruby objects in C extensions which greatly increases compatibility with MRI.  Support for BigDecimal#to_r was implemented (See #1521).A complete project changelog is available on GitHub.PythonTo see a complete list of changes, please refer to the project changelog.  Added support for the __class__ variable in the class scope.  Initial support of the venv standard-library tool, the built-in _bz2 module and the pandas package was started up.API Changes for GraalVM Integrators (SDK + Truffle)GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Added the ability to create native image heap dump directly from Graal VisualVM interface.  Improved heap dump support in the native image.1.0-RC11(2019-01-14)Native Image GenerationWe improved the handling of incomplete classpaths, i.e., code that references classes that are not provided on the classpath. The approach we took for RC10 caused problems in corner cases that would have been difficult to fix, therefore we implemented a different approach. Thanks to everyone who tried our initial approach and reported problems on GitHub. We attempted to verify that all reported problems are solved with the new approach.JavaScript  Graal.js only supports ECMAScript 5 (ES5) and newer, and enforces that rule.  Added support for sharing Java objects using the experimental Node.js Worker Threads API.  Added support for ScriptEngine GLOBAL_SCOPE bindings.  Added options to enable/disable several extension features e.g., print() or load().  Added options to disable features for security reasons e.g., eval().More details can be found in the project changelog on GitHub.LLVM RuntimeGraalVM now reports source filenames and line numbers for LLVM functions in stack traces if the bitcode is compiled with debug information, even if the original source is not available.Find a complete changelog on GitHub.RubyA complete project changelog is available on GitHub. Here is a short list of most notable changes:  Allowed signal 0 to be used with Process.kill (see #1474).  Implemented Dir.each_child.  Added missing support for the close_others option to exec and spawn.  Implemented the missing MatchData#named_captures method (see #1512).  Process::CLOCK_ constants have been given the same value as in standard Ruby.  All core files now make use of frozen String literals, reducing the number of String allocations for core methods.PythonThe changelog is available on GitHub.  Added the ginstall custom module to install known packages such as NumPy and setup tools using graalpython -m ginstall.  Added support for the yield from syntax.  Added more built-in methods to the time module.  Added support for the standard zipfile module.  Added the built-in _cvs module.  Various bug fixes and performance improvements.  Removed the exposure of internal languages through polyglot.eval.R  The R version was upgraded to R-3.5.1.  R does not print or log any details for internal errors unless it is run with  --jvm.DR:+PrintErrorStacktracesToFile.  Newly implemented R native API functions:  Rf_duplicated, Rf_setVar, norm_rand, exp_rand.  Numerous bug fixes.More details can be found in the project changelog on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)Please refer to the project changelogs for a list of APIs changes:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Added CPU monitoring of native-image processes.  Improved the search feature in text views - thread dumps, OQL console results, etc..  Heap viewer is now displaying JVM arguments, has improved performance and memory management.1.0-RC10(2018-12-05)Bug fixes and performance improvements across all GraalVM components.Native Image GenerationAdded a new option --allow-incomplete-classpath with GraalVM 1.0-rc10. By default (without specifying this option), classes that are reachable, but missing on the class path, are reported at native image generation time. When specifying this new option, missing classes are only reported at run time. The option provides support for, e.g., libraries that probe the existence of classes, catch the class loading error, and then fall back to a different behavior. This should result in more applications being able to compile to a GraalVM native image.JavaScriptThe project changelog is available on GitHub.  Added the ability to construct the Java classpath programmatically. If you know at runtime where the classes and jar files are located – you can add them to the classpath and use Java code from them.  Compatibility: added support for several proposals which might become parts of ECMAScript 2019: Array.prototype.{flat,flatMap}, well-formed JSON.stringify, globalThis.  Compatibility: moved several non-standard builtins behind flags (see the  changelog).LLVM Runtime  Improved the debugging experience: internal functions (originating from the GraalVM LLVM interpreter implementation) are now hidden in the stack traces by default and can be debugged with --inspect.Internal; and unhandled exceptions are now output to stderr instead of stdout.More details can be found in the project changelog on GitHub.RubyGraalVM 1.0-rc10 implementation of Ruby comes with several new features and multiple bug fixeswhich can be found in the project changelog on GitHub.  Compatibility: implemented the following API and added libraries:          The nkf and kconv standard libraries were added.      Queue and SizedQueue, #close and #closed?, have been implemented.      Kernel#clone(freeze) has been implemented.      Warning.warn has been implemented.      Thread.report_on_exception has been implemented.        Compatibility: ArgumentError messages now better match MRI.Python  Several users-facing improvements were made to the embedding interfaces: getting/setting the current working directory in Python now uses the appropriate Truffle APIs, Python will report side effects in the KEY_INFO message, and the KEYS message now responds with attributes and methods (not with dict keys).  The interactive help() builtin now works, including asking about language and syntax.A complete project changelog is available on GitHub.RMade important steps for compatibility with the R ecosystem:  Improved the support for popular packages: Rcpp modules, dplyr now mostly works,and FastR provides its own version of data.table (work in progress).  A new builtin function install.fastr.packages(pkgs) can be used to install FastR-specific versions of the rJava and data.table packages.  Fixed linking problems on MacOS when installing R packages and using Fortran code.The full changelogis available on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVMSeveral quality of life improvements:  Added the display of system properties for SVM heap dumps.  Added support for the fields histogram and merged references for guest languages: JavaScript, Ruby, and so on.  Improved CPU Sampler accuracy.Ideal Graph Visualizer  The tool understands mx project structure now, e.g., the GraalVM compiler project when opening sources.  Improved performance when laying out large graphs.1.0-RC9(2018-11-05)GraalVM for Java Developers (GraalVM + compiler)  Updated based JDK to 8u192. You can find the JDK release notes at the Oracle Technology Network website.RubyGraalVM 1.0-rc9 implementation of Ruby features security updates and multiple bug fixeswhich can be found in the project changelog on GitHub.  Here is a short list of most notable changes:  LLVM for Oracle Linux 7 can now be installed without building from source.  The supported version of LLVM for Oracle Linux has been updated from 3.8 to 4.0.  mysql2 is now patched to avoid a bug in passing NULL to rb_scan_args, and now passes the majority of its test suite.  The post-install script now automatically detects if recompiling the OpenSSL C extension is needed. The post-install script should always be run in TravisCI as well, see the documentation.  Detect when the system libssl is incompatible more accurately and add instructions on how to recompile the extension.Python  Added the support help in the builtin Python shell.  Added readline to enable history and autocompletion in the Python shell.  Add support for the -q, -E, -s, and -S Python launcher flags.  Improved support for string and bytes regular expressions using our TRegex engine.  Started the initial support for the binascii module.A complete project changelog is available on GitHub.R  Various improvements in handling of foreign objects in R.  Added missing R builtins and C API: eapply builtin and rapply builtin.More details can be found in the project changelog on GitHub.JavaScriptA complete changelog is available on GitHub.LLVM RuntimeThe project changelog is available on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)  Added SourceElement.ROOT and StepConfig.suspendAnchors() to tune debugger stepping.  Added Context.Builder.logHandler and Engine.Builder.logHandler methods to install a logging handler writing into a given OutputStream.  Primitives, host and Proxy values can now be shared between multiple context and engine instances. They no longer throw an IllegalArgumentException when shared.The major GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Improved Python heapwalker by fixing class names and adding support for PString.  Fixed handling Page Up/Down in ProfilerTreeTable. See GH-109 for details.1.0-RC8(2018-10-19)GraalVM for Java Developers (GraalVM + compiler)  Added the support for Intel bit manipulation instructions. For more details, see #666.  Virtualize unsafe compare and swap calls on non-escaping objects. See #636.Maven Artifacts  The com.oracle.truffle group ID was renamed to org.graalvm.truffle.  The graal-sdk, launcher-common and polyglot-tck artifacts were moved from the org.graalvm group ID to org.graalvm.sdk.  New artifacts that are now available:          org.graalvm.compiler:compiler      org.graalvm.js:js      org.graalvm.js:js-launcher      org.graalvm.js:js-scriptengine      org.graalvm.regex:regex      org.graalvm.tools:chromeinspector      org.graalvm.tools:profiler      org.graalvm.truffle:truffle-nfi      com.oracle.substratevm:library-support      com.oracle.substratevm:objectfile      com.oracle.substratevm:pointsto      com.oracle.substratevm:svm-driver      com.oracle.substratevm:svm        The artifacts that are now modular JARs:          truffle-api      graal-sdk      js      js-scriptengine      compiler        The compiler artifact provides the jdk.internal.vm.compiler module and can be used to upgrade that module in JDK 11. Unlike the module present in the JDK, this version contains the optimizing Truffle runtime.Native Image Generation  The native image generator now has automatic support for services loaded using ServiceLoader.All service implementation classes, listed in the META-INF directory, are available automatically as soon as the service interface is used. This eliminates the need to manually register resources and reflection support for such classes. The automatic registration can be disabled with the -H:-UseServiceLoaderFeature option.  Finished the support for isolates (starting multiple independent VM instances at run time) and compressed references (to reduce memory footprint; Enterprise Edition only). More details are in an upcoming blog article.  A new Maven plugin allows native image generation from within a Maven build.  All components necessary for native image generation (Substrate VM and the GraalVM compiler) are now available on Maven Central. The dependency for that is:      &amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;com.oracle.substratevm&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;svm&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;1.0.0-rc8&amp;lt;/version&amp;gt;    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;  &amp;lt;/dependency&amp;gt;  JavaScript  Updated Node.js to version 10.9.0.A complete changelog is available on GitHub.LLVM RuntimeThe project changelog is available on GitHub.Ruby  Ubuntu 18.04 LTS, Fedora 28, and macOS 10.14 (Mojave) now supported.  Java.synchronized(object) { } and TruffleRuby.synchronized(object) { } methods have been added.  Added a TruffleRuby::AtomicReference class.  Performance of setting the last exception on a thread has now been improved.A complete project changelog is available on GitHub.Python  Python now supports the allocation profiler (--memtracer) to analyze the heap usage of applications.The changelog is available on GitHub.RGraalVM 1.0-rc8 implementation of R came up with multiple bug fixes which can be found in the project changelog on GitHub.ToolsGraal VisualVM  Introduced the CPU and Memory Sampler for guest languages.  Submitted improvements in the R language heapwalker.API Changes for GraalVM Integrators (SDK + Truffle)The major GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC7(2018-10-03)GraalVM for Java Developers (GraalVM + compiler)  Added the virtualization of Unsafe compare and swap calls, for more details see GH-636.Native Image Generation  Support for the Java security framework, see JCA-SECURITY-SERVICES.md for the details.  Support for https URL connections, see URL-PROTOCOLS.md for more details.JavaScript  Improved support for sharing of shapes between Contexts with the same Engine, which allows to reuse ASTs and objects across different manually created contexts.  Support for BigInteger typed TypedArrays.More details can be found in the project changelog on GitHub.LLVM RuntimeThe full changelog is available on GitHub.  New polyglot builtin polyglot_has_member.  Removed support for implicit polyglot types for local variables as the availability of type information is not guaranteed. Explicit polyglot casts are now strictly required (polyglot_as_typed). See docs/INTEROP.md and polyglot.h for more details.  Support for IR-level (textual representation of bitcode files) tracing, i.e., creating an execution log of all bitcodes that were executed, for debugging purposes.  Preliminary support for LLVM 7.RubyThe complete changelog is available on GitHub. Here is a short list of most notable changes.  Useful inspect strings have been added for more foreign objects.  Added the rbconfig/sizeof native extension for better MRI compatibility.  Support for pg 1.1. The extension now compiles successfully, but may still have issues with some datatypes.  readline can now be interrupted by the interrupt signal (Ctrl+C). This fixes Ctrl+C to work in IRB.  Fixed version check preventing TruffleRuby from working with Bundler 2.0 and later.  Removed obsoleted patches for Bundler compatibility now that Bundler 1.16.5 has built-in support for TruffleRuby.  Fixed problem with Kernel.public_send not tracking its caller properlyrb_thread_call_without_gvl() no longer holds the C-extensions lock.  Fixed caller_locations when called inside method_added.  Fixed mon_initialize when called inside initialize_copy.Python  Added support for the re.split builtin.  Enhanced the java interop builtin module with introspection utility methods.  Changes in C extension interface to reduce overhead.The changelogis available on GitHub.R  AWT based graphics devices (jpg, png, X11, …) is supported when running FastR as a native image.  eval.polyglot: the parameter source was renamed to code.  New builtin as.data.frame.polyglot.value creates R data frames from Polyglot objects (KEYS are used as column names, the values must be homogenous arrays, e.g., respond to HAS_SIZE).  Paths in eval.polyglot are resolved relative to the current working directory.  Various fixes necessary to pass dplyr tests (GitHub version of dplyr).More details can be found in the project changelog on GitHub.ToolsIdeal Graph Visualizer  User can navigate to Javascript (guest language) source from the graph nodes.  Ideal Graph Visualizer prompts to download plugins to support Javascript editing.  Simple scripts (written in Javascript) can be applied on graph data.API Changes for GraalVM Integrators (SDK + Truffle)  GraalVM SDK and Truffle license changes from GPL2 with Class Path Exception to the Universal Permissive License (UPL). Please refer to the license files for more information: GraalVM Truffle license, GraalVM SDK license.To see the list of changes to the APIs, please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC6(2018-08-31)GraalVM for Java Developers (GraalVM + compiler)  New optimization to remove unnecessary allocation in some calls to Enum.values().  See calls to Enum.values() don’t optimise away as expected for the details.Native Image Generation  Delay class initialization to runtime: By default, all classes that are seen asreachable for a native image are initialized during image building, i.e., theclass initialization method is executed during image building and is not seen asa reachable method at runtime. But for some classes, it is necessary to executethe class initialization method at runtime. This is now possible using the newoption --delay-class-initialization-to-runtime=&amp;lt;comma separate list of classnames&amp;gt; or using the new API RuntimeClassInitialization class.  Direct byte buffer are no longer allowed in the image heap: We added a new verification during image generation to ensure that no direct or mapped byte buffers (MappedByteBuffer instances) are in the image heap. Such buffers have either a pointer to C memory or reference a file descriptor, i.e., native resources that are available during image generation but no longer at image runtime. Using such a buffer would lead to a segfault at runtime. We discovered this issue because Netty has a few direct buffers that are created in class initializers. It is necessary to delay the initialization of such classes to runtime.  Better automatic discovery of classes, methods, and fields accessed via reflection. When String parameters of Class.forName, Class.getMethod, Class.getField, and other similar classes can be constant folded during image generation, then these classes, methods, and fields are automatically registered for reflection usage and do not need to be registered manually on the command line. Constant String parameters are a common pattern to support, e.g., different JDK versions or different library versions where a class, method, or field is not present in all cases and therefore cannot be used directly.LLVM RuntimeThe full changelogis available on GitHub.  Support for LLVM IR-level debugging, i.e., debugging at the level of *.ll instead of *.c files.  New polyglot cast functions for primitive array types, which allows object from other languages to be used like primitive arrays.  Support for function pointer members in polyglot_as_typed, which allows objects from other languages to be used in expressions like obj-&amp;gt;func(args).RubyThe complete changelog is available on GitHub. Here is a short list of most notable changes.  TruffleRuby is now usable as a JSR 223 (javax.script) language;  A migration guide from JRuby is now included.  The embedded configuration -Xembedded can now be set set on the launcher command line.  Polyglot.export can now be used with primitives and converts strings to Java, when Polyglot.import converts them from Java.  Foreign objects optimisations such as unboxing foreign strings on to_s, to_str, and inspect.  Optimized performance and keyword rest arguments (def foo(**kwrest)).  Multiple bug fixes from user reports.PythonThe full changelog is available on GitHub.  Improved compatibility with regular expressions by including CPython’s sre module as a fallback engine (in addition to Truffle’s regular expression engine).  C extension modules can now be compiled with LLVM 5+, which was prevented by internal incompatibilities before.  Introduced lazy string concatenation to significantly speed up code patterns that repeatedly concatenated strings.  Numerous C-API improvements to extend support for scikit-learn.  Extensions and fixes in various areas: behavior of function and code objects, collections, exception handling during import, type ids, documentation and generators.  Update standard library to CPython 3.6.5.  Enable reuse of ASTs in multiple Contexts (requires the contexts to be created in the same polyglot Engine).RThe full changelogis available on GitHub.  Support for reading/writing graphical parameters via par.  Added numerous builtins to the C API, enabling support for packages like RCurl, rjson, compare, naivebayes, etc.  Added support for formulas that include ....  Various bug fixes: attributes of NULL objects, of CR/LF handling in readLine, La_chol with pivot, warnings/errors in vector coercion.API Changes for GraalVM Integrators (SDK + Truffle)To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC5(2018-07-31)GraalVM 1.0-rc5 is the first release where we provide pre-built binaries for GraalVM Community on macOS. As always all binaries are available from the downloads page.KNOWN ISSUES  The GraalVM Community distribution for macOS currently depends on some libraries that are not installed by default on current MacOS versions.This might cause issues with UI-related functionality:    Library not loaded: /usr/X11/lib/libfreetype.6.dylib    The necessary components can be added, e.g., by installing https://www.xquartz.org. We will remove this dependency in upcoming versions of GraalVM Community for macOS.  GraalVM for Java Developers (GraalVM + compiler)  1.0-RC5 includes JVMCI changes necessary to support compiling the GraalVM compiler ahead of time and deploying as a shared library alongside libjvm.so (i.e., libgraal). Note that the implementation of libgraal itself is not a part of this release as it is still under development.Native Image Generation  Added API that allows an application to distinguish between native image building, native image runtime, and regular Java execution. For more information and documentation, look at the class  ImageInfo.JavaScript  Removed legacy NashornExtensions option, use --js.nashorn-compat instead.  Added support for Symbol.prototype.description.  Added support for String.prototype.matchAll.More details can be found in the project changelog on GitHub.RubyThe full changelog is available in the GitHub repository, but here are some of the most notable changes.  Simpler installation on macOS: it is no longer needed to add LLVM (/usr/local/opt/llvm@4/bin) to PATH on macOS.  --log.ruby.level= can be used to set the log level from any language launcher.  String#unpack1 has been implemented.  Optimized required and optional keyword arguments.  -Dtruffleruby.log and TRUFFLERUBY_LOG have been removed - use -Dpolyglot.log.ruby.level.  The custom log levels PERFORMANCE and PATCH have been removed.Python  Generator expressions now properly evaluate their first iterator in the definition scope at definition time.  Fixes for embedders to ensure top scopes are stable and local scopes always contain TruffleObjects.  C-API improvements to support simple Cython modules.  Support recognition of Python source files with the polyglot launcher, so that now --language python is not necessary when starting Python scripts with the polyglot launcher (note that the polyglot launcher still needs to be rebuilt using bin/gu rebuild-images polyglot after installing Python).Full changelog is available on GitHub CHANGELOG.md.RSee CHANGELOG for the list of changes.LLVM RuntimeThe project changelog is available on GitHub.  Support the __builtin_debugtrap function based on LLVM’s @llvmn.debugtrap intrinsic, which can be used to drop into the debugger (e.g., Chrome Inspector).  Support “zero-length array at end of struct” pattern when accessing polyglot values as structs.  Improved performance of global variable access.  Improved support for vectorized bitcode operations generated by clang.API Changes for GraalVM Integrators (SDK + Truffle)  Added new execution listener API that allows for simple, efficient and fine-grained introspection of executed code.  Changed the default language context policy from SHARED to EXCLUSIVE, i.e. by default there is one exclusive language instance per polyglot or inner context. This can be configured by the language using the context policy.To see the full list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Graal VisualVM was added to the GraalVM Community distribution.1.0-RC4(2018-07-13)General RemarksWhile we provide updated components for all languages for this rc4 release, only the JavaScript component received fixes from its upstream repository. All other languages are unchanged in terms of functionality.The next release, rc5, is planned for the beginning of August and will provide updates for all components.JavaScriptThe GraalVM JavaScript component has been updated to provide better compatibility with the Nashorn engine. There now is a --nashorn-compat flag to enable backwards compatibility functionality. This flag is highly discouraged for new applications, but can simplify the migration from Nashorn to GraalVM for existing code.  Access getters and setters like fields  Provide Java.extend, Java.super, JavaImporter, JSAdapter  Allow to construct Interfaces or AbstractClasses      Provide top-level package globals java, javafx, javax, com, org, edu    Provide Java.isScriptFunction, Java.isScriptObject, Java.isJavaMethod and Java.isJavaFunctionSome global functions and objects have been added for the scripting mode and can be enabled with the --scripting flag:  Provide $EXEC, $ENV, $ARG, $OPTIONS1.0-RC3(2018-06-29)GraalVM for Java Developers (GraalVM + compiler)  Updated the underlying JDK version to “1.8.0_172” from “1.8.0_171”. You can find the JDK release notes at the Oracle Technology Network website.  Fixed a rare NullPointerException during JVMCI initialization.Native Image Generation  Added support for java.lang.reflect.Proxy supporting both automatic detection and manual configuration. Please refer to the documentation on GitHub for the details.  Added support for Classloader.getResource() and similar methods.  Added support for loading services through theServiceLoader.  Fixed a ClassCastException on generating native images for profile-guided-optimizations (with the --pgo-instrument command line option).JavaScript  Enabled code sharing between Contexts with the same Engine.  Added support for BigInt arithmetic expressions.  Added a flag for the Nashorn compatibility mode --js.nashorn-compat, for the details and migration from Nashorn please refer to the documentation.  Rename the flag for the V8 compatibility mode to js.v8-compat.More details can be found in the project changelog on GitHub.RubyThe full changelog is available in the GitHub repository, but here are some of the most notable changes.  Added ability to call is_a? on foreign objects.  Fixed: Qnil/Qtrue/Qfalse/Qundef can now be used as initial value for global variables in C extensions.  Fixed: SIGPIPE is correctly caught on SubstrateVM, and the corresponding write() raises Errno::EPIPE when the read end of a pipe or socket is closed.  Fixed determining the source encoding for eval() based on the magic encoding comment.Additionally, we implemented a number of performance improvements for stat() related calls, eval(), String substitutions, reading from IO and more.PythonGraalVM Python implementation is still in the early stages, but we’re making progress towards the goal of running applications which use SciPy.  Various C-API improvements allow to run simple NumPy examples.  Implemented buffered I/O and more encodings support, which enables working with files through the standard open function without having to force unbuffered access, and enables working with files that have encodings other than utf-8.  Most math module functions are now implemented and work correctly.  The random module substitute was removed and we now run the standard library random module to be fully compatible.  Improved thread-safety in the embedded scenarios when using Python contexts from multiple threads.More details are available in the project’s changelog on GitHub.R  Added more missing R builtins and C API functions, see CHANGELOG for a complete list.  Simplified installation, the script that configures FastR for the current system  jre/languages/R/bin/configure_fastr does not require Autotools anymore.  Added configuration files to allow users to build a native image of the FastR runtime, which reduces the startup time. Run jre/languages/R/bin/install_r_native_image to build the image.  Fixed an issue with the plotting window not displaying anything after it was closed and reopened.LLVM Runtime  New builtins polyglot_from_typed and polyglot_as_typed, which can be used to dynamically attach types to polyglot objects.  Implementers of TruffleObject can now respond to the GetDynamicType message to provide a type when an object is accessed from LLVM code.More details are available in the project changelog.API Changes for GraalVM Integrators (SDK + Truffle)  Added support for logging in Truffle languages and instruments.  Removed deprecated ResultVerifier.getDefaultResultVerifier API.To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVMWe improved memory footprint and introduced several UI improvements for cleaner more responsive experience of Graal VisualVM. In addition to that, there are the following improvements:  Added recognition of the LLVM Runtime processes.  Improved displaying logical values of guest languages’ objects.  Improved the Object Query Language (OQL) Console for inspecting memory dumps functionality — sorting, filtering, aggregation, unlimited number of results now work.Chrome inspector  Multiple inspector sessions for multiple polyglot engines can run on the same port now.1.0-RC2(2018-06-05)GraalVM for Java Developers  Updated the underlying JDK version to “1.8.0_171” from “1.8.0_161”. You can find the JDK release notes at the Oracle Technology Network website.  Improved support for the Java Microbenchmark harness. Since JMH 1.21, GraalVM is a recognized and supported JVM.  Fixed a StackOverflow exception an improved performance when recursively inlining of invokedynamic instructions.  Fixed a compiler error causing incorrect code generation while building the scalac compiler.Native Image Generation  Added support for building statically linked native images. Now you can pass --static, and if you have static libc and zlib installed, it generates a standalone executable that will not require libc for running.  Added Classpath exception to the license of SubstrateVM and the Graal compiler components to make sure all GraalVM code ending up in a native image is subject to this clause.  Fixed the handling of implicit exceptions (NullPointerExeption, ArrayIndexOutOfBoundsException, ClassCastException, …): all exceptions now have correct stack traces and can be caught as expected. Previously, implicit exceptions were sometimes not caught by an exception handler within the same method.  Fixed a number of exceptions during the generation of native images that were reported by early adopters.JavaScript  Updated Node.js to 8.11.1 (from 8.9.4), it is not a breaking change, but it brings numerous improvements, including CVE-listed security fixes.LLVM Runtime  Added a new API for accessing Java types and instantiating foreign objects from LLVM languages.Now it is possible to easily call Java code from native programs compiled to the LLVM bitcode. The example below shows how you can access Java’s BigInteger long math operations from C.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *bigInteger = polyglot_java_type(&quot;java.math.BigInteger&quot;);    void *(*BigInteger_valueOf)(long) = polyglot_get_member(bigInteger, &quot;valueOf&quot;);    void *bi = BigInteger_valueOf(2);    void *result = polyglot_invoke(bi, &quot;pow&quot;, 256);    char buffer[100];    polyglot_as_string(polyglot_invoke(result, &quot;toString&quot;),                       buffer,                       sizeof(buffer),                       &quot;ascii&quot;);    printf(&quot;%sn&quot;, buffer);}If we compile it to the LLVM bitcode, we can execute it with GraalVM. You can see that it computes the value of2^256 which isn’t that easy to do in C otherwise.# shelajev at shrimp.local in /tmp→ clang -c -O1 -emit-llvm -I$GRAALVM_HOME/jre/languages/llvm big-integer-demo.c# shelajev at shrimp.local in /tmp→ lli --jvm big-integer-demo.bc115792089237316195423570985008687907853269984665640564039457584007913129639936A more detailed list of changes to the LLVM interpreter can be found in the full changelog.Ruby  We are now compatible with Ruby 2.4.4.  Java.import name imports Java classes as top-level constants.  Coercion of foreign numbers to Ruby numbers now works.  to_s works on all foreign objects and calls the Java toString.  to_str will try to UNBOX and then re-try to_str, in order to provoke the unboxing of foreign strings.Much more details can be found in the full changelog.RAmong the other changes, we improved the stability of GraalVM’s R implementation.  Added a /jre/languages/R/bin/configure_fastr script that allows FastR’s native build scripts to adopt to the current system, which makes installing R packages much more stable.  The fastr_errors.log file was renamed to fastr_errors_pidXYZ.log and is stored in either initial working directory, the user home directory, /tmp, or the FastR home directory (picking the first location that is writeable). Please add it to the bug reports if you submit issues.Python  Added support for the Python unittest framework.  Python now supports breaking on exceptions and unwinding to stack frames in Chrome inspector.API Changes for GraalVM Integrators (SDK + Truffle)Both GraalVM SDK and Truffle are offering API for developers trying to build things on top of GraalVM, language implementations, embedding GraalVM, and so on.  Enabled code sharing between guest language Contexts with the same Engine, speeding up the repeated evaluation of the code.To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsVisualVM  Fixed the issues with loading polyglot heap dumps  fixed executing of scripts in R console  improved recognition of R REPL  fixed loop to nodes  fixed memory leak in child nodes  improved appearance on MacOS  Applicability fixes  added roots histogram for classGraalVM Updater gu  The default operation mode changed from “install from local files” to “install from catalog”.  -c option for installing from the catalog, can be omitted (installing from the catalog the default), but specifying -c still works.  Use -F to install from local files, i.e. bin/gu -F /tmp/ruby-installable.jar.Chrome InspectorFixed a number of issues:  fixed the initial suspend of node scripts with no statement on the first line  fixed tooltip issues and representation of the functions  fixed issues with re-connection of Chrome inspector client",
                    "url": " /release-notes/release-candidates/"
                  },
                  
                  "reference-manual-ruby-reportingperformanceproblems":  {
                    "title": "",
                    "content": "Reporting Performance ProblemsWe are interested in hearing from you if you experience lower performance with TruffleRuby than with other implementations of Ruby.The Compatibility guide lists some features which we know are slow and are unlikely to get faster.Common Problems and WhyTruffleRuby uses extremely sophisticated techniques to optimize your Ruby program.These optimizations take time to apply, so TruffleRuby is often a lot slower than other implementations until it has had time to warm up.Also, TruffleRuby tries to find a “stable state” of your program and then automatically remove the dynamism of Ruby where it is not needed, but this then means that if the stable state is disturbed, performance lowers again until TruffleRuby can adapt to the new stable state.Another problem is that TruffleRuby is very good at removing unnecessary work, such as calculations thatare not needed or loops that contain no work.All of these issues make it hard to benchmark TruffleRuby. This is not a problem that is unique to us - it applies to many sophisticated virtual machines - but most Ruby implementations are not yet performing optimizations powerful enough to show these problems, so they may be new to some people in the Ruby community.Using the Enterprise Edition of GraalVMTo experiment with how fast TruffleRuby can be, we recommend using theEnterprise Edition of GraalVM and rebuilding the Ruby executable images.Using the JVM ConfigurationFor the best peak performance, use the JVM configuration, using --jvm.The default native configuration starts faster but does not quite reach the same peak performance.However, you must then use a good benchmarking tool, like benchmark-ips described below, to run the benchmark, or the slowerwarmup time will mean that you do not see TruffleRuby’s true performance in the benchmark.If you want to write simpler benchmarks that just run a while loop with a simple timer (which we would not recommend anyway), then use the default native mode so that startup and warmup time is shorter.How to Check for Basic Performance ProblemsIf you are examining the performance of TruffleRuby, we would recommend that you always run with the --engine.TraceCompilation flag.If you see compilation failures or repeated compilation of the same methods, this is an indicator that something is not working as intended and you may need to examine why, or ask us to help you do so.If you do not run with this flag, TruffleRuby will try to work around errors and you will not see that there is a problem.How to Write a Performance BenchmarkThe TruffleRuby team recommends that you use benchmark-ips to check the performance of TruffleRuby.It makes things easier for us if you report any potential performance problems using a report from benchmark-ips.A benchmark could look like this:require &#39;benchmark/ips&#39;Benchmark.ips do |x|  x.iterations = 2  x.report(&quot;adding&quot;) do    14 + 2  endendWe use the x.iterations = extension in benchmark-ips to run the warmup and measurement cycles of benchmark-ips two times, to ensure the results are stable and that enough warmup was provided (which can be tweaked with x.warmup = 5).You should see something like this:Warming up --------------------------------------              adding    20.933k i/100ms              adding     1.764M i/100msCalculating -------------------------------------              adding      2.037B (±12.7%) i/s -      9.590B in   4.965741s              adding      2.062B (±11.5%) i/s -     10.123B in   4.989398sWe want to look at the last line, which says that TruffleRuby runs 2.062 billion iterations of this block per second, with a margin of error of ±11.5%.Compare that to an implementation like Rubinius:Warming up --------------------------------------              adding    71.697k i/100ms              adding    74.983k i/100msCalculating -------------------------------------              adding      2.111M (±12.2%) i/s -     10.302M              adding      2.126M (±10.6%) i/s -     10.452MHere, TruffleRuby’s performance can be described as a thousand times faster than Rubinius.That seems like a lot - and what is actually happening here is that TruffleRuby is optimizingaway your benchmark.The effect is less pronounced with complex code that cannot be optimized away.Final Technical Note: Blackholes and Value ProfilingSome benchmarking tools for other languages have features called “blackholes.”These surround a value and make it appear to be a variable at runtime, even if it is in fact a constant, so that the optimizer does not remove it and actually performs any computations that use it.However, TruffleRuby uses extensive value profiling (caching of values and turning them into constants), so that even if you make a value appear to be a variable at its source, it is likely to be value-profiled at an intermediate stage.In general, more complex benchmarks that naturally defeat value profiling are preferable, rather than manually adding annotations to turn off important features.",
                    "url": " /reference-manual/ruby/ReportingPerformanceProblems/"
                  },
                  
                  "reference-manual-ruby-rubymanagers":  {
                    "title": "",
                    "content": "Ruby Managers and InstallersIf you have installed GraalVM, it is recommended to add TruffleRuby to a Ruby manager.SeeConfiguring Ruby managers for the full GraalVM distribution below.Installing TruffleRuby with RVM, ruby-build, or ruby-installTruffleRuby is supported by the 3 major Ruby installers.RVMUpgrade RVM to let RVM know about the latest TruffleRuby release:rvm get headInstall the latest TruffleRuby release with:rvm install trufflerubyYou can also install the latest nightly build of TruffleRuby with:rvm install truffleruby-headruby-build and rbenvWe assume you already have ruby-build installed as a plugin for rbenv.First, you need to upgrade ruby-build to get the latest TruffleRuby definition.See ruby-build’s instructions for upgrading.On macOS, if ruby-build is installed via Homebrew and you do not see the latest TruffleRuby release, you might need to install the HEAD version of ruby-build with:brew reinstall --HEAD ruby-buildCheck the latest available version of TruffleRuby with:rbenv install --list | grep trufflerubyThen install the latest TruffleRuby release with:rbenv install truffleruby-[LATEST_VERSION]You can also install the latest nightly build of TruffleRuby with:rbenv install truffleruby-devruby-install and chrubyFirst, you need at least ruby-install 0.7.1 to get TruffleRuby support.Check your version with:ruby-install --versionIf it is older than 0.7.1, you need to update to the latest ruby-install.Follow the installation instructions, since the steps for upgrading ruby-install are the same as the steps for installing it.Then install the latest TruffleRuby release with:ruby-install --latestruby-install trufflerubyruby-install does not support installing nightly builds.Please use ruby-build (which also works with chruby) if you want to install nightly builds:ruby-build truffleruby-dev ~/.rubies/truffleruby-devThere are also instructions on the chruby wiki if you prefer to install TruffleRuby manually.Configuring Ruby Managers for the Full GraalVM DistributionWhen installing GraalVM and Ruby, it is recommended to add TruffleRuby to a Ruby manager for ease of use.Make sure you ran the post-install script before adding GraalVM to Ruby managers.Then follow these steps to integrate GraalVM with your Ruby manager.The first step is to find the TruffleRuby home.On macOS, run:ruby_home=$(path/to/graalvm/Contents/Home/bin/ruby -e &#39;print RbConfig::CONFIG[&quot;prefix&quot;]&#39;)On Linux and other platforms, run:ruby_home=$(path/to/graalvm/bin/ruby -e &#39;print RbConfig::CONFIG[&quot;prefix&quot;]&#39;)rbenvTo add TruffleRuby to rbenv, create a symbolic link in the versions directory of rbenv:ln -s &quot;$ruby_home&quot; &quot;$RBENV_ROOT/versions/truffleruby&quot;rbenv shell trufflerubyruby --versionchrubyTo add TruffleRuby to chruby, create a symbolic link to the $HOME/.rubies directory:ln -s &quot;$ruby_home&quot; &quot;$HOME/.rubies/truffleruby&quot;chruby trufflerubyruby --versionRVMRVM has a command for adding a precompiled Ruby to the list of available rubies:rvm mount &quot;$ruby_home&quot; -n trufflerubyrvm use ext-trufflerubyruby --versionasdf (with asdf-ruby plugin)Adding Truffleruby to asdf functions, much like rbenv or chruby, creates a symbolic link in the .installs/ruby directory but you also need to reshim:ln -s &quot;$ruby_home&quot; &quot;$HOME/.asdf/installs/ruby/truffleruby&quot;asdf reshim ruby trufflerubyasdf local ruby trufflerubyruby --versionUsing TruffleRuby without a Ruby ManagerIf you are using a Ruby manager like rvm, rbenv, or chruby and wish not to add TruffleRuby to one of them, make sure that the manager does not set environment variables GEM_HOME and GEM_PATH.The variables are picked up by TruffleRuby (as any other Ruby implementation would do) causing TruffleRuby to pickup the wrong gem home instead of its own.It can be fixed for the current terminal by clearing the environment with one of the following commands:rbenv systemchruby systemrvm use system# Or manually:unset GEM_HOME GEM_PATH",
                    "url": " /reference-manual/ruby/RubyManagers/"
                  },
                  
                  "ruby":  {
                    "title": "",
                    "content": "",
                    "url": " /ruby/"
                  },
                  
                  "docs-search":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/search/"
                  },
                  
                  "security-guide":  {
                    "title": "",
                    "content": "Security GuideThis security guide provides developers and embedders with information on the security model and features of GraalVM for developers and embedders who seek to build a secure application on top of it.It assumes that readers are familiar with the GraalVM architecture.This guide does not replace but rather supplements the Java security documentation with aspects unique to GraalVM.It also provides security researchers with information on GraalVM’s security model.  Security Model  Language Launchers  Guest Applications  Native Image  Security Manager and Untrusted Code  GraalVM Enterprise to GraalVM Community DowngradeSecurity ModelGraalVM is a shared runtime. It accepts instructions in a higher-levelprogramming language (or an intermediate representation thereof) as input, which is executed later.Developers that implement security controls for their applications (such as access control) in code that is being run by GraalVM can rely on the correct execution of instructions.Incorrect execution of security-critical code running on top of GraalVM that allows to bypass such a security control is regarded a security vulnerability.GraalVM does not support execution of untrusted code.If untrusted and potentially malicious code is to be executed, we recommend GraalVM customers who have an immediate requirement to execute untrusted and potentially adversarial code, adopt the appropriate external isolation primitives to ensure the confidentiality and integrity of their application data.Debug features should only be used in a trusted environment as they provide privileged access to an application, allowing to inspect and change its state and behavior.They may further open network sockets to allow debug clients to connect.Experimental and early-adopter features in GraalVM are not for production use and may have security limitations not covered in the Security Guide.We appreciate reports of bugs that break the security model via the processoutlined in the Reporting Vulnerabilities guide.Language LaunchersFor every language implemented with the Truffle framework, and shipped with GraalVM, a launcher, e.g., interactive shell, is provided.These launchers behave in the same way and come with the same security guarantees as their “original” counterparts.Guest ApplicationsGraalVM allows a host application written in a JVM-based language to execute guest applications written in a Truffle language via the Polyglot API.When creating a context, the host application can control which resources the guest can access.This mechanism is only fully supported for Javascript.By default, access to all managed resources is denied and needs to be granted explicitly, following the principle of least privilege.Host InteroperabilityGraalVM allows exchanging objects between the host and the guest application.By default only methods of host classes that are explicitly annotated by the embedder are exposed to guest applications.By exposing security critical host methods, access restrictions can be bypassed.For example, a guest application in a context that is created with allowIO=false cannot perform IO operations via the guest language’s native API.However, exposing a host method to the context that allows writing to arbitrary files effectively bypasses this restriction.Sharing Execution EnginesApplication developers may choose to share execution engines among execution contexts for performance reasons.While the context holds the state of the executed code, the engine holds the code itself.Sharing of an execution engine among multiple contexts needs to be set up explicitly and can increase performance in scenarios where a number of contexts execute the same code. In scenarios where contexts that share an execution engine for common code also execute sensitive (i.e., private) code, the corresponding source objects can opt out from code sharing with:Source.newBuilder(…).cached(false).build()Computational Resource Limits  Note: Available with GraalVM Enterprise.GraalVM Enterprise allows restricting certain computational resources used by guest applications, such as CPU time, heap memory or the number of threads that can be concurrently used by a context.These sandboxing options are also available via the Polyglot embedding API.ScriptEngine CompatibilityFor reasons of backward compatibility, certain guest languages also support Java’s ScriptEngine interface.For example, this allows GraalVM JavaScript to be used as a drop-in replacement for Nashorn.However, to maintain compatibility, the Nashorn GraalVM JavaScript ScriptEngine interface will create a context with all privileges granted to the script and should be used with extreme caution and only for trusted code.Managed Execution of Native Code  Note: Available with GraalVM Enterprise.The Truffle framework also supports the LLVM intermediate representation (IR) as a guest language. Several native system programming languages, above all C/C++, can be compiled to LLVM IR with the LLVM compiler toolchain. Typically, theselanguages are not memory-safe by themselves and it must be remembered that violations of memory safety are a frequent cause of security vulnerabilities.In managed mode, all ties to the native level are abstracted and routed through GraalVM Enterprise. In particular this means that:  In regards to temporal and spatial memory safety, memory is allocated from the Java heap. This means that memory allocations are managed objects and all accesses are performed in a memory-safe manner (no arbitrary pointer arithmetics and no unchecked out-of-bounds accesses).  Regarding type safety, it is not possible to reinterpret a data pointer into a function pointer and execute arbitrary instructions (since these are distinct pointer types for LLVM runtime).  System calls are intercepted and routed to the corresponding TruffleAPIs. For example, file IO is mapped to the Truffle FileSystem API.The set of currently supported system calls is very limited – only syscalls that can safely be mapped to the Truffle API level are available. Since LLVM Runtime in managed mode always runs bitcode compiled for Linux/x86, it only needs to implement system calls for this platform.  All dependent libraries are executed in managed mode as well, removing all references to natively executed system libraries. This includes libraries that are provided by the LLVM Runtime, such as muslibc.Managed mode can be selected when creating a context (Context.create()) or when calling the bin/lli binary by specifying the --llvm.managed option. A “managed” context will adhere to any restrictions (e.g., allowIO) passed during context creation and does not need the allowNativeAccess privilege.Native ImageThe native image builder generates a snapshot of an application after startup and bundles it in a binary executable.By default, the native image builder executes the static initializers of classes at build time and persists the state in the native image heap.This means that any information that is obtained or computed in static initializers becomes part of the native image executable.This can lead to unintentionally including properties of the build environment, such as environment variables in the image heap.This can either result in sensitive data ending up in the snapshot or fixing initialization data that is supposed to be obtained at startup, such as random number seeds.Developers can request static initializers that process sensitive information to be instead executed at runtime by either specifying the --initialize-at-run-time CLI parameter when building a native image, or making use of the RuntimeClassInitialization API.In addition, developers can run the native image builder in a dedicated environment, such as a container, that does not contain any sensitive information in the first place.Serialization in Native ImageNative Image supports Serialization to help users deserialize the constructors for classes, contained in a native image in the first place.These classes should be whitelisted in an additional specific configuration file, as other classes cannot be deserialized.Deserialization support also adds optional object checksums, and only classes with the same checksum can be deserialized at runtime.The checksum mechanism must not be used for security purposes and the deserialization of untrusted data is not supported.Security Manager and Untrusted CodeThe OpenJDK vulnerability group strongly discourages running untrusted code under a security manager.This also applies to GraalVM, which does not support untrusted code execution in Java.While GraalVM’s ability to restrict the execution of guest language applications to a certain extent is not dependent on a security manager, it is not suited to be used as a sandbox for running untrusted code.Note that security manager deprecation is an option in JEP-411.Native Image does not support a security manager in general. Attempting to set a security manager will trigger a runtime error.The Truffle framework needs to be invoked with all permissions to make full use of its functionality - it provides its own controls to manage resources.GraalVM Enterprise to GraalVM Community Downgrade  Note: Managed execution of native code is available with GraalVM Enterprise.When downgrading to GraalVM Community, native code execution is only available with the allowNativeAccess privilege.This also applies to languages implemented with Truffle that allow for native code extensions, such as Python and Ruby.Computational resource limit options are not recognized by GraalVM Community.",
                    "url": " /security-guide/"
                  },
                  
                  "slack-invitation":  {
                    "title": "",
                    "content": "",
                    "url": " /slack-invitation/"
                  },
                  
                  "reference-manual-ruby-standalonedistribution":  {
                    "title": "",
                    "content": "Standalone DistributionFor details regarding the three ways to install TruffleRuby, see Getting Started.The recommended way is to install GraalVM as it provides the most flexibility.However, you can also use what we call the standalone distribution of TruffleRuby, either via your Ruby manager/installer, or as a simple binary tarball.Releases of the standalone distribution are available on GitHub.Nightly builds are also available.The standalone distributions are the files:truffleruby-VERSION-linux-amd64.tar.gztruffleruby-VERSION-macos-amd64.tar.gzTesting TruffleRuby in TravisCITruffleRuby is now integrated in TravisCI.Just add truffleruby in the build matrix, such as:language: rubyrvm:  - 2.6.1  - truffleruby  - truffleruby-headSee the TravisCI documentation for details.Please report any issue you might find.Testing TruffleRuby in GitHub ActionsIn GitHub Actions, you can easily setup TruffleRuby with ruby/setup-ruby:name: My workflowon: [push]jobs:  test:    strategy:      fail-fast: false      matrix:        ruby: [ 2.6, truffleruby, truffleruby-head ]    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v2    - uses: ruby/setup-ruby@v1      with:        ruby-version: ${{ matrix.ruby }}    - run: ruby -vSee the README of that action for more documentation.Testing TruffleRuby in CIIf you use another continuous integration system, simply follow these instructions to run TruffleRuby in CI: download and extract the archive, add it to PATH, and run the post-install script.Latest ReleaseSet TRUFFLERUBY_VERSION to the latest TruffleRuby version from GitHub releases.export TRUFFLERUBY_VERSION=&amp;lt;desired_version&amp;gt;curl -L https://github.com/oracle/truffleruby/releases/download/vm-$TRUFFLERUBY_VERSION/truffleruby-$TRUFFLERUBY_VERSION-linux-amd64.tar.gz | tar xzexport PATH=&quot;$PWD/truffleruby-$TRUFFLERUBY_VERSION-linux-amd64/bin:$PATH&quot;$PWD/truffleruby-$TRUFFLERUBY_VERSION-linux-amd64/lib/truffle/post_install_hook.shruby -vLatest Nightly BuildHere are the instructions for manually installing the latest nightly build:curl -L https://github.com/ruby/truffleruby-dev-builder/releases/latest/download/truffleruby-head-ubuntu-18.04.tar.gz | tar xzexport PATH=&quot;$PWD/truffleruby-head/bin:$PATH&quot;$PWD/truffleruby-head/lib/truffle/post_install_hook.shruby -vRubyGems ConfigurationNote that you also need to ensure GEM_HOME and GEM_PATH are not set, so TruffleRuby uses the correct GEM_HOME and GEM_PATH.See Using TruffleRuby without a Ruby managerfor details.DependenciesTruffleRuby’s dependencies need to be installed for TruffleRuby to run correctly.",
                    "url": " /reference-manual/ruby/StandaloneDistribution/"
                  },
                  
                  "support":  {
                    "title": "",
                    "content": "GraalVM SupportOracle GraalVM Enterprise Edition is available:      for testing, evaluation, or for developing non-production applications under the Oracle Technology Network License Agreement for GraalVM Enterprise Edition.        for production use, GraalVM Enterprise is available as part of the Oracle Java SE Subscription which includes 24x7x365 Oracle premier support and the access to My Oracle Support (MOS).  GraalVM Community is an open source software built from the sources available on GitHub and distributed under version 2 of the GNU General Public  License with the “Classpath” Exception.GraalVM Community is free to use for any purpose and comes with no strings attached, but also no guarantees orsupport.Subscribe and post to graalvm-users@oss.oracle.com for usability questions.To report a bug or an enhancement request for GraalVM Community, useGitHub Issues. GraalVM Enterprise bugsor enhancement requests should be reported using My Oracle Support (MOS).Any security vulnerabilities in either GraalVM Community or GraalVM Enterprise should only be reported via email to secalert_us@oracle.com.",
                    "url": " /support/"
                  },
                  
                  "tools":  {
                    "title": "",
                    "content": "GraalVM Debugging and Monitoring ToolsGraalVM provides a set of tools for developers to debug and monitor deployed applications, as well as the GraalVM platform, itself.Traditional tools may not be ready to diagnose polyglot programs.GraalVM tools, however, are implemented to inspect single or multi-language applications by debugging via numerous clients, profiling, statement counting, dynamic analysis, and much more.Learn more about each of the tools:  VisualVM  Chrome Debugger  GraalVM Visual Studio Code Extensions  Language Server Protocol  Debug Adapter Protocol  GraalVM Insight  Code Coverage Command Line Tool  Profiling Command Line Tool  Ideal Graph Visualizer",
                    "url": " /tools/"
                  },
                  
                  "reference-manual-ruby-tools":  {
                    "title": "",
                    "content": "Development Tools for RubyTruffleRuby ships with tools automatically provided by GraalVM. Run --help:tools to see a full list of options.The following program is used for illustration:require &#39;chunky_png&#39;a = ChunkyPNG::Image.from_file(&#39;a.png&#39;)b = ChunkyPNG::Image.from_file(&#39;b.png&#39;)c = a.compose(b, 0, 0)c.save(&#39;c.png&#39;)VisualVMYou need to use the --jvm runtime configuration and install GraalVM to use VisualVM.VisualVM is a GUI with many tools:  monitoring such as CPU usage, heap size, time spent in GC, etc (tab: Monitor)  capturing and exploring heap dumps (tab: Monitor)  a list of threads and their status, and thread dumps (tab: Threads)  CPU and memory sampling profilers at the Java level (tab: Sampler)  a CPU sampling profiler at the Ruby level (tab: Polyglot Sampler)There is more documentation about VisualVM on the GraalVM website.ProfilingCPU TracerThe CPU tracer records the number of times methods, blocks, or statements that are run, and prints a histogram.Enable it with --cputracer:-----------------------------------------------------------------------------------------------------------------------------------Tracing Histogram. Counted a total of 41663 element executions.  Total Count: Number of times the element was executed and percentage of total executions.  Interpreted Count: Number of times the element was interpreted and percentage of total executions of this element.  Compiled Count: Number of times the compiled element was executed and percentage of total executions of this element.----------------------------------------------------------------------------------------------------------------------------------- Name                                               |          Total Count |    Interpreted Count |       Compiled Count | Location----------------------------------------------------------------------------------------------------------------------------------- ChunkyPNG::Color#a                                 |          6474  15.5% |          6474 100.0% |             0   0.0% | chunky_png/color.rb~296-298:12189-12237 block in ChunkyPNG::Canvas::PNGDecoding#decode_png_str_scanline_paeth |          5248  12.6% |          5248 100.0% |             0   0.0% | chunky_png/canvas/png_decoding.rb~476:25098-25131 ChunkyPNG::Color#int8_mult                         |          3619   8.7% |          3619 100.0% |             0   0.0% | chunky_png/color.rb~344-347:13821-13900 ChunkyPNG::Canvas#width                            |          3205   7.7% |          3205 100.0% |             0   0.0% | chunky_png/canvas.rb~50:1853-1874 block in ChunkyPNG::Canvas::PNGEncoding#encode_png_str_scanline_up |          3072   7.4% |          3072 100.0% |             0   0.0% | chunky_png/canvas/png_encoding.rb~404:20111-20145 ChunkyPNG::Canvas#get_pixel                        |          2048   4.9% |          2048 100.0% |             0   0.0% | chunky_png/canvas.rb~184-186:7144-7203 ChunkyPNG::Color#opaque?                           |          1872   4.5% |          1872 100.0% |             0   0.0% | chunky_png/color.rb~304-306:12410-12468 ChunkyPNG::Color#fully_transparent?                |          1500   3.6% |          1500 100.0% |             0   0.0% | chunky_png/color.rb~327-329:13138-13207 block in ChunkyPNG::Canvas::PNGDecoding#decode_png_str_scanline_up |          1408   3.4% |          1408 100.0% |             0   0.0% | chunky_png/canvas/png_decoding.rb~453:24009-24042 block in ChunkyPNG::Canvas::PNGDecoding#decode_png_str_scanline_sub |          1280   3.1% |          1280 100.0% |             0   0.0% | chunky_png/canvas/png_decoding.rb~443:23517-23550 ChunkyPNG::Color#b                                 |          1037   2.5% |          1037 100.0% |             0   0.0% | chunky_png/color.rb~288-290:11969-12024 ChunkyPNG::Color#r                                 |          1036   2.5% |          1036 100.0% |             0   0.0% | chunky_png/color.rb~272-274:11534-11590 ChunkyPNG::Color#g                                 |          1035   2.5% |          1035 100.0% |             0   0.0% | chunky_png/color.rb~280-282:11752-11808 ChunkyPNG::Color#compose_quick                     |          1024   2.5% |          1024 100.0% |             0   0.0% | chunky_png/color.rb~358-368:14300-14740 ChunkyPNG::Canvas#set_pixel                        |          1024   2.5% |          1024 100.0% |             0   0.0% | chunky_png/canvas.rb~149-151:5706-5780 block (2 levels) in ChunkyPNG::Canvas::Operations#compose! |          1024   2.5% |          1024 100.0% |             0   0.0% | chunky_png/canvas/operations.rb~58:2331-2367 block in ChunkyPNG::Palette#opaque?                |           848   2.0% |           848 100.0% |             0   0.0% | chunky_png/palette.rb~89:3319-3361 SortedSet#add                                      |           848   2.0% |           848 100.0% |             0   0.0% | lib/mri/set.rb~741-745:1000-1169 ChunkyPNG::Color#rgba                              |           518   1.2% |           518 100.0% |             0   0.0% | chunky_png/color.rb~100-102:3905-3973 block in ChunkyPNG::Canvas::PNGDecoding#decode_png_str_scanline_average |           256   0.6% |           256 100.0% |             0   0.0% | chunky_png/canvas/png_decoding.rb~464:24513-24546 rb_str_new                                         |           199   0.5% |           199 100.0% |             0   0.0% | src/main/c/cext/ruby.c~837:23634-23684 is_managed_rstring_ptr                             |           193   0.5% |           193 100.0% |             0   0.0% | src/main/c/cext/ruby.c~832:23499-23538 is_rstring_ptr                                     |           193   0.5% |           193 100.0% |             0   0.0% | src/main/c/cext/ruby.c~828:23430-23461 strlen                                             |           190   0.5% |           190 100.0% |             0   0.0% | string.c~56:0 rb_str_new_cstr                                    |           190   0.5% |           190 100.0% |             0   0.0% | src/main/c/cext/ruby.c~858:24268-24310 RB_NIL_P                                           |           138   0.3% |           138 100.0% |             0   0.0% | src/main/c/cext/ruby.c~413:11068-11094Note how the C function strlen and the C preprocessor macro RB_NIL_P show up, being called by the zlib C extension.CPU SamplerThe CPU tracer records the cumulative time spent executing methods, blocks, or statements, and prints a histogram. Enable it with --cpusampler:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------Sampling Histogram. Recorded 3895 samples with period 1ms.  Self Time: Time spent on the top of the stack.  Total Time: Time spent somewhere on the stack.  Opt %: Percent of time spent in compiled and therefore non-interpreted code.--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Thread: Thread[main,5,main] Name                                                                                |      Total Time     |  Opt % ||       Self Time     |  Opt % | Location--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- &amp;lt;main&amp;gt;                                                                              |       3635ms  93.3% |   0.0% ||       1086ms  27.9% |   0.0% | test.rb~1-6:0-140 &amp;lt;top (required)&amp;gt;                                                                    |       1068ms  27.4% |   0.0% ||        708ms  18.2% |   0.0% | chunky_png.rb~1-179:0-5528 block in ChunkyPNG::Canvas::PNGEncoding#encode_png_str_scanline_up                  |        643ms  16.5% |   0.0% ||        643ms  16.5% |   0.0% | chunky_png/canvas/png_encoding.rb~404:20111-20145 __sulong_dispose_context                                                            |        260ms   6.7% |   0.0% ||        257ms   6.6% |   0.0% | sulong_dispose_context.c~33:0 block in ChunkyPNG::Canvas::PNGDecoding#decode_png_str_scanline_paeth               |         58ms   1.5% |   0.0% ||         58ms   1.5% |   0.0% | chunky_png/canvas/png_decoding.rb~476:25098-25131 do_checksum                                                                         |         77ms   2.0% |   0.0% ||         47ms   1.2% |   0.0% | src/main/c/zlib/zlib.c~389:12721-12796 ChunkyPNG::Palette#initialize                                                       |         52ms   1.3% |   0.0% ||         41ms   1.1% |   0.0% | chunky_png/palette.rb~21-24:954-1074 block in Gem::Specification.load                                                    |         39ms   1.0% |   0.0% ||         39ms   1.0% |   0.0% | bigdecimal-1.4.1.gemspec~5:126-154 rb_define_method                                                                    |         50ms   1.3% |   0.0% ||         36ms   0.9% |   0.0% | src/main/c/cext/ruby.c~2185:61849-61941 rb_tr_init                                                                          |         44ms   1.1% |   0.0% ||         34ms   0.9% |   0.0% | src/main/c/cext/ruby.c~93:2351-2384 &amp;lt;top (required)&amp;gt;                                                                    |         42ms   1.1% |   0.0% ||         33ms   0.8% |   0.0% | chunky_png/canvas.rb~1-372:0-13593 __sulong_byte_array_to_native                                                       |         30ms   0.8% |   0.0% ||         30ms   0.8% |   0.0% | crt0.c~59:0 rb_str_new                                                                          |         33ms   0.8% |   0.0% ||         29ms   0.7% |   0.0% | src/main/c/cext/ruby.c~837:23634-23684 __sulong_init_context                                                               |         68ms   1.7% |   0.0% ||         26ms   0.7% |   0.0% | crt0.c~80:0 Init_zlib                                                                           |        145ms   3.7% |   0.0% ||         24ms   0.6% |   0.0% | src/main/c/zlib/zlib.c~4465:112360-112374 rb_zlib_crc32                                                                       |        101ms   2.6% |   0.0% ||         24ms   0.6% |   0.0% | src/main/c/zlib/zlib.c~473:14760-14808 rb_data_typed_object_wrap                                                           |         21ms   0.5% |   0.0% ||         21ms   0.5% |   0.0% | src/main/c/cext/ruby.c~2834:79544-79639 rb_tr_load_library                                                                  |         22ms   0.6% |   0.0% ||         20ms   0.5% |   0.0% | src/main/c/cext/ruby.c~2906:81858-81897 ChunkyPNG::Canvas::PNGEncoding#encode_png_str_scanline_up                           |        662ms  17.0% |   0.0% ||         19ms   0.5% |   0.0% | chunky_png/canvas/png_encoding.rb~403-409:20027-20347 rb_define_class_id_under                                                            |         18ms   0.5% |   0.0% ||         18ms   0.5% |   0.0% | src/main/c/cext/ruby.c~2165:61106-61178 ChunkyPNG::Chunk.read                                                               |        137ms   3.5% |   0.0% ||         17ms   0.4% |   0.0% | chunky_png/chunk.rb~18-26:783-1054 Datastream                                                                          |         15ms   0.4% |   0.0% ||         15ms   0.4% |   0.0% | chunky_png/datastream.rb~11:364-381 ChunkyPNG::Color#compose_quick                                                      |         37ms   0.9% |   0.0% ||         14ms   0.4% |   0.0% | chunky_png/color.rb~358-368:14300-14740 rb_deflate_s_deflate                                                                |         27ms   0.7% |   0.0% ||         13ms   0.3% |   0.0% | src/main/c/zlib/zlib.c~1622:44042-44097 ChunkyPNG::Canvas::PNGDecoding#decode_png_str_scanline_paeth                        |         71ms   1.8% |   0.0% ||         13ms   0.3% |   0.0% | chunky_png/canvas/png_decoding.rb~475-488:25010-25650 ChunkyPNG::Palette.from_canvas                                                      |         64ms   1.6% |   0.0% ||         12ms   0.3% |   0.0% | chunky_png/palette.rb~63-68:2377-2629 __sulong_byte_arrays_to_native                                                      |         42ms   1.1% |   0.0% ||         12ms   0.3% |   0.0% | crt0.c~69:0 ChunkyPNG::Chunk::ImageData.combine_chunks                                          |        167ms   4.3% |   0.0% ||         12ms   0.3% |   0.0% | chunky_png/chunk.rb~247-253:9766-9980 rb_inflate_initialize                                                               |         19ms   0.5% |   0.0% ||         12ms   0.3% |   0.0% | src/main/c/zlib/zlib.c~1887:51522-51576 strlen                                                                              |         12ms   0.3% |   0.0% ||         12ms   0.3% |   0.0% | string.c~56:0 zstream_run                                                                         |         76ms   2.0% |   0.0% ||         12ms   0.3% |   0.0% | src/main/c/zlib/zlib.c~1024:27867-27929By default you see this histogram, but you can also see a call tree with --cpusampler.Output=calltree.-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Sampling CallTree. Recorded 3102 samples with period 1ms.  Self Time: Time spent on the top of the stack.  Total Time: Time spent somewhere on the stack.  Opt %: Percent of time spent in compiled and therefore non-interpreted code.----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Thread: Thread[main,5,main] Name                                                                                        |      Total Time     |  Opt % ||       Self Time     |  Opt % | Location-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ChunkyPNG::Canvas::PNGEncoding#save                                                        |        582ms  18.8% |   0.0% ||          5ms   0.2% |   0.0% | chunky_png/canvas/png_encoding.rb~42-44:1754-1871   block in ChunkyPNG::Canvas::PNGEncoding#save                                              |        577ms  18.6% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/canvas/png_encoding.rb~43:1797-1861    ChunkyPNG::Canvas::PNGEncoding#write                                                     |        577ms  18.6% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/canvas/png_encoding.rb~34-36:1430-1521     ChunkyPNG::Image#to_datastream                                                          |        571ms  18.4% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/image.rb~61-65:2314-2447      ChunkyPNG::Canvas::PNGEncoding#to_datastream                                           |        569ms  18.3% |   0.0% ||          1ms   0.0% |   0.0% | chunky_png/canvas/png_encoding.rb~74-89:3715-4561       ChunkyPNG::Canvas::PNGEncoding#encode_png_pixelstream                                 |        489ms  15.8% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/canvas/png_encoding.rb~153-165:7702-8570        ChunkyPNG::Canvas::PNGEncoding#encode_png_image_without_interlacing                  |        489ms  15.8% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/canvas/png_encoding.rb~172-176:8925-9195         ChunkyPNG::Canvas::PNGEncoding#encode_png_image_pass_to_stream                      |        489ms  15.8% |   0.0% ||          3ms   0.1% |   0.0% | chunky_png/canvas/png_encoding.rb~203-231:10502-11685          block in ChunkyPNG::Canvas::PNGEncoding#encode_png_image_pass_to_stream            |        481ms  15.5% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/canvas/png_encoding.rb~225:11418-11456           ChunkyPNG::Canvas::PNGEncoding#encode_png_str_scanline_up                         |        481ms  15.5% |   0.0% ||         11ms   0.4% |   0.0% | chunky_png/canvas/png_encoding.rb~403-409:20027-20347            block in ChunkyPNG::Canvas::PNGEncoding#encode_png_str_scanline_up               |        470ms  15.2% |   0.0% ||        470ms  15.2% |   0.0% | chunky_png/canvas/png_encoding.rb~404:20111-20145          block in ChunkyPNG::Canvas::PNGEncoding#encode_png_image_pass_to_stream            |          5ms   0.2% |   0.0% ||          1ms   0.0% |   0.0% | chunky_png/canvas/png_encoding.rb~219:11252-11284           ChunkyPNG::Canvas::PNGEncoding#encode_png_pixels_to_scanline_truecolor_8bit       |          4ms   0.1% |   0.0% ||          4ms   0.1% |   0.0% | chunky_png/canvas/png_encoding.rb~236-238:11896-12009       ChunkyPNG::Canvas::PNGEncoding#determine_png_encoding                                 |         60ms   1.9% |   0.0% ||          2ms   0.1% |   0.0% | chunky_png/canvas/png_encoding.rb~102-145:5085-7303        ChunkyPNG::Canvas#palette                                                            |         51ms   1.6% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/canvas.rb~268-270:10089-10154         ChunkyPNG::Palette.from_canvas                                                      |         51ms   1.6% |   0.0% ||          9ms   0.3% |   0.0% | chunky_png/palette.rb~63-68:2377-2629          ChunkyPNG::Palette#initialize                                                      |         42ms   1.4% |   0.0% ||         30ms   1.0% |   0.0% | chunky_png/palette.rb~21-24:954-1074           SortedSet#initialize                                                              |         12ms   0.4% |   0.0% ||          0ms   0.0% |   0.0% | lib/mri/set.rb~726-729:725-819            SortedSet#merge                                                                  |         12ms   0.4% |   0.0% ||          6ms   0.2% |   0.0% | lib/mri/set.rb~770-773:1759-1847             SortedSet#add                                                                   |          6ms   0.2% |   0.0% ||          6ms   0.2% |   0.0% | lib/mri/set.rb~741-745:1000-1169        ChunkyPNG::Palette#best_color_settings                                               |          7ms   0.2% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/palette.rb~195-211:7150-7613         ChunkyPNG::Palette#opaque?                                                          |          3ms   0.1% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/palette.rb~88-90:3303-3369          SortedSet#each                                                                     |          3ms   0.1% |   0.0% ||          2ms   0.1% |   0.0% | lib/mri/set.rb~775-779:1850-2004           block in ChunkyPNG::Palette#opaque?                                               |          1ms   0.0% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/palette.rb~89:3319-3361            ChunkyPNG::Color#opaque?                                                         |          1ms   0.0% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/color.rb~304-306:12410-12468             ChunkyPNG::Color#a                                                              |          1ms   0.0% |   0.0% ||          1ms   0.0% |   0.0% | chunky_png/color.rb~296-298:12189-12237         ChunkyPNG::Palette#black_and_white?                                                 |          3ms   0.1% |   0.0% ||          1ms   0.0% |   0.0% | chunky_png/palette.rb~104-106:3841-3940          SortedSet#each                                                                     |          2ms   0.1% |   0.0% ||          1ms   0.0% |   0.0% | lib/mri/set.rb~775-779:1850-2004           SortedSet#to_a                                                                    |          1ms   0.0% |   0.0% ||          1ms   0.0% |   0.0% | lib/mri/set.rb~781-784:2007-2116         ChunkyPNG::Palette#grayscale?                                                       |          1ms   0.0% |   0.0% ||          0ms   0.0% |   0.0% | chunky_png/palette.rb~96-98:3570-3642          SortedSet#each                                                                     |          1ms   0.0% |   0.0% ||          1ms   0.0% |   0.0% | lib/mri/set.rb~775-779:1850-2004       ChunkyPNG::Chunk::ImageData.split_in_chunks                                           |         19ms   0.6% |   0.0% ||          7ms   0.2% |   0.0% | chunky_png/chunk.rb~255-259:9983-10267        rb_deflate_s_deflate                                                                 |         12ms   0.4% |   0.0% ||          4ms   0.1% |   0.0% | src/main/c/zlib/zlib.c~1622:44042-44097         rb_ensure                                                                           |          5ms   0.2% |   0.0% ||          1ms   0.0% |   0.0% | src/main/c/cext/ruby.c~2107:59266-59360          deflate_run                                                                        |          4ms   0.1% |   0.0% ||          0ms   0.0% |   0.0% | src/main/c/zlib/zlib.c~1589:43218-43240           zstream_run                                                                       |          4ms   0.1% |   0.0% ||          0ms   0.0% |   0.0% | src/main/c/zlib/zlib.c~1024:27867-27929            zstream_append_input                                                             |          1ms   0.0% |   0.0% ||          0ms   0.0% |   0.0% | src/main/c/zlib/zlib.c~827:23738-23804             rb_str_buf_cat                                                                  |          1ms   0.0% |   0.0% ||          0ms   0.0% |   0.0% | src/main/c/cext/ruby.c~981:27520-27591              rb_str_cat                                                                     |          1ms   0.0% |   0.0% ||          0ms   0.0% |   0.0% | src/main/c/cext/ruby.c~882:24901-24968               rb_enc_str_new                                                                |          1ms   0.0% |   0.0% ||          0ms   0.0% |   0.0% | src/main/c/cext/ruby.c~1301:37035-37101CoverageThe coverage tool reports coverage by statement, line, and root.Root means the root of a function, i.e., how many methods and blocks were covered.Enable it with --coverage:-------------------------------------------------------------------------------------------------------------------------------------Code coverage histogram.  Shows what percent of each element was covered during execution------------------------------------------------------------------------------------------------------------------------------------- Path                                                                                            |  Statements |    Lines |    Roots------------------------------------------------------------------------------------------------------------------------------------- chunky_png-1.3.11/lib/chunky_png.rb                                                             |     100.00% |  100.00% |  100.00% chunky_png-1.3.11/lib/chunky_png/canvas.rb                                                      |      58.40% |   69.41% |   35.90% chunky_png-1.3.11/lib/chunky_png/canvas/adam7_interlacing.rb                                    |      28.57% |   50.00% |   28.57% chunky_png-1.3.11/lib/chunky_png/canvas/data_url_exporting.rb                                   |      80.00% |   83.33% |   80.00% chunky_png-1.3.11/lib/chunky_png/canvas/data_url_importing.rb                                   |      57.14% |   70.00% |   80.00% chunky_png-1.3.11/lib/chunky_png/canvas/drawing.rb                                              |       8.28% |   44.02% |   13.33% chunky_png-1.3.11/lib/chunky_png/canvas/masking.rb                                              |      28.57% |   51.72% |   44.44% chunky_png-1.3.11/lib/chunky_png/canvas/operations.rb                                           |      42.42% |   65.07% |   21.95% chunky_png-1.3.11/lib/chunky_png/canvas/png_decoding.rb                                         |      52.84% |   68.27% |   26.98% chunky_png-1.3.11/lib/chunky_png/canvas/png_encoding.rb                                         |      44.44% |   62.07% |   40.43% chunky_png-1.3.11/lib/chunky_png/canvas/resampling.rb                                           |      17.46% |   48.51% |   25.00% chunky_png-1.3.11/lib/chunky_png/canvas/stream_exporting.rb                                     |      61.54% |   72.22% |   44.44% chunky_png-1.3.11/lib/chunky_png/canvas/stream_importing.rb                                     |      31.82% |   45.83% |   40.00% chunky_png-1.3.11/lib/chunky_png/chunk.rb                                                       |      82.84% |   86.32% |   68.42% chunky_png-1.3.11/lib/chunky_png/color.rb                                                       |      41.82% |   59.00% |   33.93% chunky_png-1.3.11/lib/chunky_png/compatibility.rb                                               |      75.00% |   66.67% |   75.00% chunky_png-1.3.11/lib/chunky_png/datastream.rb                                                  |      83.56% |   87.50% |   80.00% chunky_png-1.3.11/lib/chunky_png/dimension.rb                                                   |      42.11% |   62.07% |   23.08% chunky_png-1.3.11/lib/chunky_png/image.rb                                                       |      85.00% |   90.32% |   90.00% chunky_png-1.3.11/lib/chunky_png/palette.rb                                                     |      41.18% |   63.46% |   42.31% chunky_png-1.3.11/lib/chunky_png/point.rb                                                       |      42.86% |   62.96% |   25.00% chunky_png-1.3.11/lib/chunky_png/vector.rb                                                      |      40.98% |   63.10% |   10.34% chunky_png-1.3.11/lib/chunky_png/version.rb                                                     |     100.00% |  100.00% |  100.00%-------------------------------------------------------------------------------------------------------------------------------------DebuggingChrome InspectorGraalVM lets you debug Ruby programs, and any other language supported by GraalVM, using the Chrome DevTools Protocol to attach to debuggers such as Chrome Developer Tools.Run with --inspect, open the given URL in Chrome, drag your file system into the sources list, and then set a breakpoint and resume execution.Having the debugger attached and simple breakpoints set should not reduce performance.NetBeansYou can also debug GraalVM languages using NetBeans.Run with --jvm --vm.agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y and attach to the process as if you were debugging a Java program.Then click Toggle pause in GraalVM script (the pause icon with a G superimposed) and break, and you will break into the Ruby code.You will see Ruby stack frames and local variables rather than Java stack frames and local variables.",
                    "url": " /reference-manual/ruby/Tools/"
                  },
                  
                  "reference-manual-ruby-trufflerubyadditions":  {
                    "title": "",
                    "content": "TruffleRuby Additional FunctionalityTruffleRuby is intended to be usable as a standard Ruby implementation that runs programs developed on other implementations, but it also provides additional functionality beyond that of other implementations.See the Compatibility guide for compatibility with other Ruby implementations.Detecting If You Run on TruffleRubyYou can use the --version command-line option. TruffleRuby will report for example:truffleruby ..., like ruby ..., GraalVM CE Native [x86_64-darwin]In Ruby code, you can look at the standard RUBY_ENGINE constant, which will be &#39;truffleruby&#39;.In C code TRUFFLERUBY is defined.It is also possible to use feature-detection instead of looking at RUBY_ENGINE.TruffleRuby is an integral part of GraalVM, so the version number of TruffleRuby is always the same as the version of GraalVM that contains it.If you are using TruffleRuby outside of GraalVM, such as a standard JVM, the version will be &#39;0.0&#39;.You can find the version number of GraalVM and TruffleRuby using the standard RUBY_ENGINE_VERSION constant.TruffleRuby Methods and ClassesTruffleRuby provides these non-standard methods and classes that provide additional functionality in the TruffleRuby module:      TruffleRuby.jit? reports if the GraalVM Compiler is available and will be used.        TruffleRuby.native? reports if TruffleRuby is compiled as a native executable.        TruffleRuby.cexts? reports if TruffleRuby has the GraalVM LLVM Runtime for C extensions available.        TruffleRuby.revision reports the source control revision used to build TruffleRuby as a String. Also available as RUBY_REVISION, like CRuby 2.7+.        TruffleRuby.full_memory_barrier ensures lack of reordering of loads or stores before the barrier with loads or stores after the barrier.        TruffleRuby.graalvm_home returns the GraalVM home or nil if running outside of GraalVM (e.g., TruffleRuby standalone).        TruffleRuby.synchronized(object) { } will run the block while holding an implicit lock per object instance.  Atomic References      atomic_reference = TruffleRuby::AtomicReference.new(value=nil) creates a new atomic reference with a reference to a given object.        atomic_reference.get gets the value of an atomic reference, returning the value.        atomic_reference.set(new_value) sets the value of an atomic reference and causes a memory barrier on writes involving new_value.        atomic_reference.get_and_set(new_value) sets the value of an atomic reference, returns the previous value, and causes a memory barrier on writes involving new_value.        atomic_reference.compare_and_set(expected_value, new_value) sets the value of an atomic reference, only if it currently has the expected value, returning a boolean to say whether or not it was set, and causes a memory barrier on writes involving new_value. For numeric objects it will get the current value and then check that the current value is also a numeric and that it is equal to the expected value by calling ==, then perform an atomic compare and set.        AtomicReference is marshalable.  Concurrent MapsTruffleRuby::ConcurrentMap is a key-value data structure, like a Hash and using #hash and #eql? to compare keys and identity to compare values. Unlike Hash it is unordered. All methods on TruffleRuby::ConcurrentMap are thread-safe but should have higher concurrency than a fully syncronized implementation. It is intended to be used by gems such as concurrent-ruby - please use via this gem rather than using directly.      map = TruffleRuby::ConcurrentMap.new([initial_capacity: ...], [load_factor: ...])        map[key] = new_value        map[key]        map.compute_if_absent(key) { computed_value } if the key is not found, run the block and store the result. The block is run at most once. Returns the computed value.        map.compute_if_present(key) { |current_value| computed_value } if the key is found, run the block and store the result. If the block returns nil the entry for that key is removed. The block is run at most once. Returns the final value, or nil if the block returned nil.        map.compute(key) { |current_value| computed_value } run the block, passing the current value if there is one or nil, and store the result. If the block returns nil the entry for that key is removed. Returns the computed value.        map.merge_pair(key, new_value) { |existing_value| merged_value } if key is not found or is nil, store the new value, otherwise call the block and store the result, or remove the entry if the block returns nil. Returns the final value for that entry, or nil if the block returned nil.        map.replace_pair(key, expected_value, new_value) replace the value for key but only if the existing value for it is the same as expected_value (compared by identity). Returns if the value was replaced or not.        map.replace_if_exists(key, value) replace the value for key but only if it was found. Returns value if the key exists or nil.        map.get_and_set(key, new_value) sets the value for a key and returns the previous value.        map.key?(key) returns if a key is in the map.        map.delete(key) removes a key from the map if it exists, returning the value or nil if it did not exist.        map.delete_pair(key, expected_value) removes a key but only if the existing value for it is the same as expected_value (compared by identity). Returns if the key was deleted.        map.clear removes all entries from the map.        map.size gives the number of entries in the map.        map.get_or_default(key, default_value)        map.each_pair { |key, value| ... }  FFITruffleRuby includes a Ruby-FFI backend. This should be transparent: you can just install the ffi gem as normal, and it will use TruffleRuby’s FFI backend. TruffleRuby also includes a default version of the FFI gem, so require &quot;ffi&quot; always works on TruffleRuby, even if the gem is not installed.Polyglot ProgrammingThe Polyglot and Java modules provide access to the polyglot programming functionality of GraalVM.They are described in the Polyglot Programming guide.Unsupported Additional FunctionalityYou may be able to find some other modules and methods not listed here that look interesting, such as Truffle::POSIX or Truffle::FFI.Additional modules and methods not listed in this document are designed to support the implementation of TruffleRuby and should not be used. They may be modified or made not visible to user programs in the future, and you should not use them.Extra macros, functions, and variables in TruffleRuby C extension headers beyond those provided by MRI, such as those starting with rb_tr_*, are unsupported and should not be used by any C extension.",
                    "url": " /reference-manual/ruby/TruffleRubyAdditions/"
                  },
                  
                  "reference-manual-ruby-utf8locale":  {
                    "title": "",
                    "content": "Setting Up a UTF-8 LocaleYou may need a UTF-8 locale to run some Ruby applications.For example we have found that Ruby Spec needs such a locale.RedHat-based: Fedora, Oracle Linux, etcexport LANG=en_US.UTF-8Debian-based: Ubuntu, etcsudo apt-get install -y localessudo locale-gen en_US.UTF-8export LANG=en_US.UTF-8",
                    "url": " /reference-manual/ruby/UTF8Locale/"
                  },
                  
                  "community-video-library":  {
                    "title": "",
                    "content": "Maximizing Performance with GraalVMMaking Java applications faster with GraalVMThis video shows how one can optimize for different performance aspects, such as peak performance, startup time or memory footprint with GraalVM.                              watch video                                                Everything You Need to Know about GraalVMA deep dive into GraalVM’s components and capabilities ofLearn how to run Java applications with GraalVM, create native images, run dynamic languages and make them work with existing Java code base.                      watch video                            GraalVM Native Images: The Best Startup Solution for Your ApplicationsOtimize startup time and memory requirements of Java applicationsIn this session you will learn how compile your Java applications to GraalVM native images, see several examples of compiling programs ahead-of-time and packaging them into minimal containers.                      watch video                            GraalVM in Practice at the Dutch National PoliceLearn how GraalVM was used to digitize the paperwork and apply data scienceIn this session Nathan Perdijk talks about how GraalVM was brought into practice at the Dutch National Police by integrating R code into a Spring Boot application written in Java and Scala.                      watch video                            Optimizing the Performance of Machine Learning at NetSuiteUsing GraalVM, Python and grCUDA to build a ML-driven recommendation systemLearn how you can easily integrate your favorite Python ML library into an enterprise Java application, or even take advantage of GPU acceleration for model training, while barely changing your application stack.                      watch video                            Running Spring Boot Applications as GraalVM Native ImagesDiscover how you can achieve fast startup and low memory footprint for Spring Boot appsIn this talk Sébastien Deleuze shares updates on the ongoing work performed by the Spring team to allow running Spring Boot applications as GraalVM native images for instant startup and low memory consumption.                      watch video                            ",
                    "url": " /community/video-library/"
                  },
                  
                  "videos":  {
                    "title": "",
                    "content": "",
                    "url": " /videos/"
                  },
                  
                  "tools-visualvm":  {
                    "title": "",
                    "content": "VisualVMGraalVM comes with the VisualVM tool which includes heap analysisfeatures for the supported guest languages. These languages and features arecurrently available:  Java: Heap Summary, Objects View, Threads View, OQL Console  JavaScript: Heap Summary, Objects View, Thread View  Python: Heap Summary, Objects View  Ruby: Heap Summary, Objects View, Threads View  R: Heap Summary, Objects ViewStarting VisualVMTo start VisualVM, execute jvisualvm. Immediately after startup, the tool shows all locally running Java processes in the Applications area, including the VisualVM process, itself.Capture a Heap DumpTo capture a heap dump of, for example, a Ruby application for later analysis,start your application and let it run for a few seconds to warm up. Thenright-click its process in VisualVM and invoke the Heap Dump action. Anew heap viewer for the Ruby process opens.Note: Native Image does not implement the JVMTI agent, so triggering heap dump creation from the Applications area is impossible. Apply the -H:+AllowVMInspection flag with the native-image tool for native image processes. This way your application will handle signals and capture a heap dump when it receives the SIGUSR1 signal. The guest language REPL process must be started also with the --jvm flag to monitor it using VisualVM. This functionality is available with GraalVM Enterprise Edition. It is not available in GraalVM Community Edition. See the Generating Native Heap Dumps page for details on capturing heap dumps from a native image process.Analyzing ObjectsInitially the Summary view for the Java heap is displayed. To analyze the Rubyheap, click the leftmost (Summary) dropdown in the Heap Viewer toolbar, choosethe Ruby Heap scope and select the Objects view. Now the heap viewer displaysall Ruby heap objects, aggregated by their type.Expand the Proc node in the Results view to see a list of objects of this type.Each object displays its logical value as provided by the underlyingimplementation. Expand the objects to access their variables and references,where available.Now enable the Preview, Variables, and References details by clicking the buttonsin the toolbar, and select the individual ProcType objects. Where available, thePreview view shows the corresponding source fragment, the Variables view showsvariables of the object, and the References view shows objects referring to theselected object.Last, use the Presets dropdown in the Heap Viewer toolbar to switch the viewfrom All Objects to Dominators or GC Roots. To display the heap dominators,retained sizes must be computed first, which can take a few minutes for theserver.rb example. Select the Objects aggregation in the toolbar to view theindividual dominators or GC roots.Analyzing ThreadsClick the leftmost dropdown in the Heap Viewer toolbar and select the Threadsview for the Ruby heap. The heap viewer now displays the Ruby thread stacktrace, including local objects. The stack trace can alternatively be displayedtextually by clicking the HTML toolbar button.Reading JFR SnapshotsThe VisualVM tool bundled with GraalVM 19.2.x and later has the ability to read JFR snapshots – snapshots taken with JDK Flight Recorder (previously Java Flight Recorder). JFR is a tool for collectingdiagnostic and profiling data about a running Java application. It is integratedinto the Java Virtual Machine (JVM) and causes almost no performance overhead,so it can be used even in heavily loaded production environments.To install the JFR support, released as a plugin:  Run &amp;lt;GRAALVM_HOME&amp;gt;/bin/jvisualvm to start VisualVM;  Navigate to Tools &amp;gt; Plugins &amp;gt; Available Plugins to list all available plugins, then install the VisualVM-JFR andVisualVM-JFR-Generic modules.The JFR snapshots can be opened using either the File &amp;gt; Load action, or bydouble-clicking the JFR Snapshots node and adding the snapshot into the JFRrepository, permanently. Please follow the documentation for your Java version tocreate JFR snapshots.The JFR viewer reads all JFR snapshots created from Java 7 onward, and presents the data in typicalVisualVM views familiar to the tool users.These views and functionality tabs are currently available:  Overview tab - displays the basic information about the recorded process likeits main class, arguments, JVM version and configuration, and system properties.This tab also provides access to the recorded thread dumps.  Monitor tab - shows the process uptime and basic telemetry: CPU usage, Heapand Metaspace utilization, number of loaded classes, and number of live &amp;amp; startedthreads.  Threads tab - reconstructs the threads timeline based on all events recorded inthe snapshot as precisely as possible, based on the recording configuration.  Locks tab - allows the user to analyze threads synchronization.  File IO tab - presents information on read and write events to the filesystem.  Socket IO tab - presents information on read and write events to the network.  Sampler tab - shows per-thread CPU utilization and memory allocations, and aheap histogram. There is also an experimental feature, “CPU sampler,” for building a CPUsnapshot from the recorded events. It does not provide an exact performanceanalysis but still helps to understand what was going on in the recordedapplication, and where the CPU bottleneck might be.  Browser tab - provides a generic browser of all events recorded in the snapshot.  Environment tab - gives an overview of the recording machine setup and conditionslike CPU model, memory size, operating system version, CPU utilization, memoryusage, etc.  Recording tab - lists the recording settings and basic snapshot telemetry likenumber of events, total recording time, etc.Note: the support of JDK Flight Recorder is currently experimental. Some advanced features likeanalyzing JVM internals, showing event stack traces, or support for creating JFRsnapshots from live processes are not available in this preview version and willbe addressed incrementally in the following releases.",
                    "url": " /tools/visualvm/"
                  },
                  
                  "tools-vscode":  {
                    "title": "",
                    "content": "Visual Studio Code ExtensionsHere you will learn about GraalVM intergation into Visual Studio Code (VS Code).Visual Studio Code (VS Code) is an integrated development environment that provides the embedded Git and GitHub control, syntax highlighting, code refactoring, and much more.GraalVM Extension, introduced with the GraalVM 19.2 release, has been created to provide a polyglot environment in VS Code.It provides users the environment for editing and debugging programs running on GraalVM, including JavaScript and Node.js support by default. Users can edit, run and debug either single-language applications written in any of the GraalVM-supported languages (JS, Ruby, R, and Python) or polyglot applications in the same runtime.The extension has progressed since then and now offers an installation wizzard that allows downloading and installing GraalVM and its optional features directly from the user interface.By installing the Apache NetBeans Language Server extension on top of it, users receive also editting and debugging support for Java.Micronaut Extension, introduced with the GraalVM 20.3 release, provides the basic support for developing applications based on the Micronaut Framework. Apart from the Micronaut project creation wizard, it adds also special special support for generating native images with GraalVM in VS Code.",
                    "url": " /tools/vscode/"
                  },
                  
                  "why-graalvm":  {
                    "title": "",
                    "content": "GraalVM is a high-performance runtime that provides significant improvements inapplication performance and efficiency which is ideal for microservices. It isdesigned for applications written in Java, JavaScript, LLVM-based languages suchas C and C++, and other dynamic languages. It removes the isolation betweenprogramming languages and enables interoperability in a shared runtime. It canrun either standalone or in the context of OpenJDK, Node.js or Oracle Database.For Java ProgramsFor existing Java applications, GraalVM can provide benefits by running them faster, providing extensibility via scripting languages, or creating ahead-of-time compiled native images.Run Java FasterGraalVM can run in the context of OpenJDK to make Java applications run faster with a new just-in-time compilation technology. GraalVM takes over the compilation of Java bytecode to machine code. In particular for other JVM-based languages such as Scala, this configuration can achieve benefits, as for example experienced by Twitter running GraalVM in production.The compiler of GraalVM provides performance advantages for highly abstracted programs due to its ability to remove costly object allocations in many scenarios. You can find details in this research paper. Better inlining and more aggressive speculative optimizations can lead to additional benefits for complex long-running applications, see a Stream API example.Whether and how much of a difference GraalVM makes in terms of performance depends of course on the concrete workload. We are interested in receiving any kind of benchmarking results that can help us make GraalVM even faster.Make Your Application ExtensibleGraalVM enables running JavaScript, R, Python, Ruby, LLVM IR and Web Assembly in the context of Java applications. It offers the ability to expose Java data structures to those languages with fine-grained host access filters. The integration is language-agnostic, i.e., an integration for JavaScript can at the later point be also used to execute any other GraalVM-based language. Proxy mechanisms allow mocking up dynamic objects from Java data structures and expose them to the embedded scripts. Take a look at the description on how to make your JVM-based application extensible with GraalVM.Create a Native ImageRunning your application inside a Java VM comes with startup and footprint costs. GraalVM has a feature to create native images for existing JVM-based applications. The image generation process employs static analysis to find any code reachable from the main Java method and then performs full ahead-of-time (AOT) compilation. The resulting native binary contains the whole program in machine code form for its immediate execution. It can be linked with other native programs and can optionally include the GraalVM compiler for complementary just-in-time (JIT) compilation support to run any GraalVM-based language with high performance. For additional performance, native images can be built with profile guided optimizations gathered in a previous run of the application. See an example of how to build native images here.For Node.js ProgramsGraalVM can run in the context of Node.js by replacing V8 with GraalVM for executing JavaScript. The main benefits of doing so is to enable polyglot applications (e.g., use Java, R, or Python libraries), run Node.js with large heap configurations and Java’s garbage collectors, or use GraalVM’s interoperability to define data structures in C/C++ and use them from JavaScript.Reuse Libraries from Java, R, or PythonGraalVM enables the use of existing Java libraries or Java frameworks (like Spark or Flink) directly from Node.js. Also, one can use for example R or Python for data science or plotting directly from a JavaScript application. Find an example of a polyglot application here.Run with Large HeapsThe V8 JavaScript engine included in the standard Node.js distribution is tuned for browser configurations and designed to work effectively in small heap scenarios. We enable running Node.js with the heap management of the JVM, opening the ability for large heap configurations and suitable garbage collection settings. The maximum configurable heap size is 32 Gb with compressed 32-bit pointers, and terabytes of heap are supported in the 64-bit pointer configuration.Define Data Structures in C/C++GraalVM allows efficient combination of native code (e.g., written in C/C++) and JavaScript. Native data structures can be directly accessed and the compiler can inline across any boundary. This can be beneficial in a scenario where efficient data structures are managed and allocated in C while other parts of the application are written in Node.js. Find an example of such scenario in the reference manual.For Ruby, R, Python or WebAssemblyRuby, R, Python, WebAssembly are experimental in the GraalVM ecosystem and not recommended for production use at this time, but we are actively working on stability and support for all modules for those languages. At this point in time, we can run simpler applications of Ruby, R, and Python but we do not have the same full compatibility we provide for Java and Node.js applications.WebAssembly currently implements the WebAssembly MVP (Minimum Viable Product) specification and is the youngest language in the GraalVM environment.Apart from the standard GraalVM benefits such as language interoperability (e.g., use Java or JavaScript from those applications), GraalVM can achieve high speedups of 10x or more for those languages. We are happy to assist with making existing Ruby and R applications work with GraalVM, but we cannot guarantee out-of-the-box compatibility for these languages yet.Running in Oracle DatabaseGraalVM is designed for embeddability and can be executed in databases. Ourprototype of the Oracle Database Multilingual Engine (MLE) is availablehere. It allows Oracle Database usersto run JavaScript, using browserify to execute Node.js modules, and to writeextensions in Python.For Microservices FrameworksGraalVM Native Image, currently available as an Early Adopter technology, works with many different Java microservices frameworks.Several projects have already accepted this technology as a platform for theirapplications: Quarkus, Micronaut, Helidon. Also, the Spring Native project provides beta support for compiling Spring applications to native executables using GraalVM Native Image. For these frameworks GraalVM nativeimages significantly reduce the runtime memory requirements compared to runningon HotSpot. We believe that GraalVM Native Image technology can become the bestway for deploying cloud native applications.            ![microservices]({{ “/resources/img/ms_memory_footprint.png”      relative_url }})                  ![microservices]({{ “/resources/img/ms_startup_time.png”      relative_url }})      For Your PlatformWe encourage the development of GraalVM embeddings similar to our ownintegrations in the Oracle Database, OpenJDK, or Node.js. Together with researchcollaboration partners, we already explored ideas of embedding in Spark orFlink. Find a description on how to embed GraalVM in your existing JVM-basedapplication or native application here.For Your Languages and ToolsGraalVM is an open ecosystem and we invite third party systems to participatevia connecting their own programming languages, tools, or platforms.Implement Your Own LanguageThe Truffle language implementation framework (Truffle), allows running programming languages efficiently on GraalVM. It simplifies language implementation by automatically deriving high-performance code from interpreters. You can find details about the approach in this research paper.Implementing your own language using GraalVM will not only give you high performance. More importantly, it allows your language to connect with the rich tooling provided by the GraalVM ecosystem. Also, it enables your language to run in the context of any GraalVM embedding.We developed a demonstration language called “SimpleLanguage” to show the Truffle features. Find out how to get started implementing a language.Create Language-agnostic ToolsGraalVM provides a framework for creating language-agnostic tools like debuggers, profilers, or other instrumentations. GraalVM provides a standardized way to express and run program code enabling cross-language research and the development of tools that are developed once and then can be applied to any language.",
                    "url": " /why-graalvm/"
                  },
                  
                  "docs-getting-started-windows":  {
                    "title": "",
                    "content": "Installation on Windows PlatformsYou can install GraalVM Community Edition on the Windows operating system from an archive file (zip).Follow these steps:  Navigate to the GraalVM Releases repository on GitHub. Depending on the workload, select Java 11 based or Java 8 based distribution for Windows, and download.  Change the directory to the location where you want to install GraalVM, then move the .zip archive file to it.  Unzip the archive to your file system.  There can be multiple JDKs installed on the machine. The next step is to configure the runtime environment. Setting environment variables via the command line will work the same way for Windows 7, 8 and 10.          Point the PATH environment variable to the GraalVM bin directory:          setx /M PATH &quot;C:Progra~1Java&amp;lt;graalvm&amp;gt;bin;%PATH%&quot;            Set the JAVA_HOME environment variable to resolve to the GraalVM installation directory:          setx /M JAVA_HOME &quot;C:Progra~1Java&amp;lt;graalvm&amp;gt;&quot;        Note that the /M flag, equivalent to -m, requires elevated user privileges.              Restart Command Prompt to reload the environment variables. Then use thefollowing command to check whether the variables were set correctly:    echo %PATH%echo %JAVA_HOME%  For Oracle GraalVM Enterprise Edition users, find the installation instructions here.Installation NoteTo run GraalVM Community Edition based on OpenJDK 8u292 on a Windows platform, the MSVCR100.dll redistributable package needs to be installed (for more details, see the issue #3187).Supported FunctionalitiesThe GraalVM Community distribution for Windows platforms includes OpenJDK with the GraalVM compiler enabled, the GraalVM Updater tool to install additional functionalities, the JavaScript runtime, and the developer tools (e.g., Chrome inspector based debugger, Profiler, etc.).Currently, the GraalVM environment on Windows can be extended with Native Image, Java on Trufle, WebAssembly, and Node.js support.Prerequisites for Using Native Image on WindowsTo make use of Native Image on Windows, observe the following recommendations.The required Microsoft Visual C++ (MSVC) version depends on the JDK version that GraalVM is based on.For GraalVM based on JDK 8, you will need MSVC 2010 SP1 version. The recommended installation method is using Microsoft Windows SDK 7.1:  Download the SDK file GRMSDKX_EN_DVD.iso for from Microsoft.  Mount the image by opening F:SetupSDKSetup.exe directly.For GraalVM distribution based on JDK 11, you will need MSVC 2017 15.5.5 or later version.The last prerequisite, common for both distributions, is the proper Developer Command Prompt for your version of Visual Studio. On Windows the native-image tool only works when it is executed from the x64 Native Tools Command Prompt.",
                    "url": " /docs/getting-started/windows/"
                  },
                  
                  "community-workshop":  {
                    "title": "",
                    "content": "",
                    "url": " /community/workshop/"
                  },
                  
                  "assets-main-css":  {
                    "title": "",
                    "content": "@import “minima”;",
                    "url": " /assets/main.css"
                  },
                  
                  "docs-release-notes-19-0":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/19_0/"
                  },
                  
                  "docs-release-notes-19-1":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/19_1/"
                  },
                  
                  "docs-release-notes-19-2":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/19_2/"
                  },
                  
                  "docs-release-notes-19-3":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/19_3/"
                  },
                  
                  "docs-release-notes-20-0":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/20_0/"
                  },
                  
                  "docs-release-notes-20-1":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/20_1/"
                  },
                  
                  "docs-release-notes-20-2":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/20_2/"
                  },
                  
                  "docs-release-notes-20-3":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/20_3/"
                  },
                  
                  "docs-release-notes-21-0":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/21_0/"
                  },
                  
                  "docs-faq":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/faq/"
                  },
                  
                  "docs-graalvm-as-a-platform":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/graalvm-as-a-platform/"
                  },
                  
                  "docs-release-notes":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/"
                  },
                  
                  "docs-release-notes-version-roadmap":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/version-roadmap/"
                  },
                  
                  "docs-graalvm-as-a-platform-implement-instrument":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/graalvm-as-a-platform/implement-instrument/"
                  },
                  
                  "docs-graalvm-as-a-platform-implement-language":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/graalvm-as-a-platform/implement-language/"
                  },
                  
                  "docs-release-notes-known-issues":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/known-issues/"
                  },
                  
                  "docs-reference-manual":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/reference-manual/"
                  },
                  
                  "docs-release-notes-release-candidates":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/release-notes/release-candidates/"
                  },
                  
                  "docs-support":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/support/"
                  },
                  
                  "docs-why-graal":  {
                    "title": "",
                    "content": "",
                    "url": " /docs/why-graal/"
                  },
                  
                  "redirects-json":  {
                    "title": "",
                    "content": "{“/docs/release-notes/19_0/”:”https://www.graalvm.org/release-notes/19_0/”,”/docs/release-notes/19_1/”:”https://www.graalvm.org/release-notes/19_1/”,”/docs/release-notes/19_2/”:”https://www.graalvm.org/release-notes/19_2/”,”/docs/release-notes/19_3/”:”https://www.graalvm.org/release-notes/19_3/”,”/docs/release-notes/20_0/”:”https://www.graalvm.org/release-notes/20_0/”,”/docs/release-notes/20_1/”:”https://www.graalvm.org/release-notes/20_1/”,”/docs/release-notes/20_2/”:”https://www.graalvm.org/release-notes/20_2/”,”/docs/release-notes/20_3/”:”https://www.graalvm.org/release-notes/20_3/”,”/docs/release-notes/21_0/”:”https://www.graalvm.org/release-notes/21_0/”,”/docs/faq/”:”https://www.graalvm.org/faq/”,”/docs/graalvm-as-a-platform/”:”https://www.graalvm.org/graalvm-as-a-platform/”,”/docs/release-notes/”:”https://www.graalvm.org/release-notes/”,”/docs/release-notes/version-roadmap/”:”https://www.graalvm.org/release-notes/version-roadmap/”,”/docs/graalvm-as-a-platform/implement-instrument/”:”https://www.graalvm.org/graalvm-as-a-platform/implement-instrument/”,”/docs/graalvm-as-a-platform/implement-language/”:”https://www.graalvm.org/graalvm-as-a-platform/implement-language/”,”/docs/release-notes/known-issues/”:”https://www.graalvm.org/release-notes/known-issues/”,”/docs/reference-manual/”:”https://www.graalvm.org/reference-manual/”,”/docs/release-notes/release-candidates/”:”https://www.graalvm.org/release-notes/release-candidates/”,”/slack-invitation/”:”https://join.slack.com/t/graalvm/shared_invite/enQtODM1NTQzNDIyMjk0LTNlYjBhNTdiNDQxNTdkNDE0ZmFlNzMwNDcyOWZjOTEzN2UyMTM5MTk5YjY1ZDgwMWU2NGQwNjVhZWVhOWRiOGQ”,”/docs/support/”:”https://www.graalvm.org/support/”,”/docs/why-graal/”:”https://www.graalvm.org/why-graalvm/”}",
                    "url": " /redirects.json"
                  },
                  
                  "sitemap-xml":  {
                    "title": "",
                    "content": "{% if page.xsl %}{% endif %}{% assign collections = site.collections | where_exp:&#39;collection&#39;,&#39;collection.output != false&#39; %}{% for collection in collections %}{% assign docs = collection.docs | where_exp:&#39;doc&#39;,&#39;doc.sitemap != false&#39; %}{% for doc in docs %}{{ doc.url | replace:&#39;/index.html&#39;,&#39;/&#39; | absolute_url | xml_escape }}{% if doc.last_modified_at or doc.date %}{{ doc.last_modified_at | default: doc.date | date_to_xmlschema }}{% endif %}&amp;lt;/url&amp;gt;{% endfor %}{% endfor %}{% assign pages = site.html_pages | where_exp:’doc’,’doc.sitemap != false’ | where_exp:’doc’,’doc.url != “/404.html”’ %}{% for page in pages %}{{ page.url | replace:&#39;/index.html&#39;,&#39;/&#39; | absolute_url | xml_escape }}{% if page.last_modified_at %}{{ page.last_modified_at | date_to_xmlschema }}{% endif %}&amp;lt;/url&amp;gt;{% endfor %}{% assign static_files = page.static_files | where_exp:’page’,’page.sitemap != false’ | where_exp:’page’,’page.name != “404.html”’ %}{% for file in static_files %}{{ file.path | replace:&#39;/index.html&#39;,&#39;/&#39; | absolute_url | xml_escape }}{{ file.modified_time | date_to_xmlschema }}&amp;lt;/url&amp;gt;{% endfor %}&amp;lt;/urlset&amp;gt;",
                    "url": " /sitemap.xml"
                  },
                  
              };
              </script>

              <div role="button" class="menu-btn menu-btn--sidebar js-show-sidebar" title="sweet hamburger">
                <div class="hamburger"><div class="inner"></div></div>
              </div>
            </div>
          </div>
        </div>
    </div>
  </div>
</article>

<!-- JavaScript libraries -->
<script src="/resources/js/lunr.min.js"></script>
<script src="/resources/lib/jquery/jquery-3.4.1.min.js"></script>

</div>

      </main>

      <footer class="footer">
  <div class="container-fluid container-fluid--custom-sm">
    <div class="row">
      <div class="col-12 col-sm-12 col-md-12 col-lg-12">
        <div class="row">
          <div class="col-md-3 col-sm-12">
            <a href="/" class="logo-footer">
              <img src="/resources/img/logo.svg" alt="graalvm_logo">
            </a>
          </div>

          <div class="col-md-3 col-sm-6 col-6">
            <h6 class="title-footer">GraalVM</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="/docs/getting-started/">Quick Start</a></li>
              <li class="footer-list__item"><a href="/docs/graalvm-reference/">Reference Manual</a></li>
              <li class="footer-list__item"><a href="https://www.graalvm.org/sdk/javadoc/">GraalVM SDK Javadoc</a></li>
              <li class="footer-list__item"><a href="/release-notes/">Release Notes</a></li>
            </ul>
          </div>

          <div class="col-md-2 col-sm-6 col-6">
            <h6 class="title-footer">Open Source</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="/community/">Community</a></li>
              <li class="footer-list__item"><a href="/community/contributors/">Contributors</a></li>
              <li class="footer-list__item"><a href="/community/advisory-board/">Advisory Board</a></li>
              <li class="footer-list__item"><a href="/slack-invitation">Slack</a></li>
            </ul>
          </div>

          <div class="col-md-2 col-sm-6 col-6">
            <h6 class="title-footer">Stay Tuned</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="https://medium.com/graalvm">Medium</a></li>
              <li class="footer-list__item"><a href="https://github.com/oracle/graal">GitHub</a></li>
              <li class="footer-list__item"><a href="https://twitter.com/graalvm">Twitter</a></li>
              <li class="footer-list__item"><a href="https://www.linkedin.com/company/graalvm">Linkedin</a></li>
            </ul>
          </div>

          <div class="col-md-2 col-sm-6 col-6">
            <h6 class="title-footer">Useful Links</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="https://docs.oracle.com/en/graalvm/">Oracle Help Center</a></li>
              <li class="footer-list__item"><a href="https://www.oracle.com/java/graalvm/">Oracle GraalVM</a></li>
              <li class="footer-list__item"><a href="https://labs.oracle.com/">Oracle Labs</a></li>
              <li class="footer-list__item"><a href="/support/">Support</a></li>
            </ul>
          </div>
        </div>

        <div class="row">
          <div class="col-sm-12">
            <p class="copyright">
              Copyright © 2018, 2021, Oracle and/or its affiliates. All rights reserved. Oracle and Java are registered trademarks. Other names may be trademarks of their respective owners.
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

    </div>
    <div class="overlay"></div>

    <script src='/resources/lib/twitter-fetcher.js'></script>
    <script src='/resources/lib/slick-slider/slick.min.js'></script>
    <script src='/resources/js/main.js'></script>
  </body>
</html>
