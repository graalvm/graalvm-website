<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:image" content='/jdk23/resources/img/graalvm.png' />
  <meta name="twitter:widgets:border-color" content="#55acee">

  <title>
    
      GraalVM
    
  </title>
  <meta name="description" content="GraalVM is an advanced JDK with ahead-of-time Native Image compilation."/>

  <link rel="icon" id="favicon" href='/jdk23/resources/img/favicon/favicon-light/favicon-light.ico'>

  <link rel="manifest" href='/jdk23/resources/img/favicon/site.webmanifest'>
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <script src='/jdk23/resources/lib/jquery/jquery-3.6.1.min.js'></script>
  <link rel="stylesheet" href='/jdk23/assets/main.css'>
  <script src='/jdk23/resources/lib/bootstrap/js/bootstrap.min.js'></script>
  <script src='/jdk23/resources/lib/highlight/highlight.pack.js'></script>
  <script src='/jdk23/resources/lib/purl/purl.js'></script>
  <script src='/jdk23/resources/lib/fiddle/fiddle.js' defer></script>
  <link rel="stylesheet" href='/jdk23/resources/styles/fiddle.css'>
  <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>

  <body class="preload">

    <div>
      <header  class="header header--content"  role="banner">

  

  <div class="container-fluid container-fluid--custom-sm">
    <div class="row">
      <div class="col-12 col-sm-12 col-md-12 col-lg-10">
        <div class="d-flex">
          <a href="https://www.graalvm.org/">
            <img src='/jdk23/resources/img/logo_header.svg' alt="GraalVM logo">
          </a>  
        </div>
      </div>
    </div>
  </div>
  <div>
    <div class="row">
      <div class="docsnote">
        <div class="docsnote__body">
          <div class="docsnote__column">
            <div class="docsnote__card">
              <div class="container">
                <div class="rightside">
                  <img src='/jdk23/resources/img/note-icon-docs-light.svg'>
                  <p class="docsnote__subtitle">
                    This documentation is for an old GraalVM version. See the 
                    <a href="#" onclick="selected('latest', 'latest'); return false;">latest version</a>.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</header>
      <main class="content content--home wrapper" aria-label="Content">
        <div class="container-fluid container-fluid--custom-sm">
  <div class="row">
    <div class="col-12 col-sm-12 col-md-12 col-lg-10 offset-lg-1">
      <br>
      <a href="/jdk23/" class="link-back"><i>&#9664;</i>Table of Contents</a>
      <h1 id="reachability-metadata">Reachability Metadata</h1>

<p>The dynamic language features of the JVM (for example, reflection and resource handling) compute the <em>dynamically-accessed program elements</em> such as fields, methods, or resource URLs at run time. 
On HotSpot this is possible because all class files and resources are available at run time and can be loaded by the runtime. 
Availability of all classes and resources, and their loading at run time, comes with an extra overhead in memory and startup time.</p>

<p>To make native binaries small, the <code>native-image</code> builder performs <a href="/jdk23/reference-manual/native-image/basics/#static-analysis-reachability-and-closed-world-assumption">static analysis</a> at build time to determine only the necessary program elements that are needed for the correctness of the application. 
Small binaries allow fast application startup and low memory footprint, however they come at a cost: determining dynamically-accessed application elements via static analysis is infeasible as reachability of those elements depends on data that is available <em>only</em> at run time.</p>

<p>To ensure inclusion of necessary dynamically-accessed elements into the native binary, the <code>native-image</code> builder requires <strong>reachability metadata</strong> (hereinafter referred to as <em>metadata</em>). 
Providing the builder with correct and exhaustive reachability metadata guarantees application correctness and ensures compatibility with third-party libraries at runtime.</p>

<p>Metadata can be provided to the <code>native-image</code> builder in the following ways:</p>
<ul>
  <li>By <a href="#computing-metadata-in-code">computing metadata in code</a> <a href="/jdk23/reference-manual/native-image/basics/#image-build-time-vs-image-run-time">when the native binary is built</a> and storing required elements into the <a href="/jdk23/reference-manual/native-image/basics/#native-image-heap">initial heap of the native binary</a>.</li>
  <li>By <a href="#specifying-metadata-with-json">providing the <em>reachability-metadata.json</em> file(s)</a> stored in the <em>META-INF/native-image/&lt;groupId&gt;/&lt;artifactId&gt;/</em> directory on the classpath. For more information about how to collect metadata for your application automatically, see <a href="/jdk23/reference-manual/native-image/metadata/AutomaticMetadataCollection/">Collecting Metadata Automatically</a>.</li>
  <li>For more advanced use cases, where classpath scanning or build-time initialization is needed, by using the <a href="https://www.graalvm.org/sdk/javadoc/org/graalvm/nativeimage/hosted/Feature.html">Native Image Feature API</a>.</li>
</ul>

<blockquote>
  <p>Note: Native Image is migrating to the more user-friendly implementation of reachability metadata that shows problems early on and allows easy debugging.</p>

  <p>To enable the new user-friendly reachability-metadata mode for your application, pass the option <code>--exact-reachability-metadata</code> at build time. To enable the user-friendly mode only for concrete packages, pass <code>--exact-reachability-metadata=&lt;comma-separated-list-of-packages&gt;</code>.</p>

  <p>To get an overview of all places in your code where missing registrations occur, without committing to the exact behavior, you can pass <code>-XX:MissingRegistrationReportingMode=Warn</code> when starting the application.</p>

  <p>To detect places where the application accidentally ignores a missing registration error (with <code>catch (Throwable t)</code> blocks), pass <code>-XX:MissingRegistrationReportingMode=Exit</code> when starting the application. The application will then unconditionally print the error message with the stack trace and exit immediately. This behavior is ideal for running application tests to guarantee all metadata is included.</p>

  <p>The user-friendly implementation for reflection will become the default in future releases of GraalVM so the timely adoption is important to avoid project breakage.</p>
</blockquote>

<h3 id="table-of-contents">Table of Contents</h3>

<ul>
  <li><a href="#computing-metadata-in-code">Computing Metadata in Code</a></li>
  <li><a href="#specifying-metadata-with-json">Specifying Metadata with JSON</a></li>
  <li><a href="#metadata-types">Metadata Types</a></li>
  <li><a href="#reflection">Reflection (Including Dynamic Proxies)</a></li>
  <li><a href="#java-native-interface">Java Native Interface</a></li>
  <li><a href="#resources">Resources</a></li>
  <li><a href="#resource-bundles">Resource Bundles</a></li>
  <li><a href="#serialization">Serialization</a></li>
  <li><a href="#sample-reachability-metadata">Sample Reachability Metadata</a></li>
  <li><a href="#defining-classes-at-run-time">Defining Classes at Run Time</a></li>
</ul>

<h2 id="computing-metadata-in-code">Computing Metadata in Code</h2>

<p>Computing metadata in code can be achieved in two ways:</p>

<ol>
  <li>
    <p>By providing <em>constant</em> arguments to functions that dynamically access elements of the JVM. See, for example, <code>Class#forName</code> in the following code:</p>

    <pre><code class="language-java"> class ReflectiveAccess {
     public Class&lt;Foo&gt; fetchFoo() throws ClassNotFoundException {
         return Class.forName("Foo");
     }
 }
</code></pre>
    <p>Here, <code>Class.forName("Foo")</code> is evaluated into a constant at build time. When the native binary is built, this value is stored in its <a href="/jdk23/reference-manual/native-image/basics/#native-image-heap">initial heap</a>.
 If the class <code>Foo</code> does not exist, the call to <code>Class#forName</code> will be transformed into <code>throw ClassNotFoundException("Foo")</code>.</p>

    <p>The <em>constant</em> is defined as:</p>
    <ul>
      <li>A literal (for example, <code>"Foo"</code> or <code>1</code>).</li>
      <li>Access to a static field that is <a href="/jdk23/reference-manual/native-image/optimizations-and-performance/ClassInitialization/">initialized at build time</a>.</li>
      <li>Access to an effectively final variable.</li>
      <li>Defining an array that whose lenght is constant, and all values are constant.</li>
      <li>Simple computations on other constants (for example, <code>"F"</code> + <code>"oo"</code>, or an indexing into an array).</li>
    </ul>

    <p>When passing constant arrays, the following approaches to declare and populate an array are equivalent from the point of view of the <code>native-image</code> builder:</p>

    <pre><code class="language-java">  Class&lt;?&gt;[] params0 = new Class&lt;?&gt;[]{String.class, int.class};
  Integer.class.getMethod("parseInt", params0);
</code></pre>

    <pre><code class="language-java">  Class&lt;?&gt;[] params1 = new Class&lt;?&gt;[2];
  params1[0] = Class.forName("java.lang.String");
  params1[1] = int.class;
  Integer.class.getMethod("parseInt", params1);
</code></pre>

    <pre><code class="language-java">  Class&lt;?&gt;[] params2 = {String.class, int.class};
  Integer.class.getMethod("parseInt", params2);
</code></pre>

    <p>Note that Native Image currently aggressively computes constants, and therefore it is not possible to specify exactly what is a constant at build time.</p>
  </li>
  <li>
    <p>By <a href="/jdk23/reference-manual/native-image/optimizations-and-performance/ClassInitialization/">initializing classes at build time</a> and storing dynamically accessed elements into the initial heap of the native executable. 
This way of providing metadata is suited for cases when specifying metadata with constants or in JSON is not possible. 
This is necessary in cases when:</p>
    <ul>
      <li>The user code needs to generate new class bytecode.</li>
      <li>The user code needs to traverse the classpath to compute the dynamically accessed program elements necessary for the application.</li>
    </ul>

    <p>In the following example:</p>

    <pre><code class="language-java"> class InitializedAtBuildTime {
     private static Class&lt;?&gt; aClass;
     static {
         try {
             aClass = Class.forName(readFile("class.txt"));
         } catch (ClassNotFoundException e) {
             throw RuntimeException(e);
         }
     }

     public Class&lt;?&gt; fetchFoo() {
         return aClass;
     }
 }
</code></pre>
  </li>
</ol>

<p>The dynamically accessed elements will be included into the native executable’s heap only if that part of the heap is reachable through an enclosing method (for example, <code>InitializedAtBuildTime#fetchFoo</code>) or a static field (for example, <code>InitializedAtBuildTime.aClass</code>).</p>

<h2 id="specifying-metadata-with-json">Specifying Metadata with JSON</h2>

<p>All metadata specified in the <em>reachability-metadata.json</em> file that is located in any of the classpath entries at <em>META-INF/native-image/&lt;groupId&gt;/&lt;artifactId&gt;/</em>.
The JSON schema for the reachability metadata is defined in <a href="/jdk23/docs/reference-manual/native-image/assets/reachability-metadata-schema-v1.0.0.json">reachability-metadata-schema-v1.0.0.json</a>.</p>

<p>A sample <em>reachability-metadata.json</em> file can be found <a href="#sample-reachability-metadata">in the sample section</a>.
The <em>reachability-metadata.json</em> configuration contains a single object with one field for each type of metadata. Each field in the top-level object contains an array of <em>metadata entries</em>:</p>
<pre><code class="language-json">{
  "reflection":[],
  "resources":[],
  "bundles":[],
  "serialization":[],
  "jni":[]
}
</code></pre>

<p>For example, Java reflection metadata is specified under <code>reflection</code>, and an example entry looks like:</p>
<pre><code class="language-json">{
  "reflection": [
    {
      "type": "Foo"
    }
  ]
}
</code></pre>

<h3 id="conditional-metadata-entries">Conditional Metadata Entries</h3>

<p>Each entry in JSON-based metadata should be <em>conditional</em> to avoid unnecessary growth of the native binary size.
A conditional entry is specified by adding a <code>condition</code> field to the entry in the following way:</p>
<pre><code class="language-json">{
  "condition": {
    "typeReached": "&lt;fully-qualified-class-name&gt;"
  },
  &lt;metadata-entry&gt;
}
</code></pre>

<p>A metadata entry with a <code>typeReached</code> condition is considered available at run time, only when the specified fully-qualified type is <em>reached</em> at run time. 
Before that, all dynamic accesses to the element represented with the <code>metadata-entry</code> will behave as if the <code>metadata-entry</code> does not exist.
This means that those dynamic accesses will throw a missing-registration error.</p>

<p>A type is reached at run time, right before the <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5">class-initialization routine</a> starts for that type (class or interface), or any of the type’s subtypes are reached.
For <code>"typeReached": "ConditionType"</code> that guards a metadata entry in the following example, the type is considered reached:</p>
<pre><code class="language-java">class SuperType {
    static {
        // ConditionType reached (subtype reached) =&gt; metadata entry available
    }
}
class ConditionType extends SuperType {
    static {
        // ConditionType reached (before static initializer) =&gt; metadata entry available
    }
    static ConditionType singleton() {
        // ConditionType reached (already initialized) =&gt; metadata entry available
    }
}
public class App {
    public static void main(String[] args) {
        // ConditionType not reached =&gt; metadata entry not available
        ConditionType.class;
        // ConditionType not reached (ConditionType.class doesn't start class initialization) =&gt; metadata entry not available  
        ConditionType.singleton();
        // ConditionType reached (already initialized) =&gt; metadata entry available
    }
}
</code></pre>

<p>A type is also reached, if it is marked as <code>initialize-at-build-time</code> or any of its subtypes are marked as <code>initialize-at-build-time</code> and they exist on the classpath.</p>

<p>Array types are never marked as reached and as such cannot be used in conditions.</p>

<p>A conditional metadata entry is included into the image when the fully-qualified type is reachable at build time. 
This entry affects the image size, and it will be available at run time only when the condition is reached at run time.</p>

<p>You can find more examples of the metadata files in the <a href="https://github.com/oracle/graalvm-reachability-metadata">GraalVM Reachability Metadata repository</a>.</p>

<h2 id="metadata-types">Metadata Types</h2>

<p>Native Image accepts the following types of reachability metadata:</p>
<ul>
  <li><a href="#reflection">Java reflection</a> (the <code>java.lang.reflect.*</code> API) enables Java code to examine its own classes, methods, fields, and their properties at run time.</li>
  <li><a href="#java-native-interface">JNI</a> allows native code to access classes, methods, fields and their properties at run time.</li>
  <li><a href="#resources">Resources</a> allow arbitrary files present on the classpath to be dynamically accessed in the application.</li>
  <li><a href="#resource-bundles">Resource Bundles</a> Java localization support (<code>java.util.ResourceBundle</code>) that enables Java code to load L10N resources.</li>
  <li><a href="#serialization">Serialization</a> enables writing (and reading) Java objects to (and from) streams.</li>
  <li>(Experimental) <a href="#predefined-classes">Predefined Classes</a> provide support for dynamically generated classes.</li>
</ul>

<h2 id="reflection">Reflection</h2>

<p>For all methods in this section Native Image will compute reachability at build time given that all the call arguments are constant. 
Providing constant arguments in code is a preferred way to provide metadata as it requires no duplication of information in external JSON files.</p>

<p>Reflection in Java starts with <code>java.lang.Class</code> that allows fetching further reflective elements such as methods and fields. 
The class can be fetched reflectively via the following static functions on <code>java.lang.Class</code>:</p>
<ul>
  <li><code>java.lang.Class forName(java.lang.String) throws java.lang.ClassNotFoundException</code></li>
  <li><code>java.lang.Class forName(java.lang.String, boolean, java.lang.ClassLoader) throws java.lang.ClassNotFoundException</code></li>
  <li><code>java.lang.Class forName(java.lang.Module, java.lang.String)</code></li>
  <li><code>java.lang.Class arrayType()</code> - requires metadata for the array type.
The classes can be also fetched reflectively loading a class from a name with <code>java.lang.ClassLoader#loadClass(String)</code>.</li>
</ul>

<p>To provide metadata for the calls that fetch a <code>Class</code> reflectively, the following entry must be added to the <code>reflection</code> array in <em>reachability-metadata.json</em>:</p>
<pre><code class="language-json">{
  "type": "FullyQualifiedReflectivelyAccessedType"
}
</code></pre>

<p>For proxy classes, the <code>java.lang.Class</code> is fetched with the following methods on <code>java.lang.reflect.Proxy</code>:</p>
<ul>
  <li><code>java.lang.Class getProxyClass(java.lang.ClassLoader, java.lang.Class[]) throws java.lang.IllegalArgumentException</code></li>
  <li><code>java.lang.Object newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)</code></li>
</ul>

<p>Metadata, for proxy classes, is in the form an ordered collection of interfaces that defines a proxy:</p>
<pre><code class="language-json">{
  "type": {
    "proxy": ["FullyQualifiedInterface1", "...", "FullyQualifiedInterfaceN"]
  }
}
</code></pre>

<p>Invocation of methods above without the provided metadata will result in throwing <code>MissingReflectionRegistrationError</code> which extends <code>java.lang.Error</code> and
should not be handled. Note that even if a type does not exist on the classpath, the methods above will throw a <code>MissingReflectionRegistrationError</code>.</p>

<p>The following methods on <code>java.lang.Class</code> will throw a <code>MissingRegistrationError</code> if the metadata is not provided for a given type:</p>
<ul>
  <li><code>Constructor getConstructor(Class[]) throws NoSuchMethodException,SecurityException</code></li>
  <li><code>Constructor getDeclaredConstructor(Class[]) throws NoSuchMethodException,SecurityException</code></li>
  <li><code>Constructor[] getConstructors() throws SecurityException</code></li>
  <li><code>Constructor[] getDeclaredConstructors() throws SecurityException</code></li>
  <li><code>Method getMethod(String,Class[]) throws NoSuchMethodException,SecurityException</code></li>
  <li><code>Method getDeclaredMethod(String,Class[]) throws NoSuchMethodException,SecurityException</code></li>
  <li><code>Method[] getMethods() throws SecurityException</code></li>
  <li><code>Method[] getDeclaredMethods() throws SecurityException</code></li>
  <li><code>Field getField(String) throws NoSuchFieldException,SecurityException</code></li>
  <li><code>Field getDeclaredField(String) throws NoSuchFieldException,SecurityException</code></li>
  <li><code>Field[] getFields() throws SecurityException</code></li>
  <li><code>Field[] getDeclaredFields() throws SecurityException</code></li>
  <li><code>RecordComponent[] getRecordComponents()</code></li>
  <li><code>Class[] getPermittedSubclasses()</code></li>
  <li><code>Object[] getSigners()</code></li>
  <li><code>Class[] getNestMembers()</code></li>
  <li><code>Class[] getClasses()</code></li>
  <li><code>Class[] getDeclaredClasses() throws SecurityException</code></li>
</ul>

<p>Furthermore, all reflective lookups via <code>java.lang.invoke.MethodHandles.Lookup</code> will also require metadata for the type to be present, or they will throw <code>MissingReflectionRegistrationError</code>.</p>

<p>Note that for lambda-proxy classes, metadata can not be provided.
This is a <a href="https://github.com/oracle/graal/issues/7476">known issue</a> that will be addressed in the future releases of GraalVM.</p>

<h3 id="reflective-method-invocation">Reflective Method Invocation</h3>

<p>To reflectively invoke methods, the method signature must be added to the <code>type</code> metadata:</p>
<pre><code class="language-json">{
  "type": "TypeWhoseMethodsAreInvoked",
  "methods": [
    {"name": "&lt;methodName1&gt;", "parameterTypes": ["&lt;param-type1&gt;", "&lt;param-typeI&gt;", "&lt;param-typeN&gt;"]},
    {"name": "&lt;methodName2&gt;", "parameterTypes": ["&lt;param-type1&gt;", "&lt;param-typeI&gt;", "&lt;param-typeN&gt;"]}
  ]
}
</code></pre>

<p>As a convenience, one can allow method invocation for groups of methods by adding the following in <em>reachability-metadata.json</em>:</p>
<pre><code class="language-json">{
  "type": "TypeWhoseMethodsAreInvoked",
  "allDeclaredConstructors": true,
  "allPublicConstructors": true,
  "allDeclaredMethods": true,
  "allPublicMethods": true
}
</code></pre>
<p><code>allDeclaredConstructors</code> and <code>allDeclaredMethods</code> allow calls invocations of methods declared on a given type. 
<code>allPublicConstructors</code> and <code>allPublicMethods</code> allow invocations of all public methods defined on a type and all of its supertypes.</p>

<p>In case the method-invocation metadata is missing, the following methods will throw a <code>MissingReflectionRegistrationError</code>:</p>
<ul>
  <li><code>java.lang.reflect.Method#invoke(Object, Object...)</code></li>
  <li><code>java.lang.reflect.Constructor#newInstance(Object...)</code></li>
  <li><code>java.lang.invoke.MethodHandle#invokeExact(Object...)</code></li>
  <li><code>java.lang.invoke.MethodHandle#invokeWithArguments</code> (all overloaded versions)</li>
</ul>

<h3 id="reflective-field-value-access">Reflective Field-Value Access</h3>

<p>To reflectively access (get or set) field values, metadata about field names must be added to the type:</p>
<pre><code class="language-json">{
  "type": "TypeWhoseFieldValuesAreAccessed",
  "fields": [{"name": "&lt;fieldName1&gt;"}, {"name": "&lt;fieldNameI&gt;"}, {"name": "&lt;fieldNameN&gt;"}]
}
</code></pre>

<p>As a convenience one can allow field-value access for all fields by adding the following in <em>reachability-metadata.json</em>:</p>
<pre><code class="language-json">{
  "type": "TypeWhoseFieldValuesAreAccessed",
  "allDeclaredFields": true,
  "allPublicFields": true
}
</code></pre>
<p><code>allDeclaredFields</code> allow access to all fields declared on a given type, and <code>allPublicFields</code> allows access to all public fields of the given type and all of its supertypes.</p>

<p>In case the field-value-access metadata is missing, the following methods will throw a <code>MissingReflectionRegistrationError</code>:</p>
<ul>
  <li><code>java.lang.reflect.Field#get(Object)</code></li>
  <li><code>java.lang.reflect.Field#set(Object, Object)</code></li>
  <li>All accessor methods on <code>java.lang.reflect.VarHandle</code>.</li>
</ul>

<h3 id="unsafe-allocation-of-a-type">Unsafe Allocation of a Type</h3>

<p>For unsafe allocation of a type via <code>sun.misc.Unsafe#allocateInstance(Class&lt;?&gt;)</code>, or from native code via <code>AllocObject(jClass)</code>, we must provide the following metadata:</p>
<pre><code class="language-json">{
  "type": "FullyQualifiedUnsafeAllocatedType",
  "unsafeAllocated": true
}
</code></pre>
<p>Otherwise, these methods will throw a <code>MissingReflectionRegistrationError</code>.</p>

<h3 id="reflection-metadata-summary">Reflection Metadata Summary</h3>

<p>The overall definition of a type in JSON can have the following values:</p>
<pre><code class="language-json">{
  "condition": {
    "typeReached": "&lt;condition-class&gt;"
  },
  "type": "&lt;class&gt;|&lt;proxy-interface-list&gt;",
  "fields": [
    {"name": "&lt;fieldName&gt;"}
  ],
  "methods": [
    {"name": "&lt;methodName&gt;", "parameterTypes": ["&lt;param-type&gt;"]}
  ],
  "allDeclaredConstructors": true,
  "allPublicConstructors": true,
  "allDeclaredMethods": true,
  "allPublicMethods": true,
  "allDeclaredFields": true,
  "allPublicFields": true,
  "unsafeAllocated": true
}
</code></pre>

<h2 id="java-native-interface">Java Native Interface</h2>

<p>Java Native Interface (JNI) allows native code to access arbitrary Java types and type members.
Native Image cannot predict what such native code will lookup, write to or invoke.
To build a native binary for a Java application that uses JNI to access Java values, JNI metadata is required.</p>

<p>For example, the following <code>C</code> code:</p>
<pre><code class="language-C">jclass clazz = FindClass(env, "jni/accessed/Type");
</code></pre>
<p>looks up the <code>jni.accessed.Type</code> class, which can then be used to instantiate <code>jni.accessed.Type</code>, invoke its methods or access its fields.</p>

<p>The metadata entry for the above call can <em>only</em> be provided via <em>reachability-metadata.json</em>. Specify the <code>type</code> entry in the <code>jni</code> field:</p>
<pre><code class="language-json">{
  "jni":[
    {
      "type": "jni.accessed.Type"
    }
  ]
}
</code></pre>

<p>Adding the metadata for a type does not allow to fetch all of its fields and methods with <code>GetFieldID</code>, <code>GetStaticFieldID</code>, <code>GetStaticMethodID</code>, and <code>GetMethodID</code>.</p>

<p>To access field values, we need to provide field names:</p>
<pre><code class="language-json">{
  "type": "jni.accessed.Type",
  "fields": [{"name": "value"}]
}
</code></pre>
<p>To access all fields one can use the following attributes:</p>
<pre><code class="language-json">{
  "type": "jni.accessed.Type",
  "allDeclaredFields": true,
  "allPublicFields": true
}
</code></pre>
<p><code>allDeclaredFields</code> allow access to all fields declared on a given type, and <code>allPublicFields</code> allows access to all public fields of the given type and all of its supertypes.</p>

<p>To call Java methods from JNI, we must provide metadata for the method signatures:</p>
<pre><code class="language-json">{
  "type": "jni.accessed.Type",
  "methods": [
    {"name": "&lt;methodName1&gt;", "parameterTypes": ["&lt;param-type1&gt;", "&lt;param-typeI&gt;", "&lt;param-typeN&gt;"]},
    {"name": "&lt;methodName2&gt;", "parameterTypes": ["&lt;param-type1&gt;", "&lt;param-typeI&gt;", "&lt;param-typeN&gt;"]}
  ]
}
</code></pre>
<p>As a convenience, one can allow method invocation for groups of methods by adding the following:</p>
<pre><code class="language-json">{
  "type": "jni.accessed.Type",
  "allDeclaredConstructors": true,
  "allPublicConstructors": true,
  "allDeclaredMethods": true,
  "allPublicMethods": true
}
</code></pre>
<p><code>allDeclaredConstructors</code> and <code>allDeclaredMethods</code> allow calls invocations of methods declared on a given type.
<code>allPublicConstructors</code> and <code>allPublicMethods</code> allow invocations of all public methods defined on a type and all of its supertypes.</p>

<p>To allocate objects of a type with <code>AllocObject</code>, the metadata must be stored in the <code>reflection</code> section:</p>
<pre><code class="language-json">{
  "reflection": [
    {
      "type": "jni.accessed.Type",
      "unsafeAllocated": true
    }
  ]
}
</code></pre>

<p>Failing to provide metadata for an element that is dynamically accessed from native code will result in an exception (<code>MissingJNIRegistrationError</code>).</p>

<blockquote>
  <p>Note that most libraries that use JNI do not handle exceptions properly, so to see which elements are missing <code>--exact-reachability-metadata</code> in combination with <code>-XX:MissingRegistrationReportingMode=Warn</code> must be used.</p>
</blockquote>

<h2 id="resources">Resources</h2>

<p>Java is capable of accessing any resource on the application class path, or the module path for which the requesting code has permission to access.
Resource metadata instructs the <code>native-image</code> builder to include specified resources and resource bundles in the produced binary.
A consequence of this approach is that some parts of the application that use resources for configuration (such as logging) are effectively configured at build time.</p>

<p>Native Image will detect calls to <code>java.lang.Class#getResource</code> and <code>java.lang.Class#getResourceAsStream</code> in which:</p>
<ul>
  <li>The class on which these methods are called is constant</li>
  <li>The first argument (<code>name</code>) is a constant
and automatically register such resources.</li>
</ul>

<p>The code below will work out of the box, because:</p>
<ul>
  <li>It uses a class literal (<code>Example.class</code>) as the receiver</li>
  <li>It uses a string literal as the <code>name</code> parameter
    <pre><code class="language-java">class Example {
 public void conquerTheWorld() {
     InputStream plan = Example.class.getResourceAsStream("plans/v2/conquer_the_world.txt");
 }
}
</code></pre>
  </li>
</ul>

<h3 id="resource-metadata-in-json">Resource Metadata in JSON</h3>

<p>Resource metadata is specified in the <code>resources</code> field of the <em>reachability-metadata.json</em> file. 
Here is the example of resource metadata:</p>
<pre><code class="language-json">{
  "resources": [
    {
      "glob": "path1/level*/**"
    }
  ]
}
</code></pre>

<p>The <code>glob</code> field uses a subset of <a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob-pattern</a> rules for specifying resources. 
There are several rules to be observed when specifying a resource path:</p>
<ul>
  <li>The <code>native-image</code> tool supports only <em>star</em> (<code>*</code>) and <em>globstar</em> (<code>**</code>) wildcard patterns.
    <ul>
      <li>Per definition, <em>star</em> can match any number of any characters on one level while <em>globstar</em> can match any number of characters at any level.</li>
      <li>If there is a need to treat a star literally (without special meaning), it can be escaped using <code>\</code> (for example, <code>\*</code>).</li>
    </ul>
  </li>
  <li>In the glob, a <em>level</em> represents a part of the pattern separated with <code>/</code>.</li>
  <li>When writing glob patterns the following rules must be observed:
    <ul>
      <li>Glob cannot be empty (for example, <code>""</code> )</li>
      <li>Glob cannot end with a trailing slash (<code>/</code>) (for example, <code>"foo/bar/"</code>)</li>
      <li>Glob cannot contain more than two consecutive (non-escaped) <code>*</code> characters on one level (for example, <code>"foo/***/"</code> )</li>
      <li>Glob cannot contain empty levels (for example, <code>"foo//bar"</code>)</li>
      <li>Glob cannot contain two consecutive globstar wildcards (example, <code>"foo/**/**"</code>)</li>
      <li>Glob cannot have other content on the same level as globstar wildcard (for example, <code>"foo/**bar/x"</code>)</li>
    </ul>
  </li>
</ul>

<p>Given the following project structure:</p>
<pre><code>app-root
└── src
    └── main
        └── resources
            ├── Resource0.txt
            └── Resource1.txt
</code></pre>
<p>You can:</p>
<ul>
  <li>Include all resources with glob <code>**/Resource*.txt</code> (<code>{ "glob":}</code>)</li>
  <li>Include <em>Resource0.txt</em> with glob <code>**/Resource0.txt</code></li>
  <li>Include <em>Resource0.txt</em> and <em>Resource1.txt</em> with globs <code>**/Resource0.txt</code> and <code>**/Resource1.txt</code></li>
</ul>

<h3 id="resources-in-java-modules">Resources in Java Modules</h3>

<p>For every resource or resource bundle, it is possible to specify the module from which the resource or resource bundle should be taken.
You can specify a module name in the separate <code>module</code> field in each entry.
For example:</p>
<pre><code class="language-json">{
   "resources": [
      {
        "module:": "library.module",
        "glob": "resource-file.txt" 
      }
   ]
}
</code></pre>

<p>This will cause the <code>native-image</code> tool to only include <em>resource-file.txt</em> from the Java module <code>library.module</code>.
If other modules or the classpath containing resources that match the pattern <em>resource-file.txt</em>, only the one in <em>library-module</em> is registered to be included into a native executable.
Native Image will also ensure that the modules are guaranteed to be accessible at runtime.</p>

<p>Take the following code pattern:</p>
<pre><code class="language-java">InputStream resource = ModuleLayer.boot().findModule("library.module").getResourceAsStream(resourcePath);
</code></pre>
<p>It will always work as expected for resources registered as described above (even if the module does not contain any code that is considered reachable by static analysis).</p>

<h3 id="embedded-resources-information">Embedded Resources Information</h3>

<p>There are two ways to see which resources were included in a native executable:</p>
<ol>
  <li>Use the option <code>--emit build-report</code> to generate a build report for your native executable.
There you can find information about all included resources under the <code>Resources</code> tab.</li>
  <li>Use the option <code>-H:+GenerateEmbeddedResourcesFile</code> to generate a JSON file  <em>embedded-resources.json</em>, listing all included resources.</li>
</ol>

<p>For each registered resource you get:</p>
<ul>
  <li><strong>Module</strong> (or <code>unnamed</code> if a resource does not belong to any module)</li>
  <li><strong>Name</strong> (resource path)</li>
  <li><strong>Origin</strong> (location of the resource on the system)</li>
  <li><strong>Type</strong> (whether the resource is a file, directory, or missing)</li>
  <li><strong>Size</strong> (actual resource size)</li>
</ul>

<blockquote>
  <p>Note: The size of a resource directory represents only the size of the names of all directory entries (not a sum of the content sizes).</p>
</blockquote>

<h2 id="resource-bundles">Resource Bundles</h2>
<p>Java localization support (<code>java.util.ResourceBundle</code>) enables to load L10N resources and show messages localized for a specific <em>locale</em>.
Native Image needs knowledge of the resource bundles that your application uses so that it can include appropriate resources and program elements to the application.</p>

<p>A simple bundle can be specified in the <code>bundles</code> section of <em>reachability-metadata.json</em>:</p>

<pre><code class="language-json">{
  "bundles": [
    {
      "name":"your.pkg.Bundle"
    }
  ]
}
</code></pre>

<p>To request a bundle from a specific module:</p>
<pre><code class="language-json">{
  "bundles": [
    {
      "name":"app.module:module.pkg.Bundle"
    }
  ]
}
</code></pre>

<p>By default, resource bundles are included for all locales that are <a href="#locales">included into the image</a>. 
Below is the example how to include only specific locales for a bundle:</p>
<pre><code class="language-json">{
  "bundles": [
    {
      "name": "specific.locales.Bundle",
      "locales": ["en", "de", "sk"]
    }
  ]
}
</code></pre>

<h3 id="locales">Locales</h3>

<p>It is also possible to specify which locales should be included in a native executable and which should be the default.
For example, to switch the default locale to Swiss German and also include French and English, use the following options:</p>
<pre><code class="language-shell">native-image -Duser.country=CH -Duser.language=de -H:IncludeLocales=fr,en
</code></pre>
<p>The locales are specified using <a href="https://docs.oracle.com/javase/tutorial/i18n/locale/matching.html">language tags</a>.
You can include all locales via <code>-H:+IncludeAllLocales</code>, but note that it increases the size of the resulting executable.</p>

<h2 id="serialization">Serialization</h2>

<p>Java can serialize (or deserialize) any class that implements the <code>Serializable</code> interface.
Native Image supports serialization (or deserialization) with proper serialization metadata registration.
This is necessary because serialization usually requires reflective accesses to the object that is being serialized.</p>

<h3 id="serialization-metadata-registration-in-code">Serialization Metadata Registration In Code</h3>

<p>Native Image detects calls to <code>ObjectInputFilter.Config#createFilter(String pattern)</code> and if the <code>pattern</code> argument is constant, the exact classes mentioned in the pattern will be registered for serialization. 
For example, the following pattern will register the class <code>pkg.SerializableClass</code> for serialization:</p>
<pre><code class="language-java">  var filter = ObjectInputFilter.Config.createFilter("pkg.SerializableClass;!*;")
  objectInputStream.setObjectInputFilter(proof);
</code></pre>
<p>Using this pattern has a positive side effect of improving security on the JVM as only <code>pkg.SerializableClass</code> can be received by the 
<code>objectInputStream</code>.</p>

<p>Wildcard patterns do the serialization registration only for lambda-proxy classes of an enclosing class. For example, to register lambda serialization in an enclosing class <code>pkg.LambdaHolder</code> use:</p>
<pre><code class="language-java">  ObjectInputFilter.Config.createFilter("pkg.LambdaHolder$$Lambda*;")
</code></pre>

<p>Patterns like <code>"pkg.**"</code> and <code>"pkg.Prefix*"</code> will not perform serialization registration as they are too general and would increase image size significantly.</p>

<p>For calls to the <code>sun.reflect.ReflectionFactory#newConstructorForSerialization(java.lang.Class)</code> and <code>sun.reflect.ReflectionFactory#newConstructorForSerialization(java.lang.Class, )</code> native image detects calls to these functions when all arguments and the receiver are constant. For example, the following call will register <code>SerializlableClass</code> for serialization:</p>
<pre><code class="language-java">  ReflectionFactory.getReflectionFactory().newConstructorForSerialization(SerializableClass.class);
</code></pre>
<p>To create a custom constructor for serialization use:</p>
<pre><code class="language-java">  var constructor = SuperSuperClass.class.getDeclaredConstructor();
  var newConstructor = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(BaseClass.class, constructor);
</code></pre>

<p>Proxy classes can only be registered for serialization via the JSON files.</p>

<h3 id="serialization-metadata-in-json">Serialization Metadata in JSON</h3>
<p>Serialization metadata is specified in the <code>serialization</code> section of <em>reachability-metadata.json</em>.</p>

<p>To specify a regular <code>serialized.Type</code> use</p>
<pre><code class="language-json">{
  "serialization": [
    {
      "type": "serialized.Type"
    }
  ]
}
</code></pre>

<p>To specify a proxy class for serialization, use the following entry:</p>
<pre><code class="language-json">{
  "serialization": [
    {
      "type": {
        "proxy": ["FullyQualifiedInterface1", "...", "FullyQualifiedInterfaceN"]
      }
    }
  ]
}
</code></pre>

<p>In rare cases an application might explicitly make calls to:</p>
<pre><code class="language-java">    ReflectionFactory.newConstructorForSerialization(Class&lt;?&gt; cl, Constructor&lt;?&gt; constructorToCall);
</code></pre>
<p>In which the passed <code>constructorToCall</code> differs from what would automatically be used if regular serialization of <code>cl</code>.</p>

<p>To also support such serialization use cases, it is possible to register serialization for a class with a
custom <code>constructorToCall</code>.
For example, to allow serialization of <code>org.apache.spark.SparkContext$$anonfun$hadoopFile$1</code>, use the declared constructor of <code>java.lang.Object</code> as a custom <code>targetConstructor</code>, use:</p>
<pre><code class="language-json">{
  "serialization": [
    {
      "type": "&lt;fully-qualified-class-name&gt;",
      "customTargetConstructorClass": "&lt;custom-target-constructor-class&gt;"
    }
  ]
}
</code></pre>

<h2 id="sample-reachability-metadata">Sample Reachability Metadata</h2>

<p>See below is a sample reachability metadata configuration that you can use in <em>reachabilty-metadata.json</em>:</p>

<pre><code class="language-json">{
  "reflection": [
    {
      "type": "reflectively.accessed.Type",
      "fields": [
        {
          "name": "field1"
        }
      ],
      "methods": [
        {
          "name": "method1",
          "parameterTypes": ["&lt;param-type1&gt;", "&lt;param-typeI&gt;", "&lt;param-typeN&gt;"] 
        }
      ],
      "allDeclaredConstructors": true,
      "allPublicConstructors": true,
      "allDeclaredFields": true,
      "allPublicFields": true,
      "allDeclaredMethods": true,
      "allPublicMethods": true,
      "unsafeAllocated": true
    }
  ],
  "jni": [
    {
      "type": "jni.accessed.Type",
      "fields": [
        {
          "name": "field1"
        }
      ],
      "methods": [
        {
          "name": "method1",
          "parameterTypes": ["&lt;param-type1&gt;", "&lt;param-typeI&gt;", "&lt;param-typeN&gt;"]
        }
      ],
      "allDeclaredConstructors": true,
      "allPublicConstructors": true,
      "allDeclaredFields": true,
      "allPublicFields": true,
      "allDeclaredMethods": true,
      "allPublicMethods": true
    }
  ],
  "resources": [
    {
      "module": "optional.module.of.a.resource",
      "glob": "path1/level*/**"
    }
  ],
  "bundles": [
    {
      "name": "fully.qualified.bundle.name",
      "locales": ["en", "de", "other_optional_locales"]
    }
  ],
  "serialization": [
    {
      "type": "serialized.Type",
      "customTargetConstructorClass": "optional.serialized.super.Type"
    }
  ]
}
</code></pre>

<h2 id="defining-classes-at-run-time">Defining Classes at Run Time</h2>

<p>Java has support for loading new classes from bytecode at run time, which is not possible in Native Image as all classes must be known at build time (the “closed-world assumption”).
To overcome this issue there are the following options:</p>
<ol>
  <li>Modify or reconfigure your application (or a third-party library) so that it does not generate classes at runtime or load them via non-built-in class loaders.</li>
  <li>If the classes must be generated, try to generate them at build time in a static initializer of a dedicated class.
The generated java.lang.Class objects should be stored in static fields and the dedicated class initialized by passing <code>--initialize-at-build-time=&lt;class_name&gt;</code> as the build argument.</li>
  <li>If none of the above is applicable, use the <a href="/jdk23/reference-manual/native-image/metadata/AutomaticMetadataCollection/">Native Image Agent</a> to run the application and collect predefined classes with
<code>java -agentlib:native-image-agent=config-output-dir=&lt;config-dir&gt;,experimental-class-define-support &lt;application-arguments&gt;</code>.
At runtime, if there is an attempt to load a class with the same name and bytecode as one of the classes encountered during tracing, the predefined class will be supplied to the application.</li>
</ol>

<p>Predefined classes metadata is specified in a <em>predefined-classes-config.json</em> file and conform to the JSON schema defined in
<a href="/jdk23/docs/reference-manual/native-image/assets/predefined-classes-config-schema-v1.0.0.json">predefined-classes-config-schema-v1.0.0.json</a>.
The schema also includes further details and explanations how this configuration works. Here is the example of the predefined-classes-config.json:</p>
<pre><code class="language-json">[
  {
    "type": "agent-extracted",
    "classes": [
      {
        "hash": "&lt;class-bytecodes-hash&gt;",
        "nameInfo": "&lt;class-name"
      }
    ]
  }
]
</code></pre>
<blockquote>
  <p>Note: Predefined classes metadata is not meant to be manually written.
Note: Predefined classes are the best-effort approach for legacy projects, and they are not guaranteed to work.</p>
</blockquote>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><a href="/jdk23/reference-manual/native-image/metadata/AutomaticMetadataCollection/">Metadata Collection with the Tracing Agent</a></li>
  <li><a href="/jdk23/reference-manual/native-image/metadata/Compatibility/">Native Image Compatibility Guide</a></li>
  <li><a href="https://github.com/oracle/graalvm-reachability-metadata">GraalVM Reachability Metadata Repository</a></li>
</ul>

      </div>
  </div>
</div>
      </main>
      <footer class="footer footer__mobile">
  <div class="container-fluid container-fluid--custom-sm">
    <div class="row footer-content">
      <div class="footer__columns">
        <div class="footer__columns-item">
          <h6 class="title-footer">API Documentation</h6>
          <div class="grow">
            <ul class="footer-list">
              <li class="footer-list__item"><a href="https://www.graalvm.org/sdk/javadoc/">GraalVM SDK Javadoc</a></li>
              <li class="footer-list__item"><a href="https://www.graalvm.org/truffle/javadoc/">GraalVM Truffle Javadoc</a></li>
            </ul>
          </div>
        </div>
        <div class="footer__columns-item">
          <h6 class="title-footer">Learn More</h6>
          <div class="grow">
            <ul class="footer-list">
              <li class="footer-list__item"><a href="https://github.com/oracle/graal/" target="_blank">Open Source Repository</a></li>
              <li class="footer-list__item"><a href="https://www.graalvm.org/release-notes/" target="_blank">Release notes</a></li>
              <li class="footer-list__item"><a href="https://github.com/graalvm/graalvm-demos/"
                  target="_blank">Demos</a></li>
              <li class="footer-list__item"><a href="https://medium.com/graalvm" target="_blank">Blog</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="col-12 col-sm-12 col-md-12 col-lg-12">
      <div class="row">
        <div class="col-sm-12">
          <p class="copyright">
            Copyright © 2024, Oracle and/or its affiliates. All rights reserved. Oracle and Java are registered trademarks. Other names may be trademarks of their respective owners.
          </p>
        </div>
      </div>
    </div>
  </div>
</footer>

    </div>

    <div class="overlay"></div>

    <script src='/jdk23/resources/js/main.js'></script>
  </body>

</html>
