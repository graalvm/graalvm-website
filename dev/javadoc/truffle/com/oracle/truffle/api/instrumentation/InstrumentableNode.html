<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (26) -->
<title>InstrumentableNode (GraalVM Truffle Java API Reference)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="declaration: package: com.oracle.truffle.api.instrumentation, interface: InstrumentableNode">
<meta name="generator" content="javadoc/ClassWriter">
<link rel="stylesheet" type="text/css" href="../../../../../resource-files/jquery-ui.min.css">
<link rel="stylesheet" type="text/css" href="../../../../../resource-files/stylesheet.css">
<script type="text/javascript" src="../../../../../script-files/script.js"></script>
<script type="text/javascript" src="../../../../../script-files/jquery-3.7.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-files/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">const pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="nav-content">
<div class="nav-menu-button"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button></div>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../search.html">Search</a></li>
<li><a href="../../../../../help-doc.html#class">Help</a></li>
</ul>
<div class="about-language"><b>GraalVM Truffle Java API Reference<br>26.0.0-dev</b><br>013ccc18ba271bdaed93c6e78b460f5f715a0f1c</div>
</div>
</div>
<div class="sub-nav">
<div class="nav-content">
<ol class="sub-nav-list">
<li><a href="package-summary.html">com.oracle.truffle.api.instrumentation</a></li>
<li><a href="InstrumentableNode.html" class="current-selection">InstrumentableNode</a></li>
</ol>
<div class="nav-list-search"><input type="text" id="search-input" disabled placeholder="Search documentation (type /)" aria-label="Search in documentation" autocomplete="off" spellcheck="false"><input type="reset" id="reset-search" disabled value="Reset"></div>
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="main-grid">
<nav role="navigation" class="toc" aria-label="Table of contents">
<div class="toc-header">Contents&nbsp;<input type="text" class="filter-input" disabled placeholder="Filter contents (type .)" aria-label="Filter table of contents" autocomplete="off" spellcheck="false"><input type="reset" class="reset-filter" disabled tabindex="-1" value="Reset"></div>
<ol class="toc-list" tabindex="-1">
<li><a href="#" tabindex="0">Description</a></li>
<li><a href="#nested-class-summary" tabindex="0">Nested Class Summary</a></li>
<li><a href="#method-summary" tabindex="0">Method Summary</a></li>
<li><a href="#method-detail" tabindex="0">Method Details</a>
<ol class="toc-list">
<li><a href="#isInstrumentable()" tabindex="0">isInstrumentable()</a></li>
<li><a href="#createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)" tabindex="0">createWrapper(ProbeNode)</a></li>
<li><a href="#findProbe()" tabindex="0">findProbe()</a></li>
<li><a href="#hasTag(java.lang.Class)" tabindex="0">hasTag(Class)</a></li>
<li><a href="#getNodeObject()" tabindex="0">getNodeObject()</a></li>
<li><a href="#materializeInstrumentableNodes(java.util.Set)" tabindex="0">materializeInstrumentableNodes(Set)</a></li>
<li><a href="#findNearestNodeAt(int,java.util.Set)" tabindex="0">findNearestNodeAt(int, Set)</a></li>
<li><a href="#findNearestNodeAt(int,int,java.util.Set)" tabindex="0">findNearestNodeAt(int, int, Set)</a></li>
<li><a href="#findInstrumentableParent(com.oracle.truffle.api.nodes.Node)" tabindex="0">findInstrumentableParent(Node)</a></li>
<li><a href="#createProbe(com.oracle.truffle.api.source.SourceSection)" tabindex="0">createProbe(SourceSection)</a></li>
</ol>
</li>
</ol>
<button class="hide-sidebar"><span>Hide sidebar&nbsp;</span><img src="../../../../../resource-files/left.svg" alt="Hide sidebar"></button><button class="show-sidebar"><img src="../../../../../resource-files/right.svg" alt="Show sidebar"><span>&nbsp;Show sidebar</span></button></nav>
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<h1 title="Interface InstrumentableNode" class="title">Interface InstrumentableNode</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Superinterfaces:</dt>
<dd><code><a href="../nodes/NodeInterface.html" title="interface in com.oracle.truffle.api.nodes">NodeInterface</a></code></dd>
</dl>
<hr>
<div class="horizontal-scroll">
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">InstrumentableNode</span><span class="extends-implements">
extends <a href="../nodes/NodeInterface.html" title="interface in com.oracle.truffle.api.nodes">NodeInterface</a></span></div>
<div class="block">Interface implemented by AST <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>nodes</code></a> that may be <em>instrumentable</em>: an AST
location where <a href="TruffleInstrument.html" title="class in com.oracle.truffle.api.instrumentation">Truffle
instruments</a> are permitted to listen to before and after using execution event listeners.
<p>
If a node is instrumentable depends on the return value of <a href="#isInstrumentable()"><code>isInstrumentable()</code></a>. All
instrumentable nodes must also extend <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a>. All other member methods of this
interface are only allowed to be invoked if <a href="#isInstrumentable()"><code>isInstrumentable()</code></a> returns <code>true</code>
.
<p>
Every instrumentable node is required to create a wrapper for this instrumentable node in
<a href="#createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)"><code>createWrapper(ProbeNode)</code></a>. The instrumentation framework will, when needed during
execution, <a href="../nodes/Node.html#replace(T)"><code>replace</code></a> the instrumentable node with a <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> and delegate to the original node. After the replacement of an instrumentable node with
a wrapper we refer to the original node as an instrumented node.
<p>
Wrappers can be generated automatically using an annotation processor by annotating the class
with @<a href="GenerateWrapper.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>GenerateWrapper</code></a>. If an instrumentable node subclass has additional declared methods
than its instrumentable base class that are used by other nodes, then a new wrapper should be
generated or implemented for the subclass, otherwise the replacement of the wrapper will fail.
<p>
Instrumentable nodes may return <code>true</code> to indicate that they were tagged by <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation"><code>tag</code></a>. Tags are used by guest languages to indicate that a <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> is a member of a
certain category of nodes. For example a debugger
<a href="TruffleInstrument.html" title="class in com.oracle.truffle.api.instrumentation"><code>instrument</code></a> might require a guest
language to tag all nodes as <a href="StandardTags.StatementTag.html" title="class in com.oracle.truffle.api.instrumentation"><code>statements</code></a> that should be
considered as such. See <a href="#hasTag(java.lang.Class)"><code>hasTag(Class)</code></a> for further details on how to use tags.
<p>
<b>Example minimal implementation of an instrumentable node:</b>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet" id="snippet-com.oracle.truffle.api.instrumentation.InstrumentableNode1"><code class="language-java">@GenerateWrapper
abstract static class SimpleNode extends Node
                implements InstrumentableNode {

    public abstract Object execute(VirtualFrame frame);

    public boolean isInstrumentable() {
        return true;
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        // ASTNodeWrapper is generated by @GenerateWrapper
        return new SimpleNodeWrapper(this, probe);
    }
}
</code></pre>
</div>


<p>
Example for a typical implementation of an instrumentable node with support for source
sections:</b>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet" id="snippet-com.oracle.truffle.api.instrumentation.InstrumentableNode2"><code class="language-java">@GenerateWrapper
abstract static class RecommendedNode extends Node
                implements InstrumentableNode {

    private static final int NO_SOURCE = -1;

    private int sourceCharIndex = NO_SOURCE;
    private int sourceLength;

    public abstract Object execute(VirtualFrame frame);

    // invoked by the parser to set the source
    void setSourceSection(int charIndex, int length) {
        assert sourceCharIndex == NO_SOURCE : "source should only be set once";
        this.sourceCharIndex = charIndex;
        this.sourceLength = length;
    }

    public final boolean isInstrumentable() {
        // all AST nodes with source are instrumentable
        return sourceCharIndex != NO_SOURCE;
    }

    @Override
    @TruffleBoundary
    public final SourceSection getSourceSection() {
        if (sourceCharIndex == NO_SOURCE) {
            // AST node without source
            return null;
        }
        RootNode rootNode = getRootNode();
        if (rootNode == null) {
            // not yet adopted yet
            return null;
        }
        Source source = rootNode.getSourceSection().getSource();
        return source.createSection(sourceCharIndex, sourceLength);
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        // ASTNodeWrapper is generated by @GenerateWrapper
        return new RecommendedNodeWrapper(this, probe);
    }
}
</code></pre>
</div>


<p></div>
<dl class="notes">
<dt>Since:</dt>
<dd>0.33</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#isInstrumentable()">to decide whether node is instrumentable.</a></li>
<li><a href="#hasTag(java.lang.Class)">Implement hasTag to decide whether an instrumentable node is tagged with a
     tag.</a></li>
<li><a href="GenerateWrapper.html" title="annotation interface in com.oracle.truffle.api.instrumentation">Use an annotation processor to generate the wrapper class.</a></li>
<li><a href="Instrumenter.html#attachExecutionEventListener(com.oracle.truffle.api.instrumentation.SourceSectionFilter,T)"><code>Instrumenter.attachExecutionEventListener(SourceSectionFilter, ExecutionEventListener)</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Interface</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static interface&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="InstrumentableNode.WrapperNode.html" class="type-name-link" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode.WrapperNode</a></code></div>
<div class="col-last even-row-color">
<div class="block">Nodes that the instrumentation framework inserts into guest language ASTs (between
<a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>instrumentable</code></a> guest language nodes and their parents) for the
purpose of interposing on execution events and reporting them via the instrumentation
framework.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button><button id="method-summary-table-tab5" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab5', 3)" class="table-tab">Default Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel" aria-labelledby="method-summary-table-tab0">
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#createProbe(com.oracle.truffle.api.source.SourceSection)" class="member-name-link">createProbe</a><wbr>(<a href="../source/SourceSection.html" title="class in com.oracle.truffle.api.source">SourceSection</a>&nbsp;sourceSection)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Method allows to create an eager probe node given an instrumentable node.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode.WrapperNode</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)" class="member-name-link">createWrapper</a><wbr>(<a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a>&nbsp;probe)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a new, never adopted, unshared <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> node implementation for
this <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>instrumentable</code></a> node.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1"><code>static <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1"><code><a href="#findInstrumentableParent(com.oracle.truffle.api.nodes.Node)" class="member-name-link">findInstrumentableParent</a><wbr>(<a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a>&nbsp;node)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1">
<div class="block">Find the first <a href="#isInstrumentable()"><code>instrumentable</code></a> node on it's parent chain.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#findNearestNodeAt(int,int,java.util.Set)" class="member-name-link">findNearestNodeAt</a><wbr>(int&nbsp;line,
 int&nbsp;column,
 <a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source line and column position, according to
the guest language control flow, that is tagged with some of the given tags.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#findNearestNodeAt(int,java.util.Set)" class="member-name-link">findNearestNodeAt</a><wbr>(int&nbsp;sourceCharIndex,
 <a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source character index according to the guest
language control flow, that is tagged with some of the given tags.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#findProbe()" class="member-name-link">findProbe</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Determines how to find a probe given an instrumentable node.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#getNodeObject()" class="member-name-link">getNodeObject</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Returns an interop capable object that contains all keys and values of attributes associated
with this node.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#hasTag(java.lang.Class)" class="member-name-link">hasTag</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&nbsp;tag)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Returns <code>true</code> if this node should be considered tagged by a given tag else
<code>false</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#isInstrumentable()" class="member-name-link">isInstrumentable</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns <code>true</code> if this node is instrumentable.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#materializeInstrumentableNodes(java.util.Set)" class="member-name-link">materializeInstrumentableNodes</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;materializedTags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Removes optimizations performed in this AST node to restore the syntactic AST structure.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="isInstrumentable()">
<h3>isInstrumentable</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">isInstrumentable</span>()</div>
<div class="block">Returns <code>true</code> if this node is instrumentable. Instrumentable nodes are points
where instrumenters can attach execution events. The return values of instrumentable nodes
must always be interop capable values.
<p>
The implementation of this method must ensure that its result is stable after the parent
<a href="../nodes/RootNode.html" title="class in com.oracle.truffle.api.nodes"><code>root node</code></a> was wrapped in a <a href="../CallTarget.html" title="interface in com.oracle.truffle.api"><code>CallTarget</code></a> using
<a href="../nodes/RootNode.html#getCallTarget()"><code>RootNode.getCallTarget()</code></a>. The result is stable if the result of calling this method
remains always the same.
<p>
This method might be called in parallel from multiple threads even if the language is single
threaded. The method may be invoked without a language context currently being active.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)">
<h3>createWrapper</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode.WrapperNode</a></span>&nbsp;<span class="element-name">createWrapper</span><wbr><span class="parameters">(<a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a>&nbsp;probe)</span></div>
<div class="block">Returns a new, never adopted, unshared <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> node implementation for
this <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>instrumentable</code></a> node. The returned wrapper implementation must
extend the same type that implements <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>InstrumentableNode</code></a>.
<p>
The instrumentation framework will, when needed during execution, <a href="../nodes/Node.html#replace(T)"><code>replace</code></a> the instrumentable node with a <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> and delegate to the
original node. After the replacement of an instrumentable node with a wrapper we refer to the
original node as an instrumented node. Wrappers can be generated automatically using an
annotation processor by annotating the class with @<a href="GenerateWrapper.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>GenerateWrapper</code></a>. Please note that
if an instrumentable node subclass has additional execute methods then a new wrapper must be
generated or implemented. Otherwise the <a href="../nodes/Node.html#replace(T)"><code>replacement</code></a> of the
instrumentable node with the wrapper will fail if the subtype is used as static type in nodes
<a href="../nodes/Node.Child.html" title="annotation interface in com.oracle.truffle.api.nodes"><code>children</code></a>.
<p>
A wrapper forwards the following events concerning the delegate to the given <a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation"><code>probe</code></a> for propagation through the instrumentation framework, e.g. to
<a href="ExecutionEventListener.html" title="interface in com.oracle.truffle.api.instrumentation">event listeners</a> bound to this guest language program
location:
<ul>
<li><a href="ProbeNode.html#onEnter(com.oracle.truffle.api.frame.VirtualFrame)">onEnter(Frame)</a>:
an <em>execute</em> method on the delegate is ready to be called;</li>
<li><a href="ProbeNode.html#onReturnValue(com.oracle.truffle.api.frame.VirtualFrame,java.lang.Object)">onReturnValue(Frame,Object)</a>: an <em>execute</em> method on the delegate has just returned a
(possibly <code>null</code>) value;</li>
<li><a href="ProbeNode.html#onReturnExceptionalOrUnwind(com.oracle.truffle.api.frame.VirtualFrame,java.lang.Throwable,boolean)">onReturnExceptionalOrUnwind(Frame,Throwable, boolean)</a>: an <em>execute</em> method on the
delegate has just thrown an exception.</li>
</ul>
<p>
This method is always invoked on an interpreter thread. The method may be invoked without a
language context currently being active.
<p>
If <a href="#findProbe()"><code>findProbe()</code></a> is overriden and never returns a <code>null</code> value, then
<a href="#createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)"><code>createWrapper(ProbeNode)</code></a> does not need to be implemented and may throw an
<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/UnsupportedOperationException.html" title="class or interface in java.lang" class="external-link"><code>UnsupportedOperationException</code></a> instead.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>probe</code> - the <a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation"><code>probe node</code></a> to be adopted and sent execution events by the
           wrapper</dd>
<dt>Returns:</dt>
<dd>a <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> implementation</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="findProbe()">
<h3>findProbe</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a></span>&nbsp;<span class="element-name">findProbe</span>()</div>
<div class="block">Determines how to find a probe given an instrumentable node. Implementing this method allows
to customize probe storage, e.g. if a different strategy should be used other than the
default wrapper node strategy. The default implementation discovers the probe through the
parent wrapper node by calling <a href="InstrumentableNode.WrapperNode.html#getProbeNode()"><code>InstrumentableNode.WrapperNode.getProbeNode()</code></a>. A probe can be initialized
lazily on <a href="#findProbe()"><code>findProbe()</code></a> calls using <a href="#createProbe(com.oracle.truffle.api.source.SourceSection)"><code>createProbe(SourceSection)</code></a>. This method
will never be invoked if <a href="#isInstrumentable()"><code>isInstrumentable()</code></a> returns <code>false</code>.
<p>
If this method returns <code>null</code> then the default wrapper node strategy will be
applied for this instrumentable node. A custom probe storage strategy must therefore ensure
that this method never returns <code>null</code>.
<p>
The probe must be stored/read from a reference with volatile semantics. This method must
produce a <a href="../CompilerDirectives.html#isPartialEvaluationConstant(java.lang.Object)"><code>partial evaluation
constant</code></a> if the receiver is a PE constant.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="#createProbe(com.oracle.truffle.api.source.SourceSection)"><code>createProbe(SourceSection)</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="hasTag(java.lang.Class)">
<h3>hasTag</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">hasTag</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&nbsp;tag)</span></div>
<div class="block">Returns <code>true</code> if this node should be considered tagged by a given tag else
<code>false</code>. In order for a Truffle language to support a particular tag, the tag must
also be marked as <a href="ProvidedTags.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>provided</code></a> by the language.
<p>
Tags are used by guest languages to indicate that a <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> is a member of a
certain category of nodes. For example a debugger <a href="TruffleInstrument.html" title="class in com.oracle.truffle.api.instrumentation"><code>instrument</code></a> might
require a guest language to tag all nodes as statements that should be considered as such.
<p>
The node implementor may decide how to implement tagging for nodes. The simplest way to
implement tagging using Java types is by overriding the <a href="#hasTag(java.lang.Class)"><code>hasTag(Class)</code></a> method. This
example shows how to tag a node subclass and all its subclasses as statement:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet" id="snippet-hasTag(java.lang.Class)1"><code class="language-java">@GenerateWrapper
abstract static class StatementNode extends SimpleNode
                implements InstrumentableNode {

    @Override
    public final Object execute(VirtualFrame frame) {
        executeVoid(frame);
        return null;
    }

    public abstract void executeVoid(VirtualFrame frame);

    @Override
    public final WrapperNode createWrapper(ProbeNode probe) {
        return StatementNodeWrapper.create(this, probe);
    }

    public boolean hasTag(Class&lt;? extends Tag&gt; tag) {
        if (tag == StandardTags.StatementTag.class) {
            return true;
        }
        return false;
    }
}
</code></pre>
</div>


<p>
Often it is impossible to just rely on the node's Java type to implement tagging. This
example shows how to use local state to implement tagging for a node.

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet" id="snippet-hasTag(java.lang.Class)2"><code class="language-java">@GenerateWrapper
static class HaltNode extends Node implements InstrumentableNode {
    private boolean isDebuggerHalt;

    public void setDebuggerHalt(boolean isDebuggerHalt) {
        this.isDebuggerHalt = isDebuggerHalt;
    }

    public Object execute(VirtualFrame frame) {
        // does nothing;
        return null;
    }

    public boolean isInstrumentable() {
        return true;
    }

    public boolean hasTag(Class&lt;? extends Tag&gt; tag) {
        if (tag == Debugger.HaltTag.class) {
            return isDebuggerHalt;
        }
        return false;
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        return new HaltNodeWrapper(this, probe);
    }

}

</code></pre>
</div>


<p>
The implementation of hasTag method must ensure that its result is stable after the parent
<a href="../nodes/RootNode.html" title="class in com.oracle.truffle.api.nodes"><code>root node</code></a> was wrapped in a <a href="../CallTarget.html" title="interface in com.oracle.truffle.api"><code>CallTarget</code></a> using
<a href="../nodes/RootNode.html#getCallTarget()"><code>RootNode.getCallTarget()</code></a>. The result is stable if the result of calling this method
for a particular tag remains always the same.
<p>
This method might be called in parallel from multiple threads even if the language is single
threaded. The method may be invoked without a language context currently being active.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tag</code> - the class <a href="ProvidedTags.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>provided</code></a> by
           the <a href="../TruffleLanguage.html" title="class in com.oracle.truffle.api"><code>language</code></a></dd>
<dt>Returns:</dt>
<dd><code>true</code> if the node should be considered tagged by a tag else
        <code>false</code>.</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="getNodeObject()">
<h3>getNodeObject</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span>&nbsp;<span class="element-name">getNodeObject</span>()</div>
<div class="block">Returns an interop capable object that contains all keys and values of attributes associated
with this node. The returned object must return <code>true</code> in response to the
<a href="../interop/InteropLibrary.html#hasMembers(java.lang.Object)"><code>has members</code></a> message.
If <code>null</code> is returned then an empty tag object without any readable keys will be
assumed. Multiple calls to <a href="#getNodeObject()"><code>getNodeObject()</code></a> for a particular node may return the same
or objects with different identity. The returned object must not support any write operation.
The returned object must not support execution or instantiation and must not have a size.
<p>
For performance reasons it is not recommended to eagerly collect all properties of the node
object when <a href="#getNodeObject()"><code>getNodeObject()</code></a> is invoked. Instead, the language should lazily compute
them when they are read. If the node object contains dynamic properties, that change during
the execution of the AST, then the node must return an updated value for each key when it is
read repeatedly. In other words the node object must always represent the current state of
this AST <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a>. The implementer should not cache the node instance in the AST.
The instrumentation framework will take care of caching node object instances when they are
requested by tools.
<p>
<b>Compatibility:</b> In addition to the expected keys by the tag specification, the language
implementation may provide any set of additional keys and values. Tools might depend on these
language specific tags and might break if keys or values are changed without notice.
<p>
For a memory efficient implementation the language might make the instrumentable <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>Node</code></a>
a TruffleObject and return this instance.
<p>
This method might be called in parallel from multiple threads even if the language is single
threaded. The method may be invoked without a language context currently being active. The
<a href="../nodes/Node.html#getLock()"><code>AST lock</code></a> is held while <a href="#getNodeObject()"><code>getNodeObject()</code></a> object is invoked.
There is no lock held when the object is read.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the node object as TruffleObject or <code>null</code> if no node object properties
        are available for this instrumented node</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="materializeInstrumentableNodes(java.util.Set)">
<h3>materializeInstrumentableNodes</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode</a></span>&nbsp;<span class="element-name">materializeInstrumentableNodes</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;materializedTags)</span></div>
<div class="block">Removes optimizations performed in this AST node to restore the syntactic AST structure.
Guest languages may decide to group multiple nodes together into a single node. This is
useful to reduce the memory consumed by the AST representation and it can also improve the
execution performance when interpreting the AST. Performing such optimizations often modify
the syntactic AST structure, leading to invalid execution events reported to the
instrumentation framework. Implementing this method allows the instrumented node to restore
the syntactic AST structure when needed. It provides a list of tags that were requested by
all current execution event bindings to allow the language to do the materialization
selectively for instrumentable nodes with certain tags only.
<p>
The returned instrumentable nodes must return themselves when this method is called on them
with the same tags. Materialized nodes should not be re-materialized again. Instrumentation
relies on the stability of materialized nodes. Use <a href="../nodes/Node.html#notifyInserted(com.oracle.truffle.api.nodes.Node)"><code>Node.notifyInserted(Node)</code></a> when you
need to change the structure of instrumentable nodes.
<p>
Node must return itself from this method when it has already seen all the materializedTags
specified as an argument, i.e., not only if the set of tags is exactly the same as before,
but also if the current set of tags is completely contained in the union of all the sets of
tags specified in all the calls of this method that led to creation of this materialized
node.
<p>
If the node returns a new node from this method, the subtree rooted at the new node must be
completely unadopted, i.e., all nodes it contains must not have existed in the original AST.
Also, the new subtree must be completely materialized, so that no new materializations occur
when the instrumentation framework instruments the new subtree during the current traversal.
<p>
The AST lock is acquired while this method is invoked. Therefore it is not allowed to run
guest language code while this method is invoked. This method might be called in parallel
from multiple threads even if the language is single threaded. The method may be invoked
without a language context currently being active. Language reference is always available.
<p>
In the example below, we show how the <code>IncrementNode</code> with a
<code>ConstantNode</code> child is optimized into a <code>ConstantIncrementNode</code> and
how it can implement <code>materializeSyntaxNodes</code> to restore the syntactic structure
of the AST:
<p>
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet" id="snippet-materializeInstrumentableNodes(java.util.Set)1"><code class="language-java">@GenerateWrapper
abstract static class ExpressionNode extends Node
                implements InstrumentableNode {
    abstract int execute(VirtualFrame frame);

    public boolean isInstrumentable() {
        return true;
    }

    public boolean hasTag(Class&lt;? extends Tag&gt; tag) {
        return tag == StandardTags.ExpressionTag.class;
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        return new ExpressionNodeWrapper(this, probe);
    }
}

class ConstantNode extends ExpressionNode {

    private final int constant;

    ConstantNode(int constant) {
        this.constant = constant;
    }

    @Override
    int execute(VirtualFrame frame) {
        return constant;
    }

}

// node with constant folded operation
class ConstantIncrementNode extends ExpressionNode {
    final int constantIncremented;

    ConstantIncrementNode(int constant) {
        this.constantIncremented = constant + 1;
    }

    // desguar to restore syntactic structure of the AST
    public InstrumentableNode materializeInstrumentableNodes(
                    Set&lt;Class&lt;? extends Tag&gt;&gt; tags) {
        if (tags.contains(StandardTags.ExpressionTag.class)) {
            return new IncrementNode(
                            new ConstantNode(constantIncremented - 1));
        }
        return this;
    }

    @Override
    int execute(VirtualFrame frame) {
        return constantIncremented;
    }

}

// node with full semantics of the node.
class IncrementNode extends ExpressionNode {
    @Child ExpressionNode child;

    IncrementNode(ExpressionNode child) {
        this.child = child;
    }

    @Override
    int execute(VirtualFrame frame) {
        return child.execute(frame) + 1;
    }
}
</code></pre>
</div>
</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>materializedTags</code> - a set of tags that requested to be materialized</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="findNearestNodeAt(int,java.util.Set)">
<h3>findNearestNodeAt</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></span>&nbsp;<span class="element-name">findNearestNodeAt</span><wbr><span class="parameters">(int&nbsp;sourceCharIndex,
 <a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</span></div>
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source character index according to the guest
language control flow, that is tagged with some of the given tags. The source character index
is in this node's source. The nearest node will preferably be in the same block/function as
the character index. This node acts as a context node - either a node containing the
character index if such node exists, or node following the character index if exists, or node
preceding the character index otherwise.
<p>
Return an instrumentable node that is tagged with some of the tags and containing the
character index, if such exists and there is not a more suitable sibling node inside the
container source section. Return the next sibling tagged node otherwise, or the previous one
when the next one does not exist.
<p>
<u>Use Case</u><br>
The current use-case of this method is a relocation of breakpoint position, for instance.
When a user submits a breakpoint at the source character index, a nearest logical
instrumentable node that has suitable tags needs to be found to move the breakpoint
accordingly.
<p>
<u>Default Implementation</u><br>
This method has a default implementation, which assumes that the materialized Truffle
<a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>Node</code></a> hierarchy corresponds with the logical guest language AST structure. If this is
not the case for a particular guest language, this method needs to be implemented, possibly
with the help of language specific AST node classes.
<p>
The default algorithm is following:<br>
<ol>
<li>If the character index is smaller than the start index of this node's source section,
return the first tagged child of this node.</li>
<li>If the character index is larger than the end index of this node's source section, return
the last tagged child of this node.</li>
<li>Otherwise, this node's source section contains the character index. Use following steps
to find the nearest tagged node in this node's hierarchy:
<ol type="a">
<li>Traverse the node children in declaration order (AST breadth-first order). For every
child do:
<ol>
<li>When the child is not instrumentable, include its children into the traversal.</li>
<li>When the child does not have a source section assigned, ignore it.</li>
<li>When the <code>sourceCharIndex</code> is inside the child's source section, find if it's
tagged with one of the tags (store as <code>isTagged</code>) and repeat recursively from
<b>3.a.</b> using this child as the node.</li>
<li>When the child is above the character index, remember a sorted list of such children up
to the lowest tagged child (store in <code>higherNodes</code> list).</li>
<li>When the child is below the character index, remember a sorted list of such children down
to the highest tagged child (store in <code>lowerNodes</code> list).</li>
</ol>
</li>
<li>If a tagged child node was found in <b>3.a</b> with source section matching the
<code>sourceCharIndex</code>, return it.</li>
<li>Otherwise, we check the list of lower/higher nodes:
<ol>
<li>Prefer the node after the character index.</li>
<li>Traverse <code>higherNodes</code> in ascending order. When the node is tagged, return it,
when not, repeat with that node from <b>3.a.</b></li>
<li>If no tagged node was found, traverse <code>lowerNodes</code> in descending order. When
the node is tagged, return it, when not, repeat with that node from <b>3.a.</b></li>
<li>When nothing was found in the steps above, return <code>null</code>.</li>
</ol>
</li>
<li>If <b>c.</b> didn't provide a tagged node, apply this algorithm recursively to a parent
of this node, if exists. If you encounter the nearest tagged parent node found in <b>3.a</b>,
return it. Otherwise, return a tagged child found in the steps above, if any.</li>
</ol>
</li>
</ol></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>sourceCharIndex</code> - the 0-based character index in this node's source, to find the nearest
           tagged node from</dd>
<dd><code>tags</code> - a set of tags, the nearest node needs to be tagged with at least one tag from
           this set</dd>
<dt>Returns:</dt>
<dd>the nearest instrumentable node according to the execution flow and tagged with some
        of the tags, or <code>null</code> when none was found</dd>
<dt>Since:</dt>
<dd>0.33</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#findNearestNodeAt(int,int,java.util.Set)"><code>findNearestNodeAt(int, int, Set)</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="findNearestNodeAt(int,int,java.util.Set)">
<h3>findNearestNodeAt</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></span>&nbsp;<span class="element-name">findNearestNodeAt</span><wbr><span class="parameters">(int&nbsp;line,
 int&nbsp;column,
 <a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/26/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</span></div>
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source line and column position, according to
the guest language control flow, that is tagged with some of the given tags.
<p>
Behaves in the same way as <a href="#findNearestNodeAt(int,java.util.Set)"><code>findNearestNodeAt(int, Set)</code></a> but uses line/column as the
position specification instead of a character index.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>line</code> - 1-based line number</dd>
<dd><code>column</code> - 1-based column number, or less than one when the column is unknown</dd>
<dd><code>tags</code> - a set of tags, the nearest node needs to be tagged with at least one tag from
           this set</dd>
<dt>Returns:</dt>
<dd>the nearest instrumentable node according to the execution flow and tagged with some
        of the tags, or <code>null</code> when none was found</dd>
<dt>Since:</dt>
<dd>23.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#findNearestNodeAt(int,java.util.Set)"><code>findNearestNodeAt(int, Set)</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="findInstrumentableParent(com.oracle.truffle.api.nodes.Node)">
<h3>findInstrumentableParent</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></span>&nbsp;<span class="element-name">findInstrumentableParent</span><wbr><span class="parameters">(<a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a>&nbsp;node)</span></div>
<div class="block">Find the first <a href="#isInstrumentable()"><code>instrumentable</code></a> node on it's parent chain. If the
provided node is instrumentable itself, it is returned. If not, the first parent node that is
instrumentable is returned, if any.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - a Node</dd>
<dt>Returns:</dt>
<dd>the first instrumentable node, or <code>null</code> when no instrumentable parent
        exists.</dd>
<dt>Since:</dt>
<dd>20.3</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="createProbe(com.oracle.truffle.api.source.SourceSection)">
<h3>createProbe</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a></span>&nbsp;<span class="element-name">createProbe</span><wbr><span class="parameters">(<a href="../source/SourceSection.html" title="class in com.oracle.truffle.api.source">SourceSection</a>&nbsp;sourceSection)</span></div>
<div class="block">Method allows to create an eager probe node given an instrumentable node. This is useful to
implement custom probe storage by implementing <a href="#findProbe()"><code>findProbe()</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>sourceSection</code> - the eager materialized source section for this probe.</dd>
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><center>Copyright &copy; 2012, 2025, Oracle and/or its affiliates. All rights reserved.</center></small></p>
</footer>
</main>
</div>
</body>
</html>
