<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) -->
<title>InstrumentableNode (GraalVM Truffle Java API Reference)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="declaration: package: com.oracle.truffle.api.instrumentation, interface: InstrumentableNode">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><b>GraalVM Truffle Java API Reference<br>24.1.0-dev</b><br>62922ebf8b8def5c1f4b871342d328c264093161</div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.oracle.truffle.api.instrumentation</a></div>
<h1 title="Interface InstrumentableNode" class="title">Interface InstrumentableNode</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Superinterfaces:</dt>
<dd><code><a href="../nodes/NodeInterface.html" title="interface in com.oracle.truffle.api.nodes">NodeInterface</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">InstrumentableNode</span><span class="extends-implements">
extends <a href="../nodes/NodeInterface.html" title="interface in com.oracle.truffle.api.nodes">NodeInterface</a></span></div>
<div class="block">Interface implemented by AST <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>nodes</code></a> that may be <em>instrumentable</em>: an AST
 location where <a href="TruffleInstrument.html" title="class in com.oracle.truffle.api.instrumentation">Truffle
 instruments</a> are permitted to listen to before and after using execution event listeners.
 <p>
 If a node is instrumentable depends on the return value of <a href="#isInstrumentable()"><code>isInstrumentable()</code></a>. All
 instrumentable nodes must also extend <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a>. All other member methods of this
 interface are only allowed to be invoked if <a href="#isInstrumentable()"><code>isInstrumentable()</code></a> returns <code>true</code>
 .
 <p>
 Every instrumentable node is required to create a wrapper for this instrumentable node in
 <a href="#createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)"><code>createWrapper(ProbeNode)</code></a>. The instrumentation framework will, when needed during
 execution, <a href="../nodes/Node.html#replace(T)"><code>replace</code></a> the instrumentable node with a <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> and delegate to the original node. After the replacement of an instrumentable node with
 a wrapper we refer to the original node as an instrumented node.
 <p>
 Wrappers can be generated automatically using an annotation processor by annotating the class
 with @<a href="GenerateWrapper.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>GenerateWrapper</code></a>. If an instrumentable node subclass has additional declared methods
 than its instrumentable base class that are used by other nodes, then a new wrapper should be
 generated or implemented for the subclass, otherwise the replacement of the wrapper will fail.
 <p>
 Instrumentable nodes may return <code>true</code> to indicate that they were tagged by <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation"><code>tag</code></a>. Tags are used by guest languages to indicate that a <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> is a member of a
 certain category of nodes. For example a debugger
 <a href="TruffleInstrument.html" title="class in com.oracle.truffle.api.instrumentation"><code>instrument</code></a> might require a guest
 language to tag all nodes as <a href="StandardTags.StatementTag.html" title="class in com.oracle.truffle.api.instrumentation"><code>statements</code></a> that should be
 considered as such. See <a href="#hasTag(java.lang.Class)"><code>hasTag(Class)</code></a> for further details on how to use tags.
 <p>
 <b>Example minimal implementation of an instrumentable node:</b>

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">@GenerateWrapper
abstract static class SimpleNode extends Node
                implements InstrumentableNode {

    public abstract Object execute(VirtualFrame frame);

    public boolean isInstrumentable() {
        return true;
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        // ASTNodeWrapper is generated by @GenerateWrapper
        return new SimpleNodeWrapper(this, probe);
    }
}
</code></pre>
</div>


 <p>
 Example for a typical implementation of an instrumentable node with support for source
 sections:</b>
 
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">@GenerateWrapper
abstract static class RecommendedNode extends Node
                implements InstrumentableNode {

    private static final int NO_SOURCE = -1;

    private int sourceCharIndex = NO_SOURCE;
    private int sourceLength;

    public abstract Object execute(VirtualFrame frame);

    // invoked by the parser to set the source
    void setSourceSection(int charIndex, int length) {
        assert sourceCharIndex == NO_SOURCE : "source should only be set once";
        this.sourceCharIndex = charIndex;
        this.sourceLength = length;
    }

    public final boolean isInstrumentable() {
        // all AST nodes with source are instrumentable
        return sourceCharIndex != NO_SOURCE;
    }

    @Override
    @TruffleBoundary
    public final SourceSection getSourceSection() {
        if (sourceCharIndex == NO_SOURCE) {
            // AST node without source
            return null;
        }
        RootNode rootNode = getRootNode();
        if (rootNode == null) {
            // not yet adopted yet
            return null;
        }
        Source source = rootNode.getSourceSection().getSource();
        return source.createSection(sourceCharIndex, sourceLength);
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        // ASTNodeWrapper is generated by @GenerateWrapper
        return new RecommendedNodeWrapper(this, probe);
    }
}
</code></pre>
</div>

 
 <p></div>
<dl class="notes">
<dt>Since:</dt>
<dd>0.33</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#isInstrumentable()"><code>to decide whether node is instrumentable.</code></a></li>
<li><a href="#hasTag(java.lang.Class)"><code>Implement hasTag to decide whether an instrumentable node is tagged with a
      tag.</code></a></li>
<li><a href="GenerateWrapper.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>Use an annotation processor to generate the wrapper class.</code></a></li>
<li><a href="Instrumenter.html#attachExecutionEventListener(com.oracle.truffle.api.instrumentation.SourceSectionFilter,T)"><code>Instrumenter.attachExecutionEventListener(SourceSectionFilter, ExecutionEventListener)</code></a></li>
</ul>
</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Interface</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static interface&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="InstrumentableNode.WrapperNode.html" class="type-name-link" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode.WrapperNode</a></code></div>
<div class="col-last even-row-color">
<div class="block">Nodes that the instrumentation framework inserts into guest language ASTs (between
 <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>instrumentable</code></a> guest language nodes and their parents) for the
 purpose of interposing on execution events and reporting them via the instrumentation
 framework.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button><button id="method-summary-table-tab5" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab5', 3)" class="table-tab">Default Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode.WrapperNode</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)" class="member-name-link">createWrapper</a><wbr>(<a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a>&nbsp;probe)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a new, never adopted, unshared <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> node implementation for
 this <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>instrumentable</code></a> node.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1"><code>static <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1"><code><a href="#findInstrumentableParent(com.oracle.truffle.api.nodes.Node)" class="member-name-link">findInstrumentableParent</a><wbr>(<a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a>&nbsp;node)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1">
<div class="block">Find the first <a href="#isInstrumentable()"><code>instrumentable</code></a> node on it's parent chain.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#findNearestNodeAt(int,int,java.util.Set)" class="member-name-link">findNearestNodeAt</a><wbr>(int&nbsp;line,
 int&nbsp;column,
 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source line and column position, according to
 the guest language control flow, that is tagged with some of the given tags.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#findNearestNodeAt(int,java.util.Set)" class="member-name-link">findNearestNodeAt</a><wbr>(int&nbsp;sourceCharIndex,
 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source character index according to the guest
 language control flow, that is tagged with some of the given tags.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#getNodeObject()" class="member-name-link">getNodeObject</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Returns an interop capable object that contains all keys and values of attributes associated
 with this node.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#hasTag(java.lang.Class)" class="member-name-link">hasTag</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&nbsp;tag)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Returns <code>true</code> if this node should be considered tagged by a given tag else
 <code>false</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#isInstrumentable()" class="member-name-link">isInstrumentable</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns <code>true</code> if this node is instrumentable.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#materializeInstrumentableNodes(java.util.Set)" class="member-name-link">materializeInstrumentableNodes</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;materializedTags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Removes optimizations performed in this AST node to restore the syntactic AST structure.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="isInstrumentable()">
<h3>isInstrumentable</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">isInstrumentable</span>()</div>
<div class="block">Returns <code>true</code> if this node is instrumentable. Instrumentable nodes are points
 where instrumenters can attach execution events. The return values of instrumentable nodes
 must always be interop capable values.
 <p>
 The implementation of this method must ensure that its result is stable after the parent
 <a href="../nodes/RootNode.html" title="class in com.oracle.truffle.api.nodes"><code>root node</code></a> was wrapped in a <a href="../CallTarget.html" title="interface in com.oracle.truffle.api"><code>CallTarget</code></a> using
 <a href="../nodes/RootNode.html#getCallTarget()"><code>RootNode.getCallTarget()</code></a>. The result is stable if the result of calling this method
 remains always the same.
 <p>
 This method might be called in parallel from multiple threads even if the language is single
 threaded. The method may be invoked without a language context currently being active.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="createWrapper(com.oracle.truffle.api.instrumentation.ProbeNode)">
<h3>createWrapper</h3>
<div class="member-signature"><span class="return-type"><a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode.WrapperNode</a></span>&nbsp;<span class="element-name">createWrapper</span><wbr><span class="parameters">(<a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation">ProbeNode</a>&nbsp;probe)</span></div>
<div class="block">Returns a new, never adopted, unshared <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> node implementation for
 this <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>instrumentable</code></a> node. The returned wrapper implementation must
 extend the same type that implements <a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>InstrumentableNode</code></a>.
 <p>
 The instrumentation framework will, when needed during execution, <a href="../nodes/Node.html#replace(T)"><code>replace</code></a> the instrumentable node with a <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> and delegate to the
 original node. After the replacement of an instrumentable node with a wrapper we refer to the
 original node as an instrumented node. Wrappers can be generated automatically using an
 annotation processor by annotating the class with @<a href="GenerateWrapper.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>GenerateWrapper</code></a>. Please note that
 if an instrumetnable node subclass has additional execute methods then a new wrapper must be
 generated or implemented. Otherwise the <a href="../nodes/Node.html#replace(T)"><code>replacement</code></a> of the
 instrumentable node with the wrapper will fail if the subtype is used as static type in nodes
 <a href="../nodes/Node.Child.html" title="annotation interface in com.oracle.truffle.api.nodes"><code>children</code></a>.
 <p>
 A wrapper forwards the following events concerning the delegate to the given <a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation"><code>probe</code></a> for propagation through the instrumentation framework, e.g. to
 <a href="ExecutionEventListener.html" title="interface in com.oracle.truffle.api.instrumentation">event listeners</a> bound to this guest language program
 location:
 <ul>
 <li><a href="ProbeNode.html#onEnter(com.oracle.truffle.api.frame.VirtualFrame)">onEnter(Frame)</a>:
 an <em>execute</em> method on the delegate is ready to be called;</li>
 <li><a href="ProbeNode.html#onReturnValue(com.oracle.truffle.api.frame.VirtualFrame,java.lang.Object)">onReturnValue(Frame,Object)</a>: an <em>execute</em> method on the delegate has just returned a
 (possibly <code>null</code>) value;</li>
 <li><a href="ProbeNode.html#onReturnExceptionalOrUnwind(com.oracle.truffle.api.frame.VirtualFrame,java.lang.Throwable,boolean)">onReturnExceptionalOrUnwind(Frame,Throwable, boolean)</a>: an <em>execute</em> method on the
 delegate has just thrown an exception.</li>
 </ul>
 <p>
 This method is always invoked on an interpreter thread. The method may be invoked without a
 language context currently being active.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>probe</code> - the <a href="ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation"><code>probe node</code></a> to be adopted and sent execution events by the
            wrapper</dd>
<dt>Returns:</dt>
<dd>a <a href="InstrumentableNode.WrapperNode.html" title="interface in com.oracle.truffle.api.instrumentation"><code>wrapper</code></a> implementation</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasTag(java.lang.Class)">
<h3>hasTag</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">hasTag</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&nbsp;tag)</span></div>
<div class="block">Returns <code>true</code> if this node should be considered tagged by a given tag else
 <code>false</code>. In order for a Truffle language to support a particular tag, the tag must
 also be marked as <a href="ProvidedTags.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>provided</code></a> by the language.
 <p>
 Tags are used by guest languages to indicate that a <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> is a member of a
 certain category of nodes. For example a debugger <a href="TruffleInstrument.html" title="class in com.oracle.truffle.api.instrumentation"><code>instrument</code></a> might
 require a guest language to tag all nodes as statements that should be considered as such.
 <p>
 The node implementor may decide how to implement tagging for nodes. The simplest way to
 implement tagging using Java types is by overriding the <a href="#hasTag(java.lang.Class)"><code>hasTag(Class)</code></a> method. This
 example shows how to tag a node subclass and all its subclasses as statement:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">@GenerateWrapper
abstract static class StatementNode extends SimpleNode
                implements InstrumentableNode {

    @Override
    public final Object execute(VirtualFrame frame) {
        executeVoid(frame);
        return null;
    }

    public abstract void executeVoid(VirtualFrame frame);

    @Override
    public final WrapperNode createWrapper(ProbeNode probe) {
        return StatementNodeWrapper.create(this, probe);
    }

    public boolean hasTag(Class&lt;? extends Tag&gt; tag) {
        if (tag == StandardTags.StatementTag.class) {
            return true;
        }
        return false;
    }
}
</code></pre>
</div>


 <p>
 Often it is impossible to just rely on the node's Java type to implement tagging. This
 example shows how to use local state to implement tagging for a node.

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">@GenerateWrapper
static class HaltNode extends Node implements InstrumentableNode {
    private boolean isDebuggerHalt;

    public void setDebuggerHalt(boolean isDebuggerHalt) {
        this.isDebuggerHalt = isDebuggerHalt;
    }

    public Object execute(VirtualFrame frame) {
        // does nothing;
        return null;
    }

    public boolean isInstrumentable() {
        return true;
    }

    public boolean hasTag(Class&lt;? extends Tag&gt; tag) {
        if (tag == Debugger.HaltTag.class) {
            return isDebuggerHalt;
        }
        return false;
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        return new HaltNodeWrapper(this, probe);
    }

}

</code></pre>
</div>


 <p>
 The implementation of hasTag method must ensure that its result is stable after the parent
 <a href="../nodes/RootNode.html" title="class in com.oracle.truffle.api.nodes"><code>root node</code></a> was wrapped in a <a href="../CallTarget.html" title="interface in com.oracle.truffle.api"><code>CallTarget</code></a> using
 <a href="../nodes/RootNode.html#getCallTarget()"><code>RootNode.getCallTarget()</code></a>. The result is stable if the result of calling this method
 for a particular tag remains always the same.
 <p>
 This method might be called in parallel from multiple threads even if the language is single
 threaded. The method may be invoked without a language context currently being active.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tag</code> - the class <a href="ProvidedTags.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>provided</code></a> by
            the <a href="../TruffleLanguage.html" title="class in com.oracle.truffle.api"><code>language</code></a></dd>
<dt>Returns:</dt>
<dd><code>true</code> if the node should be considered tagged by a tag else
         <code>false</code>.</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getNodeObject()">
<h3>getNodeObject</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span>&nbsp;<span class="element-name">getNodeObject</span>()</div>
<div class="block">Returns an interop capable object that contains all keys and values of attributes associated
 with this node. The returned object must return <code>true</code> in response to the
 <a href="../interop/InteropLibrary.html#hasMembers(java.lang.Object)"><code>has members</code></a> message.
 If <code>null</code> is returned then an empty tag object without any readable keys will be
 assumed. Multiple calls to <a href="#getNodeObject()"><code>getNodeObject()</code></a> for a particular node may return the same
 or objects with different identity. The returned object must not support any write operation.
 The returned object must not support execution or instantiation and must not have a size.
 <p>
 For performance reasons it is not recommended to eagerly collect all properties of the node
 object when <a href="#getNodeObject()"><code>getNodeObject()</code></a> is invoked. Instead, the language should lazily compute
 them when they are read. If the node object contains dynamic properties, that change during
 the execution of the AST, then the node must return an updated value for each key when it is
 read repeatedly. In other words the node object must always represent the current state of
 this AST <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a>. The implementer should not cache the node instance in the AST.
 The instrumentation framework will take care of caching node object instances when they are
 requested by tools.
 <p>
 <b>Compatibility:</b> In addition to the expected keys by the tag specification, the language
 implementation may provide any set of additional keys and values. Tools might depend on these
 language specific tags and might break if keys or values are changed without notice.
 <p>
 For a memory efficient implementation the language might make the instrumentable <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>Node</code></a>
 a TruffleObject and return this instance.
 <p>
 This method might be called in parallel from multiple threads even if the language is single
 threaded. The method may be invoked without a language context currently being active. The
 <a href="../nodes/Node.html#getLock()"><code>AST lock</code></a> is held while <a href="#getNodeObject()"><code>getNodeObject()</code></a> object is invoked.
 There is no lock held when the object is read.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the node object as TruffleObject or <code>null</code> if no node object properties
         are available for this instrumented node</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="materializeInstrumentableNodes(java.util.Set)">
<h3>materializeInstrumentableNodes</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="InstrumentableNode.html" title="interface in com.oracle.truffle.api.instrumentation">InstrumentableNode</a></span>&nbsp;<span class="element-name">materializeInstrumentableNodes</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;materializedTags)</span></div>
<div class="block">Removes optimizations performed in this AST node to restore the syntactic AST structure.
 Guest languages may decide to group multiple nodes together into a single node. This is
 useful to reduce the memory consumed by the AST representation and it can also improve the
 execution performance when interpreting the AST. Performing such optimizations often modify
 the syntactic AST structure, leading to invalid execution events reported to the
 instrumentation framework. Implementing this method allows the instrumented node to restore
 the syntactic AST structure when needed. It provides a list of tags that were requested by
 all current execution event bindings to allow the language to do the materialization
 selectively for instrumentable nodes with certain tags only.
 <p>
 The returned instrumentable nodes must return themselves when this method is called on them
 with the same tags. Materialized nodes should not be re-materialized again. Instrumentation
 relies on the stability of materialized nodes. Use <a href="../nodes/Node.html#notifyInserted(com.oracle.truffle.api.nodes.Node)"><code>Node.notifyInserted(Node)</code></a> when you
 need to change the structure of instrumentable nodes.
 <p>
 Node must return itself from this method when it has already seen all the materializedTags
 specified as an argument, i.e., not only if the set of tags is exactly the same as before,
 but also if the current set of tags is completely contained in the union of all the sets of
 tags specified in all the calls of this method that led to creation of this materialized
 node.
 <p>
 If the node returns a new node from this method, the subtree rooted at the new node must be
 completely unadopted, i.e., all nodes it contains must not have existed in the original AST.
 Also, the new subtree must be completely materialized, so that no new materializations occur
 when the instrumentation framework instruments the new subtree during the current traversal.
 <p>
 The AST lock is acquired while this method is invoked. Therefore it is not allowed to run
 guest language code while this method is invoked. This method might be called in parallel
 from multiple threads even if the language is single threaded. The method may be invoked
 without a language context currently being active. Language reference is always available.
 <p>
 In the example below, we show how the <code>IncrementNode</code> with a
 <code>ConstantNode</code> child is optimized into a <code>ConstantIncrementNode</code> and
 how it can implement <code>materializeSyntaxNodes</code> to restore the syntactic structure
 of the AST:
 <p>
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">@GenerateWrapper
abstract static class ExpressionNode extends Node
                implements InstrumentableNode {
    abstract int execute(VirtualFrame frame);

    public boolean isInstrumentable() {
        return true;
    }

    public boolean hasTag(Class&lt;? extends Tag&gt; tag) {
        return tag == StandardTags.ExpressionTag.class;
    }

    public WrapperNode createWrapper(ProbeNode probe) {
        return new ExpressionNodeWrapper(this, probe);
    }
}

class ConstantNode extends ExpressionNode {

    private final int constant;

    ConstantNode(int constant) {
        this.constant = constant;
    }

    @Override
    int execute(VirtualFrame frame) {
        return constant;
    }

}

// node with constant folded operation
class ConstantIncrementNode extends ExpressionNode {
    final int constantIncremented;

    ConstantIncrementNode(int constant) {
        this.constantIncremented = constant + 1;
    }

    // desguar to restore syntactic structure of the AST
    public InstrumentableNode materializeInstrumentableNodes(
                    Set&lt;Class&lt;? extends Tag&gt;&gt; tags) {
        if (tags.contains(StandardTags.ExpressionTag.class)) {
            return new IncrementNode(
                            new ConstantNode(constantIncremented - 1));
        }
        return this;
    }

    @Override
    int execute(VirtualFrame frame) {
        return constantIncremented;
    }

}

// node with full semantics of the node.
class IncrementNode extends ExpressionNode {
    @Child ExpressionNode child;

    IncrementNode(ExpressionNode child) {
        this.child = child;
    }

    @Override
    int execute(VirtualFrame frame) {
        return child.execute(frame) + 1;
    }
}
</code></pre>
</div>
</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>materializedTags</code> - a set of tags that requested to be materialized</dd>
<dt>Since:</dt>
<dd>0.33</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="findNearestNodeAt(int,java.util.Set)">
<h3>findNearestNodeAt</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></span>&nbsp;<span class="element-name">findNearestNodeAt</span><wbr><span class="parameters">(int&nbsp;sourceCharIndex,
 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</span></div>
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source character index according to the guest
 language control flow, that is tagged with some of the given tags. The source character index
 is in this node's source. The nearest node will preferably be in the same block/function as
 the character index. This node acts as a context node - either a node containing the
 character index if such node exists, or node following the character index if exists, or node
 preceding the character index otherwise.
 <p>
 Return an instrumentable node that is tagged with some of the tags and containing the
 character index, if such exists and there is not a more suitable sibling node inside the
 container source section. Return the next sibling tagged node otherwise, or the previous one
 when the next one does not exist.
 <p>
 <u>Use Case</u><br>
 The current use-case of this method is a relocation of breakpoint position, for instance.
 When a user submits a breakpoint at the source character index, a nearest logical
 instrumentable node that has suitable tags needs to be found to move the breakpoint
 accordingly.
 <p>
 <u>Default Implementation</u><br>
 This method has a default implementation, which assumes that the materialized Truffle
 <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>Node</code></a> hierarchy corresponds with the logical guest language AST structure. If this is
 not the case for a particular guest language, this method needs to be implemented, possibly
 with the help of language specific AST node classes.
 <p>
 The default algorithm is following:<br>
 <ol>
 <li>If the character index is smaller than the start index of this node's source section,
 return the first tagged child of this node.</li>
 <li>If the character index is larger than the end index of this node's source section, return
 the last tagged child of this node.</li>
 <li>Otherwise, this node's source section contains the character index. Use following steps
 to find the nearest tagged node in this node's hierarchy:
 <ol type="a">
 <li>Traverse the node children in declaration order (AST breadth-first order). For every
 child do:
 <ol>
 <li>When the child is not instrumentable, include its children into the traversal.</li>
 <li>When the child does not have a source section assigned, ignore it.</li>
 <li>When the <code>sourceCharIndex</code> is inside the child's source section, find if it's
 tagged with one of the tags (store as <code>isTagged</code>) and repeat recursively from
 <b>3.a.</b> using this child as the node.</li>
 <li>When the child is above the character index, remember a sorted list of such children up
 to the lowest tagged child (store in <code>higherNodes</code> list).</li>
 <li>When the child is below the character index, remember a sorted list of such children down
 to the highest tagged child (store in <code>lowerNodes</code> list).</li>
 </ol>
 </li>
 <li>If a tagged child node was found in <b>3.a</b> with source section matching the
 <code>sourceCharIndex</code>, return it.</li>
 <li>Otherwise, we check the list of lower/higher nodes:
 <ol>
 <li>Prefer the node after the character index.</li>
 <li>Traverse <code>higherNodes</code> in ascending order. When the node is tagged, return it,
 when not, repeat with that node from <b>3.a.</b></li>
 <li>If no tagged node was found, traverse <code>lowerNodes</code> in descending order. When
 the node is tagged, return it, when not, repeat with that node from <b>3.a.</b></li>
 <li>When nothing was found in the steps above, return <code>null</code>.</li>
 </ol>
 </li>
 <li>If <b>c.</b> didn't provide a tagged node, apply this algorithm recursively to a parent
 of this node, if exists. If you encounter the nearest tagged parent node found in <b>3.a</b>,
 return it. Otherwise, return a tagged child found in the steps above, if any.</li>
 </ol>
 </li>
 </ol></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>sourceCharIndex</code> - the 0-based character index in this node's source, to find the nearest
            tagged node from</dd>
<dd><code>tags</code> - a set of tags, the nearest node needs to be tagged with at least one tag from
            this set</dd>
<dt>Returns:</dt>
<dd>the nearest instrumentable node according to the execution flow and tagged with some
         of the tags, or <code>null</code> when none was found</dd>
<dt>Since:</dt>
<dd>0.33</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#findNearestNodeAt(int,int,java.util.Set)"><code>findNearestNodeAt(int, int, Set)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="findNearestNodeAt(int,int,java.util.Set)">
<h3>findNearestNodeAt</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></span>&nbsp;<span class="element-name">findNearestNodeAt</span><wbr><span class="parameters">(int&nbsp;line,
 int&nbsp;column,
 <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Set.html" title="class or interface in java.util" class="external-link">Set</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="Tag.html" title="class in com.oracle.truffle.api.instrumentation">Tag</a>&gt;&gt;&nbsp;tags)</span></div>
<div class="block">Find the nearest <a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes"><code>node</code></a> to the given source line and column position, according to
 the guest language control flow, that is tagged with some of the given tags.
 <p>
 Behaves in the same way as <a href="#findNearestNodeAt(int,java.util.Set)"><code>findNearestNodeAt(int, Set)</code></a> but uses line/column as the
 position specification instead of a character index.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>line</code> - 1-based line number</dd>
<dd><code>column</code> - 1-based column number, or less than one when the column is unknown</dd>
<dd><code>tags</code> - a set of tags, the nearest node needs to be tagged with at least one tag from
            this set</dd>
<dt>Returns:</dt>
<dd>the nearest instrumentable node according to the execution flow and tagged with some
         of the tags, or <code>null</code> when none was found</dd>
<dt>Since:</dt>
<dd>23.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#findNearestNodeAt(int,java.util.Set)"><code>findNearestNodeAt(int, Set)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="findInstrumentableParent(com.oracle.truffle.api.nodes.Node)">
<h3>findInstrumentableParent</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a></span>&nbsp;<span class="element-name">findInstrumentableParent</span><wbr><span class="parameters">(<a href="../nodes/Node.html" title="class in com.oracle.truffle.api.nodes">Node</a>&nbsp;node)</span></div>
<div class="block">Find the first <a href="#isInstrumentable()"><code>instrumentable</code></a> node on it's parent chain. If the
 provided node is instrumentable itself, it is returned. If not, the first parent node that is
 instrumentable is returned, if any.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - a Node</dd>
<dt>Returns:</dt>
<dd>the first instrumentable node, or <code>null</code> when no instrumentable parent
         exists.</dd>
<dt>Since:</dt>
<dd>20.3</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><center>Copyright &copy; 2012, 2024, Oracle and/or its affiliates. All rights reserved.</center></small></p>
</footer>
</div>
</div>
</body>
</html>
