<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) -->
<title>GenerateBytecode (GraalVM Truffle Java API Reference)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="declaration: package: com.oracle.truffle.api.bytecode, annotation type: GenerateBytecode">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><b>GraalVM Truffle Java API Reference<br>24.2.0-dev</b><br>f5b124bd2d56c761dd736bd7e81b4e18597fe01d</div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Field</li>
<li><a href="#annotation-interface-required-element-summary">Required</a></li>
<li><a href="#annotation-interface-optional-element-summary">Optional</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li><a href="#annotation-interface-element-detail">Element</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation-interface-required-element-summary">Required</a>&nbsp;|&nbsp;</li>
<li><a href="#annotation-interface-optional-element-summary">Optional</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation-interface-element-detail">Element</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.oracle.truffle.api.bytecode</a></div>
<h1 title="Annotation Interface GenerateBytecode" class="title">Annotation Interface GenerateBytecode</h1>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="annotations"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/annotation/Retention.html" title="class or interface in java.lang.annotation" class="external-link">@Retention</a>(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#SOURCE" title="class or interface in java.lang.annotation" class="external-link">SOURCE</a>)
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/annotation/Target.html" title="class or interface in java.lang.annotation" class="external-link">@Target</a>(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/annotation/ElementType.html#TYPE" title="class or interface in java.lang.annotation" class="external-link">TYPE</a>)
</span><span class="modifiers">public @interface </span><span class="element-name type-name-label">GenerateBytecode</span></div>
<div class="block">Generates a bytecode interpreter using the Bytecode DSL. The Bytecode DSL automatically produces
 an optimizing bytecode interpreter from a set of Node-like "operations". The following is an
 example of a Bytecode DSL interpreter with a single <code>Add</code> operation.

 <pre>
 &#64;GenerateBytecode(languageClass = MyLanguage.class)
 public abstract class MyBytecodeRootNode extends RootNode implements BytecodeRootNode {
     &#64;Operation
     public static final class Add {
         &#64;Specialization
         public static int doInts(int lhs, int rhs) {
             return lhs + rhs;
         }

         &#64;Specialization
         &#64;TruffleBoundary
         public static String doStrings(String lhs, String rhs) {
             return lhs + rhs;
         }
     }
 }
 </pre>

 <p>
 The Bytecode DSL generates a node suffixed with <code>Gen</code> (e.g., <code>MyBytecodeRootNodeGen</code>)
 that contains (among other things) a full bytecode encoding, an optimizing interpreter, and a
 <code>Builder</code> class to generate and validate bytecode automatically.
 <p>
 A node can opt in to additional features, like an <a href="#enableUncachedInterpreter()"><code>uncached
 interpreter</code></a>, <a href="#boxingEliminationTypes()"><code>boxing elimination</code></a>, <a href="#enableQuickening()"><code>quickened instructions</code></a>, and more. The fields of this annotation control which features are
 included in the generated interpreter.
 <p>
 For information about using the Bytecode DSL, please consult the <a href="https://github.com/oracle/graal/blob/master/truffle/docs/bytecode_dsl/BytecodeDSL.md">tutorial</a>.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== ANNOTATION INTERFACE REQUIRED MEMBER SUMMARY =========== -->
<li>
<section class="member-summary" id="annotation-interface-required-element-summary">
<h2>Required Element Summary</h2>
<div class="caption"><span>Required Elements</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Required Element</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a><wbr>&lt;? extends <a href="../TruffleLanguage.html" title="class in com.oracle.truffle.api">TruffleLanguage</a>&lt;?&gt;&gt;</code></div>
<div class="col-second even-row-color"><code><a href="#languageClass()" class="member-name-link">languageClass</a></code></div>
<div class="col-last even-row-color">
<div class="block">The <a href="../TruffleLanguage.html" title="class in com.oracle.truffle.api"><code>TruffleLanguage</code></a> class associated with this node.</div>
</div>
</div>
</section>
</li>
<!-- =========== ANNOTATION INTERFACE OPTIONAL MEMBER SUMMARY =========== -->
<li>
<section class="member-summary" id="annotation-interface-optional-element-summary">
<h2>Optional Element Summary</h2>
<div class="caption"><span>Optional Elements</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Optional Element</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#allowUnsafe()" class="member-name-link">allowUnsafe</a></code></div>
<div class="col-last even-row-color">
<div class="block">Whether to use unsafe array accesses.</div>
</div>
<div class="col-first odd-row-color"><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;?&gt;[]</code></div>
<div class="col-second odd-row-color"><code><a href="#boxingEliminationTypes()" class="member-name-link">boxingEliminationTypes</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Primitive types the interpreter should attempt to avoid boxing up.</div>
</div>
<div class="col-first even-row-color"><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#defaultLocalValue()" class="member-name-link">defaultLocalValue</a></code></div>
<div class="col-last even-row-color">
<div class="block">Sets the default value that <a href="BytecodeLocal.html" title="class in com.oracle.truffle.api.bytecode"><code>locals</code></a> return when they are read without
 ever being written.</div>
</div>
<div class="col-first odd-row-color"><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#defaultUncachedThreshold()" class="member-name-link">defaultUncachedThreshold</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Sets the default number of times an uncached interpreter must return, branch backwards, or
 yield before transitioning to cached.</div>
</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#enableBlockScoping()" class="member-name-link">enableBlockScoping</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enables block scoping, which limits a local's lifetime to the lifetime of the enclosing
 Block/Root operation.</div>
</div>
<div class="col-first odd-row-color"><code>boolean</code></div>
<div class="col-second odd-row-color"><code><a href="#enableBytecodeDebugListener()" class="member-name-link">enableBytecodeDebugListener</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Whether the <a href="debug/BytecodeDebugListener.html" title="interface in com.oracle.truffle.api.bytecode.debug"><code>BytecodeDebugListener</code></a> methods should be notified by generated code.</div>
</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#enableMaterializedLocalAccesses()" class="member-name-link">enableMaterializedLocalAccesses</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enables materialized local accesses.</div>
</div>
<div class="col-first odd-row-color"><code>boolean</code></div>
<div class="col-second odd-row-color"><code><a href="#enableQuickening()" class="member-name-link">enableQuickening</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Whether to generate quickened bytecodes for user-provided operations.</div>
</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#enableRootBodyTagging()" class="member-name-link">enableRootBodyTagging</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enables automatic root body tagging if <a href="#enableTagInstrumentation()"><code>instrumentation</code></a> is
 enabled.</div>
</div>
<div class="col-first odd-row-color"><code>boolean</code></div>
<div class="col-second odd-row-color"><code><a href="#enableRootTagging()" class="member-name-link">enableRootTagging</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enables automatic root tagging if <a href="#enableTagInstrumentation()"><code>instrumentation</code></a> is
 enabled.</div>
</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#enableSerialization()" class="member-name-link">enableSerialization</a></code></div>
<div class="col-last even-row-color">
<div class="block">Whether the generated interpreter should support serialization and deserialization.</div>
</div>
<div class="col-first odd-row-color"><code>boolean</code></div>
<div class="col-second odd-row-color"><code><a href="#enableSpecializationIntrospection()" class="member-name-link">enableSpecializationIntrospection</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Whether to generate introspection data for specializations.</div>
</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#enableTagInstrumentation()" class="member-name-link">enableTagInstrumentation</a></code></div>
<div class="col-last even-row-color">
<div class="block">Whether the generated interpreter should support Truffle tag instrumentation.</div>
</div>
<div class="col-first odd-row-color"><code>boolean</code></div>
<div class="col-second odd-row-color"><code><a href="#enableUncachedInterpreter()" class="member-name-link">enableUncachedInterpreter</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Whether to generate an uncached interpreter.</div>
</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#enableYield()" class="member-name-link">enableYield</a></code></div>
<div class="col-last even-row-color">
<div class="block">Whether the generated interpreter should support coroutines via a <code>yield</code> operation.</div>
</div>
<div class="col-first odd-row-color"><code>boolean</code></div>
<div class="col-second odd-row-color"><code><a href="#storeBytecodeIndexInFrame()" class="member-name-link">storeBytecodeIndexInFrame</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Whether the generated interpreter should store the bytecode index (bci) in the frame.</div>
</div>
<div class="col-first even-row-color"><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a><wbr>&lt;?&gt;</code></div>
<div class="col-second even-row-color"><code><a href="#tagTreeNodeLibrary()" class="member-name-link">tagTreeNodeLibrary</a></code></div>
<div class="col-last even-row-color">
<div class="block">Allows to customize the <a href="../interop/NodeLibrary.html" title="class in com.oracle.truffle.api.interop"><code>NodeLibrary</code></a> implementation that is used for tag
 instrumentation.</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details" id="annotation-interface-element-detail">
<ul class="details-list">
<!-- ============ ANNOTATION INTERFACE MEMBER DETAIL =========== -->
<li>
<section class="member-details">
<h2>Element Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="languageClass()">
<h3>languageClass</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;? extends <a href="../TruffleLanguage.html" title="class in com.oracle.truffle.api">TruffleLanguage</a>&lt;?&gt;&gt;</span>&nbsp;<span class="element-name">languageClass</span></div>
<div class="block">The <a href="../TruffleLanguage.html" title="class in com.oracle.truffle.api"><code>TruffleLanguage</code></a> class associated with this node.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableUncachedInterpreter()">
<h3>enableUncachedInterpreter</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableUncachedInterpreter</span></div>
<div class="block">Whether to generate an uncached interpreter.
 <p>
 The uncached interpreter improves start-up performance by executing
 <a href="../dsl/GenerateUncached.html" title="annotation interface in com.oracle.truffle.api.dsl"><code>uncached</code></a> nodes instead of allocating and
 executing cached (specializing) nodes. The node will transition to a specializing interpreter
 after enough invocations/back-edges (as determined by <a href="#defaultUncachedThreshold()"><code>defaultUncachedThreshold()</code></a>).
 <p>
 To generate an uncached interpreter, all operations need to support uncached execution. If an
 operation cannot easily support uncached execution, it can instead
 <a href="Operation.html#forceCached()"><code>force a transition to cached</code></a> before the operation is executed
 (this may limit the utility of the uncached interpreter).</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="defaultUncachedThreshold()">
<h3>defaultUncachedThreshold</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">defaultUncachedThreshold</span></div>
<div class="block">Sets the default number of times an uncached interpreter must return, branch backwards, or
 yield before transitioning to cached.
 <p>
 The default uncached threshold expression supports a subset of Java (see the
 <a href="../dsl/Cached.html" title="annotation interface in com.oracle.truffle.api.dsl"><code>Cached</code></a> documentation). It should evaluate to an
 int. It should be a positive value, <code>0</code>, or <code>Integer.MIN_VALUE</code>. A threshold of
 <code>0</code> will cause each bytecode node to immediately transition to cached on first
 invocation. A threshold of <code>Integer.MIN_VALUE</code> forces a bytecode node to stay uncached
 (i.e., it will not transition to cached).
 <p>
 The default local value expression can be a constant literal (e.g., <code>"42"</code>), in which
 case the value will be validated at build time. However, the expression can also refer to
 static members of the bytecode root node (and validation is deferred to run time). The
 following example declares a default threshold of 32 that can be overridden with a system
 property:

 <pre>
 &#64;GenerateBytecode(..., defaultUncachedThreshold = "DEFAULT_UNCACHED_THRESHOLD")
 abstract class MyBytecodeRootNode extends RootNode implements BytecodeRootNode {

     static final int DEFAULT_UNCACHED_THRESHOLD = Integer.parseInt(System.getProperty("defaultUncachedThreshold", "32"));

     // ...
 }
 </pre>

 Other expressions like static method calls are also possible. Note that instance members of
 the root node cannot be bound with the default uncached threshold expression for efficiency
 reasons.
 <p>
 To override this default threshold for a given bytecode node, an explicit threshold can be
 set using <a href="BytecodeNode.html#setUncachedThreshold(int)"><code>BytecodeNode.setUncachedThreshold(int)</code></a>.
 <p>
 This field has no effect unless the uncached interpreter is
 <a href="#enableUncachedInterpreter()"><code>enabled</code></a>.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>"16"</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableSerialization()">
<h3>enableSerialization</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableSerialization</span></div>
<div class="block">Whether the generated interpreter should support serialization and deserialization.
 <p>
 When serialization is enabled, the Bytecode DSL generates code to convert bytecode nodes to
 and from a serialized byte array representation. The code effectively serializes the node's
 execution data (bytecode, constants, etc.) and all of its non-transient fields.
 <p>
 The serialization logic is defined in static <code>serialize</code> and <code>deserialize</code>
 methods of the generated root class. The generated <a href="BytecodeRootNodes.html" title="class in com.oracle.truffle.api.bytecode"><code>BytecodeRootNodes</code></a> class also
 overrides <a href="BytecodeRootNodes.html#serialize(java.io.DataOutput,com.oracle.truffle.api.bytecode.serialization.BytecodeSerializer)"><code>BytecodeRootNodes.serialize(java.io.DataOutput, com.oracle.truffle.api.bytecode.serialization.BytecodeSerializer)</code></a>.
 <p>
 This feature can be used to avoid the overhead of parsing source code on start up. Note that
 serialization still incurs some overhead, as it does not trivially copy bytecode directly: in
 order to validate the bytecode (balanced stack pointers, valid branches, etc.), serialization
 encodes builder method calls and deserialization replays those calls.
 <p>
 Note that the generated <code>deserialize</code> method takes a <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Supplier.html" title="class or interface in java.util.function" class="external-link"><code>Supplier<DataInput></code></a> rather than a <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/DataInput.html" title="class or interface in java.io" class="external-link"><code>DataInput</code></a> directly. The supplier should
 produce a fresh <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/DataInput.html" title="class or interface in java.io" class="external-link"><code>DataInput</code></a> each time because the input may be processed
 multiple times (due to <a href="BytecodeRootNodes.html#update(com.oracle.truffle.api.bytecode.BytecodeConfig)"><code>reparsing</code></a>).</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="serialization/BytecodeSerializer.html" title="interface in com.oracle.truffle.api.bytecode.serialization"><code>BytecodeSerializer</code></a></li>
<li><a href="serialization/BytecodeDeserializer.html" title="interface in com.oracle.truffle.api.bytecode.serialization"><code>BytecodeDeserializer</code></a></li>
<li><a href="https://github.com/oracle/graal/blob/master/truffle/src/com.oracle.truffle.api.bytecode.test/src/com/oracle/truffle/api/bytecode/test/examples/SerializationTutorial.java">Serialization
      tutorial</a></li>
</ul>
</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableTagInstrumentation()">
<h3>enableTagInstrumentation</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableTagInstrumentation</span></div>
<div class="block">Whether the generated interpreter should support Truffle tag instrumentation. When
 instrumentation is enabled, the generated builder will define <code>startTag(...)</code> and
 <code>endTag(...)</code> methods that can be used to annotate the bytecode with
 <a href="../instrumentation/Tag.html" title="class in com.oracle.truffle.api.instrumentation"><code>tags</code></a>. Truffle tag instrumentation also
 allows you to specify implicit tagging using <a href="Operation.html#tags()"><code>Operation.tags()</code></a>. If tag instrumentation
 is enabled all tagged operations will automatically handle and insert <a href="../instrumentation/ProbeNode.html" title="class in com.oracle.truffle.api.instrumentation"><code>probes</code></a> from the Truffle instrumentation framework.
 <p>
 Only tags that are <a href="../instrumentation/ProvidedTags.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>provided</code></a> by the specified <a href="#languageClass()"><code>Truffle language</code></a> can be used.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="#enableRootTagging()"><code>enableRootTagging()</code></a></li>
<li><a href="#enableRootBodyTagging()"><code>enableRootBodyTagging()</code></a></li>
</ul>
</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableRootTagging()">
<h3>enableRootTagging</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableRootTagging</span></div>
<div class="block">Enables automatic root tagging if <a href="#enableTagInstrumentation()"><code>instrumentation</code></a> is
 enabled. Automatic root tagging automatically tags each root with <a href="../instrumentation/StandardTags.RootTag.html" title="class in com.oracle.truffle.api.instrumentation"><code>StandardTags.RootTag</code></a> if the
 language <a href="../instrumentation/ProvidedTags.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>provides</code></a> it.
 <p>
 Root tagging requires the probe to be notified before the <a href="Prolog.html" title="annotation interface in com.oracle.truffle.api.bytecode"><code>prolog</code></a> is executed.
 Implementing this behavior manually is not trivial and not recommended. It is recommended to
 use automatic root tagging. For inlining performed by the parser it may be useful to emit
 custom <a href="../instrumentation/StandardTags.RootTag.html" title="class in com.oracle.truffle.api.instrumentation"><code>root</code></a> tag using the builder methods for inlined methods. This ensures
 that tools can still work correctly for inlined calls.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="#enableRootBodyTagging()"><code>enableRootBodyTagging()</code></a></li>
</ul>
</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableRootBodyTagging()">
<h3>enableRootBodyTagging</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableRootBodyTagging</span></div>
<div class="block">Enables automatic root body tagging if <a href="#enableTagInstrumentation()"><code>instrumentation</code></a> is
 enabled. Automatic root body tagging automatically tags each root with <a href="../instrumentation/StandardTags.RootBodyTag.html" title="class in com.oracle.truffle.api.instrumentation"><code>StandardTags.RootBodyTag</code></a> if
 the language <a href="../instrumentation/ProvidedTags.html" title="annotation interface in com.oracle.truffle.api.instrumentation"><code>provides</code></a> it.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="#enableRootTagging()"><code>enableRootTagging()</code></a></li>
</ul>
</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="tagTreeNodeLibrary()">
<h3>tagTreeNodeLibrary</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;?&gt;</span>&nbsp;<span class="element-name">tagTreeNodeLibrary</span></div>
<div class="block">Allows to customize the <a href="../interop/NodeLibrary.html" title="class in com.oracle.truffle.api.interop"><code>NodeLibrary</code></a> implementation that is used for tag
 instrumentation. This option only makes sense if <a href="#enableTagInstrumentation()"><code>enableTagInstrumentation()</code></a> is set
 to <code>true</code>.
 <p>
 Common use-cases when implementing a custom tag tree node library is required:
 <ul>
 <li>Allowing instruments to access the current receiver or function object.
 <li>Implementing custom scopes for local variables instead of the default scope.
 <li>Hiding certain local local variables or arguments from instruments.
 </ul>
 <p>
 Minimal example of a tag node library:

 <pre>
 &#64;ExportLibrary(value = NodeLibrary.class, receiverType = TagTreeNode.class)
 final class MyTagTreeNodeExports {

     &#64;ExportMessage
     static boolean hasScope(TagTreeNode node, Frame frame) {
         return true;
     }

     &#64;ExportMessage
     &#64;SuppressWarnings("unused")
     static Object getScope(TagTreeNode node, Frame frame, boolean nodeEnter) throws UnsupportedMessageException {
         return new MyScope(node, frame);
     }
 }
 </pre>

 See the <a href="../interop/NodeLibrary.html" title="class in com.oracle.truffle.api.interop"><code>NodeLibrary</code></a> javadoc for more details.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="TagTreeNode.html" title="class in com.oracle.truffle.api.bytecode"><code>TagTreeNode</code></a></li>
</ul>
</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>com.oracle.truffle.api.bytecode.TagTreeNodeExports.class</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allowUnsafe()">
<h3>allowUnsafe</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">allowUnsafe</span></div>
<div class="block">Whether to use unsafe array accesses.
 <p>
 Unsafe accesses are faster, but they do not perform array bounds checks. This means it is
 possible (though unlikely) for unsafe accesses to cause undefined behaviour. Undefined
 behavior may only happen due to a bug in the Bytecode DSL implementation and not language
 implementation code.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableYield()">
<h3>enableYield</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableYield</span></div>
<div class="block">Whether the generated interpreter should support coroutines via a <code>yield</code> operation.
 <p>
 The yield operation returns a <a href="ContinuationResult.html" title="class in com.oracle.truffle.api.bytecode"><code>ContinuationResult</code></a> from the current point in execution.
 The <a href="ContinuationResult.html" title="class in com.oracle.truffle.api.bytecode"><code>ContinuationResult</code></a> saves the current state of the interpreter so that it can be
 resumed at a later time. The yield and resume actions pass values, enabling communication
 between the caller and callee.
 <p>
 Technical note: in theoretical terms, a <a href="ContinuationResult.html" title="class in com.oracle.truffle.api.bytecode"><code>ContinuationResult</code></a> implements an asymmetric
 stack-less coroutine.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="ContinuationResult.html" title="class in com.oracle.truffle.api.bytecode"><code>ContinuationResult</code></a></li>
</ul>
</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableMaterializedLocalAccesses()">
<h3>enableMaterializedLocalAccesses</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableMaterializedLocalAccesses</span></div>
<div class="block">Enables materialized local accesses. Materialized local accesses allow a root node to access
 the locals of any outer root nodes (root nodes created by enclosing <code>Root</code> operations)
 in addition to its own locals. These accesses take the
 <a href="../frame/MaterializedFrame.html" title="interface in com.oracle.truffle.api.frame"><code>materialized frame</code></a> containing the
 local as an operand. Materialized local accesses can be used to implement closures and nested
 functions with lexical scoping.
 <p>
 When materialized local accesses are enabled, the interpreter defines two additional
 operations, <code>LoadLocalMaterialized</code> and <code>StoreLocalMaterialized</code>, which implement
 the local accesses. Implementations can also use <a href="MaterializedLocalAccessor.html" title="class in com.oracle.truffle.api.bytecode"><code>MaterializedLocalAccessor</code></a>s to access
 locals from user-defined operations.
 <p>
 Materialized local accesses can <i>only</i> be used where the local is
 <a href="#enableBlockScoping()"><code>in scope</code></a>. The bytecode generator guarantees that each
 materialized access's local is in scope at the static location of the access, but since root
 nodes can be called at any time, it is still possible to execute the root node (and thus
 perform the access) when the local is out of scope, leading to unexpected behaviour (e.g.,
 reading an incorrect local value). When the bytecode index is
 <a href="#storeBytecodeIndexInFrame()"><code>stored in the frame</code></a>, the interpreter will dynamically
 validate each materialized access, throwing a runtime exception when the local is not in
 scope. Thus, to diagnose issues with invalid materialized accesses, it is recommended to
 enable storing the bytecode index in the frame.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableBlockScoping()">
<h3>enableBlockScoping</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableBlockScoping</span></div>
<div class="block">Enables block scoping, which limits a local's lifetime to the lifetime of the enclosing
 Block/Root operation. Block scoping is enabled by default. If this flag is set to
 <code>false</code>, locals use root scoping, which keeps locals alive for the lifetime of the
 root node (i.e., the entire invocation).
 <p>
 The value of this flag significantly changes the behaviour of local variables, so the value
 of this flag should be decided relatively early in the development of a language.
 <p>
 When block scoping is enabled, all local variables are scoped to the closest enclosing
 Block/Root operation. When a local variable's enclosing Block ends, it falls out of scope and
 its value is automatically <a href="../frame/Frame.html#clear(int)"><code>cleared</code></a> (or reset to a
 <a href="#defaultLocalValue()"><code>default value</code></a>, if provided). Locals scoped to the Root operation
 are not cleared on exit. Block scoping allows the interpreter to reuse a frame index for
 multiple locals that have disjoint lifetimes, which can reduce the frame size.
 <p>
 With block scoping, a different set of locals can be live at different bytecode indices. The
 interpreter retains extra metadata to track the lifetimes of each local. The local accessor
 methods of <a href="BytecodeNode.html" title="class in com.oracle.truffle.api.bytecode"><code>BytecodeNode</code></a> (e.g., <a href="BytecodeNode.html#getLocalValues(int,com.oracle.truffle.api.frame.Frame)"><code>BytecodeNode.getLocalValues(int, Frame)</code></a>) take
 the current bytecode index as a parameter so that they can correctly compute the locals in
 scope. These liveness computations can require extra computation, so accessing locals using
 bytecode instructions or <a href="LocalAccessor.html" title="class in com.oracle.truffle.api.bytecode"><code>LocalAccessors</code></a> (which validate liveness at
 parse time) is encouraged when possible. The bytecode index should be a
 <a href="../CompilerAsserts.html#partialEvaluationConstant(boolean)"><code>partial evaluation constant</code></a> for
 performance reasons. The lifetime of local variables can also be accessed through
 introspection using <a href="LocalVariable.html#getStartIndex()"><code>LocalVariable.getStartIndex()</code></a> and
 <a href="LocalVariable.html#getEndIndex()"><code>LocalVariable.getEndIndex()</code></a>.
 <p>
 When root scoping is enabled, all local variables are assigned a unique index in the frame
 regardless of the current source location. They are never cleared, and frame indexes are not
 reused. Consequently, the bytecode index parameter on the local accessor methods of
 <a href="BytecodeNode.html" title="class in com.oracle.truffle.api.bytecode"><code>BytecodeNode</code></a> has no effect. Root scoping does not retain additional liveness metadata
 (which may be a useful footprint optimization); this also means
 <a href="LocalVariable.html#getStartIndex()"><code>LocalVariable.getStartIndex()</code></a> and <a href="LocalVariable.html#getEndIndex()"><code>LocalVariable.getEndIndex()</code></a> methods do not
 return lifetime data.
 <p>
 Root scoping is primarily intended for cases where the implemented language does not use
 block scoping. It can also be useful if the default block scoping is not flexible enough and
 custom scoping rules are needed.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableQuickening()">
<h3>enableQuickening</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableQuickening</span></div>
<div class="block">Whether to generate quickened bytecodes for user-provided operations.
 <p>
 Quickened versions of instructions support a subset of the
 <a href="../dsl/Specialization.html" title="annotation interface in com.oracle.truffle.api.dsl"><code>specializations</code></a> defined by an operation.
 They can improve interpreted performance by reducing footprint and requiring fewer guards.
 <p>
 Quickened versions of operations can be specified using
 <a href="ForceQuickening.html" title="annotation interface in com.oracle.truffle.api.bytecode"><code>ForceQuickening</code></a>. When an instruction re-specializes
 itself, the interpreter attempts to automatically replace it with a quickened instruction.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="storeBytecodeIndexInFrame()">
<h3>storeBytecodeIndexInFrame</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">storeBytecodeIndexInFrame</span></div>
<div class="block">Whether the generated interpreter should store the bytecode index (bci) in the frame.
 <p>
 By default, methods that compute location-dependent information (like
 <a href="BytecodeNode.html#getBytecodeLocation(com.oracle.truffle.api.frame.Frame,com.oracle.truffle.api.nodes.Node)"><code>BytecodeNode.getBytecodeLocation(com.oracle.truffle.api.frame.Frame, Node)</code></a>) must
 follow <a href="../nodes/Node.html#getParent()"><code>Node parent</code></a> pointers and scan the bytecode to compute the
 current bci, which is not suitable for the fast path. When this feature is enabled, an
 implementation can use
 <a href="BytecodeNode.html#getBytecodeIndex(com.oracle.truffle.api.frame.Frame)"><code>BytecodeNode.getBytecodeIndex(com.oracle.truffle.api.frame.Frame)</code></a> to obtain the bci
 efficiently on the fast path and use it for location-dependent computations (e.g.,
 <a href="BytecodeNode.html#getBytecodeLocation(int)"><code>BytecodeNode.getBytecodeLocation(int)</code></a>).
 <p>
 Note that operations always have fast-path access to the bci using a bind parameter (e.g.,
 <code>@Bind("$bytecodeIndex") int bci</code>); this feature should only be enabled for fast-path
 bci access outside of the current operation (e.g., for closures or frame introspection).
 Storing the bci in the frame increases frame size and requires additional frame writes, so it
 can negatively affect performance.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="boxingEliminationTypes()">
<h3>boxingEliminationTypes</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;?&gt;[]</span>&nbsp;<span class="element-name">boxingEliminationTypes</span></div>
<div class="block">Primitive types the interpreter should attempt to avoid boxing up. Each type should be
 primitive class literal (e.g., <code>int.class</code>).
 <p>
 If boxing elimination types are provided, the cached interpreter will generate instruction
 variants that load/store primitive values when possible. It will automatically use these
 instructions in a best-effort manner (falling back on boxed representations when necessary).</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>{}</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableSpecializationIntrospection()">
<h3>enableSpecializationIntrospection</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableSpecializationIntrospection</span></div>
<div class="block">Whether to generate introspection data for specializations. The data is accessible using
 <a href="Instruction.Argument.html#getSpecializationInfo()"><code>Instruction.Argument.getSpecializationInfo()</code></a>.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="defaultLocalValue()">
<h3>defaultLocalValue</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">defaultLocalValue</span></div>
<div class="block">Sets the default value that <a href="BytecodeLocal.html" title="class in com.oracle.truffle.api.bytecode"><code>locals</code></a> return when they are read without
 ever being written. Unless a default local value is specified, loading from a
 <a href="BytecodeLocal.html" title="class in com.oracle.truffle.api.bytecode"><code>local</code></a> that was never stored into throws a
 <a href="../frame/FrameSlotTypeException.html" title="class in com.oracle.truffle.api.frame"><code>FrameSlotTypeException</code></a>.
 <p>
 It is recommended for the default local value expression to refer to a static and final
 constant in the bytecode root node. For example:

 <pre>
 &#64;GenerateBytecode(..., defaultLocalValue = "DEFAULT_VALUE")
 abstract class MyBytecodeRootNode extends RootNode implements BytecodeRootNode {

     static final DefaultValue DEFAULT_VALUE = DefaultValue.INSTANCE;

     // ...
 }
 </pre>

 The expression supports a subset of Java (see the <a href="../dsl/Cached.html" title="annotation interface in com.oracle.truffle.api.dsl"><code>Cached</code></a> documentation), including other expressions like <code>null</code> or a static method
 call. Note that instance members of the root node cannot be bound with the default local
 value expression for efficiency reasons.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>""</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="enableBytecodeDebugListener()">
<h3>enableBytecodeDebugListener</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">enableBytecodeDebugListener</span></div>
<div class="block">Whether the <a href="debug/BytecodeDebugListener.html" title="interface in com.oracle.truffle.api.bytecode.debug"><code>BytecodeDebugListener</code></a> methods should be notified by generated code. By
 default the debug bytecode listener is enabled if the root node implements
 <a href="debug/BytecodeDebugListener.html" title="interface in com.oracle.truffle.api.bytecode.debug"><code>BytecodeDebugListener</code></a>. If this attribute is set to <code>false</code> then the debug
 bytecode listener won't be notified. This attribute may be useful to keep a default debug
 listener implementation permanently in the source code but only enable it temporarily during
 debug sessions.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>24.2</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd><code>true</code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><center>Copyright &copy; 2012, 2024, Oracle and/or its affiliates. All rights reserved.</center></small></p>
</footer>
</div>
</div>
</body>
</html>
